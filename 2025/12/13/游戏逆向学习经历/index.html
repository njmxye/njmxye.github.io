<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>游戏逆向 | 楠 寻 の 小 窝</title><meta name="author" content="楠寻njmxye"><meta name="copyright" content="楠寻njmxye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="cap0：VS2019环境点击下载VS2019sdk+wdk开发环境提取码: cnmd 虚拟机环境点击下载win10_22h2完美环境提取码: cnmd cap0：双机调试https:&#x2F;&#x2F;github.com&#x2F;4d61726b&#x2F;VirtualKD-Redux&#x2F;x64扔到虚拟机里，f8禁用签名检测，windbg自动连接。 windbg命令内存显示命令（虚拟内存） dq - 显示四字（8字节）格式的内">
<meta property="og:type" content="article">
<meta property="og:title" content="游戏逆向">
<meta property="og:url" content="https://njmxye.de5.net/2025/12/13/%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%8E%86/index.html">
<meta property="og:site_name" content="楠 寻 の 小 窝">
<meta property="og:description" content="cap0：VS2019环境点击下载VS2019sdk+wdk开发环境提取码: cnmd 虚拟机环境点击下载win10_22h2完美环境提取码: cnmd cap0：双机调试https:&#x2F;&#x2F;github.com&#x2F;4d61726b&#x2F;VirtualKD-Redux&#x2F;x64扔到虚拟机里，f8禁用签名检测，windbg自动连接。 windbg命令内存显示命令（虚拟内存） dq - 显示四字（8字节）格式的内">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg">
<meta property="article:published_time" content="2025-12-13T23:00:00.000Z">
<meta property="article:modified_time" content="2026-02-09T13:35:41.292Z">
<meta property="article:author" content="楠寻njmxye">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"><link rel="shortcut icon" href="https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/favicon.png"><link rel="canonical" href="https://njmxye.de5.net/2025/12/13/%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%8E%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="cWyLZN3gSLDdjz3lqJl60UiBZnrX1fPVfGqm_rELJZA"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '游戏逆向',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2026-02-09 13:35:41'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"><link rel="stylesheet" href="/assets/css/APlayer.min.css" class="aplayer-style-marker">
<script src="/assets/js/APlayer.min.js" class="aplayer-script-marker"></script>
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.helloimg.com/i/2024/12/20/6764f5f231582.png')"><nav id="nav"><span id="blog-info"><a href="/" title="楠 寻 の 小 窝"><span class="site-name">楠 寻 の 小 窝</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">游戏逆向</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-13T23:00:00.000Z" title="发表于 2025-12-13 23:00:00">2025-12-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-02-09T13:35:41.292Z" title="更新于 2026-02-09 13:35:41">2026-02-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">43.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>206分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="游戏逆向"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="cap0：VS2019环境"><a href="#cap0：VS2019环境" class="headerlink" title="cap0：VS2019环境"></a>cap0：VS2019环境</h2><p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1MoV7svLZc6YzVHVPNw3Viw">点击下载VS2019sdk+wdk开发环境</a><br>提取码: cnmd</p>
<h3 id="虚拟机环境"><a href="#虚拟机环境" class="headerlink" title="虚拟机环境"></a>虚拟机环境</h3><p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1nE5RWqhHU0VtHQu5Sw0XOA">点击下载win10_22h2完美环境</a><br>提取码: cnmd</p>
<h2 id="cap0：双机调试"><a href="#cap0：双机调试" class="headerlink" title="cap0：双机调试"></a>cap0：双机调试</h2><p><a target="_blank" rel="noopener" href="https://github.com/4d61726b/VirtualKD-Redux/">https://github.com/4d61726b/VirtualKD-Redux/</a><br>x64扔到虚拟机里，f8禁用签名检测，windbg自动连接。</p>
<h3 id="windbg命令"><a href="#windbg命令" class="headerlink" title="windbg命令"></a>windbg命令</h3><h4 id="内存显示命令（虚拟内存）"><a href="#内存显示命令（虚拟内存）" class="headerlink" title="内存显示命令（虚拟内存）"></a>内存显示命令（虚拟内存）</h4><ul>
<li><strong>dq</strong> - 显示四字（8字节）格式的内存内容<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dq esp          ; 显示ESP寄存器指向的内存（8字节显示）</span><br></pre></td></tr></table></figure></li>
<li><strong>dd</strong> - 显示双字（4字节）格式的内存内容  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd eax          ; 显示EAX寄存器指向的内存（4字节显示）</span><br></pre></td></tr></table></figure></li>
<li><strong>dw</strong> - 显示字（2字节）格式的内存内容<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dw esp+10       ; 显示ESP+10处的内存（2字节显示）</span><br></pre></td></tr></table></figure></li>
<li><strong>db</strong> - 显示字节格式的内存内容<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db esp          ; 显示ESP寄存器指向的内存（字节显示）</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="内存编辑命令"><a href="#内存编辑命令" class="headerlink" title="内存编辑命令"></a>内存编辑命令</h4><ul>
<li><strong>eq/ed/ew/eb</strong> - 编辑内存内容（写入值）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eq eax 12345678     ; 在EAX处写入四字数据</span><br><span class="line">ed eax 12345678     ; 在EAX处写入双字数据</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="调试器扩展命令（物理内存）"><a href="#调试器扩展命令（物理内存）" class="headerlink" title="调试器扩展命令（物理内存）"></a>调试器扩展命令（物理内存）</h4><ul>
<li><strong>!dq/!dd/!dw/!dn</strong> - 调试器扩展命令，显示内存<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!dq esp             ; 扩展命令显示四字格式</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="内存搜索命令"><a href="#内存搜索命令" class="headerlink" title="内存搜索命令"></a>内存搜索命令</h4><ul>
<li><strong>s -b/w/d/a/u range</strong> - 在指定范围内搜索内存<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s -b 0 L100 90              ; 在0-100范围内搜索字节0x90</span><br><span class="line">s -d 0 L1000 41424344       ; 搜索双字&quot;ABCD&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="反汇编命令"><a href="#反汇编命令" class="headerlink" title="反汇编命令"></a>反汇编命令</h4><ul>
<li><strong>u</strong> - 反汇编代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u eip                     ; 反汇编当前EIP处的代码</span><br><span class="line">u eax                     ; 反汇编EAX地址处的代码</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="寄存器命令"><a href="#寄存器命令" class="headerlink" title="寄存器命令"></a>寄存器命令</h4><ul>
<li><strong>r reg/r reg=x</strong> - 显示/修改寄存器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r                         ; 显示所有寄存器</span><br><span class="line">r eax                     ; 显示EAX寄存器值</span><br><span class="line">r eax=12345678           ; 修改EAX寄存器为指定值</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="杂项命令"><a href="#杂项命令" class="headerlink" title="杂项命令"></a>杂项命令</h4><ul>
<li><p><strong>.cls</strong> - 清除调试器屏幕显示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.cls                    ; 清除当前屏幕所有输出</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>k</strong> - 显示调用堆栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k                       ; 显示当前调用栈</span><br><span class="line">kbn                     ; 显示栈帧号、参数和函数名</span><br><span class="line">kvn                     ; 显示详细信息包括调用约定</span><br><span class="line">k= base limit           ; 显示指定范围的栈信息</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>gc/g</strong> - 继续执行调试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g                       ; 继续执行程序（运行）</span><br><span class="line">gc                      ; 继续执行（从断点恢复）</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="断点命令"><a href="#断点命令" class="headerlink" title="断点命令"></a>断点命令</h4><ul>
<li><p><strong>bp</strong> - 设置软件断点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bp 0x401000             ; 在地址0x401000设置断点</span><br><span class="line">bp main                 ; 在main函数设置断点</span><br><span class="line">bp MyFunction+10        ; 在MyFunction偏移10处设置断点</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ba r/w/e/i size addr</strong> - 设置硬件断点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ba r 4 0x401000         ; 在0x401000设置读断点（4字节）</span><br><span class="line">ba w 1 0x401000         ; 在0x401000设置写断点（1字节）</span><br><span class="line">ba e 0x401000           ; 在0x401000设置执行断点</span><br><span class="line">ba i 0x401000           ; 在0x401000设置I/O断点</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>bu</strong> - 设置未解析断点（延迟断点）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bu MyClass::Method      ; 设置延迟断点</span><br><span class="line">bu driver!DriverEntry   ; 在驱动入口设置断点</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>bl</strong> - 列出所有断点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bl                      ; 列出所有断点信息</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h4><ul>
<li><strong>“.if(){}.else{}”</strong> - 条件断点语法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bp 0x401000 &quot;.if(@eax==0)&#123;&#125;.else&#123;gc&#125;&quot;    ; EAX为0时继续执行</span><br><span class="line">bp 0x401000 &quot;.if(@eax&gt;10)&#123;&#125;.else&#123;gc&#125;&quot;    ; EAX大于10时暂停</span><br><span class="line">bp 0x401000 &quot;.if(@ecx!=0)&#123;kc;gc&#125;&quot;        ; ECX非0时显示栈并继续</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：寄存器名称前需要加@符号</p>
</blockquote>
</li>
</ul>
<h3 id="第一个驱动"><a href="#第一个驱动" class="headerlink" title="第一个驱动"></a>第一个驱动</h3><p>大厂的游戏为了反作弊，都有反作弊系统，会借助r0层权限保护游戏进程。<br>这也就是为什么你用x64dbg，ce这种调试读写工具看不到内存，甚至直接闪退的原因，反作弊通过合法手段在r0层对所有可疑函数调用做了hook，不返回内存数据。<br>windows不像linux开源，进入内核的方式只能靠驱动，0环直接操作内存cpu寄存器以各种诡谲的方式hook没被监控的函数实现绕过反作弊监管，返回或修改你想要的内存数据。</p>
<h4 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h4><p>说完原理，那么写驱动需要什么呢？<br>需要coding（废话）。<br>你需要了解windows10内核运行的机制，以及cpu、内存是怎么与内核交换数据的。<br>你还需要掌握一些内核函数库与硬件知识，</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/_kernel/">点击跳转windows驱动开发文档</a>。</li>
<li><a target="_blank" rel="noopener" href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel® 64 and IA-32 Architectures Software Developer Manuals</a></li>
<li><a target="_blank" rel="noopener" href="https://gitcode.com/Universal-Tool/6b12e">英特尔® 64和IA-32架构软件开发人员手册</a></li>
<li><a target="_blank" rel="noopener" href="https://www.vergiliusproject.com/">windows未文档化结构</a></li>
</ul>
<p>你需要了解cpp，至少能看懂。<br>你需要时常光顾各大论坛，看雪，吾爱，先知等，因为逆向圈不开源，好东西大家都想藏在自己手里，没人愿意上来就把成品注入器分享出来。所以你就得经常看看大家最新的思路，攻防最前沿。<br>你需要懂github搜索，至少知道去哪ctrlc，ctrlv。<br>如果你能用ai加快开发节奏，那更好（但ai很蠢，你知道的）。</p>
<h5 id="code"><a href="#code" class="headerlink" title="code"></a>code</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drv_unload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;卸载了傻逼。\r\n&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;加载了傻逼。\r\n&quot;</span>);</span><br><span class="line">    DriverObject-&gt;DriverUnload = drv_unload;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相信每个驱动圈的朋友都从这段代码开始，有头文件，有加载函数，有卸载函数，还有输出日志。<br>编译吧，别忘了切换x64平台，然后去虚拟机测试。</p>
<blockquote>
<p>需要用到<code>instDrv</code>软件。</p>
</blockquote>
<p>接下来，我们需要调用一些封装好的库。不需要你自己写，直接下载贴上就好，程序员最宝贵的品质是cv，不是么。<br>ia32源自<a target="_blank" rel="noopener" href="https://github.com/ia32-doc/ia32-doc">https://github.com/ia32-doc/ia32-doc</a>，hde我没找到完整出处。</p>
<p>姑且打包<a href="https://njmxye.de5.net/内核驱动常用的库与头文件.zip">点击下载内核驱动常用的库与头文件</a></p>
<h2 id="cap0：扫盲章"><a href="#cap0：扫盲章" class="headerlink" title="cap0：扫盲章"></a>cap0：扫盲章</h2><h4 id="进程-Process"><a href="#进程-Process" class="headerlink" title="进程(Process)"></a>进程(Process)</h4><p>进程代表了程序的一个运行实例，是起容纳和管理作用的对象。</p>
<h5 id="进程运行"><a href="#进程运行" class="headerlink" title="进程运行"></a>进程运行</h5><ul>
<li>进程不运行——它只管理。</li>
<li>从技术上来说，线程才是执行代码的东西。</li>
</ul>
<p>进程一般包括：</p>
<ul>
<li>可执行程序</li>
<li>私有的虚拟地址</li>
</ul>
<h5 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h5><p>每个进程都有自己的虚拟、私有、线性的地址空间。这个地址空间起始是空的，后面由操作系统慢慢映射过去；每个进程都有一个很大的、独立的虚拟空间，理论上是 2^64 字节，实际上是 2^48 或者说 2^52 。</p>
<ul>
<li>虚拟地址—&gt;Paging—&gt;RAM</li>
<li>可以用孩子与钱包来理解</li>
</ul>
<h5 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h5><ul>
<li>token</li>
<li>私有的句柄表</li>
<li>一个或多个线程</li>
<li>一个与之对应在内核的EPROCESS</li>
</ul>
<h5 id="Windbg中查看进程"><a href="#Windbg中查看进程" class="headerlink" title="Windbg中查看进程"></a>Windbg中查看进程</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!process <span class="comment">//查看当前windbg附加进程的所有信息</span></span><br><span class="line">!process <span class="number">0</span> <span class="number">0</span> <span class="comment">//查看所有进程</span></span><br><span class="line">.process /i EPROCESS <span class="comment">//附加进程</span></span><br><span class="line">dt _eprocess ffffcf040000000 <span class="comment">//查看EPROCESS结构体</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Windows一切皆对象</p>
</blockquote>
<h4 id="线程-Thread"><a href="#线程-Thread" class="headerlink" title="线程(Thread)"></a>线程(Thread)</h4><p>线程是执行代码的真正实体。线程位于进程之内，使用进程提供的资源来完成任务（比如虚拟内存和内核对象的句柄）。</p>
<h5 id="线程包含以下组件"><a href="#线程包含以下组件" class="headerlink" title="线程包含以下组件"></a>线程包含以下组件</h5><ul>
<li>当前的访问模式。或者是用户模式，或者是内核模式。</li>
<li>执行上下文。包括处理器的寄存器和执行状态。</li>
<li>一个或者两个栈。用于局部变量分配和调用管理。</li>
<li>线程局部存储（TLS）数组。它为存储线程的私有数据提供了统一的访问语义。</li>
<li>基本优先级和当前（动态的）优先级。</li>
<li>处理器亲和性（affinity）。指明线程可以在哪个处理器上运行。</li>
<li>与之对应的在内核的结构体</li>
</ul>
<h5 id="Windbg中查看线程"><a href="#Windbg中查看线程" class="headerlink" title="Windbg中查看线程"></a>Windbg中查看线程</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt _ethread ffffcf040000000 <span class="comment">//查看ETHREAD结构体</span></span><br></pre></td></tr></table></figure>
<h4 id="KPCR"><a href="#KPCR" class="headerlink" title="KPCR"></a>KPCR</h4><p>CPU的状态，gs:0处可以找到。可以理解为CPU的上下文和重要的东西</p>
<h5 id="Windbg中查看KPCR"><a href="#Windbg中查看KPCR" class="headerlink" title="Windbg中查看KPCR"></a>Windbg中查看KPCR</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dt _kpcr<span class="comment">//查看KPCR结构体</span></span><br><span class="line">dt _kpcrb <span class="comment">//查看KPCRB结构体</span></span><br></pre></td></tr></table></figure>
<h4 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h4><p>句柄是Windows内核系统中用于访问对象的机制。Windows内核系统显露了多种类型的对象供用户模式进程、内核本身以及内核模式驱动程序使用。这些类型的实例是位于系统空间的数据结构，由对象管理器（执行体的一部分）在用户模式或者内核模式代码请求时创建。</p>
<p>句柄所代表的真实对象其实在内核，而由句柄找到内核对象就是通过每个进程的句柄表来实现的。</p>
<h5 id="句柄的特性"><a href="#句柄的特性" class="headerlink" title="句柄的特性"></a>句柄的特性</h5><ul>
<li>句柄的值是4的倍数，第一个有效的句柄值是4，0永远都不是有效的句柄值。</li>
<li>内核模式代码可以调用ObReferenceObjectByHandle函数从一个有效的句柄得到指针。如果调用成功，对象的引用计数会加1，所以即使拥有这个句柄的用户模式客户决定关闭句柄，也不会对拥有指针的内核模式代码造成危险。</li>
</ul>
<blockquote>
<h4 id="内核对象名称"><a href="#内核对象名称" class="headerlink" title="内核对象名称"></a>内核对象名称</h4><p>进程和线程是没有名字的，有名字的内核对象可以通过ObReferenceObjectByName来打开，名字可以参考WinObj。</p>
</blockquote>
<h4 id="Windows系统架构"><a href="#Windows系统架构" class="headerlink" title="Windows系统架构"></a>Windows系统架构</h4><p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12140108.png" alt="windows系统架构"></p>
<ul>
<li><p><strong>HAL</strong></p>
<ul>
<li>是接近CPU的硬件之上的一个抽象层。它使得设备驱动程序可以通过调用API来工作，而不需要知道细节和具有类似中断控制器或者DMA控制器之类的特定知识。很自然地，这一层对于编写控制硬件设备的驱动程序是非常有用的。</li>
</ul>
</li>
<li><p><strong>csrss.exe</strong></p>
<ul>
<li>Windows子系统进程运行的映像文件是Csrss.exe，它可以被视为一个助手进程，帮助内核Windows系统中运行的进程进行管理。这是一个关键进程，一旦被杀掉，系统就会崩溃。</li>
</ul>
</li>
<li><p><strong>Hv</strong></p>
<ul>
<li>如果开启，那就是更大的一个权限，可以进行各种虚拟化，拦截一些指令、中断、分页EPT虚拟化、虚拟APIC。</li>
</ul>
</li>
</ul>
<h2 id="cap1：IA32E保护模式"><a href="#cap1：IA32E保护模式" class="headerlink" title="cap1：IA32E保护模式"></a>cap1：IA32E保护模式</h2><p><a href="https://njmxye.de5.net/2025/12/14/x64%E4%BD%93%E7%B3%BB%E6%8E%A2%E7%B4%A2%E5%8F%8A%E7%BC%96%E7%A8%8B/">x86x64体系探索及编程</a><br><a target="_blank" rel="noopener" href="https://gitcode.com/Universal-Tool/6b12e">英特尔® 64和IA-32架构软件开发人员手册</a></p>
<h3 id="x64与x86指令架构的区别"><a href="#x64与x86指令架构的区别" class="headerlink" title="x64与x86指令架构的区别"></a>x64与x86指令架构的区别</h3><h4 id="寄存器区别"><a href="#寄存器区别" class="headerlink" title="寄存器区别"></a>寄存器区别</h4><div class="table-container">
<table>
<thead>
<tr>
<th>8位</th>
<th></th>
<th></th>
<th>16位</th>
<th></th>
<th>32位</th>
<th></th>
<th>64位</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>原</td>
<td>新增</td>
<td>新增</td>
<td>原</td>
<td>新增</td>
<td>原</td>
<td>新增</td>
<td>扩展</td>
<td>新增</td>
</tr>
<tr>
<td>al</td>
<td>—</td>
<td>r8b</td>
<td>ax</td>
<td>r8w</td>
<td>eax</td>
<td>r8d</td>
<td>rax</td>
<td>r8</td>
</tr>
<tr>
<td>cl</td>
<td>—</td>
<td>r9b</td>
<td>cx</td>
<td>r9w</td>
<td>ecx</td>
<td>r9d</td>
<td>rcx</td>
<td>r9</td>
</tr>
<tr>
<td>dl</td>
<td>—</td>
<td>r10b</td>
<td>dx</td>
<td>r10w</td>
<td>edx</td>
<td>r10d</td>
<td>rdx</td>
<td>r10</td>
</tr>
<tr>
<td>bl</td>
<td>—</td>
<td>r11b</td>
<td>bx</td>
<td>r11w</td>
<td>ebx</td>
<td>r11d</td>
<td>rbx</td>
<td>r11</td>
</tr>
<tr>
<td>ah</td>
<td>spl</td>
<td>r12b</td>
<td>sp</td>
<td>r12w</td>
<td>esp</td>
<td>r12d</td>
<td>rsp</td>
<td>r12</td>
</tr>
<tr>
<td>ch</td>
<td>bpl</td>
<td>r13b</td>
<td>bp</td>
<td>r13w</td>
<td>ebp</td>
<td>r13d</td>
<td>rbp</td>
<td>r13</td>
</tr>
<tr>
<td>dh</td>
<td>sil</td>
<td>r14b</td>
<td>si</td>
<td>r14w</td>
<td>esi</td>
<td>r14d</td>
<td>rsi</td>
<td>r14</td>
</tr>
<tr>
<td>bh</td>
<td>dil</td>
<td>r15b</td>
<td>di</td>
<td>r15w</td>
<td>edi</td>
<td>r15d</td>
<td>rdi</td>
<td>r15</td>
</tr>
</tbody>
</table>
</div>
<p>在 x86 中，通用寄存器 eax-edx esi edi esp ebp 等。而 x64 中新增了 r8-r15 这些通用寄存器。而且 x64 新增了 8 位的寄存器 spl bpl sil dil, 这是 x86 中没有的。r8-r15 也拆分了，r8w 是 16 位 r8d 是 32 位的。同样地，x64 增加了 9 个 128 位的浮点寄存器，XMM10-XMM18, 或者是用于多媒体。另外，x64 没有 pushad/aqi 这些指令。因此 x64 想要保存堆栈只能依次 push 来保存堆栈和寄存器环境。</p>
<h4 id="地址差别"><a href="#地址差别" class="headerlink" title="地址差别"></a>地址差别</h4><p>x64 中，线性地址只有 48 位有效，可以理解为从 0x0-0xffffffffffff其中，0x0-0x800000000000 是 UserAddress, 而 0x800000000000-0xffffffffffff 是内核空间。</p>
<p>可以用Markdown的<strong>表格语法</strong>呈现这个结构，不过要注意十六进制值的排版对齐~</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th>十六进制值</th>
</tr>
</thead>
<tbody>
<tr>
<td>canonical</td>
<td>0xFFFFFFFF_FFFFFFFF</td>
</tr>
<tr>
<td></td>
<td>0xFFFF8000_00000000</td>
</tr>
<tr>
<td>———————-</td>
<td>————————————————</td>
</tr>
<tr>
<td>non-canonical</td>
<td>0xFFFF7FFF_FFFFFFFF</td>
</tr>
<tr>
<td></td>
<td>0x00008000_00000000</td>
</tr>
<tr>
<td>———————-</td>
<td>———————————————-</td>
</tr>
<tr>
<td>canonical</td>
<td>0x00007FFF_FFFFFFFF</td>
</tr>
<tr>
<td></td>
<td>0x00000080_00000000</td>
</tr>
<tr>
<td>———————-</td>
<td>———————————————-</td>
</tr>
</tbody>
</table>
</div>
<p>其中高 16 位是地址符号扩展，要么全 1, 要么全 0。<br>canonical 和 non-canonical 地址的区别是高 16 位若全为 0 1 则是 canonical (规范地址)</p>
<blockquote>
<h5 id="微软使用的地址"><a href="#微软使用的地址" class="headerlink" title="微软使用的地址"></a>微软使用的地址</h5><p>微软的内核地址是从0xFFFFF800_00000000开始的，也就是只用了44位，中间的这些虚拟地址，可以进行高地址注入。因为这块地址在硬件上是合法的。</p>
</blockquote>
<h4 id="x64全局变量寻址"><a href="#x64全局变量寻址" class="headerlink" title="x64全局变量寻址"></a>x64全局变量寻址</h4><p>x86架构下,全局变量的寻址直接是ds:[consant],但是x64下不是这样,是RIP+offset(偏移)。</p>
<p>这个全局变量的地址计算==RIP+7+0xA81B=17F60C000。</p>
<h4 id="x64调用约定-ABI"><a href="#x64调用约定-ABI" class="headerlink" title="x64调用约定(ABI)"></a>x64调用约定(ABI)</h4><p>x64统一了函数的调用约定,只要fastcall调用约定。传参是 rcx rdx r8 r9,不够则mov [rsp+20],arg5…依次类推。</p>
<blockquote>
<p>mov [rsp+20],xx,而非push xx;</p>
</blockquote>
<p>x64会在函数的prolog就会push非易失寄存器,然后提升栈线,自此不在变动RSP。提升的堆栈用于函数传递参数,栈低地址则是返回地址和传进来的函数参数。</p>
<p>所以，布局如下：</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12160812.png" alt="windows系统架构"></p>
<p>在返回的时候，Rsp就会恢复成OldRsp，然后返回上一个函数。</p>
<p>但也不是绝对的，因为<strong>预留栈空间问题</strong>，函数在调用下一个函数的时候，至少提升0x20，如果参数小于4个，就会出现预留栈空间的多问题，这个时候可能出现如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov qword ptr ss:[rsp+0x10],rbx</span><br><span class="line">mov qword ptr ss:[rsp+0x18],rsi</span><br><span class="line">push rbp</span><br><span class="line">push rdi</span><br><span class="line">push r14</span><br></pre></td></tr></table></figure>
<p>此函数可能只有一个参数，因此预留栈空间被占用。当release时，会出现这种情况。</p>
<p>局部变量的位置就是在提升堆栈的时候，sub rsp,xx,</p>
<p>其中<code>rsp+0-rsp+参数个数*8</code>是为下个函数保存的预留栈空间；<code>rsp+参数个数*8-rsp+提升的</code>就是局部变量的空间。</p>
<p><strong>由图得到栈帧提升值=(局部变量个数+所有调用函数最大数)*8</strong></p>
<h4 id="x64InlineHook"><a href="#x64InlineHook" class="headerlink" title="x64InlineHook"></a>x64InlineHook</h4><ul>
<li><code>mov rax,xx;jmp rax</code></li>
<li><code>ff 25 00 00 00 00</code> 紧跟8字节地址无限跳转（跳到下一行，数据行写要跳转的绝对地址）</li>
<li><code>ff 15 00 00 00 00</code> 紧跟8字节地址无限Call（有坑，return会跳回纯数据段，所以一般写在shellcode最后）</li>
<li>我认为最好的 先push 0，然后修改[rsp+4]（高32位）[rsp+0]（低32位），ret。（处理物理地址不可读时，epthook）</li>
</ul>
<h4 id="vs中使用内联汇编"><a href="#vs中使用内联汇编" class="headerlink" title="vs中使用内联汇编"></a>vs中使用内联汇编</h4><p>项目—&gt;右键—&gt;生成依赖项—&gt;生成自定义—&gt;勾选masm—&gt;添加asm文件—&gt;右键属性（常规-项类型-选择microsoft macro assembler）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.code</span><br><span class="line">test_asm proc</span><br><span class="line">  mov rax,rcx</span><br><span class="line">  ret</span><br><span class="line">test_asm endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>c++中重载函数名，导致引入找不到，必须声明为c</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">uint64_t</span> <span class="title">test_asm</span><span class="params">(<span class="type">uint64_t</span> arg1)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="x64保护模式"><a href="#x64保护模式" class="headerlink" title="x64保护模式"></a>x64保护模式</h3><h4 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h4><p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12150543.png" alt="控制寄存器"></p>
<h5 id="cr8"><a href="#cr8" class="headerlink" title="cr8"></a>cr8</h5><p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12150546.png" alt="cr8"></p>
<p>保存当前IRQL，即Windows下的IRQL。中断请求级别。高忽视低</p>
<h5 id="cr3"><a href="#cr3" class="headerlink" title="cr3"></a>cr3</h5><p>指向第一级页转换表结构，IA-32E分页下就是PML4</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12150549.png" alt="cr3"></p>
<p>MAXPHYADDR指物理地址线最大值，通过<code>CPUID.EAX=80000008H</code>查询：</p>
<ul>
<li>EAX[16:8]返回虚拟地址位数</li>
<li>EAX[8:0]返回最大物理地址总线</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax,0x80000008</span><br><span class="line">    |</span><br><span class="line">cpuid</span><br><span class="line">;得到如下结果</span><br><span class="line">rax=0000000000003027</span><br></pre></td></tr></table></figure>
<p>即最大虚拟地址48位，物理地址总线最大为39位。<br>其中，CR3的后12位，需在CR4.PCIDE开启后才有效；第63位同理，否则这些位均为0。</p>
<h5 id="cr0"><a href="#cr0" class="headerlink" title="cr0"></a>cr0</h5><p>重要的控制位寄存器。</p>
<h6 id="PE位"><a href="#PE位" class="headerlink" title="PE位"></a>PE位</h6><p>保护模式开启位</p>
<h6 id="PG位"><a href="#PG位" class="headerlink" title="PG位"></a>PG位</h6><p>分页开启位</p>
<h6 id="WP位"><a href="#WP位" class="headerlink" title="WP位"></a>WP位</h6><p>WP=1，Supervios权限无法修改ReadOnly内存，否则可以修改。只针对0 1 2特权</p>
<h5 id="cr4"><a href="#cr4" class="headerlink" title="cr4"></a>cr4</h5><p>对于cr0的扩展。</p>
<h6 id="TSD位"><a href="#TSD位" class="headerlink" title="TSD位"></a>TSD位</h6><p>TSD=1,RDTSC和RDTSCP只能在RO权限使用。</p>
<h6 id="SMEP位"><a href="#SMEP位" class="headerlink" title="SMEP位"></a>SMEP位</h6><p>SMEP=1，superviosr不能执行PTE属性中U/S=I的页面，同样的，还有SMAP，是访问，可以通过stac关闭。</p>
<h6 id="VMXE位"><a href="#VMXE位" class="headerlink" title="VMXE位"></a>VMXE位</h6><p>VMXE=1，代表开启虚拟化，通过CPU.EAX=01H的第五位判断是否支持硬件虚拟化。<br>值得一提的是，VMXE对于AMD无效。</p>
<h6 id="PCIDE机制"><a href="#PCIDE机制" class="headerlink" title="PCIDE机制"></a>PCIDE机制</h6><p>PCID机制是Intel 64较为新的处理器的一种机制,这个机制如下:</p>
<ul>
<li>CR4.PCIDE用于开启PCID机制</li>
<li>PCID全称进程上下文标识符,CR3的后12位就是PCID号</li>
<li>每个PCID号都有一个TLB支持,总共有0xFFFF个TLB.处理器只处理当前的PCID的TLB；</li>
</ul>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12150609.png" alt="pcide"></p>
<ul>
<li>CR3的最高位,为0时,此时切换CR3(PCID也切换)时,会发生如下情况</li>
</ul>
<p>① 使原来 PCID 为 001H 编号的 TLB 无效，即刷新 TLB。<br>② 使原来 PCID 为 001H 编号的 paging-structure cache 无效，即刷新 paging-structure cache。<br>③ 对 global page 无影响，不会刷新 global page。<br>④ 对其他 PCID 编号的 TLB 和 paging-structure cache 无影响，不会刷新其他 PCID编号的 TLB 和 paging-structure cache 内容。</p>
<p>但是如果是1，那就不会刷新了。<br>Windows在开启KPTI之后，要使用这个机制；UserCR3的PCID号是1,KernelCR3的PCID号是2;</p>
<h5 id="cr2"><a href="#cr2" class="headerlink" title="cr2"></a>cr2</h5><p>保存发生0E错误时的LinerAddress 执行 访问</p>
<h5 id="efer扩展功能寄存器"><a href="#efer扩展功能寄存器" class="headerlink" title="efer扩展功能寄存器"></a>efer扩展功能寄存器</h5><p>MSR寄存器的一个，位于0xC0000080h，只读寄存器，无法修改。但是开了VT之后，可以给GUEST_EFER写入此寄存器值，此时可以修改，是挂钩syscall的一种思路。</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12151801.png" alt="EFER"></p>
<blockquote>
<p>思路：位0置0，关闭syscall触发#GP异常，用VT接管实现挂钩syscall。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; rdmsr c0000080h</span><br><span class="line">msr[c0000080h] = 00000000`00000d01</span><br></pre></td></tr></table></figure>
<h4 id="msr寄存器"><a href="#msr寄存器" class="headerlink" title="msr寄存器"></a>msr寄存器</h4><p>MSR寄存器是一堆寄存器的组合，通过索引进行访问。MSR功能如下</p>
<p>下面是 Intel 列出的 MSR 的功能。<br>① performance-monitoring counters（性能监视计数器）。<br>② debug extensions（调试扩展的支持）。<br>③ machine-check exception capability（机器检查的能力）。<br>④ MTRR（实现 memory 类型与范围定义的寄存器）。<br>⑤ thermal and power management（功耗与温控管理）。<br>⑥ instruction-specific support（特殊指令的支持）。<br>⑦ processor feature/mode support（处理器特色和模型管理的支持）。<br>AMD 部分的 MSR 与 Intel 是兼容的，但是少了许多特色功能。</p>
<h5 id="msr对特殊指令的支持"><a href="#msr对特殊指令的支持" class="headerlink" title="msr对特殊指令的支持"></a>msr对特殊指令的支持</h5><h6 id="syscall-sysret"><a href="#syscall-sysret" class="headerlink" title="syscall/sysret"></a>syscall/sysret</h6><p>rip<br>rflags<br>ss/cs</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12151814.png" alt="msr"></p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12151815.png" alt="msr2"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; rdmsr c0000081</span><br><span class="line">msr[c0000081] = 00230010`00000000</span><br></pre></td></tr></table></figure>
<p>代表进入内核，syscall用的cs=10,ss=cs+8，其实刚好就是用的下一个在gdt表中的段描述符。<br>sysret之后，刚好就是下一个gdt表的段描述符。</p>
<p>sfmask则是用于和rflags进行not and操作的，主要是用于关闭一些位，比如tf位。不然你进入syscall，直接单步，会触发异常。</p>
<h6 id="swapgs"><a href="#swapgs" class="headerlink" title="swapgs"></a>swapgs</h6><p>x64数据段内存段无法表示基质（段的强制平坦）<br>导致gs中选择子无法满足表示基质，用ia32_gs_base当作64位基质<br>ia32_kernel_gs_base:0xc0000102h<br>ia32_gs_base:0xc0000101h<br>在执行swapgs时，切换这两个msr的值，即</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12151856.png" alt="swapgs"></p>
<p>一般用于system系统调用时切换swapgs，因为syscall进入内核不切换栈，swapgs从KPCR中找到线程内核栈，具体参考系统调用。</p>
<p>值得一提的是，windbg查这两个寄存器的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; rdmsr c0000101h</span><br><span class="line">msr[c0000101h] = fffff802`176cd000</span><br><span class="line">kd&gt; rdmsr c0000102h</span><br><span class="line">msr[c0000102h] = 00000000`00beb000</span><br></pre></td></tr></table></figure>
<p>这是因为IA32_GS_BASE和IA32_KERNEL_GS_BASE已经发生切换。因此windbg查看就是这样。而且windbg调试内核时，必须切换，不然windbg无法调试。<br>也就是说windbg调试内核必须swapgs。IA32_GS_BASE必须是R0的KPCR。但是可以通过驱动程序打印出值。需要用到操作msr寄存器的指令。</p>
<h5 id="msr寄存器的操作"><a href="#msr寄存器的操作" class="headerlink" title="msr寄存器的操作"></a>msr寄存器的操作</h5><h6 id="rdmsr进行读"><a href="#rdmsr进行读" class="headerlink" title="rdmsr进行读"></a>rdmsr进行读</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov rcx,176h</span><br><span class="line">rdmsr</span><br></pre></td></tr></table></figure>
<p>读到的内容放到edx:eax</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; r</span><br><span class="line">rax=0000000000000001 rbx=fffff802176cd180 rcx=00000000c0000101</span><br><span class="line">rdx=00000c0000000000 rsi=0000000000000001 rdi=0000000000000004</span><br><span class="line">rip=fffff8021ae00fb5 rsp=fffff80220291c58 rbp=ffffba8d3b41b040</span><br><span class="line">r8=0000000000000108  r9=ffffba8d396b9000 r10=0000000000000083</span><br><span class="line">r11=fffff80220291c88 r12=0000000000000000 r13=fffff802176cd180</span><br><span class="line">r14=0000000000000000 r15=ffffffffffffffff00</span><br><span class="line">iopl=0         nv up ei pl nz na pe nc</span><br><span class="line">cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b</span><br><span class="line">efl=00000202</span><br><span class="line"></span><br><span class="line">nt!DbgBreakPointWithStatusEnd+0x3:</span><br><span class="line">fffff802`1ae00fb5 0f32            rdmsr</span><br><span class="line"></span><br><span class="line">kd&gt; t</span><br><span class="line">fffff802`1ae00fb7 b901f84000      mov     ecx,841F0h</span><br><span class="line"></span><br><span class="line">kd&gt; r</span><br><span class="line">rax=0000000176cd000 rbx=fffff802176cd180 rcx=00000000c0000101</span><br><span class="line">rdx=00000000fffff802 rsi=0000000000000001 rdi=0000000000000004</span><br><span class="line">rip=fffff8021ae00fb7 rsp=fffff80220291c58 rbp=ffffba8d3b41b040</span><br><span class="line">r8=0000000000000108  r9=ffffba8d396b9000 r10=0000000000000083</span><br><span class="line">r11=fffff80220291c88 r12=0000000000000000 r13=fffff802176cd180</span><br><span class="line">r14=0000000000000000 r15=ffffffffffffffff00</span><br><span class="line">iopl=0         nv up ei pl nz na pe nc</span><br><span class="line">cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b</span><br><span class="line">efl=00000202</span><br></pre></td></tr></table></figure>
<p>可以看到，x64读msr寄存器是rdx:rax，也就是0xc0000101h的值是edx:eax==fffff802176cd000</p>
<h6 id="wrmsr进行写"><a href="#wrmsr进行写" class="headerlink" title="wrmsr进行写"></a>wrmsr进行写</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rcx,index</span><br><span class="line">mov rdx,writedata</span><br><span class="line">mov rax,rdx</span><br><span class="line">shr rdx,32</span><br><span class="line">wrmsr</span><br></pre></td></tr></table></figure>
<p>同样地，写msr也需要拆开进行写。</p>
<h5 id="实验验证swapgs"><a href="#实验验证swapgs" class="headerlink" title="实验验证swapgs"></a>实验验证swapgs</h5><p>前面提到，windbg任何时候rdmsr都必然是<code>KERNEL_GS_BASE</code>是R3地址，实际上<code>swaps</code>之前<code>KERNEL_GS_BASE</code>一直都是R0地址。<code>swaps</code>的本质都是<code>KERNEL_GS_BASE</code>和<code>GS_BASE</code>两个MSR寄存器互换，可以在驱动中验证这一点。</p>
<p>首先写一个<code>Swapgs</code>，它用于<code>swapgs</code>之后，读取MSR的两个<code>SWAPGS</code>相关寄存器的值，并存储起来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">_Swapgs PROC</span><br><span class="line">push rdi</span><br><span class="line">push rsi</span><br><span class="line">swapgs</span><br><span class="line">cmp rdx,0</span><br><span class="line">jz ArgIsZero</span><br><span class="line">cmp rcx,0</span><br><span class="line">jz ArgIsZero</span><br><span class="line">mov rdi,rdx ;保存一下</span><br><span class="line">mov rsi,rcx</span><br><span class="line">mov rcx,0c0000101h ;读GsBase</span><br><span class="line">call _ReadMsr</span><br><span class="line">mov [rdi],rax</span><br><span class="line">mov rcx,0c0000102h ;读KernelGsBase</span><br><span class="line">call _ReadMsr</span><br><span class="line">MOV [rsi],rax</span><br><span class="line">ArgIsZero:</span><br><span class="line">pop rsi</span><br><span class="line">pop rdi</span><br><span class="line">swapgs</span><br><span class="line">ret</span><br><span class="line">_Swapgs ENDP</span><br></pre></td></tr></table></figure>
<p>然后在驱动中打印出swapgs前后<code>KERNEL_GS_BASE</code>和<code>GS_BASE</code>验证。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">EXTERN_C NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING uRegPath)</span> &#123;</span><br><span class="line"></span><br><span class="line">    UNREFERENCED_PARAMETER(uRegPath);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    NTSTATUS status=STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">    DriverObject-&gt;DriverUnload = Unload;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> UINT64 IA32_KERNEL_GS_BASE = <span class="number">0xc0000102</span>;</span><br><span class="line">    <span class="type">const</span> UINT64 IA32_GS_BASE = <span class="number">0xc0000101</span>;</span><br><span class="line"></span><br><span class="line">    UINT64 KernelGsBase = __readMsr(IA32_KERNEL_GS_BASE);</span><br><span class="line">    UINT64 GsBase = __readMsr(IA32_GS_BASE);</span><br><span class="line"></span><br><span class="line">    kdPrint((<span class="string">&quot;[+]before swaps KernelGsBase==0x%p,GsBase==0x%p\r\n&quot;</span>,KernelGsBase,GsBase));</span><br><span class="line"></span><br><span class="line">    __swapgs(&amp;KernelGsBase,&amp;GsBase);</span><br><span class="line">    __swapgs(<span class="number">0</span>, <span class="number">0</span>);<span class="comment">//一定要再次切换 不然调用kdPrint直接卡死</span></span><br><span class="line"></span><br><span class="line">    kdPrint((<span class="string">&quot;[+]After swaps KernelGsBase==0x%p,GsBase==0x%p\r\n&quot;</span>, KernelGsBase, GsBase));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终WinDbg提示如下，验证成功。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+]before swaps KernelGsBase==0x000000006B8918000, GsBase==0xFFFFF802176CD000</span><br><span class="line">[+]After swaps KernelGsBase==0xFFFFF802176CD000, GsBase==0x000000006B8918000</span><br></pre></td></tr></table></figure>
<h4 id="long-mode下的保护模式"><a href="#long-mode下的保护模式" class="headerlink" title="long mode下的保护模式"></a>long mode下的保护模式</h4><p>保护模式是保护资源的模式，指区分权限级别以及特权级指令限制，使得用户态无法访问修改被保护的资源，如OS内核、CR寄存器、MSR寄存器等。</p>
<p>保护模式分为<strong>段保护</strong>和<strong>页保护</strong>，long-mode(x64)有意忽略保护的一些属性。</p>
<p>long-mode本质上是建立在保护模式上的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[Real Mode] --&gt;|segmentation| B[paging]</span><br><span class="line">    B --&gt;| | C[Protected Mode]</span><br><span class="line">    C --&gt;|直接进入| D[Long Mode]</span><br></pre></td></tr></table></figure>
<p>在intel64中，long-mode又被称为IA-32E。</p>
<h5 id="段保护（管理）"><a href="#段保护（管理）" class="headerlink" title="段保护（管理）"></a>段保护（管理）</h5><p>保护模式下段式管理管理的资源有</p>
<ul>
<li>CR0和CR4</li>
<li>GDTR与LDTR（可选）</li>
<li>IDTR</li>
<li>TR</li>
<li>段选择子寄存器：ES、CS、SS、DS、FS以及GS寄存器</li>
</ul>
<p>下面的系统数据结构被用于段式管理中</p>
<ul>
<li>GDT和LDT（可选）</li>
<li>IDT</li>
<li>TSS段</li>
<li>Segment Descriptor ：包括 System Segment Descriptor，Code /Data Segment Descriptor</li>
<li>Gate Descriptor：包括Call-gate，Interrupt/Trap-gate，以及Task-gate</li>
<li>Selector：选择子数据结构存放在段寄存器里</li>
</ul>
<p>段保护的职责是把和段基址相对的地址也就是逻辑地址转换为线性地址和进行行为控制，防止随意访问。</p>
<h6 id="段的内存管理"><a href="#段的内存管理" class="headerlink" title="段的内存管理"></a>段的内存管理</h6><p>实模式下，逻辑地址=段基质&lt;<4+段偏移。
CS:0X1000   CS:0X10000   0X10000+0X1000=0X11000物理地址
段偏移-->逻辑地址—&gt;物理地址<br>在保护模式下，段的基质是从段描述符加载来的。是段寄存器先加载好，意思是段寄存器有值之后，才可以去段描述符中查找段基址。</p>
<p>以下是用Markdown格式呈现的表格：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>linear address</th>
<th>base+offset</th>
</tr>
</thead>
<tbody>
<tr>
<td>base</td>
<td>1. 在实模式下：base=selector &lt;&lt; 4<br>2. 在保护模式下：base从段描述符的base域加载<br>3. 在64位模式下：base值为0</td>
</tr>
<tr>
<td>offset</td>
<td>在段的limit范围内（在64位模式下，不检查limit）</td>
</tr>
</tbody>
</table>
</div>
<p>在x64ia32e下，base强制为0，也就是平坦模型，且不检查段界限。<br>逻辑地址=线性地址（虚拟地址别称）</p>
<h6 id="段的保护措施"><a href="#段的保护措施" class="headerlink" title="段的保护措施"></a>段的保护措施</h6><p>在加载段时候,段保护会进行检查。</p>
<ul>
<li>limit(x64已去除)</li>
<li>段type</li>
<li>段Privilege</li>
</ul>
<p>值得一提的是,一旦段选择子加载进段寄存器,即段寄存器出现段选择子,则以后不会检查段的DPL和Type。除非修改段寄存器,让他重新加载段描述符。</p>
<h6 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h6><p>他是段的标识符，结构如下。<br>他是用于加载到段寄存器的可视部分的。</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12152037.png" alt="swapgs"></p>
<ul>
<li>RPL（Requested Privilege Level）：请求访问者所使用的权限级别，从0到3级。</li>
<li>TI（Table Indicator）：描述符表索引位。当TI=0时，从GDT查找；当TI=1时，从LDT查找。</li>
<li>Index（Descriptor Index）：这是Descriptor在GDT/LDT中的序号，根据TI的值在相应的描述表中查找descriptor。</li>
</ul>
<p>当段选择子(段寄存器)为0-3时，这个段选择子无效。<br>当段选择子寄存器被修改时，如果权限校验通过，段选择子就会被加载到段寄存器中。<br>x64下，对于Null Selector加载到段选择子处理器不会检查，运行加载Null Selector到除CS寄存器之外任何寄存器，并进行访问。<br>Null selector的意义在于当retf iret时，即高权到低权限，如果ES、DS、FS这些段寄存器<code>DPL&lt;CPL</code>，处理器默认会把这些段寄存器加载Null选择子。<br>防止R0-&gt;R3返回后，仍然可以访问R0的数据。</p>
<h6 id="描述符表"><a href="#描述符表" class="headerlink" title="描述符表"></a>描述符表</h6><p>段选择子用于描述符表，共有三种描述符表，为gdt，ldt，idt。<br>对于gdt表，用gdtr来表示。</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12152317.png" alt="swapgs"></p>
<p>gdtr是一个80位寄存器。<br>ldgt[内存地址]用于加载gdt，其中低16位是limit。</p>
<h6 id="段选择子寄存器"><a href="#段选择子寄存器" class="headerlink" title="段选择子寄存器"></a>段选择子寄存器</h6><p>段选择子寄存器保护可视和不可视部分。</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12152320.png" alt="swapgs"></p>
<p>其中只有sel可视，当段选择子寄存器加载段选择子，不可视部分也加载，不可视的作用是cache，防止查表浪费时间。<br>也就是前面所说的一旦段寄存器加载了段选择子，不会再进行一些dpl权限检查。</p>
<h6 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h6><p>段描述符是段选择子指向的在段描述符表中的具体内容，此处指向意味着索引。</p>
<p>对于段描述符，种类分为段描述符和门描述符。<br>按照系统性质分为系统和非系统描述符（代码数据段描述符）</p>
<ul>
<li>System descriptor（系统描述符）<ul>
<li>System Segment descriptor（系统段描述符）：包括 LDT descriptor 和 TSS descriptor。</li>
<li>Gate descriptor（门描述符）：包括 Call-gate，Interrupt-gate，Trap-gate，以及 Task-gate descriptor。</li>
</ul>
</li>
</ul>
<ul>
<li>Non-system segment descriptor（非系统描述符）<ul>
<li>Code segment descriptor（代码段描述符）。</li>
<li>Data segment descriptor（数据段描述符）。</li>
</ul>
</li>
</ul>
<p>对于Code代码段的描述符一般是如下结构</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12152053.png" alt="描述符"></p>
<p>值得注意的是L位，L即long mode的段描述符，开启后，limit和base无效。</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12152057.png" alt="描述符2"></p>
<p>对于门描述符，如调用门是如下结构</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12152100.png" alt="描述符3"></p>
<p>即s位是1，扩展128位。<br>调用门描述符可以在ldt，也可以在gdt中。</p>
<p>对于tss描述符（ldt描述符也是如此）</p>
<p>long mode下，tss不用于切换，结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTSS64</span><br><span class="line">nt!_KTSS64</span><br><span class="line">  +0x000 Reserved0 : Uint8B</span><br><span class="line">  +0x004 Rsp0      : Uint8B</span><br><span class="line">  +0x00c Rsp1      : Uint8B</span><br><span class="line">  +0x014 Rsp2      : Uint8B</span><br><span class="line">  +0x01c Ist       : [8] Uint8B</span><br><span class="line">  +0x05c Reserved1 : Uint8B</span><br><span class="line">  +0x064 Reserved2 : Uint2B</span><br><span class="line">  +0x066 IoMapBase : Uint2B</span><br></pre></td></tr></table></figure>
<p>TSS描述符如下：</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12152112.png" alt="描述符4"></p>
<p>TSS描述符可从TR寄存器（段选择子）找到。寻找方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; r tr</span><br><span class="line">tr=0040 //40是在GDT表的第八个</span><br><span class="line">kd&gt; r gdtr</span><br><span class="line">gdtr=fffff80220279fb0</span><br><span class="line">kd&gt; dq fffff80220279fb0+8*8</span><br><span class="line">fffff802`20279ff0  20008b27`80000067 00000000`fffff802</span><br><span class="line">fffff802`2027a000  0040f300`00003c00 00000000`00000000</span><br><span class="line">fffff802`2027a010  00000000`00000000 00000000`00000000</span><br><span class="line">fffff802`2027a020  00000000`00000000 00000000`00000000</span><br><span class="line">kd&gt; dt _ktss64 fffff80220278000</span><br><span class="line">nt!_KTSS64</span><br><span class="line">    +0x000 Reserved0         : 0</span><br><span class="line">    +0x008 Rsp0              : 0xfffff607`8ad3fc90</span><br><span class="line">    +0x00c Rsp1              : 0</span><br><span class="line">    +0x014 Rsp2              : 0</span><br><span class="line">    +0x01c Ist               : [8] 0</span><br><span class="line">    +0x05c Reserved1         : 0</span><br><span class="line">    +0x064 Reserved2         : 0</span><br><span class="line">    +0x066 IoMapBase         : 0x68</span><br></pre></td></tr></table></figure>
<p>IA-32E下的TSS已经不用于任务切换，只用于保存ISR中断执行时的堆栈和其他特权级的堆栈<br>其中Ist就是中断例程所用的栈。</p>
<h6 id="ldt描述符和ldt"><a href="#ldt描述符和ldt" class="headerlink" title="ldt描述符和ldt"></a>ldt描述符和ldt</h6><p>ldt描述符只能位于gdt表中</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12152200.png" alt="描述符4"></p>
<p>ldt描述符指向的内存就是ldt表，没有意义，因为注册ldt必须使用gdt，gdt被patchguard监控。</p>
<h6 id="idtr与gdtr"><a href="#idtr与gdtr" class="headerlink" title="idtr与gdtr"></a>idtr与gdtr</h6><blockquote>
<p>笔记中没有，需自己补充。</p>
</blockquote>
<h5 id="页保护（管理）"><a href="#页保护（管理）" class="headerlink" title="页保护（管理）"></a>页保护（管理）</h5><p>下面的硬件资源被用于paging管理环境中。</p>
<ul>
<li>4个控制寄存器：CR0、CR2、CR3，以及CR4。</li>
<li>IA32_EFER。</li>
</ul>
<p>下面的页转换表结构被用于paging管理环境中。</p>
<ul>
<li>PML4T（Page Map Level 4 Table）：用于Long Mode之中。</li>
<li>PDPT（Page Directory Pointer Table）。</li>
<li>PDT（Page Directory Table）。</li>
<li>PT（Page Table）。</li>
</ul>
<p>页管理的职责就是将线性地址，也就是虚拟地址，经过页管理转换成物理地址和进行访问控制，防止随意访问</p>
<h6 id="ia32e页转换模式"><a href="#ia32e页转换模式" class="headerlink" title="ia32e页转换模式"></a>ia32e页转换模式</h6><p>具体分为3种清空:4K,2M,1G页面的转换。</p>
<p>在进行页面转换时,需要用到CR0,CR2,CR3,CR4和IA32_EFER这些寄存器。</p>
<p>对于4KB分页,采取9 9 9 12分页,从CR3开始，多级指针查找。</p>
<p>48位虚拟地址,前16位符号扩展,不能使用。</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12160013.png" alt="描述符4"></p>
<p>上图为4KB分页，2MB则意味着PDE表项的PS=1。</p>
<p>值得注意的是，物理地址一定是按照页粒度对齐的。</p>
<p>即4KB分页，最末级指针的物理地址一定是4KB对齐；2MB分页，PDE所描述的物理地址一定是低21位为空，不能跨页，这是硬件规定。在PTE HOOK大页时容易出错。</p>
<h6 id="cr3结构"><a href="#cr3结构" class="headerlink" title="cr3结构"></a>cr3结构</h6><p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12160018.png" alt="描述符4"></p>
<p>本质就是多级指针，这样可以节省内存，cr3指向一个4kb物理页，因此只需要低12位忽略（低12是属性）。</p>
<h6 id="pml4e结构"><a href="#pml4e结构" class="headerlink" title="pml4e结构"></a>pml4e结构</h6><p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12160020.png" alt="描述符4"></p>
<p>任何时候，cr3和pml4e都是指向一块4kb内存的。<br>但是如果开了1gb分页，pdpte的[30:12]都为空，并且低12位属性。</p>
<h6 id="pdpte结构"><a href="#pdpte结构" class="headerlink" title="pdpte结构"></a>pdpte结构</h6><p>如上面所说，</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12160024.png" alt="描述符4"></p>
<p>如果ps（位7=1），则pdpte[30:12]为0，代表物理地址按照1gb对齐。</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12160025.png" alt="描述符4"></p>
<p>否则，2mb或者4kb的则是一样的。</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12160026.png" alt="描述符4"></p>
<h6 id="pde结构"><a href="#pde结构" class="headerlink" title="pde结构"></a>pde结构</h6><p>同样，pde也遵循大页定律。若2mb分页。</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12160029.png" alt="描述符4"></p>
<p>物理页必须对齐，即12-21位强制为0，ps=1。</p>
<p>若4kb分页。</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12160030.png" alt="描述符4"></p>
<h6 id="pte结构"><a href="#pte结构" class="headerlink" title="pte结构"></a>pte结构</h6><p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12160032.png" alt="描述符4"></p>
<p>4kb分页才会有的结构，8-12为忽略。</p>
<h6 id="页表项的其他位含义"><a href="#页表项的其他位含义" class="headerlink" title="页表项的其他位含义"></a>页表项的其他位含义</h6><ul>
<li><strong>P</strong>：存在位，经常用于OS。</li>
<li><strong>R/W位</strong>：读写位，页保护的读写</li>
<li><strong>U/S</strong>：0则Supervisor才可以访问，1则User也可以访问，高地址注入的关键 内存加载注入DLL,3换地址。</li>
<li><strong>A</strong>：访问位，处理器不清除，只置位。</li>
<li><strong>PS</strong>：大页标志</li>
<li><strong>D</strong>：脏位，代表写过，处理器不清除，只置位。</li>
<li><strong>G</strong>：CR4.PGE=1是，G位可置位，代表CR3更新时，TLB不刷新</li>
</ul>
<h5 id="tlb与cache"><a href="#tlb与cache" class="headerlink" title="tlb与cache"></a>tlb与cache</h5><p>页表是多级指针，一层层对地址访问会很耗时。TLB解决这个问题。</p>
<p>TLB(Translation Lookaside buffers)本质上是一种cache，通过TLB可以绕过多次查找内存，直接找到转换结构，这个结果包含最终的物理地址和页面的属性。</p>
<p>可以简单理解为Linear Address和PageNumber的关系。</p>
<p>分页的实质是：<code>线性地址=PageNumber+Page offset</code></p>
<p>CR3是多级指针，但其实可以看成一个一级指针；但一级指针需要全部映射、耗内存，因此CR3设计为多级指针，不过也可以从逻辑上看成一个一级指针。</p>
<p>如果把CR3看成一级指针（即一系列4KB物理地址线性排列），那么PageNumber就是前36位（对应“9 9 9 9 12”中的前4个“9”），最后12位是物理内存的偏移（Page Offset）。</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12160043.png" alt="描述符4"></p>
<p>在不同的分页模式下，Page Number的位数会变化，Page Offset的位数也会变化。</p>
<h2 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h2><h3 id="lab1：inline-hook-framework"><a href="#lab1：inline-hook-framework" class="headerlink" title="lab1：inline_hook_framework"></a>lab1：inline_hook_framework</h3><p>用到<a href="https://njmxye.de5.net/内核驱动常用的库与头文件.zip">Hde库</a>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//inline_hook.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_HOOK_COUNT 0x100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_HOOK_INFO</span> &#123;</span><br><span class="line">    <span class="type">void</span>* ori_func_addr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> SavedCode[<span class="number">14</span>];</span><br><span class="line">&#125;HOOK_INFO, * PHOOK_INFO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">inline_hook_manager</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">inline_remove_hook</span><span class="params">(<span class="type">void</span>* ori_func_addr)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">inline_hook</span><span class="params">(<span class="type">void</span>** ori_func_addr, <span class="type">void</span>* target_func)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">create_tramp_line</span><span class="params">(<span class="type">char</span>* target_func, UINT64 break_bytes_count, <span class="type">char</span>* break_bytes)</span></span>;</span><br><span class="line">    <span class="function">KIRQL <span class="title">wp_bit_off</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wp_bit_on</span><span class="params">(KIRQL)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> inline_hook_manager* <span class="title">fn_get_instance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> inline_hook_manager* instance;</span><br><span class="line">    UINT64 m_cur_hook_count;</span><br><span class="line">    HOOK_INFO m_info[MAX_HOOK_COUNT];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* m_tramp_line;</span><br><span class="line">    UINT64 m_tramp_line_used;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//inline_hook.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inline_hook.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hde64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inline_hook_manager* inline_hook_manager::instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">KIRQL <span class="title">inline_hook_manager::wp_bit_off</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">////关闭CR0</span></span><br><span class="line">    <span class="keyword">auto</span> irql = <span class="built_in">KeRaiseIrqlToDpcLevel</span>();<span class="comment">//关闭线程切换</span></span><br><span class="line">    UINT64 Cr0 = __readcr0();</span><br><span class="line">    Cr0 &amp;= <span class="number">0xfffffffffffeffff</span>;</span><br><span class="line">    __writecr0(Cr0);</span><br><span class="line">    _disable();</span><br><span class="line">    <span class="keyword">return</span> irql;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// （对应原代码片段3）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inline_hook_manager::wp_bit_on</span><span class="params">(KIRQL irql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">////开启CR0</span></span><br><span class="line">    UINT64 Cr0 = __readcr0();</span><br><span class="line">    Cr0 |= <span class="number">0x10000</span>;</span><br><span class="line">    _enable();</span><br><span class="line">    __writecr0(Cr0);</span><br><span class="line">    <span class="built_in">KeLowerIrql</span>(irql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">inline_hook_manager::inline_hook</span><span class="params">(<span class="type">void</span>** ori_func_addr, <span class="type">void</span>* target_func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_cur_hook_count &gt;= MAX_HOOK_COUNT) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    UINT64 break_byte_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* ori_func = (<span class="type">char</span>*)ori_func_addr;</span><br><span class="line">    hde64s hde&#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (break_byte_count &lt; <span class="number">14</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">hde64_disasm</span>(ori_func + break_byte_count, &amp;hde);</span><br><span class="line"></span><br><span class="line">        break_byte_count += hde.len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; info = instance-&gt;m_info;</span><br><span class="line">    info[m_cur_hook_count].ori_func_addr = ori_func;</span><br><span class="line">    <span class="built_in">memcpy</span>(info[m_cur_hook_count].SavedCode, ori_func, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    *ori_func_addr = <span class="built_in">create_tramp_line</span>(ori_func, break_byte_count, ori_func);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> jmp_code[<span class="number">14</span>] = &#123; <span class="number">0xff</span>,<span class="number">0x25</span>,<span class="number">0x00</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    *((ULONG64*)(&amp;jmp_code[<span class="number">6</span>])) = (ULONG64)target_func;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> irql = <span class="built_in">wp_bit_off</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(ori_func, jmp_code, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">wp_bit_on</span>(irql);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">inline_hook_manager::create_tramp_line</span><span class="params">(<span class="type">char</span>* target_func, UINT64 break_bytes_count, <span class="type">char</span>* break_bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">const</span> ULONG TrampLineBreakBytes = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> TrampLineCode[TrampLineBreakBytes] = &#123; <span class="comment">//push xxx mov ret 不影响任何寄存器</span></span><br><span class="line">    <span class="number">0x6A</span>, <span class="number">0x00</span>, <span class="number">0x3E</span>, <span class="number">0xC7</span>, <span class="number">0x04</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x3E</span>, <span class="number">0xC7</span>, <span class="number">0x44</span>, <span class="number">0x24</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC3</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制绝对跳转</span></span><br><span class="line">    *((PUINT32)&amp;TrampLineCode[<span class="number">6</span>]) = (UINT32)(((<span class="type">uint64_t</span>)target_func + break_bytes_count) &amp; <span class="number">0xFFFFFFFF</span>);</span><br><span class="line">    *((PUINT32)&amp;TrampLineCode[<span class="number">15</span>]) = (UINT32)((((<span class="type">uint64_t</span>)target_func + break_bytes_count) &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xFFFFFFFF</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; used = instance-&gt;m_tramp_line_used;</span><br><span class="line">    <span class="keyword">auto</span>&amp; tramp_line_base = instance-&gt;m_tramp_line;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制原先毁掉的字节</span></span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>(tramp_line_base + used, break_bytes, break_bytes_count);</span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>(tramp_line_base + used + break_bytes_count, TrampLineCode, <span class="built_in">sizeof</span>(TrampLineCode));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ret = tramp_line_base + used;</span><br><span class="line">    used += TrampLineBreakBytes + break_bytes_count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">inline_hook_manager* <span class="title">inline_hook_manager::fn_get_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        instance = (inline_hook_manager*)<span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, <span class="built_in">sizeof</span>(inline_hook_manager), <span class="string">&#x27;HOOK&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        instance-&gt;m_cur_hook_count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">RtlSecureZeroMemory</span>(instance-&gt;m_info, <span class="built_in">sizeof</span>(HOOK_INFO) * MAX_HOOK_COUNT);</span><br><span class="line">        instance-&gt;m_tramp_line = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, PAGE_SIZE, <span class="string">&#x27;Line&#x27;</span>);</span><br><span class="line">        instance-&gt;m_tramp_line_used = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DriverMain.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inline_hook.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* fnNtCreateFile)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PHANDLE FileHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ POBJECT_ATTRIBUTES ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PIO_STATUS_BLOCK IoStatusBlock,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PLARGE_INTEGER AllocationSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG FileAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG ShareAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG CreateDisposition,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG CreateOptions,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG EaLength</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"></span><br><span class="line">fnNtCreateFile g_OriNtCreateFile;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的 NtCreateFile 挂钩函数</span></span><br><span class="line"><span class="function">NTSTATUS NTAPI <span class="title">MyNtCreateFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PHANDLE FileHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ POBJECT_ATTRIBUTES ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PIO_STATUS_BLOCK IoStatusBlock,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PLARGE_INTEGER AllocationSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG FileAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG ShareAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG CreateDisposition,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG CreateOptions,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG EaLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印调试信息，确认进入挂钩函数</span></span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[+]create file\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验 ObjectAttributes 及文件名相关指针有效性</span></span><br><span class="line">    <span class="keyword">if</span> (ObjectAttributes &amp;&amp;</span><br><span class="line">        ObjectAttributes-&gt;ObjectName &amp;&amp;</span><br><span class="line">        ObjectAttributes-&gt;ObjectName-&gt;Buffer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 分配非分页内存存储文件名（包含结束符）</span></span><br><span class="line">        <span class="type">wchar_t</span>* name = (<span class="type">wchar_t</span>*)<span class="built_in">ExAllocatePool</span>(NonPagedPool,</span><br><span class="line">            ObjectAttributes-&gt;ObjectName-&gt;Length + <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 初始化内存并拷贝文件名</span></span><br><span class="line">            <span class="built_in">RtlZeroMemory</span>(name, ObjectAttributes-&gt;ObjectName-&gt;Length + <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>));</span><br><span class="line">            <span class="built_in">RtlCopyMemory</span>(name, ObjectAttributes-&gt;ObjectName-&gt;Buffer, ObjectAttributes-&gt;ObjectName-&gt;Length);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查文件名是否包含 &quot;tips.txt&quot;，若是则拒绝访问</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">wcsstr</span>(name, <span class="string">L&quot;tips.txt&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ExFreePool</span>(name);  <span class="comment">// 释放内存避免泄漏</span></span><br><span class="line">                <span class="keyword">return</span> STATUS_ACCESS_DENIED;  <span class="comment">// 返回访问拒绝状态</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">ExFreePool</span>(name);  <span class="comment">// 释放内存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用原始 NtCreateFile 函数，传递所有参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g_OriNtCreateFile</span>(</span><br><span class="line">        FileHandle,</span><br><span class="line">        DesiredAccess,</span><br><span class="line">        ObjectAttributes,</span><br><span class="line">        IoStatusBlock,</span><br><span class="line">        AllocationSize,</span><br><span class="line">        FileAttributes,</span><br><span class="line">        ShareAccess,</span><br><span class="line">        CreateDisposition,</span><br><span class="line">        CreateOptions,</span><br><span class="line">        EaBuffer,</span><br><span class="line">        EaLength</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动入口函数</span></span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">DriverEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PDRIVER_OBJECT DriverObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PUNICODE_STRING RegistryPath</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(RegistryPath);  <span class="comment">// 消除未使用参数警告</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存原始 NtCreateFile 函数地址</span></span><br><span class="line">    g_OriNtCreateFile = NtCreateFile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行内联挂钩：将 NtCreateFile 挂钩到 MyNtCreateFile</span></span><br><span class="line">    <span class="keyword">auto</span> ret = inline_hook_manager::<span class="built_in">fn_get_instance</span>()-&gt;<span class="built_in">inline_hook</span>((<span class="type">void</span>**)&amp;g_OriNtCreateFile,MyNtCreateFile);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据挂钩结果返回对应状态</span></span><br><span class="line">    <span class="keyword">return</span> ret ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lab1：sample-ptehook"><a href="#lab1：sample-ptehook" class="headerlink" title="lab1：sample_ptehook"></a>lab1：sample_ptehook</h3><p>用到<a href="https://njmxye.de5.net/内核驱动常用的库与头文件.zip">ia32库</a>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get_page_table.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ia32.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PAGE_TABLE</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> LineAddress;</span><br><span class="line">    pte_64* PteAddress;</span><br><span class="line">    pde_64* PdeAddress;</span><br><span class="line">    pdpte_64* PdpteAddress;</span><br><span class="line">    pml4e_64* Pml4eAddress;</span><br><span class="line">&#125; PAGE_TABLE, * PPAGE_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">uint64_t</span> <span class="title">va_to_pa</span><span class="params">(<span class="type">uint64_t</span> va)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">uint64_t</span> <span class="title">pa_to_va</span><span class="params">(<span class="type">uint64_t</span> pa)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">get_page_table</span><span class="params">(PAGE_TABLE&amp; table)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//page_table_self_map.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ia32.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义页表结构，存储各级页表项地址</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PAGE_TABLE</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> LineAddress;      <span class="comment">// 线性地址（虚拟地址）</span></span><br><span class="line">    pte_64* PteAddress;        <span class="comment">// PTE（页表项）地址</span></span><br><span class="line">    pde_64* PdeAddress;        <span class="comment">// PDE（页目录项）地址</span></span><br><span class="line">    pdpte_64* PdpteAddress;    <span class="comment">// PDPTE（页目录指针表项）地址</span></span><br><span class="line">    pml4e_64* Pml4eAddress;    <span class="comment">// PML4E（页映射级别4项）地址</span></span><br><span class="line">&#125; PAGE_TABLE, * PPAGE_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">va_to_pa</span><span class="params">(<span class="type">uint64_t</span> va)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MmGetPhysicalAddress</span>((VOID*)va).QuadPart;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 物理地址转虚拟地址（内核态）</span></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">pa_to_va</span><span class="params">(<span class="type">uint64_t</span> pa)</span> </span>&#123;</span><br><span class="line">    PHYSICAL_ADDRESS pa_ = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    pa_.QuadPart = pa;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint64_t</span>)<span class="built_in">MmGetVirtualForPhysical</span>(pa_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取PTE基地址（从CR3寄存器解析）</span></span><br><span class="line"><span class="function">pte_64* <span class="title">get_pte_base</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cr3 cr3_pa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    cr3_pa.flags = __readcr3();  <span class="comment">// 读取CR3寄存器，获取页目录基址</span></span><br><span class="line">    pml4e_64* cr3_va = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将CR3中的物理地址转为虚拟地址（乘以页大小，x64页大小默认4KB即0x1000）</span></span><br><span class="line">    cr3_va = (pml4e_64*)<span class="built_in">pa_to_va</span>(cr3_pa.address_of_page_directory * PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验地址有效性</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>(cr3_va)) &#123;</span><br><span class="line">        <span class="built_in">KdPrint</span>((<span class="string">&quot;[+]failed to get cr3 page\r\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历PML4表（512项），匹配页帧号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cr3_va[i].page_frame_number == cr3_pa.address_of_page_directory) &#123;</span><br><span class="line">            <span class="comment">// 构造PTE基地址（x64高地址映射，0xffff000000000000为内核空间基址，i&lt;&lt;39对应PML4索引偏移）</span></span><br><span class="line">            <span class="keyword">return</span> (pte_64*)(<span class="number">0xffff000000000000</span> | (i &lt;&lt; <span class="number">39</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据虚拟地址获取对应的PTE地址</span></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">get_pte_address_by_va</span><span class="params">(<span class="type">uint64_t</span> va)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 掩码保留虚拟地址的低47位（x64用户态虚拟地址仅低47位有效）</span></span><br><span class="line">    va &amp;= <span class="number">0x0000ffffffffffff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算偏移：右移12位（页内偏移）后左移3位（每个页表项8字节，即*8）</span></span><br><span class="line">    <span class="keyword">auto</span> offset = (va &gt;&gt; <span class="number">12</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取PTE基地址并计算最终PTE地址</span></span><br><span class="line">    <span class="type">uint64_t</span> pte_base = (<span class="type">uint64_t</span>)<span class="built_in">get_pte_base</span>();</span><br><span class="line">    <span class="keyword">return</span> pte_base + offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充PAGE_TABLE结构，获取各级页表项地址</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_page_table</span><span class="params">(PAGE_TABLE&amp; table)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> va = table.LineAddress;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次获取PTE/PDE/PDPTE/PML4E地址（逐级向上解析）</span></span><br><span class="line">    table.PteAddress = (pte_64*)<span class="built_in">get_pte_address_by_va</span>(va);</span><br><span class="line">    table.PdeAddress = (pde_64*)(<span class="built_in">get_pte_address_by_va</span>((<span class="type">uint64_t</span>)table.PteAddress));</span><br><span class="line">    table.PdpteAddress = (pdpte_64*)(<span class="built_in">get_pte_address_by_va</span>((<span class="type">uint64_t</span>)table.PdeAddress));</span><br><span class="line">    table.Pml4eAddress = (pml4e_64*)(<span class="built_in">get_pte_address_by_va</span>((<span class="type">uint64_t</span>)table.PdpteAddress));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动入口函数</span></span><br><span class="line"><span class="comment">//EXTERN_C NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObj, PUNICODE_STRING pRegPath) &#123;</span></span><br><span class="line"><span class="comment">//    UNREFERENCED_PARAMETER(pRegPath);  // 消除未使用参数警告</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    // 获取PTE基地址并打印</span></span><br><span class="line"><span class="comment">//    auto pte_base = get_pte_base();</span></span><br><span class="line"><span class="comment">//    KdPrint((&quot;[+]PteBase:%llx\r\n&quot;, pte_base));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    // 初始化页表结构并填充各级地址</span></span><br><span class="line"><span class="comment">//    PAGE_TABLE table = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//    table.LineAddress = 0;  // 测试地址：虚拟地址0</span></span><br><span class="line"><span class="comment">//    get_page_table(table);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    // 打印各级页表项地址</span></span><br><span class="line"><span class="comment">//    KdPrint((&quot;[+]PteAddress:%llx,PdeAddress:%llx,PdpteAddress:%llx,Pml4eAddress:%llx\r\n&quot;,</span></span><br><span class="line"><span class="comment">//        table.PteAddress, table.PdeAddress, table.PdpteAddress, table.Pml4eAddress));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    // 卸载驱动（示例仅测试，直接返回失败）</span></span><br><span class="line"><span class="comment">//    pDriverObj-&gt;DriverUnload = NULL;</span></span><br><span class="line"><span class="comment">//    return STATUS_UNSUCCESSFUL;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sample_pte_hook.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ia32.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;get_page_table.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sample_pte_hook.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sample_pte_hook.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logger</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* info, <span class="type">bool</span> is_err, LONG err_code)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_err) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[pte_hook]err:%s,err_code:%x\r\n&quot;</span>, info, err_code);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[pte_hook]info:%s\r\n&quot;</span>, info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isolation_pages</span><span class="params">(HANDLE process_id, <span class="type">void</span>* va)</span> </span>&#123;</span><br><span class="line">    PEPROCESS process&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    <span class="type">void</span>* fake_pages_start = <span class="number">0</span>;</span><br><span class="line">    KAPC_STATE apc&#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fake page entry</span></span><br><span class="line">    pdpte_64 fake_pdpdte;</span><br><span class="line">    pde_64 fake_pde;</span><br><span class="line">    pte_64 fake_pte;</span><br><span class="line">    <span class="comment">//fake page table</span></span><br><span class="line">    pdpte_64* fake_pdpt;</span><br><span class="line">    pde_64* fake_pdt;</span><br><span class="line">    pte_64* fake_pt;</span><br><span class="line">    <span class="comment">//4kb physical memory</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* fake_4kb_memory;</span><br><span class="line">    PAGE_TABLE table&#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//index</span></span><br><span class="line">    <span class="type">uint64_t</span> pml4e_index, pdpte_index, pde_index, pte_index;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> addr = ((<span class="type">uint64_t</span>)va &amp; <span class="number">0x0000FFFFFFFFFFFF</span>);</span><br><span class="line">    <span class="comment">//获取PageTable结构的索引</span></span><br><span class="line">    UINT64 pml4e_index = ((<span class="type">uint64_t</span>)addr &amp; <span class="number">0x0000FF8000000000</span>) &gt;&gt; <span class="number">39</span>;</span><br><span class="line"></span><br><span class="line">    UINT64 pdpte_index = ((<span class="type">uint64_t</span>)addr &amp; <span class="number">0x0000007FC0000000</span>) &gt;&gt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    UINT64 pde_index = ((<span class="type">uint64_t</span>)addr &amp; <span class="number">0x00000003FE00000</span>) &gt;&gt; <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">    UINT64 pte_index = ((<span class="type">uint64_t</span>)addr &amp; <span class="number">0x0000000001ff000</span>) &gt;&gt; <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    table.LineAddress = (<span class="type">uint64_t</span>)(<span class="built_in">PAGE_ALIGN</span>(va));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get_page_table</span>(table);</span><br><span class="line"></span><br><span class="line">    PHYSICAL_ADDRESS low&#123; <span class="number">0</span> &#125;, high&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    high.QuadPart = MAXULONG64;</span><br><span class="line">    <span class="type">bool</span> success = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    status = <span class="built_in">PsLookupProcessByProcessId</span>(process_id, &amp;process);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger</span>(<span class="string">&quot;failed to get process by process id&quot;</span>, <span class="literal">true</span>, status);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        fake_pages_start = <span class="built_in">MmAllocateContiguousMemorySpecifyCache</span>(PAGE_SIZE * <span class="number">4</span>, low, high, low, MmCached);</span><br><span class="line">        <span class="keyword">if</span> (fake_pages_start == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">logger</span>(<span class="string">&quot;failed to alloc contiguous memory&quot;</span>, <span class="literal">true</span>, STATUS_NO_MEMORY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fake_pdpt = (pdpte_64*)fake_pages_start;</span><br><span class="line">        fake_pdt = (pde_64*)((<span class="type">uint64_t</span>)fake_pages_start + PAGE_SIZE);</span><br><span class="line">        fake_pt = (pte_64*)((<span class="type">uint64_t</span>)fake_pages_start + PAGE_SIZE * <span class="number">2</span>);</span><br><span class="line">        fake_4kb_memory = (<span class="type">unsigned</span> <span class="type">char</span>*)((<span class="type">uint64_t</span>)fake_pages_start + PAGE_SIZE * <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(fake_4kb_memory, <span class="built_in">PAGE_ALIGN</span>(va), PAGE_SIZE);</span><br><span class="line">        <span class="built_in">memcpy</span>(fake_pt, table.PteAddress - pte_index, PAGE_SIZE);</span><br><span class="line">        <span class="built_in">memcpy</span>(fake_pdt, table.PdeAddress - pde_index, PAGE_SIZE);</span><br><span class="line">        <span class="built_in">memcpy</span>(fake_pdpt, table.PdpteAddress - pdpte_index, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">        fake_pt[pte_index].page_frame_number = <span class="built_in">va_to_pa</span>((<span class="type">uint64_t</span>)fake_4kb_memory) / PAGE_SIZE;</span><br><span class="line">        fake_pdt[pde_index].page_frame_number = <span class="built_in">va_to_pa</span>((<span class="type">uint64_t</span>)fake_pt) / PAGE_SIZE;</span><br><span class="line">        fake_pdpt[pdpte_index].page_frame_number = <span class="built_in">va_to_pa</span>((<span class="type">uint64_t</span>)fake_pdt) / PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">KeStackAttachProcess</span>(process, &amp;apc);</span><br><span class="line"></span><br><span class="line">        pml4e_64* cr3_va = (pml4e_64*)<span class="built_in">pa_to_va</span>((<span class="type">uint64_t</span>)__readcr3());</span><br><span class="line"></span><br><span class="line">        cr3_va[pml4e_index].page_frame_number = <span class="built_in">va_to_pa</span>((<span class="type">uint64_t</span>)fake_pdpt) / PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">KeUnstackDetachProcess</span>(&amp;apc);</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ObDereferenceObject</span>(process);</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT, PUNICODE_STRING)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isolation_pages</span>((HANDLE)<span class="number">4532</span>, (<span class="type">void</span>*)<span class="number">0xfffff80087ba5555</span>)) &#123;</span><br><span class="line">        <span class="built_in">logger</span>(<span class="string">&quot;isolation successfully&quot;</span>, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lab1：perfect-pte-hook"><a href="#lab1：perfect-pte-hook" class="headerlink" title="lab1：perfect_pte_hook"></a>lab1：perfect_pte_hook</h3><p>用到<a href="https://njmxye.de5.net/内核驱动常用的库与头文件.zip">Hde与ia32库</a>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PteHookManager.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntimage.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ia32/ia32.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Hde/hde64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_MANAGER_TAG <span class="string">&#x27;pmna&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_HOOK_COUNT 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//using uint32_t = unsigned long;</span></span><br><span class="line"><span class="comment">//using uint64_t = unsigned long long;</span></span><br><span class="line"><span class="comment">//using uint16_t = unsigned short;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_HOOK_INFO</span> &#123;</span><br><span class="line">    HANDLE ProcessId;</span><br><span class="line">    <span class="type">char</span> OriBytes[<span class="number">14</span>];</span><br><span class="line">    <span class="type">void</span>* OriAddr;</span><br><span class="line">&#125;HOOK_INFO, * PHOOK_INFO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_GLOBAL_BIT_CHANGE</span> &#123;</span><br><span class="line">    pde_64* global_pde_address;</span><br><span class="line">    pte_64* global_pte_address;</span><br><span class="line">    <span class="type">void</span>* AlignOriAddr;</span><br><span class="line">&#125;GLOBAL_BIT_CHANGE, * PGLOBAL_BIT_CHANGE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PTE_TABLE</span> &#123;</span><br><span class="line">    <span class="type">void</span>* LineAddress;</span><br><span class="line">    pte_64* Pte;</span><br><span class="line">    pde_64* Pde;</span><br><span class="line">    pdpte_64* Pdpte;</span><br><span class="line">    pml4e_64* Pml4e;</span><br><span class="line">&#125;PTE_TABLE, * PPTE_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PteHookManager</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//Pte InlineHook</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">fn_pte_inline_hook_bp_pg</span><span class="params">(HANDLE process_id, _Inout_ <span class="type">void</span>** ori_addr, <span class="type">void</span>* hk_addr)</span></span>;</span><br><span class="line">    <span class="comment">//移除钩子</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">fn_remove_hook</span><span class="params">(HANDLE process_id, <span class="type">void</span>* hook_addr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> PteHookManager* <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//添加G位信息 方便恢复</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fn_add_g_bit_info</span><span class="params">(<span class="type">void</span>* align_addr, pde_64* pde_address, pte_64* pte_address)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启关闭cr0的wp位</span></span><br><span class="line">    <span class="function">KIRQL <span class="title">fn_off_wp_bit</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fn_on_wp_bit</span><span class="params">(KIRQL old_irql)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">fn_isolation_pages</span><span class="params">(HANDLE process_id, <span class="type">void</span>* iso_addr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fn_resume_global_bits</span><span class="params">(<span class="type">void</span>* align_addr)</span></span>;</span><br><span class="line">    <span class="comment">//从Pml4e开始替换 大页使用这个,必须提供Pde 否则填0</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">fn_isolation_pagetable</span><span class="params">(cr3 cr3_reg, <span class="type">void</span>* replace_align_addr, pde_64* split_pde)</span></span>;</span><br><span class="line">    <span class="comment">//分割大页为小页</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">fn_split_large_pages</span><span class="params">(pde_64* in_pde, pde_64* out_pde)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fn_get_pte_table</span><span class="params">(PTE_TABLE&amp; table)</span></span>;</span><br><span class="line">    <span class="comment">//获取PteBase</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">fn_get_pte_base</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fn_logger_info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* log_info, <span class="type">bool</span> is_err, LONG err_code)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">fn_va_to_pa</span><span class="params">(<span class="type">void</span>* va)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">fn_pa_to_va</span><span class="params">(<span class="type">uint64_t</span> pa)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* m_PteBase = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//Hook Info</span></span><br><span class="line">    HOOK_INFO m_HookInfo[MAX_HOOK_COUNT] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    GLOBAL_BIT_CHANGE m_global_bit[MAX_HOOK_COUNT] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">uint32_t</span> m_HookCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//TrampLine Pool</span></span><br><span class="line">    <span class="type">char</span>* m_TrampLinePool = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> m_PoolUsed = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//实例</span></span><br><span class="line">    <span class="type">static</span> PteHookManager* m_Instance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PteHookManager.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PteHookManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable : 4838)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable : 4309)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Single Object</span></span><br><span class="line">PteHookManager* PteHookManager::m_Instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PteHookManager::fn_pte_inline_hook_bp_pg</span><span class="params">(HANDLE process_id, <span class="type">void</span>** ori_addr, <span class="type">void</span>* hk_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> bFirst = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bFirst) &#123;</span><br><span class="line"></span><br><span class="line">        m_PteBase = <span class="literal">nullptr</span>;</span><br><span class="line">        m_TrampLinePool = (<span class="type">char</span>*)<span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, PAGE_SIZE * <span class="number">5</span>, <span class="string">&#x27;JmpP&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!m_TrampLinePool) &#123;</span><br><span class="line">            <span class="built_in">fn_logger_info</span>(<span class="string">&quot;failed to alloc trampline pool&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清空Hook Info</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;m_HookInfo, <span class="number">0</span>, <span class="built_in">sizeof</span>(m_HookInfo));</span><br><span class="line">        m_PoolUsed = <span class="number">0</span>;</span><br><span class="line">        bFirst = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PEPROCESS Process&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    KAPC_STATE Apc&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> BREAK_BYTES_LEAST = <span class="number">14</span>;<span class="comment">//ff 25 绝对跳转</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> TrampLineBreakBytes = <span class="number">20</span>;</span><br><span class="line">    <span class="type">uint32_t</span> uBreakBytes = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* TrampLine = m_TrampLinePool + m_PoolUsed;</span><br><span class="line">    hde64s hde_info&#123; <span class="number">0</span> &#125;;<span class="comment">//反汇编引擎</span></span><br><span class="line">    <span class="type">char</span>* JmpAddressStart = (<span class="type">char</span>*)*ori_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否Hook满了</span></span><br><span class="line">    <span class="keyword">if</span> (m_HookCount == MAX_HOOK_COUNT) &#123;</span><br><span class="line">        <span class="built_in">fn_logger_info</span>(<span class="string">&quot;hooks too many&quot;</span>, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = <span class="built_in">PsLookupProcessByProcessId</span>(process_id, &amp;Process);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">fn_logger_info</span>(<span class="string">&quot;failed to get process by pid&quot;</span>, <span class="literal">true</span>, status);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先隔离页表</span></span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">fn_isolation_pages</span>(process_id, *ori_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ret) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//隔离成功,构建Hook</span></span><br><span class="line">    <span class="keyword">while</span> (uBreakBytes &lt; BREAK_BYTES_LEAST) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">hde64_disasm</span>(JmpAddressStart + uBreakBytes, &amp;hde_info)) &#123;</span><br><span class="line">            <span class="built_in">fn_logger_info</span>(<span class="string">&quot;failed to disasm addr&quot;</span>, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">ObDereferenceObject</span>(Process);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uBreakBytes += hde_info.len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//蹦床shellCode</span></span><br><span class="line">    <span class="type">char</span> TrampLineCode[TrampLineBreakBytes] = &#123;</span><br><span class="line">        <span class="number">0x6A</span>, <span class="number">0x00</span>, <span class="number">0x3E</span>, <span class="number">0xC7</span>, <span class="number">0x04</span>, <span class="number">0x24</span>,<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="number">0x3E</span>, <span class="number">0xC7</span>, <span class="number">0x44</span>, <span class="number">0x24</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC3</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> AbsoluteJmpCode[BREAK_BYTES_LEAST] = &#123;</span><br><span class="line">        <span class="number">0xff</span>,<span class="number">0x25</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="comment">//jmp [$0+0]</span></span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制绝对跳转 跳回原来的函数</span></span><br><span class="line">    *((PUINT32)&amp;TrampLineCode[<span class="number">6</span>]) = (UINT32)((<span class="type">uint64_t</span>)((JmpAddressStart + uBreakBytes)) &amp; <span class="number">0XFFFFFFFF</span>);</span><br><span class="line">    *((PUINT32)&amp;TrampLineCode[<span class="number">15</span>]) = (UINT32)((((<span class="type">uint64_t</span>)(JmpAddressStart + uBreakBytes)) &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0XFFFFFFFF</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先把破坏掉的字节复制过去</span></span><br><span class="line">    <span class="built_in">memcpy</span>(TrampLine, JmpAddressStart, uBreakBytes);</span><br><span class="line">    <span class="comment">//再把蹦回去的代码复制过去</span></span><br><span class="line">    <span class="built_in">memcpy</span>(TrampLine + uBreakBytes, TrampLineCode, TrampLineBreakBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加hook信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_HOOK_COUNT; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_HookInfo[i].ProcessId == <span class="number">0</span>) &#123;</span><br><span class="line">            m_HookInfo[i].OriAddr = JmpAddressStart;</span><br><span class="line">            <span class="built_in">memcpy</span>(m_HookInfo[i].OriBytes, JmpAddressStart, <span class="number">14</span>);</span><br><span class="line">            m_HookInfo[i].ProcessId = process_id;</span><br><span class="line">            m_HookCount++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改 设置跳转</span></span><br><span class="line">    *((<span class="type">void</span>**)&amp;AbsoluteJmpCode[<span class="number">6</span>]) = hk_addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">KeStackAttachProcess</span>(Process, &amp;Apc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> oIrpl = <span class="built_in">fn_off_wp_bit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只修改第一条指令</span></span><br><span class="line">    <span class="comment">//if(*JmpAddressStart==0x44 &amp;&amp; *(JmpAddressStart+1)==0x88 &amp;&amp; *(JmpAddressStart + 2) == 0x4c &amp;&amp; (JmpAddressSta</span></span><br><span class="line">    <span class="built_in">memcpy</span>(JmpAddressStart, AbsoluteJmpCode, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fn_on_wp_bit</span>(oIrpl);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">KeUnstackDetachProcess</span>(&amp;Apc);</span><br><span class="line"></span><br><span class="line">    *ori_addr = TrampLine;</span><br><span class="line">    m_PoolUsed += (uBreakBytes + TrampLineBreakBytes);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ObDereferenceObject</span>(Process);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PteHookManager::fn_remove_hook</span><span class="params">(HANDLE process_id, <span class="type">void</span>* hook_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PEPROCESS Process&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    KAPC_STATE Apc&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    NTSTATUS status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    status = <span class="built_in">PsLookupProcessByProcessId</span>(process_id, &amp;Process);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">fn_logger_info</span>(<span class="string">&quot;pid err&quot;</span>, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_HOOK_COUNT; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (process_id == m_HookInfo[i].ProcessId &amp;&amp; hook_addr == m_HookInfo[i].OriAddr) &#123;</span><br><span class="line">            <span class="comment">//Find</span></span><br><span class="line">            <span class="keyword">auto</span> oIrql = <span class="built_in">fn_off_wp_bit</span>();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">KeStackAttachProcess</span>(Process, &amp;Apc);</span><br><span class="line">            <span class="comment">//修改</span></span><br><span class="line">            <span class="built_in">memcpy</span>(hook_addr, m_HookInfo[i].OriBytes, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">KeUnstackDetachProcess</span>(&amp;Apc);</span><br><span class="line">            <span class="built_in">fn_on_wp_bit</span>(oIrql);</span><br><span class="line"></span><br><span class="line">            m_HookInfo[i].ProcessId = <span class="number">0</span>;</span><br><span class="line">            m_HookCount--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//同时恢复c位</span></span><br><span class="line">            <span class="built_in">fn_resume_global_bits</span>(<span class="built_in">PAGE_ALIGN</span>(hook_addr));</span><br><span class="line">            <span class="built_in">ObDereferenceObject</span>(Process);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ObDereferenceObject</span>(Process);</span><br><span class="line">    <span class="built_in">fn_logger_info</span>(<span class="string">&quot;failed to find hook in here&quot;</span>, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PteHookManager::fn_add_g_bit_info</span><span class="params">(<span class="type">void</span>* align_addr, pde_64* pde_address, pte_64* pte_address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_HOOK_COUNT; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span>&amp; info = m_Instance-&gt;m_global_bit;</span><br><span class="line">        <span class="keyword">if</span> (info[i].AlignOriAddr == <span class="number">0</span>) &#123;</span><br><span class="line">            info[i].AlignOriAddr = align_addr;</span><br><span class="line">            <span class="keyword">if</span> (pde_address) &#123;</span><br><span class="line">                info[i].global_pde_address = pde_address;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                info[i].global_pte_address = pte_address;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">KIRQL <span class="title">PteHookManager::fn_off_wp_bit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> irql = <span class="built_in">KeRaiseIrqlToDpcLevel</span>();<span class="comment">//关闭线程切换</span></span><br><span class="line">    UINT64 Cr0 = __readcr0();</span><br><span class="line">    Cr0 &amp;= <span class="number">0xfffffffffffeffff</span>;</span><br><span class="line">    __writecr0(Cr0);</span><br><span class="line">    _disable();</span><br><span class="line">    <span class="keyword">return</span> irql;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PteHookManager::fn_on_wp_bit</span><span class="params">(KIRQL old_irql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UINT64 Cr0 = __readcr0();</span><br><span class="line">    Cr0 |= <span class="number">0x10000</span>;</span><br><span class="line">    _enable();</span><br><span class="line">    __writecr0(Cr0);</span><br><span class="line">    <span class="built_in">KeLowerIrql</span>(old_irql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PteHookManager::fn_isolation_pages</span><span class="params">(HANDLE process_id, <span class="type">void</span>* iso_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PEPROCESS Process;</span><br><span class="line">    KAPC_STATE Apc&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    <span class="type">void</span>* AliginIsoAddr;</span><br><span class="line">    PTE_TABLE Table&#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    status = <span class="built_in">PsLookupProcessByProcessId</span>(process_id, &amp;Process);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">fn_logger_info</span>(<span class="string">&quot;failed to get process by pid&quot;</span>, <span class="literal">true</span>, status);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">KeStackAttachProcess</span>(Process, &amp;Apc);</span><br><span class="line"></span><br><span class="line">    AliginIsoAddr = <span class="built_in">PAGE_ALIGN</span>(iso_addr);</span><br><span class="line">    Table.LineAddress = AliginIsoAddr;</span><br><span class="line">    <span class="built_in">fn_get_pte_table</span>(Table);</span><br><span class="line">    <span class="comment">//修改G位</span></span><br><span class="line">    <span class="type">bool</span> bSuc = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//大页分割</span></span><br><span class="line">        pde_64 split_pde&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">if</span> (Table.Pde-&gt;large_page) &#123;</span><br><span class="line">            <span class="comment">//大页分割成小页</span></span><br><span class="line">            bSuc = <span class="built_in">fn_split_large_pages</span>(Table.Pde, &amp;split_pde);</span><br><span class="line">            <span class="keyword">if</span> (!bSuc) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//同时取消G位</span></span><br><span class="line">            <span class="keyword">if</span> (Table.Pde-&gt;flags &amp; <span class="number">0x100</span>) &#123;</span><br><span class="line">                (Table.Pde-&gt;flags &amp;= ~<span class="number">0x100</span>);</span><br><span class="line">                <span class="comment">//添加一个G bit 信息</span></span><br><span class="line">                <span class="built_in">fn_add_g_bit_info</span>(AliginIsoAddr, Table.Pde, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Table.Pte-&gt;global) &#123;</span><br><span class="line">                <span class="comment">//Hook 小页也得取消一下G位</span></span><br><span class="line">                (Table.Pte-&gt;global = <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">fn_add_g_bit_info</span>(AliginIsoAddr, <span class="number">0</span>, Table.Pte);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始隔离</span></span><br><span class="line">        cr3 Cr3;</span><br><span class="line">        Cr<span class="number">3.f</span>lags = __readcr3();</span><br><span class="line">        bSuc = <span class="built_in">fn_isolation_pagetable</span>(Cr3, AliginIsoAddr, &amp;split_pde);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bSuc) <span class="built_in">fn_logger_info</span>(<span class="string">&quot;isolation page success&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">fn_logger_info</span>(<span class="string">&quot;failed to isolation page&quot;</span>, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">KeUnstackDetachProcess</span>(&amp;Apc);</span><br><span class="line">    <span class="built_in">ObDereferenceObject</span>(Process);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bSuc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PteHookManager::fn_resume_global_bits</span><span class="params">(<span class="type">void</span>* align_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_HOOK_COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; gbits_info = m_Instance-&gt;m_global_bit[i];</span><br><span class="line">        <span class="keyword">if</span> (gbits_info.AlignOriAddr == align_addr) &#123;</span><br><span class="line">            <span class="comment">//find</span></span><br><span class="line">            <span class="keyword">if</span> (gbits_info.global_pde_address) ((gbits_info.global_pde_address)-&gt;flags |= <span class="number">0x100</span>);</span><br><span class="line">            <span class="keyword">if</span> (gbits_info.global_pte_address) ((gbits_info.global_pte_address-&gt;global = <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PteHookManager::fn_isolation_pagetable</span><span class="params">(cr3 cr3_reg, <span class="type">void</span>* replace_align_addr, pde_64* split_pde)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 均指向4kb内存</span></span><br><span class="line">    <span class="type">uint64_t</span>* VaPt, * Va4kb, * VaPdt, * VaPdpt, * VaPml4t;</span><br><span class="line">    <span class="comment">// LineAddr在页表结构中的位置</span></span><br><span class="line">    PTE_TABLE Table&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PHYSICAL_ADDRESS MaxAddrPa&#123; <span class="number">0</span> &#125;, LowAddrPa&#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    MaxAddrPa.QuadPart = MAXULONG64;</span><br><span class="line">    LowAddrPa.QuadPart = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先申请内存 要隔离的4kb物理地址 +3个表的4kb</span></span><br><span class="line">    VaPt = (<span class="type">uint64_t</span>*)<span class="built_in">MmAllocateContiguousMemorySpecifyCache</span>(PAGE_SIZE, LowAddrPa, MaxAddrPa, LowAddrPa, MmCached);</span><br><span class="line">    Va4kb = (<span class="type">uint64_t</span>*)<span class="built_in">MmAllocateContiguousMemorySpecifyCache</span>(PAGE_SIZE, LowAddrPa, MaxAddrPa, LowAddrPa, MmCached);</span><br><span class="line">    VaPdt = (<span class="type">uint64_t</span>*)<span class="built_in">MmAllocateContiguousMemorySpecifyCache</span>(PAGE_SIZE, LowAddrPa, MaxAddrPa, LowAddrPa, MmCached);</span><br><span class="line">    VaPdpt = (<span class="type">uint64_t</span>*)<span class="built_in">MmAllocateContiguousMemorySpecifyCache</span>(PAGE_SIZE, LowAddrPa, MaxAddrPa, LowAddrPa, MmCached);</span><br><span class="line">    VaPml4t = (<span class="type">uint64_t</span>*)<span class="built_in">fn_pa_to_va</span>(cr3_reg.address_of_page_directory * PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!VaPt || !Va4kb || !VaPdt || !VaPdpt) &#123;</span><br><span class="line">        <span class="built_in">fn_logger_info</span>(<span class="string">&quot;failed to alloc page table entry&quot;</span>, <span class="literal">true</span>, STATUS_IMPLEMENTATION_LIMIT);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Pte信息</span></span><br><span class="line">    Table.LineAddress = replace_align_addr;</span><br><span class="line">    <span class="built_in">fn_get_pte_table</span>(Table);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取PageTable结构的索引</span></span><br><span class="line">    UINT64 pml4eindex = ((<span class="type">uint64_t</span>)replace_align_addr &amp; <span class="number">0x0000FF8000000000</span>) &gt;&gt; <span class="number">39</span>;</span><br><span class="line">    UINT64 pdpteindex = ((<span class="type">uint64_t</span>)replace_align_addr &amp; <span class="number">0x0000007FC0000000</span>) &gt;&gt; <span class="number">30</span>;</span><br><span class="line">    UINT64 pdeindex = ((<span class="type">uint64_t</span>)replace_align_addr &amp; <span class="number">0x000000003FE00000</span>) &gt;&gt; <span class="number">21</span>;</span><br><span class="line">    UINT64 pteindex = ((<span class="type">uint64_t</span>)replace_align_addr &amp; <span class="number">0x00000000001FF000</span>) &gt;&gt; <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DbgBreakPoint();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先判断是否是大页 如果是 那么申请的pt不要了</span></span><br><span class="line">    <span class="keyword">if</span> (Table.Pde-&gt;large_page) &#123;</span><br><span class="line">        <span class="built_in">MmFreeContiguousMemorySpecifyCache</span>(VaPt, PAGE_SIZE, MmCached);</span><br><span class="line">        VaPt = (<span class="type">uint64_t</span>*)<span class="built_in">fn_pa_to_va</span>(split_pde-&gt;page_frame_number * PAGE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 小页 pt数组是有值的 因此复制</span></span><br><span class="line">        <span class="comment">// 先复制原来内存</span></span><br><span class="line">        <span class="built_in">memcpy</span>(VaPt, Table.Pte - pteindex, PAGE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(Va4kb, replace_align_addr, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制原来的pde到pdt中</span></span><br><span class="line">    <span class="comment">// 这里比较难理解 本质上就是复制pte到pd中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(VaPdt, Table.Pde - pdeindex, PAGE_SIZE);</span><br><span class="line">    <span class="built_in">memcpy</span>(VaPdpt, Table.Pdpte - pdpteindex, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换页表的Pfn 从Pte开始一直到Pml4e</span></span><br><span class="line">    <span class="keyword">auto</span> pReplacePte = (pte_64*)&amp;VaPt[pteindex];</span><br><span class="line">    pReplacePte-&gt;page_frame_number = <span class="built_in">fn_va_to_pa</span>(Va4kb) / PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pReplacePde = (pde_64*)&amp;VaPdt[pdeindex];</span><br><span class="line">    pReplacePde-&gt;page_frame_number = <span class="built_in">fn_va_to_pa</span>(VaPt) / PAGE_SIZE;</span><br><span class="line">    pReplacePde-&gt;large_page = <span class="number">0</span>;</span><br><span class="line">    pReplacePde-&gt;ignored_1 = <span class="number">0</span>;</span><br><span class="line">    pReplacePde-&gt;page_level_cache_disable = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pReplacePdpte = (pdpte_64*)&amp;VaPdpt[pdpteindex];</span><br><span class="line">    pReplacePdpte-&gt;page_frame_number = <span class="built_in">fn_va_to_pa</span>(VaPdt) / PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后替换cr3的Pml4e</span></span><br><span class="line">    <span class="keyword">auto</span> pReplacePml4e = (pml4e_64*)&amp;VaPml4t[pml4eindex];</span><br><span class="line">    pReplacePml4e-&gt;page_frame_number = <span class="built_in">fn_va_to_pa</span>(VaPdpt) / PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新tlb</span></span><br><span class="line">    __invlpg(pReplacePml4e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PteHookManager::fn_split_large_pages</span><span class="params">(pde_64* in_pde, pde_64* out_pde)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PHYSICAL_ADDRESS MaxAddrPa&#123; <span class="number">0</span> &#125;, LowAddrPa&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    MaxAddrPa.QuadPart = MAXULONG64;</span><br><span class="line">    LowAddrPa.QuadPart = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pt_entry_64* Pt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start_pfn = in_pde-&gt;page_frame_number;</span><br><span class="line">    Pt = (pt_entry_64*)<span class="built_in">MmAllocateContiguousMemorySpecifyCache</span>(PAGE_SIZE, LowAddrPa, MaxAddrPa, LowAddrPa, MmCached);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Pt) &#123;</span><br><span class="line">        <span class="built_in">fn_logger_info</span>(<span class="string">&quot;failed to alloc mm for new pt&quot;</span>, <span class="literal">true</span>, STATUS_NO_MEMORY);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//分割成小页 构建pt</span></span><br><span class="line">        Pt[i].flags = in_pde-&gt;flags;</span><br><span class="line">        Pt[i].large_page = <span class="number">0</span>;</span><br><span class="line">        Pt[i].global = <span class="number">0</span>;</span><br><span class="line">        Pt[i].page_frame_number = start_pfn + i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建将分割的pte填进去</span></span><br><span class="line">    <span class="comment">//in_pde-&gt;large_page = 0;</span></span><br><span class="line">    <span class="comment">//in_pde-&gt;page_frame_number = fn_va_to_pa(Pt) / PAGE_SIZE;</span></span><br><span class="line">    <span class="comment">//分割小页完成</span></span><br><span class="line"></span><br><span class="line">    out_pde-&gt;flags = in_pde-&gt;flags;</span><br><span class="line">    out_pde-&gt;large_page = <span class="number">0</span>;</span><br><span class="line">    out_pde-&gt;page_frame_number = <span class="built_in">fn_va_to_pa</span>(Pt) / PAGE_SIZE;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PteHookManager::fn_get_pte_table</span><span class="params">(PTE_TABLE&amp; table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_PteBase == <span class="number">0</span>) &#123;</span><br><span class="line">        m_PteBase = <span class="built_in">fn_get_pte_base</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_PteBase == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fn_logger_info</span>(<span class="string">&quot;failed to get pte base&quot;</span>, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> AddrMask = <span class="number">0xFFFF000000000000</span>;</span><br><span class="line">    <span class="type">void</span>* LineAddr = (<span class="type">void</span>*)(<span class="built_in">uint64_t</span>(table.LineAddress) &amp; ~AddrMask);</span><br><span class="line">    pte_64* pPte = <span class="number">0</span>;</span><br><span class="line">    pde_64* pPde = <span class="number">0</span>;</span><br><span class="line">    pdpte_64* pPdpte = <span class="number">0</span>;</span><br><span class="line">    pml4e_64* pPml4e = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取Pte pde..</span></span><br><span class="line">    pPte = (pte_64*)(((<span class="type">uint64_t</span>)LineAddr &gt;&gt; <span class="number">12</span> &lt;&lt; <span class="number">3</span>) + (<span class="type">uint64_t</span>)m_PteBase &amp; ~AddrMask);</span><br><span class="line">    pPde = (pde_64*)((((<span class="type">uint64_t</span>)pPte) &gt;&gt; <span class="number">12</span> &lt;&lt; <span class="number">3</span>) + (<span class="type">uint64_t</span>)m_PteBase &amp; ~AddrMask);</span><br><span class="line">    pPdpte = (pdpte_64*)((((<span class="type">uint64_t</span>)pPde) &gt;&gt; <span class="number">12</span> &lt;&lt; <span class="number">3</span>) + (<span class="type">uint64_t</span>)m_PteBase &amp; ~AddrMask);</span><br><span class="line">    pPml4e = (pml4e_64*)((((<span class="type">uint64_t</span>)pPdpte) &gt;&gt; <span class="number">12</span> &lt;&lt; <span class="number">3</span>) + (<span class="type">uint64_t</span>)m_PteBase &amp; ~AddrMask);</span><br><span class="line"></span><br><span class="line">    table.Pde = (pde_64*)((<span class="type">uint64_t</span>)pPde | AddrMask);</span><br><span class="line">    table.Pdpte = (pdpte_64*)((<span class="type">uint64_t</span>)pPdpte | AddrMask);</span><br><span class="line">    table.Pte = (pte_64*)((<span class="type">uint64_t</span>)pPte | AddrMask);</span><br><span class="line">    table.Pml4e = (pml4e_64*)((<span class="type">uint64_t</span>)pPml4e | AddrMask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用页表自映射获取PteBase</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">PteHookManager::fn_get_pte_base</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cr3 Cr3;</span><br><span class="line">    pml4e_64* Cr3Va = <span class="number">0</span>;</span><br><span class="line">    Cr<span class="number">3.f</span>lags = __readcr3();</span><br><span class="line">    <span class="comment">// Get Virtual Address of PML4 table</span></span><br><span class="line">    <span class="comment">// Cr3.address_of_page_directory is the PFN, so multiply by PAGE_SIZE</span></span><br><span class="line">    Cr3Va = (pml4e_64*)<span class="built_in">fn_pa_to_va</span>(Cr<span class="number">3.</span>address_of_page_directory * PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Cr3Va || !<span class="built_in">MmIsAddressValid</span>(Cr3Va)) &#123;</span><br><span class="line">        <span class="built_in">fn_logger_info</span>(<span class="string">&quot;failed to get cr3 virtual address&quot;</span>, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Traverse the PML4 table (512 entries) to find the self-reference entry</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// If the PFN of the entry points to the PML4 itself, it&#x27;s the self-reference</span></span><br><span class="line">        <span class="keyword">if</span> (Cr3Va[i].present &amp;&amp; Cr3Va[i].page_frame_number == Cr<span class="number">3.</span>address_of_page_directory) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Construct the PTE base address</span></span><br><span class="line">            <span class="comment">// The logic: 0xFFFF000000000000 (Canonical Base) | (PML4Index &lt;&lt; 39)</span></span><br><span class="line">            <span class="comment">// This maps the recursive slot to the base of the linear address space for page tables</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="type">void</span>*)(<span class="number">0xFFFF000000000000ull</span> | (i &lt;&lt; <span class="number">39</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fn_logger_info</span>(<span class="string">&quot;failed to find pte base&quot;</span>, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用页表自映射获取PteBase</span></span><br><span class="line">    <span class="comment">//原代码：思考正确性</span></span><br><span class="line">    <span class="comment">//void* PteHookManager::fn_get_pte_base()</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    cr3 Cr3;</span></span><br><span class="line">    <span class="comment">//    pml4e_64* Cr3Va = 0;</span></span><br><span class="line">    <span class="comment">//    PHYSICAL_ADDRESS Cr3Pa&#123; 0 &#125;;</span></span><br><span class="line">    <span class="comment">//    Cr3.flags = __readcr3();</span></span><br><span class="line">    <span class="comment">//参考1：</span></span><br><span class="line">    <span class="comment">//uint64_t pa_to_va(uint64_t pa) &#123;</span></span><br><span class="line">    <span class="comment">//    PHYSICAL_ADDRESS pa_ = &#123; 0 &#125;;</span></span><br><span class="line">    <span class="comment">//    pa_.QuadPart = pa;</span></span><br><span class="line">    <span class="comment">//    return (uint64_t)MmGetVirtualForPhysical(pa_);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//pte_64* get_pte_base() &#123;</span></span><br><span class="line">    <span class="comment">//    cr3 cr3_pa = &#123; 0 &#125;;</span></span><br><span class="line">    <span class="comment">//    cr3_pa.flags = __readcr3();  // 读取CR3寄存器，获取页目录基址</span></span><br><span class="line">    <span class="comment">//    pml4e_64* cr3_va = &#123; 0 &#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    // 将CR3中的物理地址转为虚拟地址（乘以页大小，x64页大小默认4KB即0x1000）</span></span><br><span class="line">    <span class="comment">//    cr3_va = (pml4e_64*)pa_to_va(cr3_pa.address_of_page_directory * PAGE_SIZE);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    // 校验地址有效性</span></span><br><span class="line">    <span class="comment">//    if (!MmIsAddressValid(cr3_va)) &#123;</span></span><br><span class="line">    <span class="comment">//        KdPrint((&quot;[+]failed to get cr3 page\r\n&quot;));</span></span><br><span class="line">    <span class="comment">//        return 0;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    // 遍历PML4表（512项），匹配页帧号</span></span><br><span class="line">    <span class="comment">//    for (uint64_t i = 0; i &lt; 512; i++) &#123;</span></span><br><span class="line">    <span class="comment">//        if (cr3_va[i].page_frame_number == cr3_pa.address_of_page_directory) &#123;</span></span><br><span class="line">    <span class="comment">//            // 构造PTE基地址（x64高地址映射，0xffff000000000000为内核空间基址，i&lt;&lt;39对应PML4索引偏移）</span></span><br><span class="line">    <span class="comment">//            return (pte_64*)(0xffff000000000000 | (i &lt;&lt; 39));</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    return 0;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//参考2：</span></span><br><span class="line">    <span class="comment">//void* GetPteBase() &#123;</span></span><br><span class="line">    <span class="comment">//    cr3 CR3;</span></span><br><span class="line">    <span class="comment">//    PHYSICAL_ADDRESS cr3_pa = &#123; 0 &#125;;</span></span><br><span class="line">    <span class="comment">//    CR3.flags = __readcr3();</span></span><br><span class="line">    <span class="comment">//    cr3_pa.QuadPart = CR3.address_of_page_directory * PAGE_SIZE;</span></span><br><span class="line">    <span class="comment">//    PULONG64 cr3_va = (PULONG64)MmGetVirtualForPhysical(cr3_pa);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    UINT64 nCount = 0;</span></span><br><span class="line">    <span class="comment">//    while ((*cr3_va &amp; 0x000FFFFFFFFFF000) != cr3_pa.QuadPart) &#123;</span></span><br><span class="line">    <span class="comment">//        if (++nCount &gt;= 512) &#123;</span></span><br><span class="line">    <span class="comment">//            return nullptr;</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line">    <span class="comment">//        cr3_va++;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//    return (void*)(0xffff000000000000 | (nCount &lt;&lt; 39));</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PteHookManager::fn_logger_info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* log_info, <span class="type">bool</span> is_err, LONG err_code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_err) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[pte_hook]err:%s,err_code:%x\r\n&quot;</span>, log_info, err_code);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[pte_hook]info:%s\r\n&quot;</span>, log_info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">PteHookManager::fn_va_to_pa</span><span class="params">(<span class="type">void</span>* va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PHYSICAL_ADDRESS Pa&#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    Pa = <span class="built_in">MmGetPhysicalAddress</span>(va);</span><br><span class="line">    <span class="keyword">return</span> Pa.QuadPart;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">PteHookManager::fn_pa_to_va</span><span class="params">(<span class="type">uint64_t</span> pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PHYSICAL_ADDRESS Pa&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    Pa.QuadPart = pa;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MmGetVirtualForPhysical</span>(Pa);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PteHookManager* <span class="title">PteHookManager::GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_Instance == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        m_Instance = (PteHookManager*)<span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, <span class="built_in">sizeof</span>(PteHookManager), PTE_MANAGER_TAG);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(m_Instance-&gt;m_global_bit, <span class="number">0</span>, <span class="built_in">sizeof</span>(GLOBAL_BIT_CHANGE) * MAX_HOOK_COUNT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_Instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DriverMain.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PteHookManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义NtOpenProcess函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* fnNtOpenProcess)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PHANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    POBJECT_ATTRIBUTES ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    PCLIENT_ID ClientId</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义NtCreateFile函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* fnNtCreateFile)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PHANDLE FileHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    POBJECT_ATTRIBUTES ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatusBlock,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER AllocationSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG FileAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG ShareAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG CreateDisposition,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG CreateOptions,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID EaBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG EaLength</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要Hook的进程PID（示例值）</span></span><br><span class="line">HANDLE g_HookPid = (HANDLE)<span class="number">4532</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存原始函数地址</span></span><br><span class="line">fnNtCreateFile g_OriNtCreateFile = <span class="literal">NULL</span>;</span><br><span class="line">fnNtOpenProcess g_OriNtOpenProcess = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hook后的NtOpenProcess函数实现</span></span><br><span class="line"><span class="function">NTSTATUS NTAPI <span class="title">MyNtOpenProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PHANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ POBJECT_ATTRIBUTES ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PCLIENT_ID ClientId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 直接调用原始函数（可根据需求添加自定义逻辑）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g_OriNtOpenProcess</span>(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hook后的NtCreateFile函数实现</span></span><br><span class="line"><span class="function">NTSTATUS NTAPI <span class="title">MyNtCreateFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PHANDLE FileHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ POBJECT_ATTRIBUTES ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PIO_STATUS_BLOCK IoStatusBlock,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PLARGE_INTEGER AllocationSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG FileAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG ShareAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG CreateDisposition,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG CreateOptions,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG EaLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调试输出：标记进入Hook函数</span></span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[+] create file\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查ObjectAttributes及文件名缓冲区有效性</span></span><br><span class="line">    <span class="keyword">if</span> (ObjectAttributes &amp;&amp;</span><br><span class="line">        ObjectAttributes-&gt;ObjectName &amp;&amp;</span><br><span class="line">        ObjectAttributes-&gt;ObjectName-&gt;Buffer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 分配非分页内存存储文件名（+sizeof(wchar_t)确保字符串终止符空间）</span></span><br><span class="line">        <span class="type">wchar_t</span>* name = (<span class="type">wchar_t</span>*)<span class="built_in">ExAllocatePool</span>(NonPagedPool,</span><br><span class="line">            ObjectAttributes-&gt;ObjectName-&gt;Length + <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 初始化内存并拷贝文件名</span></span><br><span class="line">            <span class="built_in">RtlZeroMemory</span>(name, ObjectAttributes-&gt;ObjectName-&gt;Length + <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>));</span><br><span class="line">            <span class="built_in">RtlCopyMemory</span>(name, ObjectAttributes-&gt;ObjectName-&gt;Buffer, ObjectAttributes-&gt;ObjectName-&gt;Length);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拦截创建tips.txt文件的操作</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">wcsstr</span>(name, <span class="string">L&quot;tips.txt&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ExFreePool</span>(name); <span class="comment">// 释放内存</span></span><br><span class="line">                <span class="keyword">return</span> STATUS_ACCESS_DENIED; <span class="comment">// 拒绝访问</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">ExFreePool</span>(name); <span class="comment">// 释放内存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用原始NtCreateFile函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g_OriNtCreateFile</span>(</span><br><span class="line">        FileHandle,</span><br><span class="line">        DesiredAccess,</span><br><span class="line">        ObjectAttributes,</span><br><span class="line">        IoStatusBlock,</span><br><span class="line">        AllocationSize,</span><br><span class="line">        FileAttributes,</span><br><span class="line">        ShareAccess,</span><br><span class="line">        CreateDisposition,</span><br><span class="line">        CreateOptions,</span><br><span class="line">        EaBuffer,</span><br><span class="line">        EaLength</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动卸载函数：移除Hook并清理资源</span></span><br><span class="line"><span class="function">VOID <span class="title">driver_unload</span><span class="params">(PDRIVER_OBJECT driver_object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(driver_object);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除NtCreateFile和NtOpenProcess的Hook</span></span><br><span class="line">    PteHookManager::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">fn_remove_hook</span>(g_HookPid, (<span class="type">void</span>*)NtCreateFile);</span><br><span class="line">    PteHookManager::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">fn_remove_hook</span>(g_HookPid, (<span class="type">void</span>*)NtOpenProcess);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[+] Driver unloaded, hooks removed\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动入口函数</span></span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT driver_object, PUNICODE_STRING us_regpath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Hook测试</span></span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(us_regpath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存原始函数地址</span></span><br><span class="line">    g_OriNtCreateFile = NtCreateFile;</span><br><span class="line">    g_OriNtOpenProcess = NtOpenProcess;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对指定PID进程的NtCreateFile和NtOpenProcess进行PTE inline hook</span></span><br><span class="line">    PteHookManager::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">fn_pte_inline_hook_bp_pg</span>(</span><br><span class="line">        g_HookPid,</span><br><span class="line">        (<span class="type">void</span>**)&amp;g_OriNtCreateFile,</span><br><span class="line">        (<span class="type">void</span>*)MyNtCreateFile</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    PteHookManager::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">fn_pte_inline_hook_bp_pg</span>(</span><br><span class="line">        g_HookPid,</span><br><span class="line">        (<span class="type">void</span>**)&amp;g_OriNtOpenProcess,</span><br><span class="line">        (<span class="type">void</span>*)MyNtOpenProcess</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置驱动卸载函数</span></span><br><span class="line">    driver_object-&gt;DriverUnload = driver_unload;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[+] Driver loaded, hooks installed\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lab1：other-pteHook"><a href="#lab1：other-pteHook" class="headerlink" title="lab1：other_pteHook"></a>lab1：other_pteHook</h3><p>用到<a href="https://njmxye.de5.net/内核驱动常用的库与头文件.zip">Hde与ia32库</a>。</p>
<blockquote>
<p>other_ptehook可能有错误。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//structer.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_HOOK_COUNT 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_HOOK_INFO</span> &#123;</span><br><span class="line">	HANDLE pid;</span><br><span class="line">	<span class="type">char</span> originBytes[<span class="number">14</span>];</span><br><span class="line">	<span class="type">void</span>* originAddr;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;HOOK_INFO, *PHOOK_INFO;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MDL.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_REPROTECT_CONTEXT</span> &#123;</span><br><span class="line">	PMDL Mdl;</span><br><span class="line">	PUCHAR Lockedva;</span><br><span class="line"></span><br><span class="line">&#125;REPROTECT_CONTEXT,*PREPROTECT_CONTEXT;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MmLockVaForWrite</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	PVOID Va,</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG Length,</span></span></span><br><span class="line"><span class="params"><span class="function">	__out PREPROTECT_CONTEXT ReprotectContext</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MmUnlockVaForWrite</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	__out PREPROTECT_CONTEXT ReprotectContext</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MDL.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MDL.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    MDL  内存描述页表； 用 MDL 来描述物理内存， for DMA 设备（更快 ）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MmLockVaForWrite</span><span class="params">(PVOID Va, ULONG Length, __out PREPROTECT_CONTEXT ReprotectContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">    ReprotectContext-&gt;Mdl = <span class="number">0</span>;</span><br><span class="line">    ReprotectContext-&gt;Lockedva = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    IoAllocateMdl：</span></span><br><span class="line"><span class="comment">        功能：用于分配一个描述内存页信息的 MDL（Memory Descriptor List）结构。</span></span><br><span class="line"><span class="comment">        参数：通常需要传递要描述的内存区域的虚拟地址（Va）和长度（Length），以及其他参数如是否分配辅助表、是否从非分页池中分配等。</span></span><br><span class="line"><span class="comment">        使用场景：主要用于创建描述内存页信息的 MDL 结构，但并不进行内存页的映射操作。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ReprotectContext-&gt;Mdl = <span class="built_in">IoAllocateMdl</span>(Va, Length, FALSE, FALSE, <span class="literal">NULL</span>); <span class="comment">//分配缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ReprotectContext-&gt;Mdl) &#123;</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    __try&#123;</span><br><span class="line">        <span class="built_in">MmProbeAndLockPages</span>(ReprotectContext-&gt;Mdl, KernelMode, IoWriteAccess); <span class="comment">// access or  write 可能会蓝</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    __except(EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetExceptionCode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        MmMapLockedPagesSpecifyCache：</span></span><br><span class="line"><span class="comment">            功能：用于将已经描述的内存页映射到系统地址空间中，并返回映射后的虚拟地址。</span></span><br><span class="line"><span class="comment">            参数：需要传递已经分配好的 MDL 结构（ReprotectContext-&gt;Mdl）、映射的访问模式（KernelMode）、缓存类型（MmCached）、映射的虚拟地址和是否是正常优先级等。</span></span><br><span class="line"><span class="comment">            使用场景：主要用于将已经描述的内存页映射到系统地址空间中，以便进行读写操作等。常见的使用场景包括将用户空间的缓冲区映射到内核空间，或者将内核空间的缓冲区映射到用户空间。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ReprotectContext-&gt;Lockedva = (PUCHAR)<span class="built_in">MmMapLockedPagesSpecifyCache</span>(ReprotectContext-&gt;Mdl, </span><br><span class="line">                                        KernelMode, MmCached, <span class="literal">NULL</span>, FALSE, NormalPagePriority);  <span class="comment">//真正实现映射 分配虚拟地址</span></span><br><span class="line">    <span class="keyword">if</span> (!ReprotectContext-&gt;Lockedva) &#123;</span><br><span class="line">        <span class="built_in">IoFreeMdl</span>(ReprotectContext-&gt;Mdl);</span><br><span class="line">        ReprotectContext-&gt;Mdl = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = <span class="built_in">MmProtectMdlSystemAddress</span>(ReprotectContext-&gt;Mdl, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">MmUnmapLockedPages</span>(ReprotectContext-&gt;Lockedva, ReprotectContext-&gt;Mdl); </span><br><span class="line">        <span class="built_in">MmUnlockPages</span>(ReprotectContext-&gt;Mdl);</span><br><span class="line">        <span class="built_in">IoFreeMdl</span>(ReprotectContext-&gt;Mdl);</span><br><span class="line">        ReprotectContext-&gt;Lockedva = <span class="number">0</span>;</span><br><span class="line">        ReprotectContext-&gt;Mdl = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MmUnlockVaForWrite</span><span class="params">(__out  PREPROTECT_CONTEXT ReprotectContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MmUnmapLockedPages</span>(ReprotectContext-&gt;Lockedva, ReprotectContext-&gt;Mdl);</span><br><span class="line">    <span class="built_in">MmUnlockPages</span>(ReprotectContext-&gt;Mdl);</span><br><span class="line">    <span class="built_in">IoFreeMdl</span>(ReprotectContext-&gt;Mdl);</span><br><span class="line">    ReprotectContext-&gt;Lockedva = <span class="number">0</span>;</span><br><span class="line">    ReprotectContext-&gt;Mdl = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PageTable.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;../HookManager/HookManager.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetPageTable</span><span class="params">(PAGE_TABLE&amp; table)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">GetPteBase</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PageTable.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;../ia32/ia32.hpp&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;PageTable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;../HookManager/HookManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4389)</span></span><br><span class="line"><span class="comment">//好像有关于页表自映射</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">GetPteBase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cr3 CR3;</span><br><span class="line">	PHYSICAL_ADDRESS cr3_pa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	CR<span class="number">3.f</span>lags = __readcr3();</span><br><span class="line">	cr3_pa.QuadPart = CR<span class="number">3.</span>address_of_page_directory * PAGE_SIZE;</span><br><span class="line">	PULONG64 cr3_va = (PULONG64)<span class="built_in">MmGetVirtualForPhysical</span>(cr3_pa);</span><br><span class="line"></span><br><span class="line">	UINT64 nCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> ((*cr3_va &amp; <span class="number">0x000FFFFFFFFFF000</span>) != cr3_pa.QuadPart) &#123;</span><br><span class="line">		<span class="keyword">if</span> (++nCount &gt;= <span class="number">512</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cr3_va++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span>*)(<span class="number">0xffff000000000000</span> | (nCount &lt;&lt; <span class="number">39</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetPageTable</span><span class="params">(PAGE_TABLE&amp; table)</span> </span>&#123;</span><br><span class="line">	ULONG64 PteBase = <span class="number">0</span>;</span><br><span class="line">	ULONG64 pdeBase = <span class="number">0</span>;</span><br><span class="line">	ULONG64 pdpteBase = <span class="number">0</span>;</span><br><span class="line">	ULONG64 pml4eBase = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	PteBase = (ULONG64)<span class="built_in">GetPteBase</span>();</span><br><span class="line">	<span class="built_in">DbgPrint</span>(<span class="string">&quot;PteBase :%p\n&quot;</span>, PteBase);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (PteBase == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	pdeBase = (((PteBase &amp; <span class="number">0xffffffffffff</span>) &gt;&gt; <span class="number">12</span>) &lt;&lt; <span class="number">3</span>) + PteBase;</span><br><span class="line">	pdpteBase = (((pdeBase &amp; <span class="number">0xffffffffffff</span>) &gt;&gt; <span class="number">12</span>) &lt;&lt; <span class="number">3</span>) + PteBase;</span><br><span class="line">	pml4eBase = (((pdpteBase &amp; <span class="number">0xffffffffffff</span>) &gt;&gt; <span class="number">12</span>) &lt;&lt; <span class="number">3</span>) + PteBase;</span><br><span class="line"></span><br><span class="line">	table.Entry.Pte = (pte_64*)(((((ULONG64)table.VirtualAddress &amp; <span class="number">0xffffffffffff</span>) &gt;&gt; <span class="number">12</span>) &lt;&lt; <span class="number">3</span>) + PteBase);</span><br><span class="line">	table.Entry.Pde = (pde_64*)(((((ULONG64)table.VirtualAddress &amp; <span class="number">0xffffffffffff</span>) &gt;&gt; <span class="number">21</span>) &lt;&lt; <span class="number">3</span>) + pdeBase);</span><br><span class="line">	table.Entry.Pdpte = (pdpte_64*)(((((ULONG64)table.VirtualAddress &amp; <span class="number">0xffffffffffff</span>) &gt;&gt; <span class="number">30</span>) &lt;&lt; <span class="number">3</span>) + pdpteBase);</span><br><span class="line">	table.Entry.Pml4e = (pml4e_64*)(((((ULONG64)table.VirtualAddress &amp; <span class="number">0xffffffffffff</span>) &gt;&gt; <span class="number">39</span>) &lt;&lt; <span class="number">3</span>) + pml4eBase);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HookManager.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;../structer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;../MDL/MDL.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;../ia32/ia32.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HookManager</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 单例模式</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">InstallInlinehook</span><span class="params">(HANDLE pid, __inout <span class="type">void</span>** originAddr, <span class="type">void</span>* hookAddr )</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">RemoveInlinehook</span><span class="params">(HANDLE pid, <span class="type">void</span>* hookAddr)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> HookManager* <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsolationPageTable</span><span class="params">(PEPROCESS process, <span class="type">void</span>* isolateioAddr)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">SplitLargePage</span><span class="params">(pde_64 InPde, pde_64&amp; OutPde )</span></span>; <span class="comment">// 大页分割成小页</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">ReplacePageTable</span><span class="params">(cr3 cr3, <span class="type">void</span>* replaceAlignAddr, pde_64* pde)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">ULONG64 <span class="title">VaToPa</span><span class="params">(<span class="type">void</span>* va)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span>* <span class="title">PaToVa</span><span class="params">(ULONG64 pa)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">offPGE</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	UINT32 mHookCount = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">	HOOK_INFO mHookInfo[MAX_HOOK_COUNT] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* mTrampLinePool = <span class="number">0</span>;</span><br><span class="line">	UINT32 mPoolUSED = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> HookManager* mInstance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PAGE_TABLE</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span></span><br><span class="line">	&#123;</span><br><span class="line">		pte_64* Pte;</span><br><span class="line">		pde_64* Pde;</span><br><span class="line">		pdpte_64* Pdpte;</span><br><span class="line">		pml4e_64* Pml4e;</span><br><span class="line">	&#125;Entry;</span><br><span class="line">	<span class="type">void</span>* VirtualAddress;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HookManager.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HookManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;../Hde/hde64.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;../PageTable/PageTable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">HookManager* HookManager::mInstance;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable : 4838)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable : 4309)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable : 4244)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable : 6328)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable : 6066)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable : 4996)</span></span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN_C VOID</span></span><br><span class="line"><span class="function"><span class="title">KeFlushEntireTb</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    __in BOOLEAN Invalid,</span></span></span><br><span class="line"><span class="params"><span class="function">    __in BOOLEAN AllProcessors</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HookManager::InstallInlinehook</span><span class="params">(HANDLE pid, __inout <span class="type">void</span>** originAddr, <span class="type">void</span>* hookAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> bFirst = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (bFirst) &#123;</span><br><span class="line">        mTrampLinePool = (<span class="type">char</span>*)<span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, PAGE_SIZE * <span class="number">4</span>, <span class="string">&#x27;Jmp&#x27;</span>); <span class="comment">// ExAllocatePool2 蓝屏！！！！！！！</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mTrampLinePool) &#123;</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;Error InstallInlinehook&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>(mTrampLinePool, PAGE_SIZE * <span class="number">4</span>);   </span><br><span class="line">        mPoolUSED = <span class="number">0</span>;</span><br><span class="line">        bFirst = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHookCount == MAX_HOOK_COUNT) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;FULL&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    PEPROCESS process;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(<span class="built_in">PsLookupProcessByProcessId</span>(pid, &amp;process))) <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsolationPageTable</span>(process, *originAddr)) &#123;</span><br><span class="line">        <span class="built_in">ObDereferenceObject</span>(process);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> UINT32 trampLineByteCount = <span class="number">20</span>;</span><br><span class="line">    <span class="type">const</span> UINT32 fnBreakByteLeast = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    push 0</span></span><br><span class="line"><span class="comment">    mov dword ptr ds : [rsp] , 0</span></span><br><span class="line"><span class="comment">    mov dword ptr ds : [rsp + 4] , 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">char</span> TrampLineCode[trampLineByteCount] = &#123; </span><br><span class="line">        <span class="number">0x6A</span>,<span class="number">0x00</span> ,<span class="number">0x3E</span> ,<span class="number">0xC7</span> ,<span class="number">0x04</span> ,<span class="number">0x24</span> ,<span class="number">0x00</span> ,<span class="number">0x00</span> ,<span class="number">0x00</span> ,</span><br><span class="line">        <span class="number">0x00</span> ,<span class="number">0x3E</span> ,<span class="number">0xC7</span> ,<span class="number">0x44</span> ,<span class="number">0x24</span> ,<span class="number">0x04</span> ,<span class="number">0x00</span> ,<span class="number">0x00</span> ,<span class="number">0x00</span> ,<span class="number">0x00</span> ,<span class="number">0xC3</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        mov rax, 0 </span></span><br><span class="line"><span class="comment">        Jmp rax</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">char</span> AbsoluteJmpCode[fnBreakByteLeast] = &#123;</span><br><span class="line">        <span class="number">0x48</span>,<span class="number">0xB8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">        <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0xE0</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* curTrampLinePool = mTrampLinePool + mPoolUSED;</span><br><span class="line">    <span class="type">char</span>* startJmpAddr = (<span class="type">char</span>*)*originAddr;  <span class="comment">// 要HOOK函数的首地址</span></span><br><span class="line">    UINT32 uBreakBytes = <span class="number">0</span>; </span><br><span class="line">    hde64s hdeinfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (uBreakBytes &lt; fnBreakByteLeast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">hde64_disasm</span>(startJmpAddr + uBreakBytes, &amp;hdeinfo)) &#123;</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;hde64_disasm error \n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        uBreakBytes += hdeinfo.len;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    *(PUINT32)&amp;TrampLineCode[<span class="number">6</span>] = (UINT32)((UINT64)(startJmpAddr + uBreakBytes) &amp; <span class="number">0xFFFFFFFF</span>); <span class="comment">// 取高位</span></span><br><span class="line">    *(PUINT32)&amp;TrampLineCode[<span class="number">15</span>] = (UINT32)((UINT64)(startJmpAddr + uBreakBytes)&gt;&gt;<span class="number">32</span> &amp; <span class="number">0xFFFFFFFF</span>); <span class="comment">//取低位</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(curTrampLinePool, startJmpAddr, uBreakBytes); <span class="comment">//保存原函数的 内容</span></span><br><span class="line">    <span class="built_in">memcpy</span>(curTrampLinePool + uBreakBytes, TrampLineCode, trampLineByteCount);  <span class="comment">//return 语句</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_HOOK_COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mHookInfo[i].pid != pid) &#123;</span><br><span class="line">            mHookInfo[i].pid = pid; </span><br><span class="line">            mHookInfo[i].originAddr = startJmpAddr;</span><br><span class="line">            <span class="built_in">memcpy</span>(mHookInfo[i].originBytes, startJmpAddr, uBreakBytes);</span><br><span class="line">            mHookCount++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(<span class="type">void</span>**)&amp;AbsoluteJmpCode[<span class="number">2</span>] = hookAddr; <span class="comment">// 数组地址转位一级指针：数组本身就是地址，&amp; 取一次值就变成了耳机指针， 在 * 取一次值</span></span><br><span class="line">    REPROTECT_CONTEXT Content = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    KAPC_STATE apc;</span><br><span class="line">    <span class="built_in">KeStackAttachProcess</span>(process, &amp;apc);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(<span class="built_in">MmLockVaForWrite</span>(startJmpAddr, PAGE_SIZE, &amp;Content))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>(Content.Lockedva, AbsoluteJmpCode, fnBreakByteLeast);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(<span class="built_in">MmUnlockVaForWrite</span>(&amp;Content))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">KeUnstackDetachProcess</span>(&amp;apc);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    *originAddr = curTrampLinePool;</span><br><span class="line">    mPoolUSED += (uBreakBytes + trampLineByteCount);</span><br><span class="line">    <span class="built_in">ObDereferenceObject</span>(process);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HookManager::RemoveInlinehook</span><span class="params">(HANDLE pid, <span class="type">void</span>* hookAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pid;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(hookAddr);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bool HookManager::RemoveInlinehook(HANDLE pid, void* hookAddr)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int hookIndex = -1;</span></span><br><span class="line"><span class="comment">    // 1. 查找 Hook 记录</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; MAX_HOOK_COUNT; i++) &#123;</span></span><br><span class="line"><span class="comment">        if (mHookInfo[i].pid == pid &amp;&amp; mHookInfo[i].originAddr != NULL) &#123;</span></span><br><span class="line"><span class="comment">            // 这里通常还需要校验 hookAddr 是否匹配，或者 originAddr 是否匹配</span></span><br><span class="line"><span class="comment">            // 简单起见，假设一个 PID 只有一个 Hook，或者通过 index 管理</span></span><br><span class="line"><span class="comment">             hookIndex = i;</span></span><br><span class="line"><span class="comment">             break;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    if (hookIndex == -1) &#123;</span></span><br><span class="line"><span class="comment">        DbgPrint(&quot;[HookManager] RemoveInlinehook: Hook not found\n&quot;);</span></span><br><span class="line"><span class="comment">        return false;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 保存需要恢复的数据</span></span><br><span class="line"><span class="comment">    void* originAddr = mHookInfo[hookIndex].originAddr;</span></span><br><span class="line"><span class="comment">    char originBytes[14] = &#123; 0 &#125;; // 确保这个大小足够容纳你备份的字节数</span></span><br><span class="line"><span class="comment">    memcpy(originBytes, mHookInfo[hookIndex].originBytes, sizeof(originBytes));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 2. 清理内部数组 (先清理，防止重入或逻辑死锁，虽然这里没有锁)</span></span><br><span class="line"><span class="comment">    // 即使后面恢复内存失败，这个记录也应该被标记为失效，否则会死循环占坑</span></span><br><span class="line"><span class="comment">    mHookInfo[hookIndex].pid = 0;</span></span><br><span class="line"><span class="comment">    mHookInfo[hookIndex].originAddr = NULL;</span></span><br><span class="line"><span class="comment">    memset(mHookInfo[hookIndex].originBytes, 0, sizeof(mHookInfo[hookIndex].originBytes));</span></span><br><span class="line"><span class="comment">    mHookCount--;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    PEPROCESS process = NULL;</span></span><br><span class="line"><span class="comment">    NTSTATUS status = PsLookupProcessByProcessId(pid, &amp;process);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    // 3. 如果进程已经没了，那钩子自然也没了，任务完成</span></span><br><span class="line"><span class="comment">    if (!NT_SUCCESS(status)) &#123;</span></span><br><span class="line"><span class="comment">        DbgPrint(&quot;[HookManager] Process %p already gone. Hook entry cleaned.\n&quot;, pid);</span></span><br><span class="line"><span class="comment">        return true; </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 4. 只有进程还在，才需要去恢复内存</span></span><br><span class="line"><span class="comment">    REPROTECT_CONTEXT Content = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">    KAPC_STATE apc;</span></span><br><span class="line"><span class="comment">    KeStackAttachProcess(process, &amp;apc);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    bool bSuccess = false;</span></span><br><span class="line"><span class="comment">    // 这里的长度需要和你 Install 时备份的长度完全一致，建议作为结构体成员存储</span></span><br><span class="line"><span class="comment">    if (NT_SUCCESS(MmLockVaForWrite(originAddr, PAGE_SIZE, &amp;Content))) &#123;</span></span><br><span class="line"><span class="comment">        memcpy(originAddr, originBytes, 12); // 注意：这里硬编码了长度，建议用 mHookInfo[i].patchLength</span></span><br><span class="line"><span class="comment">        MmUnlockVaForWrite(&amp;Content);</span></span><br><span class="line"><span class="comment">        bSuccess = true;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else &#123;</span></span><br><span class="line"><span class="comment">        DbgPrint(&quot;[HookManager] MmLockVaForWrite failed\n&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    KeUnstackDetachProcess(&amp;apc);</span></span><br><span class="line"><span class="comment">    ObDereferenceObject(process);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    if (bSuccess) &#123;</span></span><br><span class="line"><span class="comment">        // 5. 刷新指令缓存，防止CPU执行旧指令</span></span><br><span class="line"><span class="comment">        KeInvalidateAllCaches(); </span></span><br><span class="line"><span class="comment">        DbgPrint(&quot;[HookManager] Removed hook for pid=%p\n&quot;, pid);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    return bSuccess;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">HookManager* <span class="title">HookManager::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mInstance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        mInstance = (HookManager*)<span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, <span class="built_in">sizeof</span>(HookManager), <span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HookManager::IsolationPageTable</span><span class="params">(PEPROCESS process, <span class="type">void</span>* isolateioAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> bRet = <span class="literal">false</span>;</span><br><span class="line">    KAPC_STATE apc; </span><br><span class="line">    <span class="built_in">KeStackAttachProcess</span>(process, &amp;apc);</span><br><span class="line">    pde_64 NewPde = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">void</span>* alignAddrr; <span class="comment">// ?? </span></span><br><span class="line"></span><br><span class="line">    alignAddrr= <span class="built_in">PAGE_ALIGN</span>(isolateioAddr); <span class="comment">// 0x1000 对齐</span></span><br><span class="line">    PAGE_TABLE page_table = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    page_table.VirtualAddress = alignAddrr;</span><br><span class="line">    <span class="built_in">GetPageTable</span>(page_table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (page_table.Entry.Pde-&gt;large_page) &#123;</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;size is 2MB \n&quot;</span>);</span><br><span class="line">            bRet = <span class="built_in">SplitLargePage</span>(*page_table.Entry.Pde, NewPde);</span><br><span class="line">            <span class="keyword">if</span> (!bRet) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (page_table.Entry.Pdpte-&gt;large_page) &#123;</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;size is 1GB \n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;size is 4KB \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cr3 Cr3; </span><br><span class="line">        Cr<span class="number">3.f</span>lags = __readcr3();</span><br><span class="line">        bRet = <span class="built_in">ReplacePageTable</span>(Cr3, alignAddrr, &amp;NewPde);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bRet) &#123;</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;isolation successfully \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;Failed isolation \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">KeUnstackDetachProcess</span>(&amp;apc);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HookManager::SplitLargePage</span><span class="params">(pde_64 InPde, pde_64&amp; OutPde)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PHYSICAL_ADDRESS MaxAddrPA&#123; <span class="number">0</span> &#125;, LowAddrPa&#123; <span class="number">0</span> &#125;; </span><br><span class="line">    MaxAddrPA.QuadPart = MAXULONG64;</span><br><span class="line">    LowAddrPa.QuadPart =  <span class="number">0</span> ;</span><br><span class="line">    pt_entry_64* Pt;</span><br><span class="line">    <span class="type">uint64_t</span> StartPfn  =  InPde.page_frame_number;</span><br><span class="line"></span><br><span class="line">    Pt = (pt_entry_64*)<span class="built_in">MmAllocateContiguousMemorySpecifyCache</span>(PAGE_SIZE, LowAddrPa, MaxAddrPA, LowAddrPa, MmCached); <span class="comment">// 与MmAllocateContiguousMemory ？ </span></span><br><span class="line">    <span class="keyword">if</span> (!Pt) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;failed to MmAllocateContiguousMemorySpecifyCache&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">        Pt[i].flags = InPde.flags;</span><br><span class="line">        Pt[i].large_page = <span class="number">0</span>;</span><br><span class="line">        Pt[i].page_frame_number = StartPfn + i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OutPde.flags = InPde.flags;</span><br><span class="line">    OutPde.large_page = <span class="number">0</span>; </span><br><span class="line">    OutPde.page_frame_number = <span class="built_in">VaToPa</span>(Pt) / PAGE_SIZE;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HookManager::ReplacePageTable</span><span class="params">(cr3 cr3, <span class="type">void</span>* replaceAlignAddr, pde_64* pde)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> *Va4kb, *Vapt, *VaPdt, *VaPdpt, *VaPml4t;</span><br><span class="line">    PHYSICAL_ADDRESS MaxAddrPA&#123; <span class="number">0</span> &#125;, LowAddrPa&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    MaxAddrPA.QuadPart = MAXULONG64;</span><br><span class="line">    LowAddrPa.QuadPart = <span class="number">0</span>;</span><br><span class="line">    PAGE_TABLE pagetable = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    Va4kb = (<span class="type">uint64_t</span>*)<span class="built_in">MmAllocateContiguousMemorySpecifyCache</span>(PAGE_SIZE, LowAddrPa, MaxAddrPA, LowAddrPa, MmCached);</span><br><span class="line">    Vapt = (<span class="type">uint64_t</span>*)<span class="built_in">MmAllocateContiguousMemorySpecifyCache</span>(PAGE_SIZE, LowAddrPa, MaxAddrPA, LowAddrPa, MmCached);</span><br><span class="line">    VaPdt = (<span class="type">uint64_t</span>*)<span class="built_in">MmAllocateContiguousMemorySpecifyCache</span>(PAGE_SIZE, LowAddrPa, MaxAddrPA, LowAddrPa, MmCached);</span><br><span class="line">    VaPdpt = (<span class="type">uint64_t</span>*)<span class="built_in">MmAllocateContiguousMemorySpecifyCache</span>(PAGE_SIZE, LowAddrPa, MaxAddrPA, LowAddrPa, MmCached);</span><br><span class="line"></span><br><span class="line">    VaPml4t = (<span class="type">uint64_t</span>*)<span class="built_in">PaToVa</span>(cr<span class="number">3.</span>address_of_page_directory * PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Va4kb || !Vapt || !VaPdt || !VaPdpt) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot; Apply mm failed \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pagetable.VirtualAddress = replaceAlignAddr;</span><br><span class="line">    <span class="built_in">GetPageTable</span>(pagetable);</span><br><span class="line"></span><br><span class="line">    UINT64 pml4eindex = ((UINT64)replaceAlignAddr &amp; <span class="number">0xFF8000000000</span>) &gt;&gt; <span class="number">39</span>;</span><br><span class="line">    UINT64 pdpteindex = ((UINT64)replaceAlignAddr &amp; <span class="number">0x7FC0000000</span>) &gt;&gt; <span class="number">30</span>;</span><br><span class="line">    UINT64 pdeindex = ((UINT64)replaceAlignAddr &amp; <span class="number">0x3FE00000</span>) &gt;&gt; <span class="number">21</span>;</span><br><span class="line">    UINT64 pteindex = ((UINT64)replaceAlignAddr &amp; <span class="number">0x1FF000</span>) &gt;&gt; <span class="number">12</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (pagetable.Entry.Pde-&gt;large_page) &#123;</span><br><span class="line">        <span class="built_in">MmFreeContiguousMemorySpecifyCache</span>(Vapt, PAGE_SIZE, MmCached);</span><br><span class="line">        Vapt = (<span class="type">uint64_t</span>*)<span class="built_in">PaToVa</span>(pde-&gt;page_frame_number * PAGE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(Vapt, pagetable.Entry.Pte - pteindex, PAGE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(Va4kb, replaceAlignAddr, PAGE_SIZE);</span><br><span class="line">    <span class="built_in">memcpy</span>(VaPdt, pagetable.Entry.Pde - pdeindex, PAGE_SIZE);</span><br><span class="line">    <span class="built_in">memcpy</span>(VaPdpt, pagetable.Entry.Pdpte - pdpteindex, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pReplacePte = (pte_64*) &amp;Vapt[pteindex]; <span class="comment">// &amp; </span></span><br><span class="line">    pReplacePte-&gt;page_frame_number = <span class="built_in">VaToPa</span>(Va4kb) / PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pReplacePde = (pde_64*)&amp;VaPdt[pdeindex]; <span class="comment">// &amp; </span></span><br><span class="line">    pReplacePde-&gt;page_frame_number = <span class="built_in">VaToPa</span>(Vapt) / PAGE_SIZE;</span><br><span class="line">    pReplacePde-&gt;large_page = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pReplacePdpte = (pdpte_64*)&amp;VaPdpt[pdpteindex]; <span class="comment">// &amp; </span></span><br><span class="line">    pReplacePdpte-&gt;page_frame_number = <span class="built_in">VaToPa</span>(VaPdt) / PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pReplacePml4e = (pml4e_64*)&amp;VaPml4t[pml4eindex]; <span class="comment">// &amp; </span></span><br><span class="line">    pReplacePml4e-&gt;page_frame_number = <span class="built_in">VaToPa</span>(VaPdpt) / PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">KeFlushEntireTb</span>(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">offPGE</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ULONG64 <span class="title">HookManager::VaToPa</span><span class="params">(<span class="type">void</span>* va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PHYSICAL_ADDRESS pa; </span><br><span class="line">    pa = <span class="built_in">MmGetPhysicalAddress</span>(va);</span><br><span class="line">    <span class="keyword">return</span> pa.QuadPart;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">HookManager::PaToVa</span><span class="params">(ULONG64 pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PHYSICAL_ADDRESS Pa&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    Pa.QuadPart = pa;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MmGetVirtualForPhysical</span>(Pa);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ULONG_PTR <span class="title">KipiBroadcastWorker</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG_PTR Argument</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Argument;</span><br><span class="line">    KIRQL irql = <span class="built_in">KeRaiseIrqlToDpcLevel</span>();    <span class="comment">//提升进程特权级 , 防止切换 cpu 打断</span></span><br><span class="line">    _disable();  <span class="comment">//屏蔽中断</span></span><br><span class="line">    ULONG64 cr4 = __readcr4();</span><br><span class="line">    cr4 &amp;= <span class="number">0xffffffffffffff7f</span>; </span><br><span class="line">    __writecr4(cr4);</span><br><span class="line">    _enable();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">KeLowerIrql</span>(irql);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HookManager::offPGE</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">KeIpiGenericCall</span>(KipiBroadcastWorker, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;./HookManager/HookManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* pfnNtOpenProcess)</span><span class="params">(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PCLIENT_ID)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* pfnNtCreateFile)</span><span class="params">(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, PLARGE_INTEGER, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG)</span></span>;</span><br><span class="line"></span><br><span class="line">pfnNtOpenProcess g_oriNtOpenProcess;</span><br><span class="line">pfnNtCreateFile g_oriNtCreateFile;</span><br><span class="line">HANDLE g_pid = (HANDLE) <span class="number">1808</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS NTAPI <span class="title">FakeNtOpenProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PHANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ POBJECT_ATTRIBUTES ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PCLIENT_ID ClientId)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">102</span>,<span class="number">0</span>, <span class="string">&quot;Fake NtOpenProcess \n&quot;</span>);   <span class="comment">// 没有 \n  在windbg 的log 中看不到</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g_oriNtOpenProcess</span>(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS NTAPI <span class="title">FakeNtCreateFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PHANDLE FileHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ POBJECT_ATTRIBUTES ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PIO_STATUS_BLOCK IoStatusBlock,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PLARGE_INTEGER AllocationSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG FileAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG ShareAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG CreateDisposition,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG CreateOptions,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG EaLength)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Fake Ntfakeopenfile&quot;</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g_oriNtCreateFile</span>(FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, AllocationSize, FileAttributes, ShareAccess, CreateDisposition, CreateOptions, EaBuffer, EaLength);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载驱动函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(DriverObject);</span><br><span class="line">    HookManager::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">RemoveInlinehook</span>(g_pid, (<span class="type">void</span>*)FakeNtOpenProcess);</span><br><span class="line">    HookManager::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">RemoveInlinehook</span>(g_pid, (<span class="type">void</span>*)FakeNtCreateFile);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//下面是加载驱动，姑且不看，因为很熟悉。</span></span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegisterPath)</span></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(RegisterPath);</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    g_oriNtOpenProcess = NtOpenProcess;</span><br><span class="line">    g_oriNtCreateFile = NtCreateFile;</span><br><span class="line">    <span class="comment">//DbgPrintEx(102, 0, &quot;success main&quot;);</span></span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">102</span>, <span class="number">0</span>, <span class="string">&quot;1 \n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (HookManager::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">InstallInlinehook</span>(g_pid, (<span class="type">void</span>**)&amp;g_oriNtOpenProcess, (<span class="type">void</span>*)FakeNtOpenProcess)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrintEx</span>(<span class="number">102</span>, <span class="number">0</span>, <span class="string">&quot;success main \n&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//if (HookManager::GetInstance()-&gt;InstallInlinehook((void**)&amp;g_oriNtCreateFile, (void*)FakeNtCreateFile)) &#123;</span></span><br><span class="line">    <span class="comment">//    DbgPrintEx(102, 0, &quot;success main&quot;);</span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lab1-开源inlinehook练习"><a href="#lab1-开源inlinehook练习" class="headerlink" title="lab1-开源inlinehook练习"></a>lab1-开源inlinehook练习</h3><p><a target="_blank" rel="noopener" href="https://github.com/njmxye/drv_demo/tree/main/inlinehook">inlinehook</a></p>
<h3 id="lab1-开源pte练习"><a href="#lab1-开源pte练习" class="headerlink" title="lab1-开源pte练习"></a>lab1-开源pte练习</h3><p><a target="_blank" rel="noopener" href="https://github.com/njmxye/drv_demo/tree/main/pte">pte</a></p>
<h3 id="lab1-开源swapgs练习"><a href="#lab1-开源swapgs练习" class="headerlink" title="lab1-开源swapgs练习"></a>lab1-开源swapgs练习</h3><p><a target="_blank" rel="noopener" href="https://github.com/njmxye/drv_demo/tree/main/swapgs">swapgs</a></p>
<h3 id="lab1-开源模块基址查询"><a href="#lab1-开源模块基址查询" class="headerlink" title="lab1-开源模块基址查询"></a>lab1-开源模块基址查询</h3><p><a target="_blank" rel="noopener" href="https://github.com/njmxye/drv_demo/tree/main/mode">mode</a></p>
<h3 id="lab1-开源r02r3通信"><a href="#lab1-开源r02r3通信" class="headerlink" title="lab1-开源r02r3通信"></a>lab1-开源r02r3通信</h3><p><a target="_blank" rel="noopener" href="https://github.com/njmxye/drv_demo/tree/main/r02r3">r02r3</a></p>
<h2 id="cap2：x64-windows系统调用"><a href="#cap2：x64-windows系统调用" class="headerlink" title="cap2：x64_windows系统调用"></a>cap2：x64_windows系统调用</h2><p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-269253-1.htm">[原创]Windows内核逆向——-KiSystemCall64</a><br><a target="_blank" rel="noopener" href="https://gitcode.com/Universal-Tool/6b12e">英特尔® 64和IA-32架构软件开发人员手册</a></p>
<h3 id="r3-r0通过自陷指令进入r0的系统调用"><a href="#r3-r0通过自陷指令进入r0的系统调用" class="headerlink" title="r3-r0通过自陷指令进入r0的系统调用"></a>r3-r0通过自陷指令进入r0的系统调用</h3><h4 id="windows-x64下的系统调用指令"><a href="#windows-x64下的系统调用指令" class="headerlink" title="windows_x64下的系统调用指令"></a>windows_x64下的系统调用指令</h4><p>我们知道，系统调用是指在操作系统内核中定义的一组接口，应用程序通过调用这些接口来请求操作系统执行一些服务，比如访问磁盘、创建新进程等。</p>
<p>在x86的windows系统架构中,windows使用int 2e陷阱门进入内核,eax保留的是系统调用服务号，堆栈保存参数。在配备了sysenter指令的机器上则使用这条指令。</p>
<p>而x64的windows依然是使用int2e + 快速调用,但是快速调用为syscall指令。</p>
<h5 id="syscall指令"><a href="#syscall指令" class="headerlink" title="syscall指令"></a>syscall指令</h5><p>syscall指令依赖于msr寄存器。windows下依旧是rax作为系统服务号。下面是一个普通的系统调用，用于操作打开进程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:000000018009D3F0 NtOpenProcess  proc near               ; CODE XREF:</span><br><span class="line">.text:000000018009D3F0                                         ;</span><br><span class="line">.text:000000018009D3F0                 mov     r10, rcx        ; NtOpenProcess</span><br><span class="line">.text:000000018009D3F3                 mov     eax, 26h        ; &#x27;&amp;&#x27;</span><br><span class="line">.text:000000018009D3F8                 test    byte ptr ds:7FFE0308h, 1</span><br><span class="line">.text:000000018009D400                 jnz     short loc_18009D405</span><br><span class="line">.text:000000018009D402                 syscall                     ; Low latency system call</span><br><span class="line">.text:000000018009D402                 retn</span><br></pre></td></tr></table></figure>
<p>可以看到,他比较了<code>KUSER_SHARED_DATA</code>这个结构中的<code>308h</code>偏移处。其实这个标志位就是用于判断CPU是否支持快速调用。</p>
<p>支持,rcx赋值r10,eax赋值系统服务号,调用syscall。不支持,int2e进入中断门。</p>
<p>根据intel白皮书,syscall指令如下操作:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Operation</span><br><span class="line">IF (CS.L ≠ 1) or (IA32_EFER.LMA ≠ 1) or (IA32_EFER.SCE ≠ 1)</span><br><span class="line">    (* Not in 64-Bit Mode or SYSCALL/SYSRET not enabled in IA32_EFER *)</span><br><span class="line">    THEN #UD;</span><br><span class="line">FI;</span><br><span class="line">RCX := RIP;                          (* Will contain address of next instruction *)</span><br><span class="line">RIP := IA32_LSTAR;</span><br><span class="line">R11 := RFLAGS;</span><br><span class="line">RFLAGS := RFLAGS AND NOT(IA32_FMASK);</span><br><span class="line">CS.Selector := IA32_STAR[47:32] AND FFFCH (* Operating system provides CS; RPL forced to 0 *)</span><br><span class="line">(* Set rest of CS to a fixed value *)</span><br><span class="line">CS.Base := 0;                        (* Flat segment *)</span><br><span class="line">CS.Limit := FFFFFFH;                 (* With 4-KByte granularity, implies a 4-GByte limit *)</span><br><span class="line">CS.Type := 11;                       (* Execute/read code, accessed *)</span><br><span class="line">CS.S := 1;</span><br><span class="line">CS.DPL := 0;</span><br><span class="line">CS.P := 1;</span><br><span class="line">CS.L := 1;                           (* Entry is to 64-bit mode *)</span><br><span class="line">CS.D := 0;                           (* Required if CS.L = 1 *)</span><br><span class="line">CS.G := 1;                           (* 4-KByte granularity *)</span><br><span class="line">IF ShadowStackEnabled(CPL)</span><br><span class="line">    THEN (* adjust so bits 63:N get the value of bit N-1, where N is the CPU&#x27;s maximum linear-address width *)</span><br><span class="line">        IA32_PL3_SSP := LA_adjust(SSP);</span><br><span class="line">        (* With shadow stacks enabled the system call is supported from Ring 3 to Ring 0 *)</span><br><span class="line">        (* OS supporting Ring 0 to Ring 0 system calls or Ring 1/2 to ring 0 system call *)</span><br><span class="line">        (* Must preserve the contents of IA32_PL3_SSP to avoid losing ring 3 state *)</span><br><span class="line">FI;</span><br><span class="line">CPL := 0;</span><br><span class="line">IF ShadowStackEnabled(CPL)</span><br><span class="line">    SSP := 0;</span><br><span class="line">FI;</span><br><span class="line">IF EndbranchEnabled(CPL)</span><br><span class="line">    IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH</span><br><span class="line">    IA32_S_CET.SUPPRESS = 0</span><br><span class="line">FI;</span><br><span class="line">SS.Selector := IA32_STAR[47:32] + 8  (* SS just above CS *)</span><br><span class="line">(* Set rest of SS to a fixed value *)</span><br><span class="line">SS.Base := 0;                        (* Flat segment *)</span><br><span class="line">SS.Limit := FFFFFFH;                 (* With 4-KByte granularity, implies a 4-GByte limit *)</span><br><span class="line">SS.Type := 3;                        (* Read/write data, accessed *)</span><br><span class="line">SS.S := 1;</span><br><span class="line">SS.DPL := 0;</span><br><span class="line">SS.P := 1;</span><br><span class="line">SS.B := 1;                           (* 32-bit stack segment *)</span><br><span class="line">SS.G := 1;                           (* 4-KByte granularity *)</span><br></pre></td></tr></table></figure>
<p>RIP从MSR[IA32_LSTAR]找到，旧RIP保存到RCX。（RCX作为传参寄存器之一，在进入内核syscall之前已经保存到不用的r10寄存器中）<br>CS从MSR[IA32_STAR]的32到47位拿。SS恒等于CS+8；<br>EFLAGS从MSR[IA32_FMASK]拿，旧EFLAGS保存在r11中。</p>
<p>注意：syscall不像中断、调用门那样会自动切换TSS.RSP0，他是不切换堆栈的。</p>
<p>由此可见，r10、r11寄存器是系统调用专用寄存器，后面也有体现（赋值SSDT表的时候）</p>
<h4 id="KiSystemCall64"><a href="#KiSystemCall64" class="headerlink" title="KiSystemCall64"></a>KiSystemCall64</h4><p>在经过syscall之后，RIP被改到nt!KiSystemCall64之中。</p>
<p>这个函数是用来保存KTRAP_FRAME并根据rax找到系统调用地址。</p>
<p>通过陷入指令进入是必然要保存KTRAP_FRAME的，以便于退出回复。</p>
<p>不仅是syscall，异常通过的IDT（和int指令是一个意思）都是需要保存KTRAP_FRAME的。</p>
<p>syscall不会切换堆栈，首先就是进行栈的切换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 swapgs  ;切换gs基质</span><br><span class="line">2 mov gs:10h, rsp</span><br><span class="line">3 mov  rsp, gs:KPCR.Prcb.RspBase ; 可以看到 这个RspBase==InitialStack 直接等于KTRAP_FRAME的最低端</span><br></pre></td></tr></table></figure>
<p>然后接下来就是填充完整个KTRAP_FRAME了。</p>
<p>值得一提的是，他会检查是不是从R3来的，然后关闭SMAP（防止复制参数时CPU出错）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test  byte ptr [rbp+0F0h], 1 ; CS</span><br><span class="line">jz    short loc_14040A625</span><br><span class="line">stac        ; 关smap</span><br></pre></td></tr></table></figure>
<p>下面是线程内核堆栈图：</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12160532.png" alt="描述符4"></p>
<p>SatckBase在SwapContext的时候被存入到KPCR.RspBase，因此直接从KPCR.KPRCB的地方找到RspBase就是KTRAP_FRAME的最低端。<br>而Syscall不切换Rsp(即不从TSS中找RSP0)，因此直接就算KTRAP_FRAME。<br>而其他进入0环的方式，会找TSS.RSP0，来切换栈，此时是需要加一些东西才能到KTRAP_FRAME的。</p>
<h5 id="KiSystemServiceStart"><a href="#KiSystemServiceStart" class="headerlink" title="KiSystemServiceStart"></a>KiSystemServiceStart</h5><p>从KiSystemCall64到KiSystemServiceStart，基本都是在进行KTRAP_FRAME填充。<br>从现在，系统调用派遣开始。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">KiSystemServiceStart:</span><br><span class="line">mov     [rbx+_ETHREAD.Tcb.TrapFrame], rsp ; 可以看到,其实这个TrapFrame就是rsp 而我们的initialstack=ktrap_frame.size</span><br><span class="line">mov     edi, eax</span><br><span class="line">shr     edi, 7</span><br><span class="line">and     edi, 20h                          ; 其实就是在判断位12是不是1,用这个区分GDI系统调用</span><br><span class="line">and     eax, 0FFFH                        ; 去掉高位</span><br><span class="line">KiSystemServiceRepeat:                         ; CODE XREF: KiSystemCall64+90E↓j</span><br><span class="line">lea      r10, KeServiceDescriptorTable</span><br><span class="line">lea      r11, KeServiceDescriptorTableShadow</span><br><span class="line">test    [rbx+_ETHREAD.Tcb._union_45.ThreadFlags], 80h</span><br><span class="line">jz      short UseSSDT</span><br><span class="line">test    [rbx+_ETHREAD.Tcb._union_45.ThreadFlags], 200000h ; 再检查是不是GDI线程</span><br><span class="line">jz      short UseSSSDT</span><br><span class="line">lea    r11, KeServiceDescriptorTableFilter</span><br><span class="line"></span><br><span class="line">UseSSSDT:     ; CODE XREF: KiSystemCall64+392↑j</span><br><span class="line">mov     r10, r11 ;最终 R10就是要SSDT表</span><br><span class="line">UseSSDT:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>即只有SSDTINDEX为GDI系统调用并且是GDI线程才会使用SSSDT。<br>紧接着,开始根据SSDT表的结构以rax寻找真正的系统调用,并且找到参数个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cmp     eax, [r10+rdi+10h] ;rdi是偏移,是0x20的倍数  0x10处是SSDT的系统服务个数</span><br><span class="line">jnb     IndexTooBig</span><br><span class="line">mov     r10, [r10+rdi]     ;SSDTBase 取出0x0处</span><br><span class="line">movsx   r11, dword ptr [r10+rax*4] ;他是一个ULONG数组</span><br><span class="line">mov     rax, r11           ;赋值r11</span><br><span class="line">sar     r11, 4             ; 相当于/16(2^4)</span><br><span class="line">add     r10, r11           ;</span><br><span class="line">cmp     edi, 20h</span><br><span class="line">jnz     short loc_14040A9D0</span><br><span class="line">mov     r11, [rbx+0F0h]</span><br></pre></td></tr></table></figure>
<p>r10在下文就是直接被call r10了，他就是真正的系统调用。</p>
<p>推断得出，x64 SSDT表为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SSDT</span> &#123;</span><br><span class="line">PULONG SSDTBase;</span><br><span class="line">UINT64 Unk;</span><br><span class="line">PVOID SSDTMaxNum;</span><br><span class="line">UINT64 Unk1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TargetCALL=SSDT.SSDTBase[rax]/16+SSDTBase</p>
<h5 id="KiSystemServiceCopyEnd"><a href="#KiSystemServiceCopyEnd" class="headerlink" title="KiSystemServiceCopyEnd"></a>KiSystemServiceCopyEnd</h5><p>x64的系统调用复制是以8字节为单位进行复制的。</p>
<p>rax是经过计算的，也就是SSDTBase[rax]的最后四位*8（因为复制一个参数需要8字节）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">lea     r11, KiSystemServiceCopyEnd</span><br><span class="line">sub     r11, rax  ;rax就是需要额外复制的参数个数*8</span><br><span class="line">jmp     r11</span><br><span class="line">KiSystemServiceCopyStart:        ; DATA XREF: KiSystemServiceHandler+1Afo</span><br><span class="line">mov     rax, [rsi+70h]</span><br><span class="line">mov     [rdi+70h], rax</span><br><span class="line">mov     rax, [rsi+68h]</span><br><span class="line">mov     [rdi+68h], rax</span><br><span class="line">mov     rax, [rsi+60h]</span><br><span class="line">mov     [rdi+60h], rax</span><br><span class="line">mov     rax, [rsi+58h]</span><br><span class="line">mov     [rdi+58h], rax</span><br><span class="line">mov     rax, [rsi+50h]</span><br><span class="line">mov     [rdi+50h], rax</span><br><span class="line">mov     rax, [rsi+48h]</span><br><span class="line">mov     [rdi+48h], rax</span><br><span class="line">mov     rax, [rsi+40h]</span><br><span class="line">mov     [rdi+40h], rax</span><br><span class="line">mov     rax, [rsi+38h]</span><br><span class="line">mov     [rdi+38h], rax</span><br><span class="line">mov     rax, [rsi+30h]</span><br><span class="line">mov     [rdi+30h], rax</span><br><span class="line">mov     rax, [rsi+28h]</span><br><span class="line">mov     [rdi+28h], rax</span><br><span class="line">mov     rax, [rsi+20h]</span><br><span class="line">mov     [rdi+20h], rax</span><br><span class="line">mov     rax, [rsi+18h]</span><br><span class="line">mov     [rdi+18h], rax</span><br><span class="line">mov     rax, [rsi+10h]</span><br><span class="line">mov     [rdi+10h], rax</span><br><span class="line">mov     rax, [rsi+8]</span><br><span class="line">mov     [rdi+8], rax</span><br></pre></td></tr></table></figure>
<h5 id="etw判断"><a href="#etw判断" class="headerlink" title="etw判断"></a>etw判断</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.text:000000014040AA90 KiSystemServiceCopyEnd: ; CODE XREF: KiSystemCall64+413↑j</span><br><span class="line">                        ; DATA XREF: KiSystemServiceHandler+27↑o ...</span><br><span class="line">test    cs:KiDynamicTraceMask, 1</span><br><span class="line">jnz     ETWTrace</span><br><span class="line">test    dword ptr cs:PerfGlobalGroupMask+8, 40h</span><br><span class="line">jnz     ETWTrace</span><br><span class="line">mov     rax, r10</span><br><span class="line">call    rax  ; 否则直接进行系统调用</span><br><span class="line">nop     dword ptr [rax] </span><br><span class="line">ETWTrace:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在检查<code>KiDynamicTraceMask</code>不为0，就会进行ETW记录。ETW进行syscall hook所谓的魔数就是从这来的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mov     rcx, r10</span><br><span class="line">mov     rdx, rsp</span><br><span class="line">add     rdx, 20h</span><br><span class="line">mov     r8, 4</span><br><span class="line">mov     r9, rsp</span><br><span class="line">add     r9, 70h</span><br><span class="line">call    KiTraceSystemCallEntry ; 这里面保存着魔数 用于定位ETW SYSCALL</span><br><span class="line">mov     [rbp+50h], rax</span><br><span class="line">mov     rcx, [rsp+20h]</span><br><span class="line">mov     rdx, [rsp+28h]</span><br><span class="line">mov     r8, [rsp+30h]</span><br><span class="line">mov     r9, [rsp+38h]</span><br><span class="line">mov     r10, [rsp+40h] ; ETW hook的原理,通过Hook某些未被PG监控的函数指针。堆栈定位到这个rsp+40 改变rsp+40的值,使得call rax时到我们的函数</span><br><span class="line">add     rsp, 50h</span><br><span class="line">mov     rax, r10</span><br><span class="line">call    rax</span><br></pre></td></tr></table></figure>
<h5 id="InstrumentationCallback派遣"><a href="#InstrumentationCallback派遣" class="headerlink" title="InstrumentationCallback派遣"></a>InstrumentationCallback派遣</h5><p>这是一个回调，出现在很多地方，异常派遣、系统调用结束。如果<code>EPROCESS.InstrumentationCallback</code>位置有值，则会改变<code>KTRAP_FRAME</code>的<code>RIP</code>到<code>InstrumentationCallback</code>去执行，同时把要返回的<code>RIP</code>放进<code>r10</code>。</p>
<p>利用这个可以执行<code>ShellCode</code>，进行无线程注入。前提是Dll中无死循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SetInstrumentationCallback</span><br><span class="line">mov     rax, gs:188h</span><br><span class="line">mov     rax, [rax+_ETHREAD.Tcb._union_90.ApcState.Process]</span><br><span class="line">mov     rax, [rax+_KPROCESS.InstrumentationCallback]</span><br><span class="line">or      rax, rax</span><br><span class="line">jz      short NoInstrumentationCallback</span><br><span class="line">cmp     word ptr [rbp+0Fh], 33h</span><br><span class="line">jnz     short NoInstrumentationCallback</span><br><span class="line">mov     r10, [rbp+0E8h] ; TrapFrame的RIP 保存到r10</span><br><span class="line">mov     [rbp+0E8h], rax ; 把KProcess.InstrumentationCallback放到RIP</span><br></pre></td></tr></table></figure>
<h6 id="注册InstrumentationCallback"><a href="#注册InstrumentationCallback" class="headerlink" title="注册InstrumentationCallback"></a>注册InstrumentationCallback</h6><p>可以直接修改<code>_KPROCESS.InstrumentationCallback</code>，但这不是官网注册，可能发生不可预料的结果。</p>
<p>Windows自带的<code>ZwSetInformationProcess()</code>可以修改设置这个回调，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">SetProcessCallback</span><span class="params">(HANDLE ProcessId, ULONG_PTR InstrumentationCallback)</span> </span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    PEPROCESS Process = <span class="number">0</span>;</span><br><span class="line">    KAPC_STATE Apc = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PACCESS_TOKEN token = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PULONG tokenMask = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(<span class="built_in">PsLookupProcessByProcessId</span>(ProcessId, &amp;Process))) &#123;</span><br><span class="line">        <span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[ProcessCallback]:unable to get process!\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">PsGetProcessExitStatus</span>(Process) != STATUS_PENDING) &#123;</span><br><span class="line">        <span class="keyword">return</span> STATUS_PROCESS_IS_TERMINATING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这样无需使用句柄了</span></span><br><span class="line">    <span class="built_in">KeStackAttachProcess</span>(Process, &amp;Apc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取进程Token并设置DEBUG权限</span></span><br><span class="line">    token = <span class="built_in">PsReferencePrimaryToken</span>(Process);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置Debug权限 把3个权限都置上 因为他的权限为3个ULONG数组</span></span><br><span class="line">    <span class="comment">// 分别代表当先权限 开启的 以及默认的</span></span><br><span class="line">    tokenMask = (PULONG)((ULONG_PTR)token + <span class="number">0x40</span>);</span><br><span class="line">    <span class="comment">// 21位是DEBUG权限(位20)</span></span><br><span class="line">    tokenMask[<span class="number">0</span>] |= <span class="number">0x100000</span>;</span><br><span class="line">    tokenMask[<span class="number">1</span>] |= <span class="number">0x100000</span>;</span><br><span class="line">    tokenMask[<span class="number">2</span>] |= <span class="number">0x100000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置Instrumentaion</span></span><br><span class="line">    <span class="comment">// 但是 注意 要改先前模式,因为&amp;InstrumentationCallback可能地址校验不过去</span></span><br><span class="line">    ULONG64 uOffset=<span class="built_in">GetPreviousModeOffset</span>();</span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;PreviousModeOffset==0x%x&quot;</span>, uOffset);</span><br><span class="line"></span><br><span class="line">    status = <span class="built_in">ZwSetInformationProcess</span>(<span class="built_in">NtCurrentProcess</span>(),ProcessInstrumentationCallback, &amp;InstrumentationCallback, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">KeUnstackDetachProcess</span>(&amp;Apc);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">KeUnstackDetachProcess</span>(&amp;Apc);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="设置回调时token机制"><a href="#设置回调时token机制" class="headerlink" title="设置回调时token机制"></a>设置回调时token机制</h6><p>通过逆向，设置回调需要具备DEBUG权限，修改方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+0x4b8 Token          : _EX_FAST_REF</span><br></pre></td></tr></table></figure>
<p>在<code>EPROCESS.Token</code>中，这里保存着每个进程的<code>TOKEN</code>，它是一个锁。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffffba8d&#x27;3c6f7538 ffff8302&#x27;932d9067</span><br></pre></td></tr></table></figure></p>
<p>我们去掉最后4位，就是<code>_TOKEN</code>结构了。</p>
<h3 id="TOKEN结构解析（kd-dt命令查看）"><a href="#TOKEN结构解析（kd-dt命令查看）" class="headerlink" title="TOKEN结构解析（kd dt命令查看）"></a>TOKEN结构解析（kd dt命令查看）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _token ffff8302&#x27;932d9060</span><br><span class="line">nt!_TOKEN</span><br><span class="line">   +0x000 TokenSource       : _TOKEN_SOURCE</span><br><span class="line">   +0x010 TokenId           : _LUID</span><br><span class="line">   +0x018 AuthenticationId  : _LUID</span><br><span class="line">   +0x020 ParentTokenId     : _LUID</span><br><span class="line">   +0x028 ExpirationTime    : LARGE_INTEGER 0x6207526`b64ceb90</span><br><span class="line">   +0x030 TokenLock         : 0xffffba8d`3b8f8690 _ERESOURCE</span><br><span class="line">   +0x038 ModifiedId        : _LUID</span><br><span class="line">   +0x040 Privileges        : _SEP_TOKEN_PRIVILEGES</span><br><span class="line">   +0x058 AuditPolicy       : _SEP_AUDIT_POLICY</span><br><span class="line">   +0x078 SessionId         : 0</span><br><span class="line">   +0x07c UserAndGroupCount : 5</span><br><span class="line">   +0x080 RestrictedSidCount: 0</span><br><span class="line">   +0x084 VariableLength    : 0xa4</span><br><span class="line">   +0x088 DynamicCharged    : 0x1000</span><br><span class="line">   +0x08c DynamicAvailable  : 0</span><br><span class="line">   +0x090 DefaultOwnerIndex : 1</span><br><span class="line">   +0x098 UserAndGroups     : 0xffff8302`932d94f0 _SID_AND_ATTRIBUTES</span><br><span class="line">   +0xa0 RestrictedSids     : (null)</span><br><span class="line">   +0xa8 PrimaryGroup       : 0xffff8302`93174790 Void</span><br><span class="line">   +0xb0 DynamicPart        : 0xffff8302`93174790 -&gt; 0x101</span><br><span class="line">   +0xb8 DefaultDacl        : 0xffff8302`9317479c _ACL</span><br><span class="line">   +0xc0 TokenType          : 1 ( TokenPrimary )</span><br><span class="line">   +0xc4 ImpersonationLevel : 0 ( SecurityAnonymous )</span><br><span class="line">   +0xc8 TokenFlags         : 0x2800</span><br><span class="line">   +0xcc TokenInUse         : 0x1 &#x27;&#x27;</span><br><span class="line">   +0xd0 IntegrityLevelIndex: 4</span><br><span class="line">   +0xd4 MandatoryPolicy    : 1</span><br><span class="line">   +0xd8 LogonSession       : 0xffff8302`8fa80cb0 _SEP_LOGON_SESSION_REFERENCES</span><br><span class="line">   +0xe0 OriginatingLogonSession : _LUID</span><br><span class="line">   +0xe8 SidHash            : _SID_AND_ATTRIBUTES_HASH</span><br><span class="line">   ...</span><br><span class="line">   +0x480 BnoIsolationHandleEntry: (null)</span><br><span class="line">   +0x488 SessionObject     : (null)</span><br><span class="line">   +0x490 VariablePart      : 0xffff8302`932d9540</span><br></pre></td></tr></table></figure>
<p>其中涉及到调试权限的就是<code>Privileges</code>这个成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+0x040 Privileges        : _SEP_TOKEN_PRIVILEGES</span><br></pre></td></tr></table></figure>
<p>该成员包含三个权限Mask：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[+0x000] Present          : 0x1e72ffffb8 [Type: unsigned __int64]</span><br><span class="line">[+0x008] Enabled          : 0x1e0b1e890 [Type: unsigned __int64]</span><br><span class="line">[+0x010] EnabledByDefault : 0x1e0b1e890 [Type: unsigned __int64]</span><br></pre></td></tr></table></figure></p>
<p>分别对应“现在”“可使用”“默认启用”。<br>使用Windbg的<code>!token</code>命令确认调试权限在哪。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !TOKEN ffff8302&#x27;932d9060</span><br><span class="line">_TOKEN 0xffff8302932d9060</span><br><span class="line">TS Session ID: 0</span><br><span class="line">User: S-1-5-18</span><br><span class="line">User Groups:</span><br><span class="line">00 S-1-5-32-544</span><br><span class="line">    Attributes - Default Enabled Owner</span><br><span class="line">01 S-1-1-0</span><br><span class="line">    Attributes - Mandatory Default Enabled</span><br><span class="line">02 S-1-5-11</span><br><span class="line">    Attributes - Mandatory Default Enabled</span><br><span class="line">03 S-1-16-16384</span><br><span class="line">    Attributes - GroupIntegrity GroupIntegrityEnabled</span><br><span class="line">Primary Group: S-1-5-18</span><br><span class="line">Privs:</span><br><span class="line">03 0x00000003 SeAssignPrimaryTokenPrivilege    Attributes - </span><br><span class="line">04 0x00000004 SeLockMemoryPrivilege             Attributes - Enabled Default</span><br><span class="line">05 0x00000005 SeIncreaseQuotaPrivilege          Attributes - </span><br><span class="line">07 0x00000007 SeTcbPrivilege                    Attributes - Enabled Default</span><br><span class="line">08 0x00000008 SeSecurityPrivilege               Attributes - </span><br><span class="line">09 0x00000009 SeTakeOwnershipPrivilege          Attributes - </span><br><span class="line">10 0x0000000a SeLoadDriverPrivilege             Attributes - </span><br><span class="line">11 0x0000000b SeSystemProfilePrivilege          Attributes - Enabled Default</span><br><span class="line">12 0x0000000c SeSystemtimePrivilege             Attributes - </span><br><span class="line">13 0x0000000d SeProfileSingleProcessPrivilege   Attributes - Enabled Default</span><br><span class="line">14 0x0000000e SeIncreaseBasePriorityPrivilege   Attributes - Enabled Default</span><br><span class="line">15 0x0000000f SeCreatePagefilePrivilege         Attributes - Enabled Default</span><br><span class="line">16 0x00000010 SeCreatePermanentPrivilege        Attributes - Enabled Default</span><br><span class="line">17 0x00000011 SeBackupPrivilege                 Attributes - </span><br><span class="line">18 0x00000012 SeRestorePrivilege                Attributes - </span><br><span class="line">19 0x00000013 SeShutdownPrivilege               Attributes - </span><br><span class="line">20 0x00000014 SeDebugPrivilege                  Attributes - Enabled Default</span><br><span class="line">21 0x00000015 SeAuditPrivilege                  Attributes - Enabled Default</span><br><span class="line">22 0x00000016 SeSystemEnvironmentPrivilege      Attributes - </span><br><span class="line">23 0x00000017 SeChangeNotifyPrivilege           Attributes - Enabled Default</span><br><span class="line">25 0x00000019 SeUndockPrivilege                 Attributes - </span><br><span class="line">28 0x0000001c SeManageVolumePrivilege           Attributes - </span><br><span class="line">29 0x0000001d SeImpersonatePrivilege            Attributes - Enabled Default</span><br><span class="line">30 0x0000001e SeCreateGlobalPrivilege           Attributes - Enabled Default</span><br><span class="line">33 0x00000021 SeIncreaseWorkingSetPrivilege     Attributes - Enabled Default</span><br><span class="line">34 0x00000022 SeTimeZonePrivilege               Attributes - Enabled Default</span><br><span class="line">35 0x00000023 SeCreateSymbolicLinkPrivilege     Attributes - Enabled Default</span><br><span class="line">36 0x00000024 SeDelegateSessionUserImpersonatePrivilege Attributes - Enabled Default</span><br><span class="line">Authentication ID:         (0, 3e7)</span><br><span class="line">Impersonation Level:       Anonymous</span><br><span class="line">TokenType:                 Primary</span><br><span class="line">Source: &quot;SYSTEM&quot;           TokenFlags: 0x2800 ( Token in use )</span><br><span class="line">Token ID: bc9              ParentToken ID: 0</span><br><span class="line">Modified ID: (0, b13e)</span><br><span class="line">RestrictedSidCount: 0      RestrictedSids: 0x0000000000000000</span><br><span class="line">OriginatingLogonSession: 0</span><br><span class="line">PackageSid: (null)</span><br><span class="line">CapabilityCount: 0         Capabilities: 0x0000000000000000</span><br><span class="line">LowboxNumberEntry: 0x0000000000000000</span><br><span class="line">Security Attributes:</span><br><span class="line">Unable to get the offset of nt!_AUTHZBASEP_SECURITY_ATTRIBUTE.ListLink</span><br><span class="line">Process Token TrustLevelSid: S-1-19-512-8192</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20 0x00000014 SeDebugPrivilege                  Attributes - Enabled Default</span><br></pre></td></tr></table></figure>
<p>位20为调试权限，置位即可（需将<code>Present</code>、<code>Enabled</code>、<code>EnabledByDefault</code>三个Mask对应位同时置位）。</p>
<h5 id="sysret"><a href="#sysret" class="headerlink" title="sysret"></a>sysret</h5><p>在执行完之后，会调用sysret进行返回。指令效果和syscall完全相反。</p>
<h3 id="r0-r0的系统调用"><a href="#r0-r0的系统调用" class="headerlink" title="r0-r0的系统调用"></a>r0-r0的系统调用</h3><p>我们在驱动之中，通常也会使用系统调用函数。</p>
<p>他和R3-R0的最大区别就是：如果在驱动中用Zw开头的系统调用而不是Nt开头或者（是直接从SSDT定位的），其实就是和Nt开头的是一样的，是无视句柄权限（ObReferenceObjectByHandle）这个检查的。</p>
<p>他的原理是<code>ZwXXX</code>→<code>KiSystemInternal</code>→修改<code>Previousmode</code>→<code>NtXXX</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS __stdcall <span class="title">ZwOpenKey</span><span class="params">(PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> __int64 v3; <span class="comment">// r10</span></span><br><span class="line">    NTSTATUS result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">    _disable();</span><br><span class="line">    v3 = __readflags();</span><br><span class="line">    <span class="built_in">KiServiceInternal</span>();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如使用<code>ZwOpenKeysM</code>可以看到，他调用了<code>KiServiceInternal();</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KiServiceInternal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> v1; <span class="comment">// ST28_1</span></span><br><span class="line">    __int64 v2; <span class="comment">// ST138_8</span></span><br><span class="line"></span><br><span class="line">    _enable();</span><br><span class="line">    Ethread = <span class="built_in">KeGetCurrentThread</span>();</span><br><span class="line">    __asm &#123; prefetchw byte ptr [rbx+ETHREAD.Tcb.TrapFrame] &#125;</span><br><span class="line">    v1 = Ethread-&gt;_union_<span class="number">171.</span>UserAffinity.Reserved[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">LOBYTE</span>(Ethread-&gt;_union_<span class="number">171.</span>UserAffinity.Reserved[<span class="built_in">offsetof</span>(_ETHREAD.Tcb)]) = <span class="number">0</span>; <span class="comment">// 这个就是Previousmode</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>后面课件没有了，自己悟。</p>
</blockquote>
<h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><h3 id="lab2-set-instcallback"><a href="#lab2-set-instcallback" class="headerlink" title="lab2-set_instcallback"></a>lab2-set_instcallback</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//drv_main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN_C</span></span><br><span class="line"><span class="function">NTSYSAPI</span></span><br><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function">NTAPI</span></span><br><span class="line"><span class="function"><span class="title">ZwSetInfomationProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	__in HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	__in PROCESSINFOCLASS ProcessInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">	__in_bcount(ProcessInfomationLength) PVOID ProcessInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">	__in ULONG ProcessInformationLength</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> waring(disable:4839)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> waring(disable:4309)</span></span><br><span class="line"><span class="type">char</span> g_InstCallBackShellCode[] =</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">0x51</span>,<span class="comment">//push rcx</span></span><br><span class="line">	<span class="number">0x52</span>,<span class="comment">//push rdx</span></span><br><span class="line">	<span class="number">0x53</span>,<span class="comment">//push rbx</span></span><br><span class="line">	<span class="number">0x55</span>,</span><br><span class="line">	<span class="number">0x56</span>,</span><br><span class="line">	<span class="number">0x57</span>,</span><br><span class="line">	<span class="number">0x41</span>, <span class="number">0x50</span>,</span><br><span class="line">	<span class="number">0x41</span>, <span class="number">0x51</span>,</span><br><span class="line">	<span class="number">0x41</span>, <span class="number">0x52</span>,</span><br><span class="line">	<span class="number">0x41</span>, <span class="number">0x53</span>,</span><br><span class="line">	<span class="number">0x41</span>, <span class="number">0x54</span>,</span><br><span class="line">	<span class="number">0x41</span>, <span class="number">0x55</span>,</span><br><span class="line">	<span class="number">0x41</span>, <span class="number">0x56</span>,</span><br><span class="line">	<span class="number">0x41</span>, <span class="number">0x57</span>,</span><br><span class="line">	<span class="comment">//上面都是保存寄存器</span></span><br><span class="line">	<span class="comment">// sub rsp,0x20</span></span><br><span class="line">	<span class="number">0x48</span>,<span class="number">0x83</span>,<span class="number">0xec</span>,<span class="number">0x28</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">//中间写入一些东西shell code</span></span><br><span class="line">	<span class="number">0x49</span>,<span class="number">0xB9</span>,<span class="number">0x44</span>,<span class="number">0xD6</span>,<span class="number">0xB4</span>,<span class="number">0xFE</span>,<span class="number">0xFA</span>,<span class="number">0x7F</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">0x4D</span>,<span class="number">0x3B</span>,<span class="number">0xCA</span>,<span class="number">0x75</span>,<span class="number">0x05</span>,<span class="number">0xB8</span>,<span class="number">0x10</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">0xC0</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//0x49,0xB9,0x44,0xD6,0x40,0x2B,0xFD,0x7F,0x00,00,0x4D,0x3B,0xD1,0x75,0x05,0xB8,0x01,00,00,0xC0,</span></span><br><span class="line">	 </span><br><span class="line"></span><br><span class="line">	<span class="comment">//add rsp,0x20</span></span><br><span class="line">	<span class="number">0x48</span>,<span class="number">0x83</span>,<span class="number">0xc4</span>,<span class="number">0x28</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">//pop 寄存器</span></span><br><span class="line">	<span class="number">0x41</span>, <span class="number">0x5F</span>,</span><br><span class="line">	<span class="number">0x41</span>, <span class="number">0x5E</span>,</span><br><span class="line">	<span class="number">0x41</span>, <span class="number">0x5D</span>,</span><br><span class="line">	<span class="number">0x41</span>, <span class="number">0x5C</span>,</span><br><span class="line">	<span class="number">0x41</span>, <span class="number">0x5B</span>,</span><br><span class="line">	<span class="number">0x41</span>, <span class="number">0x5A</span>,</span><br><span class="line">	<span class="number">0x41</span>, <span class="number">0x59</span>,</span><br><span class="line">	<span class="number">0x41</span>, <span class="number">0x58</span>,</span><br><span class="line">	<span class="number">0x5F</span>,</span><br><span class="line">	<span class="number">0x5E</span>,</span><br><span class="line">	<span class="number">0x5D</span>,</span><br><span class="line">	<span class="number">0x5B</span>,</span><br><span class="line">	<span class="number">0x5A</span>,</span><br><span class="line">	<span class="number">0x59</span>,</span><br><span class="line">	<span class="number">0x41</span>, <span class="number">0xFF</span>, <span class="number">0xE2</span>,<span class="comment">//jmp r10 返回</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">set_instcallback</span><span class="params">(HANDLE process_id)</span> </span>&#123;</span><br><span class="line">	PEPROCESS process&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	KAPC_STATE apc&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	NTSTATUS status = STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">	status = <span class="built_in">PsLookupProcessByProcessId</span>(process_id, &amp;process);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[+]failed to get eprocess\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">KeStackAttachProcess</span>(process, &amp;apc);</span><br><span class="line">		<span class="type">void</span>* alloc_addr = <span class="number">0</span>;</span><br><span class="line">		SIZE_T size = PAGE_SIZE;</span><br><span class="line">		status= <span class="built_in">ZwAllocateVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), &amp;alloc_addr, <span class="number">0</span>, &amp;size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">			<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[+]failed to allocate mem\r\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[+]alloc addr:%llx\r\n&quot;</span>,alloc_addr);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memcpy</span>(alloc_addr, g_InstCallBackShellCode, <span class="built_in">sizeof</span>(g_InstCallBackShellCode));</span><br><span class="line"></span><br><span class="line">		<span class="comment">//set instcall</span></span><br><span class="line">		status = <span class="built_in">ZwSetInfomationProcess</span>(<span class="built_in">NtCurrentProcess</span>(), ProcessInstrumentationCallback, &amp;alloc_addr, <span class="built_in">sizeof</span>(&amp;alloc_addr));</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) <span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[+]set instcall back err\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">KeUnstackDetachProcess</span>(&amp;apc);</span><br><span class="line">	<span class="built_in">ObDereferenceObject</span>(process);</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT, PUNICODE_STRING)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">set_instcallback</span>((HANDLE)<span class="number">9596</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="lab2-OxygenDriver-研读开源拉闸的代码"><a href="#lab2-OxygenDriver-研读开源拉闸的代码" class="headerlink" title="lab2-OxygenDriver_研读开源拉闸的代码"></a>lab2-OxygenDriver_研读开源拉闸的代码</h3><p><a target="_blank" rel="noopener" href="https://github.com/Oxygen1a1">鸣谢-Oxygen1a1</a><br><a target="_blank" rel="noopener" href="https://github.com/Oxygen1a1/OxygenDriver">https://github.com/Oxygen1a1/OxygenDriver</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//APC.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="comment">//h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> APC&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_KAPC_ENVIRONMENT</span> &#123;</span><br><span class="line">	OriginalApcEnvironment,</span><br><span class="line">	AttachedApcEnvironment,</span><br><span class="line">	CurrentApcEnvironment,</span><br><span class="line">	InsertApcEnvironment</span><br><span class="line"></span><br><span class="line">&#125;KAPC_ENVIRONMENT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span><span class="params">(*PKRUNDOWN_ROUTINE)</span> <span class="params">(IN <span class="keyword">struct</span> _KAPC* Apc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span><span class="params">(*PKNORMAL_ROUTINE)</span><span class="params">(IN PVOID NormalContext, IN PVOID SystemArgument1, IN PVOID SystemArgument2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span><span class="params">(*PKKERNEL_ROUTINE)</span><span class="params">(PRKAPC Apc,PKNORMAL_ROUTINE* pNormalRoutine, PVOID* pNormalContext, PVOID* pSystemArgument1, PVOID* pSystemArgument2)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span> <span class="params">(*pKeInitializeApc)</span><span class="params">(__out PRKAPC Apc,__in PRKTHREAD Thread,__in KAPC_ENVIRONMENT Environment,__in PKKERNEL_ROUTINE KernelRoutine,__in_opt PKRUNDOWN_ROUTINE RundownRoutine,__in_opt PKNORMAL_ROUTINE NormalRoutine,__in_opt KPROCESSOR_MODE ApcMode,__in_opt PVOID NormalContext)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOLEAN</span> <span class="params">(*pKeInsertQueueApc)</span><span class="params">(__inout PRKAPC Apc,__in_opt PVOID SystemArgument1,__in_opt PVOID SystemArgument2,__in KPRIORITY Increment)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//专用消除</span></span><br><span class="line"><span class="function">VOID <span class="title">RunDownApcRoutine</span><span class="params">(PKAPC Apc)</span></span>;</span><br><span class="line"><span class="function">VOID <span class="title">KernelRoutineForUser</span><span class="params">(PRKAPC Apc, PKNORMAL_ROUTINE* NormalRoutine, PVOID* NormalContext, PVOID* SysArg1, PVOID* SysArg2)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">InsertAndDeliverKernelApc</span><span class="params">(PKAPC Apc, PKTHREAD Thread, KAPC_ENVIRONMENT Environment, PKKERNEL_ROUTINE KernelRoutine, PKRUNDOWN_ROUTINE RundownRoutine, PKNORMAL_ROUTINE NormalRoutine, PVOID NormalContext, PVOID SysArg1, PVOID SysArg2)</span></span>;</span><br><span class="line"><span class="function">BOOLEAN <span class="title">InsertAndDeliverUserApc</span><span class="params">(HANDLE ThreadId, CHAR* ShellCode, <span class="type">size_t</span> ShellSize, PVOID NormalContext)</span></span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//APC.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;APC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ReadWrite.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> APC;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//屏蔽未引用的形参</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span>  <span class="keyword">warning</span>(disable : 4100)</span></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">APC::RunDownApcRoutine</span><span class="params">(PKAPC Apc)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//清理空间</span></span><br><span class="line">	<span class="built_in">ExFreePool</span>(Apc);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">APC::KernelRoutineForUser</span><span class="params">(PRKAPC Apc, PKNORMAL_ROUTINE* pNormalRoutine, PVOID* pNormalContext, PVOID* pSystemArgument1, PVOID* pSystemArgument2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//用于用户APC执行时候</span></span><br><span class="line">	<span class="comment">//什么都不干</span></span><br><span class="line">	<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;KernelRoutine done,NormalRoutine==0x%p\n&quot;</span>, *pNormalRoutine);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">APC::InsertAndDeliverKernelApc</span><span class="params">(PKAPC Apc, PKTHREAD Thread, KAPC_ENVIRONMENT Environment, PKKERNEL_ROUTINE KernelRoutine, PKRUNDOWN_ROUTINE RundownRoutine, PKNORMAL_ROUTINE NormalRoutine,  PVOID NormalContext, PVOID SysArg1, PVOID SysArg2)</span> </span>&#123;</span><br><span class="line">	KPROCESSOR_MODE ApcMode = <span class="number">0</span>;<span class="comment">//KernelApc</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取KeInitlialzeApc和KeInsertQueueApc</span></span><br><span class="line">	UNICODE_STRING usKeInitializeApc = <span class="built_in">RTL_CONSTANT_STRING</span>(<span class="string">L&quot;KeInitializeApc&quot;</span>);</span><br><span class="line">	UNICODE_STRING usKeInsertQueueApc = <span class="built_in">RTL_CONSTANT_STRING</span>(<span class="string">L&quot;KeInsertQueueApc&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pKeInitializeApc KeInitializeApc = (pKeInitializeApc)<span class="built_in">MmGetSystemRoutineAddress</span>(&amp;usKeInitializeApc);</span><br><span class="line">	pKeInsertQueueApc KeInsertQueueApc = (pKeInsertQueueApc)<span class="built_in">MmGetSystemRoutineAddress</span>(&amp;usKeInsertQueueApc);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">KeInitializeApc</span>(Apc, Thread, Environment, KernelRoutine, RundownRoutine, NormalRoutine, ApcMode, NormalContext);</span><br><span class="line">	BOOLEAN bOk=<span class="built_in">KeInsertQueueApc</span>(Apc, SysArg1, SysArg2,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!bOk) &#123;</span><br><span class="line">		<span class="comment">//err</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Insert ApcList Err!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">ExFreePool</span>(Apc);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bOk;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">APC::InsertAndDeliverUserApc</span><span class="params">( HANDLE ThreadId,CHAR* ShellCode,<span class="type">size_t</span> ShellSize,PVOID NormalContext)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//DbgBreakPoint();</span></span><br><span class="line">	<span class="comment">//如果想让APC立刻执行 需要插入的时候修改ApcUserPending | 2即可</span></span><br><span class="line">	PKTHREAD Thread;</span><br><span class="line">	PKAPC Apc = (PKAPC)<span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, <span class="built_in">sizeof</span>(KAPC), <span class="string">&#x27;APC&#x27;</span>);</span><br><span class="line">	<span class="built_in">memset</span>(Apc, <span class="number">0</span>, <span class="built_in">sizeof</span>(KAPC));</span><br><span class="line">	KPROCESSOR_MODE ApcMode = <span class="number">1</span>;<span class="comment">//UserApc</span></span><br><span class="line">	<span class="keyword">auto</span> Environment = OriginalApcEnvironment;</span><br><span class="line">	PEPROCESS Process;</span><br><span class="line">	PKAPC_STATE ApcState;</span><br><span class="line">	NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">	<span class="type">size_t</span> size = <span class="number">0x1000</span>;</span><br><span class="line">	PVOID NormalRoutine=<span class="number">0</span>;</span><br><span class="line">	DWORD32 dwOldProtection = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	status=<span class="built_in">PsLookupThreadByThreadId</span>(ThreadId, &amp;Thread);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//err</span></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to get thread\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取KeInitlialzeApc和KeInsertQueueApc</span></span><br><span class="line">	UNICODE_STRING usKeInitializeApc = <span class="built_in">RTL_CONSTANT_STRING</span>(<span class="string">L&quot;KeInitializeApc&quot;</span>);</span><br><span class="line">	UNICODE_STRING usKeInsertQueueApc = <span class="built_in">RTL_CONSTANT_STRING</span>(<span class="string">L&quot;KeInsertQueueApc&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pKeInitializeApc KeInitializeApc = (pKeInitializeApc)<span class="built_in">MmGetSystemRoutineAddress</span>(&amp;usKeInitializeApc);</span><br><span class="line">	pKeInsertQueueApc KeInsertQueueApc = (pKeInsertQueueApc)<span class="built_in">MmGetSystemRoutineAddress</span>(&amp;usKeInsertQueueApc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!KeInitializeApc || !KeInsertQueueApc) &#123;</span><br><span class="line">		<span class="comment">//err</span></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to Getsystem routine!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取线程的进程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ULONG_PTR uApcState = Global::<span class="built_in">GetInstance</span>()-&gt;uApcState;</span><br><span class="line">	ApcState = (PKAPC_STATE)((ULONG_PTR)Thread + uApcState);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!uApcState) &#123;</span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Apcstate offset err!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>(ApcState)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//err</span></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to get process from Apcstate\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Process = ApcState-&gt;Process;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取PID 这里偷了个懒  没用Pdb查</span></span><br><span class="line"></span><br><span class="line">	HANDLE ProcessId = *(PHANDLE)((ULONG_PTR)Process + <span class="number">0x440</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//申请一块内存</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//先要这样一块只能执行内存,如果可写可能会被查</span></span><br><span class="line"></span><br><span class="line">	status = ReadWrite::<span class="built_in">MyAllocMem</span>(ProcessId, &amp;NormalRoutine,<span class="number">0</span>,&amp;size,MEM_COMMIT,PAGE_EXECUTE,<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将ShellCode写入到申请的内存</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//因为之前申请的原因 所以修改这个地方的页面属性 让他可写</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	status = ReadWrite::<span class="built_in">MyProtectMem</span>(ProcessId, &amp;NormalRoutine, &amp;size, PAGE_EXECUTE_READWRITE, &amp;dwOldProtection);</span><br><span class="line"></span><br><span class="line">	status = ReadWrite::<span class="built_in">MyWriteMem</span>(ProcessId, NormalRoutine, ShellCode, ShellSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在修改回去原来的页面保护属性</span></span><br><span class="line">	status = ReadWrite::<span class="built_in">MyProtectMem</span>(ProcessId, &amp;NormalRoutine, &amp;size, dwOldProtection, &amp;dwOldProtection);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">KeInitializeApc</span>(Apc, Thread, Environment, KernelRoutineForUser, RunDownApcRoutine, (APC::PKNORMAL_ROUTINE)NormalRoutine, ApcMode, NormalContext);</span><br><span class="line">	</span><br><span class="line">	BOOLEAN bOk = <span class="built_in">KeInsertQueueApc</span>(Apc, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!bOk) &#123;</span><br><span class="line">		<span class="comment">//err</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Insert ApcList Err!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">ExFreePool</span>(Apc);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	INT64* UserApcPendingAll = (INT64*)((ULONG_PTR)Thread + Global::<span class="built_in">GetInstance</span>()-&gt;uApcUserPendingAll + Global::<span class="built_in">GetInstance</span>()-&gt;uApcState);</span><br><span class="line"></span><br><span class="line">	*UserApcPendingAll |= <span class="number">2</span>;<span class="comment">//UserApcPending置位;APC立刻可以执行</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> bOk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Global.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CTL_CODE_INIT CTL_CODE(0x8000,0x801,0,0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于进线程创建的AttributeList 0环要转成CreateProcessContext 变长数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SECURITY_ATTRIBUTES</span> &#123;</span><br><span class="line">	DWORD32 nLength;</span><br><span class="line">	PVOID lpSecurityDescriptor;</span><br><span class="line">	BOOLEAN bInheritHandle;</span><br><span class="line">&#125; SECURITY_ATTRIBUTES, * PSECURITY_ATTRIBUTES, * LPSECURITY_ATTRIBUTES;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_NT_PROC_THREAD_ATTRIBUTE_ENTRY</span> &#123;</span><br><span class="line">	UINT64 Attribute;</span><br><span class="line">	SIZE_T size;</span><br><span class="line">	UINT64 Vaule;</span><br><span class="line">	UINT64 Unknown;</span><br><span class="line">&#125;NT_PROC_THREAD_ATTRIBUTE_ENTRY,* PNT_PROC_THREAD_ATTRIBUTE_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_NT_PROC_THREAD_ATTRIBUTE_LIST</span> &#123;</span><br><span class="line">	UINT64 Length;</span><br><span class="line">	_NT_PROC_THREAD_ATTRIBUTE_ENTRY Entry[<span class="number">1</span>];</span><br><span class="line">&#125;NT_PROC_THREAD_ATTRIBUTE_LIST,*PNT_PROC_THREAD_ATTRIBUTE_LIST;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LDR_DATA</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*0x000*/</span>     <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> InLoadOrderLinks;</span><br><span class="line">	<span class="comment">/*0x010*/</span>     <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> InMemoryOrderLinks;</span><br><span class="line">	<span class="comment">/*0x020*/</span>     <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> InInitializationOrderLinks;</span><br><span class="line">	<span class="comment">/*0x030*/</span>     VOID* DllBase;</span><br><span class="line">	<span class="comment">/*0x038*/</span>     VOID* EntryPoint;</span><br><span class="line">	<span class="comment">/*0x040*/</span>     ULONG32      SizeOfImage;</span><br><span class="line">	<span class="comment">/*0x044*/</span>     UINT8        _PADDING0_[<span class="number">0x4</span>];</span><br><span class="line">	<span class="comment">/*0x048*/</span>     <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING</span> FullDllName;</span><br><span class="line">	<span class="comment">/*0x058*/</span>     <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING</span> BaseDllName;</span><br><span class="line">	<span class="comment">/*0x068*/</span>     ULONG32      Flags;</span><br><span class="line">	<span class="comment">/*0x06C*/</span>     UINT16       LoadCount;</span><br><span class="line">	<span class="comment">/*0x06E*/</span>     UINT16       TlsIndex;</span><br><span class="line">	<span class="keyword">union</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*0x070*/</span>         <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> HashLinks;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">a</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*0x070*/</span>             VOID* SectionPointer;</span><br><span class="line">			<span class="comment">/*0x078*/</span>             ULONG32      CheckSum;</span><br><span class="line">			<span class="comment">/*0x07C*/</span>             UINT8        _PADDING1_[<span class="number">0x4</span>];</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">union</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*0x080*/</span>         ULONG32      TimeDateStamp;</span><br><span class="line">		<span class="comment">/*0x080*/</span>         VOID* LoadedImports;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">/*0x088*/</span>     <span class="keyword">struct</span> <span class="title class_">_ACTIVATION_CONTEXT</span>* EntryPointActivationContext;</span><br><span class="line">	<span class="comment">/*0x090*/</span>     VOID* PatchInformation;</span><br><span class="line">	<span class="comment">/*0x098*/</span>     <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> ForwarderLinks;</span><br><span class="line">	<span class="comment">/*0x0A8*/</span>     <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> ServiceTagLinks;</span><br><span class="line">	<span class="comment">/*0x0B8*/</span>     <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> StaticLinks;</span><br><span class="line">	<span class="comment">/*0x0C8*/</span>     VOID* ContextInformation;</span><br><span class="line">	<span class="comment">/*0x0D0*/</span>     UINT64       OriginalBase;</span><br><span class="line">	<span class="comment">/*0x0D8*/</span>     <span class="keyword">union</span> <span class="title class_">_LARGE_INTEGER</span> LoadTime;</span><br><span class="line">&#125;LDR_DATA, * PLDR_DATA;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里字节对齐要采用默认，不要按1对齐，这样才符合32位和64位结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LDR_DATA_TABLE_ENTRY</span></span><br><span class="line">&#123;</span><br><span class="line">	LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">	LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">	LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">	PVOID DllBase;</span><br><span class="line">	PVOID EntryPoint;</span><br><span class="line">	ULONG SizeOfImage;</span><br><span class="line">	UNICODE_STRING FullDllName;</span><br><span class="line">	UNICODE_STRING BaseDllName;</span><br><span class="line">	ULONG Flags;</span><br><span class="line">	USHORT LoadCount;</span><br><span class="line">	USHORT TlsIndex;</span><br><span class="line">	<span class="keyword">union</span> <span class="title class_">b</span></span><br><span class="line">	&#123;</span><br><span class="line">		LIST_ENTRY HashLinks;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">e</span></span><br><span class="line">		&#123;</span><br><span class="line">			PVOID SectionPointer;</span><br><span class="line">			ULONG CheckSum;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">union</span> <span class="title class_">e</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">c</span></span><br><span class="line">		&#123;</span><br><span class="line">			ULONG TimeDateStamp;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">d</span></span><br><span class="line">		&#123;</span><br><span class="line">			PVOID LoadedImports;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">_ACTIVATION_CONTEXT</span>* EntryPointActivationContext;</span><br><span class="line">	PVOID PatchInformation;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">InitPdb</span></span><br><span class="line">&#123;</span><br><span class="line">	ULONG_PTR uRvaNtWrite;</span><br><span class="line">	ULONG_PTR uRvaNtAlloc;</span><br><span class="line">	ULONG_PTR uRvaNtCreateThread;</span><br><span class="line">	ULONG_PTR uRvaNtRead;</span><br><span class="line">	ULONG_PTR uRvaNtProtect;</span><br><span class="line">	ULONG_PTR uThreadPreviouMode;</span><br><span class="line">	ULONG_PTR uVadRoot;</span><br><span class="line">	ULONG_PTR uPspNotifyEnableMaskRva;</span><br><span class="line">	ULONG_PTR uApcState;</span><br><span class="line">	ULONG_PTR uUserApcPendingAll;</span><br><span class="line">	ULONG_PTR uRvaMmpfndatabase;</span><br><span class="line">	ULONG_PTR uOriginPte;</span><br><span class="line">	ULONG_PTR fLdrInitializeThunk = <span class="number">0</span>;</span><br><span class="line">	ULONG_PTR fZwContinue = <span class="number">0</span>;</span><br><span class="line">	ULONG_PTR fRtlRaiseStatus = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//Shellcode 加载DLl</span></span><br><span class="line">	ULONG_PTR pLoadLibraryA=<span class="number">0</span>;</span><br><span class="line">	ULONG_PTR pGetProcAddress=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//x64专属</span></span><br><span class="line">	ULONG_PTR pRtlAddFunctionTable=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//因为是在对方Hook里面 所以把LdrInitializeThunk的第一个Call地址传一下</span></span><br><span class="line">	ULONG_PTR uLdrFirstCall = <span class="number">0</span>;</span><br><span class="line">	ULONG_PTR pKeServiceDescriptorTable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内核函数函数指针定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(__fastcall* pNtReadVirtualMemory)</span><span class="params">(IN HANDLE ProcessHandle, IN PVOID BaseAddress, OUT PVOID Buffer, IN ULONG BufferLength, OUT PULONG ReturnLength OPTIONAL)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(__fastcall* pNtWriteVirtualMemory)</span><span class="params">(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, <span class="type">size_t</span> BufferLength, PULONG ReturnLength OPTIONAL)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">INT64</span><span class="params">(__fastcall* pNtAllocateVirtualMemory)</span><span class="params">(INT64 hProcess, PVOID* plpAddress, INT64 Zero, INT64* pSize, INT64 flAllocationType, INT64 flProtect)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(__fastcall* pNtCreateThreadEx)</span><span class="params">(HANDLE phNewThreadHandle, DWORD32 Access, LPSECURITY_ATTRIBUTES ThreadAttribute, HANDLE hProcess, UINT64 lpStartAddress, UINT64 lpParameter, DWORD32 CreateFlags, UINT64 ZeroBit, UINT64 StackSize, UINT64 ZeroBit2, _NT_PROC_THREAD_ATTRIBUTE_LIST* pAttributeList)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(__fastcall* pNtProtectVirtualMemory)</span><span class="params">(HANDLE hProcess, PVOID* plpAddress, SIZE_T* pSize_t, DWORD32 dwNewProtect, PDWORD32 OldProtect)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Global</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//是否已经初始化</span></span><br><span class="line">	<span class="type">bool</span> bInitPdb=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pNtWriteVirtualMemory pNtWrite=<span class="number">0</span>;</span><br><span class="line">	pNtAllocateVirtualMemory pNtAlloc=<span class="number">0</span>;</span><br><span class="line">	pNtCreateThreadEx pNtCreateThread=<span class="number">0</span>;</span><br><span class="line">	pNtReadVirtualMemory pNtRead=<span class="number">0</span>;</span><br><span class="line">	pNtProtectVirtualMemory pNtProtect=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ULONG_PTR fLdrInitializeThunk=<span class="number">0</span>;</span><br><span class="line">	ULONG_PTR fZwContinue=<span class="number">0</span>;</span><br><span class="line">	ULONG_PTR fRtlRaiseStatus=<span class="number">0</span>;</span><br><span class="line">	ULONG_PTR uThreadPreviouMode=<span class="number">0</span>;</span><br><span class="line">	ULONG_PTR uApcState = <span class="number">0</span>;</span><br><span class="line">	ULONG_PTR uApcUserPendingAll = <span class="number">0</span>;</span><br><span class="line">	ULONG_PTR uVadRoot=<span class="number">0</span>;</span><br><span class="line">	PLDR_DATA_TABLE_ENTRY uDriverSection = <span class="number">0</span>;<span class="comment">//遍历Ldr_table_list_entry 找到ntosknrl基质</span></span><br><span class="line">	ULONG_PTR uNtosnrlBase = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//Shellcode 加载DLl</span></span><br><span class="line">	ULONG_PTR pLoadLibraryA=<span class="number">0</span>;</span><br><span class="line">	ULONG_PTR pGetProcAddress=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//x64专属</span></span><br><span class="line">	ULONG_PTR pRtlAddFunctionTable=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	ULONG_PTR uPspNotifyEnableMask = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//物理页帧数据库</span></span><br><span class="line">	ULONG_PTR uMmpfnDatabase = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//原型PTE的偏移</span></span><br><span class="line">	ULONG_PTR uOriginPte=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ULONG_PTR uLdrFirstCall = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ssdt</span></span><br><span class="line">	ULONG_PTR pKeServiceDescriptorTable = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//c++单例设计模式</span></span><br><span class="line">	<span class="function"><span class="type">static</span> Global* <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> Global* m_pInstance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Global.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Global* Global::m_pInstance;</span><br><span class="line"></span><br><span class="line"><span class="function">Global* <span class="title">Global::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m_pInstance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		m_pInstance = (Global*)<span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, <span class="built_in">sizeof</span>(Global), <span class="string">&#x27;Inst&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m_pInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReadWrite.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WriteByMdl</span><span class="params">(HANDLE ProcessId, PVOID BaseAddress, PVOID Buffer, <span class="type">size_t</span> BufferLength, PULONG ReturnLength OPTIONAL)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ReadWrite &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//头文件导出</span></span><br><span class="line">	</span><br><span class="line">	<span class="function">NTSTATUS <span class="title">MyWriteMem</span><span class="params">(HANDLE ProcessId, PVOID BaseAddress, PVOID Buffer, <span class="type">size_t</span> BufferLength, PULONG ReturnLength OPTIONAL)</span></span>;</span><br><span class="line">	<span class="function">NTSTATUS <span class="title">MyAllocMem</span><span class="params">(HANDLE ProcessId, PVOID* pLpAddress, INT64 ZeroBits, SIZE_T* pSize, DWORD32 flAllocationType, DWORD32 flProtect, ULONG_PTR* lpAllocAddr)</span></span>;</span><br><span class="line">	<span class="function">NTSTATUS <span class="title">MyProtectMem</span><span class="params">(HANDLE ProcessId, PVOID* plpAddress, SIZE_T* pSize_t, DWORD32 dwNewProtect, PDWORD32 OldProtect)</span></span>;</span><br><span class="line">	<span class="function">NTSTATUS <span class="title">MyReadMem</span><span class="params">(IN HANDLE ProcessId, IN PVOID BaseAddress, OUT PVOID Buffer, IN ULONG BufferLength, OUT PULONG ReturnLength OPTIONAL)</span></span>;</span><br><span class="line">	<span class="function">NTSTATUS <span class="title">MyCreateThread</span><span class="params">(HANDLE ProcessId, UINT64 lpStartAddress, UINT64 lParam, DWORD32 CreateFlags, UINT64 StackSize, OUT PHANDLE hThread)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ChangePreviousMode</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ResumePreviousMode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReadWrite.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ReadWrite.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ReadWrite;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WriteByMdl</span><span class="params">(HANDLE ProcessId, PVOID BaseAddress, PVOID Buffer, <span class="type">size_t</span> BufferLength, PULONG ReturnLength OPTIONAL)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnWPbit</span><span class="params">(KIRQL irpl)</span></span>;</span><br><span class="line"><span class="function">KIRQL <span class="title">OffWPbit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BanThreadNotify</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ResumeThreadNotify</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReadWrite::ChangePreviousMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	ULONG_PTR uOffset = Global::<span class="built_in">GetInstance</span>()-&gt;uThreadPreviouMode;</span><br><span class="line"></span><br><span class="line">	PETHREAD pCurThread = <span class="built_in">PsGetCurrentThread</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pCurThread) &#123;</span><br><span class="line">		<span class="comment">//err</span></span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]err:Failed to get current thread\n&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	*(PUCHAR)((ULONG_PTR)pCurThread + uOffset) = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReadWrite::ResumePreviousMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	ULONG_PTR uOffset = Global::<span class="built_in">GetInstance</span>()-&gt;uThreadPreviouMode;</span><br><span class="line"></span><br><span class="line">	PETHREAD pCurThread = <span class="built_in">PsGetCurrentThread</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pCurThread) &#123;</span><br><span class="line">		<span class="comment">//err</span></span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]err:Failed to get current thread\n&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*(PUCHAR)((ULONG_PTR)pCurThread + uOffset) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">ReadWrite::MyWriteMem</span><span class="params">(HANDLE ProcessId, PVOID BaseAddress, PVOID Buffer, <span class="type">size_t</span> BufferLength, PULONG ReturnLength OPTIONAL)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	HANDLE hProcess;</span><br><span class="line">	CLIENT_ID cid;</span><br><span class="line">	cid.UniqueProcess = ProcessId;</span><br><span class="line">	cid.UniqueThread = <span class="number">0</span>;</span><br><span class="line">	OBJECT_ATTRIBUTES objattr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">InitializeObjectAttributes</span>(&amp;objattr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//权限无所谓</span></span><br><span class="line">	NTSTATUS status = <span class="built_in">ZwOpenProcess</span>(&amp;hProcess, <span class="number">0</span>, &amp;objattr, &amp;cid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hProcess == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//err</span></span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]err:open process err!\n&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">ChangePreviousMode</span>();</span><br><span class="line"></span><br><span class="line">	status = Global::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">pNtWrite</span>(hProcess, BaseAddress, Buffer, BufferLength, ReturnLength);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">		<span class="comment">//err</span></span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]err:common Ntwrite failed,now try to use MdlWrite\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">		<span class="type">bool</span> bOk = <span class="built_in">WriteByMdl</span>(ProcessId, BaseAddress, Buffer, BufferLength, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!bOk) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]err:failed to write by mdl! processId:%d write at:0x%p\n&quot;</span>, ProcessId, BaseAddress));</span><br><span class="line"></span><br><span class="line">			<span class="built_in">ResumePreviousMode</span>();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]Info:mdl write success!\n&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ResumePreviousMode</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">ReadWrite::MyAllocMem</span><span class="params">(HANDLE ProcessId,PVOID* pLpAddress,INT64 ZeroBits,SIZE_T* pSize,DWORD32 flAllocationType,DWORD32 flProtect,ULONG_PTR* lpAllocAddr)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	HANDLE hProcess;</span><br><span class="line">	CLIENT_ID cid;</span><br><span class="line">	cid.UniqueProcess = ProcessId;</span><br><span class="line">	cid.UniqueThread = <span class="number">0</span>;</span><br><span class="line">	OBJECT_ATTRIBUTES objattr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	PEPROCESS Process = <span class="number">0</span>;</span><br><span class="line">	KAPC_STATE ApcState;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">InitializeObjectAttributes</span>(&amp;objattr,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;ApcState, <span class="number">0</span>, <span class="built_in">sizeof</span>(ApcState));</span><br><span class="line">	<span class="comment">//权限无所谓</span></span><br><span class="line">	NTSTATUS status=<span class="built_in">ZwOpenProcess</span>(&amp;hProcess, <span class="number">0</span>, &amp;objattr, &amp;cid);</span><br><span class="line"></span><br><span class="line">	status = <span class="built_in">PsLookupProcessByProcessId</span>(ProcessId, &amp;Process);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">		<span class="comment">//err</span></span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]err:open process err!\n&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">ChangePreviousMode</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//挂靠进程</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">KeStackAttachProcess</span>(Process, &amp;ApcState);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//先申请一块可读写的内存 不然没办法memset 一会再改回来</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">UNREFERENCED_PARAMETER</span>(flProtect);</span><br><span class="line"></span><br><span class="line">	status = <span class="built_in">ZwAllocateVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), pLpAddress, ZeroBits, pSize, flAllocationType, flProtect);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//err</span></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to alloc virtualmemory!,ErrCode=0x%x\n&quot;</span>, status);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">KeUnstackDetachProcess</span>(&amp;ApcState);</span><br><span class="line">		<span class="built_in">ResumePreviousMode</span>();</span><br><span class="line">		<span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//附加进程 刷新一下内存 memset 让他挂一下物理页 不然没办法直接读写</span></span><br><span class="line">	_try&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(*pLpAddress, <span class="number">0</span>, *pSize);</span><br><span class="line"></span><br><span class="line">	&#125;_except(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Flush mem err but maybe it doesn&#x27;t matter\r\n&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">ResumePreviousMode</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">KeUnstackDetachProcess</span>(&amp;ApcState);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ResumePreviousMode</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">MmIsAddressValid</span>((PVOID)lpAllocAddr)) &#123;</span><br><span class="line"></span><br><span class="line">		*lpAllocAddr = *(ULONG_PTR*)pLpAddress;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]info:alloc success,alloc addr:0x%p\n&quot;</span>, *pLpAddress);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">ReadWrite::MyCreateThread</span><span class="params">(HANDLE ProcessId,UINT64 lpStartAddress,UINT64 lParam,DWORD32 CreateFlags,UINT64 StackSize,OUT PHANDLE hThread)</span> </span>&#123;</span><br><span class="line">	CLIENT_ID cid = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	OBJECT_ATTRIBUTES objattr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">InitializeObjectAttributes</span>(&amp;objattr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">	HANDLE hProcess = <span class="number">0</span>;</span><br><span class="line">	cid.UniqueProcess = ProcessId;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	status = <span class="built_in">ZwOpenProcess</span>(&amp;hProcess, <span class="number">0</span>, &amp;objattr, &amp;cid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to get process handle errcode=0x%x\n&quot;</span>, status);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这些参数均是逆的3环到0环传参过程</span></span><br><span class="line">	<span class="comment">//HANDLE phNewThreadHandle, DWORD32 Access, UINT64 ThreadAttribute, HANDLE hProcess, UINT64 lpStartAddress, </span></span><br><span class="line">	<span class="comment">//UINT64 lpParameter, DWORD32 CreateFlags, UINT64 ZeroBit, UINT64 StackSize, UINT64 ZeroBit2, INT64 pAttributeList</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化AttributeList</span></span><br><span class="line">	ULONG_PTR pTeb;</span><br><span class="line">	ULONG_PTR pClientID[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	_NT_PROC_THREAD_ATTRIBUTE_LIST* AttributeList = (_NT_PROC_THREAD_ATTRIBUTE_LIST*)<span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool,<span class="number">0x48</span>,<span class="string">&#x27;Thre&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	AttributeList-&gt;Length = <span class="number">0x48</span>;</span><br><span class="line">	AttributeList-&gt;Entry[<span class="number">0</span>].Attribute = <span class="number">0x10003</span>;</span><br><span class="line">	AttributeList-&gt;Entry[<span class="number">0</span>].size = <span class="number">0x10</span>;</span><br><span class="line">	AttributeList-&gt;Entry[<span class="number">0</span>].Vaule = (UINT64)pClientID;</span><br><span class="line">	AttributeList-&gt;Entry[<span class="number">0</span>].Unknown = <span class="number">0</span>;</span><br><span class="line">	AttributeList-&gt;Entry[<span class="number">1</span>].Attribute = <span class="number">0x10004</span>;</span><br><span class="line">	AttributeList-&gt;Entry[<span class="number">1</span>].size = <span class="number">0x8</span>;</span><br><span class="line">	AttributeList-&gt;Entry[<span class="number">1</span>].Vaule = (UINT64)&amp;pTeb;</span><br><span class="line">	AttributeList-&gt;Entry[<span class="number">1</span>].Unknown = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">ChangePreviousMode</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">BanThreadNotify</span>();</span><br><span class="line">	</span><br><span class="line">	status = Global::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">pNtCreateThread</span>(hThread, <span class="number">0</span>, <span class="number">0</span>, hProcess, lpStartAddress, lParam, CreateFlags, <span class="number">0</span>, StackSize, <span class="number">0</span>, AttributeList);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//err</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;Failed to create thread!errcode=0x%x\n&quot;</span>, status);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">ResumeThreadNotify</span>();</span><br><span class="line"></span><br><span class="line">		<span class="built_in">ResumePreviousMode</span>();</span><br><span class="line"></span><br><span class="line">		<span class="built_in">ExFreePool</span>(AttributeList);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">ExFreePool</span>(AttributeList);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ResumeThreadNotify</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ResumePreviousMode</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">ReadWrite::MyReadMem</span><span class="params">(IN HANDLE ProcessId, IN PVOID BaseAddress, OUT PVOID Buffer, IN ULONG BufferLength, OUT PULONG ReturnLength OPTIONAL)</span></span>&#123;</span><br><span class="line">	HANDLE hProcess = <span class="number">0</span>;</span><br><span class="line">	CLIENT_ID cid = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	OBJECT_ATTRIBUTES objattr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	NTSTATUS status;</span><br><span class="line">	<span class="built_in">InitializeObjectAttributes</span>(&amp;objattr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	cid.UniqueProcess = ProcessId;</span><br><span class="line"></span><br><span class="line">	status = <span class="built_in">ZwOpenProcess</span>(&amp;hProcess, <span class="number">0</span>, &amp;objattr, &amp;cid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to get process handle errcode=0x%x\n&quot;</span>, status);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">ChangePreviousMode</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	status=Global::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">pNtRead</span>(hProcess, BaseAddress, Buffer, BufferLength, ReturnLength);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//err</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to read process mem! err code=0x%x\n&quot;</span>, status);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">ResumePreviousMode</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">ResumePreviousMode</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">ReadWrite::MyProtectMem</span><span class="params">(HANDLE ProcessId, PVOID* plpAddress, SIZE_T* pSize_t, DWORD32 dwNewProtect, PDWORD32 OldProtect)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	CLIENT_ID cid;</span><br><span class="line">	cid.UniqueProcess = ProcessId;</span><br><span class="line">	cid.UniqueThread = <span class="number">0</span>;</span><br><span class="line">	OBJECT_ATTRIBUTES objattr;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;objattr,<span class="number">0</span>,<span class="built_in">sizeof</span>(OBJECT_ATTRIBUTES));</span><br><span class="line">	<span class="built_in">InitializeObjectAttributes</span>(&amp;objattr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	HANDLE hProcess=<span class="number">0</span>;</span><br><span class="line">	NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">	status=<span class="built_in">ZwOpenProcess</span>(&amp;hProcess, <span class="number">0</span>, &amp;objattr, &amp;cid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">		<span class="comment">//err</span></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to get process handle errcode=0x%x\n&quot;</span>,status);</span><br><span class="line">		<span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">ChangePreviousMode</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	status=Global::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">pNtProtect</span>(hProcess,plpAddress,pSize_t,dwNewProtect,OldProtect);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//err</span></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to change mem attributes! errcode=0x%x\n&quot;</span>,status);</span><br><span class="line">		<span class="built_in">ResumePreviousMode</span>();</span><br><span class="line">		<span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">ResumePreviousMode</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BanThreadNotify</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	PLONG PspNotifyEnableMask = (PLONG)Global::<span class="built_in">GetInstance</span>()-&gt;uPspNotifyEnableMask;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>(PspNotifyEnableMask)) &#123;</span><br><span class="line">		<span class="comment">//ERR</span></span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]err:Failed to disable thread callbacks\n&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//禁止线程回调</span></span><br><span class="line">	_InterlockedAnd(PspNotifyEnableMask, <span class="number">0xFFFFFFF7</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ResumeThreadNotify</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	PLONG PspNotifyEnableMask = (PLONG)Global::<span class="built_in">GetInstance</span>()-&gt;uPspNotifyEnableMask;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>(PspNotifyEnableMask)) &#123;</span><br><span class="line">		<span class="comment">//ERR</span></span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]err:Failed to enable thread callbacks\n&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//禁止线程回调</span></span><br><span class="line">	_InterlockedOr(PspNotifyEnableMask, <span class="number">8u</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnWPbit</span><span class="params">(KIRQL irpl)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//开启CR0</span></span><br><span class="line">	UINT64 Cr0 = __readcr0();</span><br><span class="line">	Cr0 |= <span class="number">0x10000</span>;</span><br><span class="line">	_enable();</span><br><span class="line">	__writecr0(Cr0);</span><br><span class="line">	<span class="built_in">KeLowerIrql</span>(irpl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">KIRQL <span class="title">OffWPbit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭CR0</span></span><br><span class="line">	<span class="keyword">auto</span> irql = <span class="built_in">KeRaiseIrqlToDpcLevel</span>();<span class="comment">//关闭线程切换</span></span><br><span class="line">	UINT64 Cr0 = __readcr0();</span><br><span class="line">	Cr0 &amp;= <span class="number">0xfffffffffffeffff</span>;</span><br><span class="line">	__writecr0(Cr0);</span><br><span class="line">	_disable();</span><br><span class="line">	<span class="keyword">return</span> irql;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WriteByMdl</span><span class="params">(HANDLE ProcessId, PVOID BaseAddress, PVOID Buffer, <span class="type">size_t</span> BufferLength, PULONG ReturnLength OPTIONAL)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UNREFERENCED_PARAMETER</span>(ReturnLength);</span><br><span class="line"></span><br><span class="line">	PMDL mdl = <span class="literal">nullptr</span>;</span><br><span class="line">	PVOID pMappedAddress = <span class="literal">nullptr</span>;</span><br><span class="line">	KAPC_STATE apc_state;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;apc_state, <span class="number">0</span>, <span class="built_in">sizeof</span>(KAPC_STATE));</span><br><span class="line">	PEPROCESS pEprocess = <span class="literal">nullptr</span>;</span><br><span class="line">	</span><br><span class="line">	NTSTATUS status=<span class="built_in">PsLookupProcessByProcessId</span>(ProcessId, &amp;pEprocess);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">		<span class="comment">//ERR</span></span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]err:failed to get process\n&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">KeStackAttachProcess</span>(pEprocess, &amp;apc_state);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>(BaseAddress)) &#123;</span><br><span class="line">		<span class="comment">//err</span></span><br><span class="line">		<span class="built_in">KeUnstackDetachProcess</span>(&amp;apc_state);</span><br><span class="line">		<span class="built_in">ObDereferenceObject</span>(pEprocess);</span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]err:address invalid!\n&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mdl = <span class="built_in">MmCreateMdl</span>(<span class="number">0</span>, BaseAddress, BufferLength);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == mdl) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">KeUnstackDetachProcess</span>(&amp;apc_state);</span><br><span class="line">		<span class="built_in">ObDereferenceObject</span>(pEprocess);</span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]err:failed to create mdl!\n&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//锁定页面</span></span><br><span class="line">	<span class="built_in">MmBuildMdlForNonPagedPool</span>(mdl);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pMappedAddress = <span class="built_in">MmMapLockedPagesSpecifyCache</span>(mdl, KernelMode, MmCached, <span class="number">0</span>, <span class="number">0</span>, NormalPagePriority);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//强写</span></span><br><span class="line">	KIRQL oldIrql = <span class="built_in">OffWPbit</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>(pMappedAddress)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">OnWPbit</span>(oldIrql);</span><br><span class="line">		<span class="built_in">KeUnstackDetachProcess</span>(&amp;apc_state);</span><br><span class="line">		<span class="built_in">ObDereferenceObject</span>(pEprocess);</span><br><span class="line">		<span class="built_in">IoFreeMdl</span>(mdl);</span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]err:Mapped addr within mdl err!\n&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__try&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">RtlCopyMemory</span>(pMappedAddress, Buffer, BufferLength);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	__except (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">OnWPbit</span>(oldIrql);</span><br><span class="line">		<span class="built_in">KeUnstackDetachProcess</span>(&amp;apc_state);</span><br><span class="line">		<span class="built_in">ObDereferenceObject</span>(pEprocess);</span><br><span class="line">		<span class="built_in">MmUnmapLockedPages</span>(pMappedAddress, mdl);</span><br><span class="line">		<span class="built_in">IoFreeMdl</span>(mdl);</span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]err:Cpoy err!\n&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">OnWPbit</span>(oldIrql);</span><br><span class="line">	<span class="built_in">MmUnmapLockedPages</span>(pMappedAddress, mdl);</span><br><span class="line">	<span class="built_in">IoFreeMdl</span>(mdl);</span><br><span class="line">	<span class="built_in">KeUnstackDetachProcess</span>(&amp;apc_state);</span><br><span class="line">	<span class="built_in">ObDereferenceObject</span>(pEprocess);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PTEHook.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PageAttrHide.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PTEHOOK&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_HookSavedInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">		ULONG sysindex=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		ULONG_PTR OriginAddress=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;HookSavedInfo,*pHookSavedInfo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//SSDT结构</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SYSTEM_SERVICE_TABLE</span> &#123;</span><br><span class="line">		PLONG  		ServiceTableBase;</span><br><span class="line">		PVOID  		ServiceCounterTableBase;</span><br><span class="line">		ULONGLONG  	NumberOfServices;</span><br><span class="line">		PVOID  		ParamTableBase;</span><br><span class="line">	&#125; SYSTEM_SERVICE_TABLE, * PSYSTEM_SERVICE_TABLE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PteHook</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//cpp单例设计模式</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">fn_ptehook_hooksyscall</span><span class="params">(ULONG sysindex, ULONG_PTR TargetFunc,<span class="type">bool</span> bRetOrigin=<span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fn_ptehook_resumehooksyscall</span><span class="params">(ULONG sysindex)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//bool fn_ptehook_hookanyaddr(ULONG_PTR HookOrigin,ULONG_PTR HookTarget,bool IsRetOrigin)</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> PteHook* <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  MAX_HOOK_COUNT 100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PAGES_COUNT_NONPAGEDMM 0x1000</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">fn_init_isolaiton_ptes</span><span class="params">(HANDLE ProcessId,ULONG_PTR uIsolationAddr,<span class="type">int</span> PageCount)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取SST表到成员变量</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">fn_get_ssdt</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入到HookInfo方便恢复</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">fn_insert_hook</span><span class="params">(ULONG sysindex)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">ULONG_PTR <span class="title">fn_get_syscall_by_index</span><span class="params">(ULONG sysindex)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//SST表</span></span><br><span class="line"></span><br><span class="line">	PSYSTEM_SERVICE_TABLE sst=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Hook的SsdtHook保存</span></span><br><span class="line">	HookSavedInfo  ArrHookSavedInfo[MAX_HOOK_COUNT];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//逻辑是申请一块1000页的非分页内存 然后用个成员变量记录当前使用了多少页了</span></span><br><span class="line"></span><br><span class="line">	UINT32 uUsedCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	PVOID pNonPagedMm = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> PteHook* m_PteHook;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PTEHook.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PTEHook.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> PTEHOOK;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PteHook* PteHook::m_PteHook;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> PTEHOOK::PteHook::<span class="built_in">fn_ptehook_hooksyscall</span>(ULONG sysindex, ULONG_PTR TargetFunc, <span class="type">bool</span> bRetOrigin)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	ULONG_PTR uSstBase = <span class="number">0</span>;</span><br><span class="line">	UINT32 uOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//新修改进去的Offset</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">KdPrint</span>((<span class="string">&quot;替换的uOffset==0x%p\r\n&quot;</span>, uOffset));</span><br><span class="line">	<span class="comment">//获取sst表 只获取非gui的ssdt</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!sst)  <span class="keyword">if</span> (!<span class="built_in">fn_get_ssdt</span>()) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//检查index</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sysindex &gt; sst-&gt;NumberOfServices) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OyxgenDriver_SSDTHook]err:error sysindex\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将其添加到Saved里面</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">fn_insert_hook</span>(sysindex)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	uSstBase = (ULONG_PTR)sst-&gt;ServiceTableBase;</span><br><span class="line"></span><br><span class="line">	uOffset = (TargetFunc - uSstBase) * <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">KdPrint</span>((<span class="string">&quot;即将替换的Offset==0x%p\r\n&quot;</span>, uOffset));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//替换</span></span><br><span class="line"></span><br><span class="line">	sst-&gt;ServiceTableBase[sysindex * <span class="number">4</span>] = uOffset;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PteHook* PTEHOOK::PteHook::<span class="built_in">GetInstance</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!m_PteHook) &#123;</span><br><span class="line"></span><br><span class="line">		m_PteHook = (PteHook*)<span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, <span class="built_in">sizeof</span>(PteHook), <span class="string">&#x27;PTEH&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> m_PteHook;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//init ptes isolation</span></span><br><span class="line"><span class="type">bool</span> PTEHOOK::PteHook::<span class="built_in">fn_init_isolaiton_ptes</span>(HANDLE ProcessId,ULONG_PTR uIsolationAddr, <span class="type">int</span> PageCount)</span><br><span class="line">&#123;</span><br><span class="line">	PageAttrHide::PteTable table = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Vertify addr valid</span></span><br><span class="line"></span><br><span class="line">	uIsolationAddr &amp;= <span class="number">0xfffffffffffff000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PageCount; i++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>((PVOID)(uIsolationAddr + PageCount * <span class="number">0x1000</span>))) &#123;</span><br><span class="line">			<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:summit address is invalid\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Alloc a NonPaged mem and get it&#x27;s physical addr , full it original ptes</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PageCount; i++) &#123;</span><br><span class="line"></span><br><span class="line">		table.pLineAddr = uIsolationAddr + i * <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">		PageAttrHide::<span class="built_in">GetLineAddrPteTable</span>(&amp;table);</span><br><span class="line"></span><br><span class="line">		PULONG_PTR Ptes = (PULONG_PTR)table.Pte;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>(Ptes)) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to change ptes\r\n&quot;</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//alloc a nonpaged mm size of 0x1000 * 4kb ==0x4000kb 16mb</span></span><br><span class="line">		<span class="keyword">if</span>(!pNonPagedMm) pNonPagedMm = <span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, MAX_PAGES_COUNT_NONPAGEDMM, <span class="string">&#x27;NONP&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> PTEHOOK::PteHook::<span class="built_in">fn_get_ssdt</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;sst = (PSYSTEM_SERVICE_TABLE)Global::<span class="built_in">GetInstance</span>()-&gt;pKeServiceDescriptorTable;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> PTEHOOK::PteHook::<span class="built_in">fn_insert_hook</span>(ULONG sysindex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_HOOK_COUNT; i++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ArrHookSavedInfo[i].sysindex == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">//没被占用</span></span><br><span class="line">			<span class="keyword">this</span>-&gt;ArrHookSavedInfo[i].sysindex = sysindex;</span><br><span class="line">			<span class="keyword">this</span>-&gt;ArrHookSavedInfo[i].OriginAddress = <span class="built_in">fn_get_syscall_by_index</span>(sysindex);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver_SSDTHook]err:there is no space for new hook\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ULONG_PTR PTEHOOK::PteHook::<span class="built_in">fn_get_syscall_by_index</span>(ULONG sysindex)</span><br><span class="line">&#123;</span><br><span class="line">	UINT32 uOffset = (<span class="keyword">this</span>-&gt;sst-&gt;ServiceTableBase[sysindex * <span class="number">4</span>] / <span class="number">0x10</span>);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">KdPrint</span>((<span class="string">&quot;uOffset=0x%x\r\n&quot;</span>,uOffset));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ((ULONG_PTR)uOffset+(ULONG_PTR)<span class="keyword">this</span>-&gt;sst-&gt;ServiceTableBase);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PageAttrHide.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_ZERO_ACCESS         0  <span class="comment">// this value is not used.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_READONLY            1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_EXECUTE             2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_EXECUTE_READ        3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_READWRITE           4  <span class="comment">// bit 2 is set if this is writable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_WRITECOPY           5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_EXECUTE_READWRITE   6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_EXECUTE_WRITECOPY   7</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_NOCACHE            0x8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_GUARD_PAGE         0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_DECOMMIT           0x10   <span class="comment">// NO_ACCESS, Guard page</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_NOACCESS           0x18   <span class="comment">// NO_ACCESS, Guard_page, nocache.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_UNKNOWN_PROTECTION 0x100  <span class="comment">// bigger than 5 bits!</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PageAttrHide&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> ULONG_PTR uMmpfnSize = <span class="number">0x30</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">PteTable</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//传入的线性地址</span></span><br><span class="line">		ULONG_PTR pLineAddr;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取的</span></span><br><span class="line">		ULONG_PTR Pte;</span><br><span class="line">		ULONG_PTR Pde;</span><br><span class="line">		ULONG_PTR PdPte;</span><br><span class="line">		ULONG_PTR Pml4e;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//软件解析PTE</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_MMPTE_SOFTWARE</span>              <span class="comment">// 13 elements, 0x8 bytes (sizeof) </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Valid : <span class="number">1</span>;                 <span class="comment">// 0 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       PageFileReserved : <span class="number">1</span>;      <span class="comment">// 1 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       PageFileAllocated : <span class="number">1</span>;     <span class="comment">// 2 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       ColdPage : <span class="number">1</span>;              <span class="comment">// 3 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       SwizzleBit : <span class="number">1</span>;            <span class="comment">// 4 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Protection : <span class="number">5</span>;            <span class="comment">// 5 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Prototype : <span class="number">1</span>;             <span class="comment">// 10 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Transition : <span class="number">1</span>;            <span class="comment">// 11 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       PageFileLow : <span class="number">4</span>;           <span class="comment">// 12 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       UsedPageTableEntries : <span class="number">10</span>; <span class="comment">// 16 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       ShadowStack : <span class="number">1</span>;           <span class="comment">// 26 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Unused : <span class="number">5</span>;                <span class="comment">// 27 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       PageFileHigh : <span class="number">32</span>;         <span class="comment">// 32 BitPosition                  </span></span><br><span class="line">	&#125;MMPTE_SOFTWARE, * PMMPTE_SOFTWARE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//硬件解析PTE</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_MMPTE_HARDWARE</span>            <span class="comment">// 18 elements, 0x8 bytes (sizeof) </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Valid : <span class="number">1</span>;               <span class="comment">// 0 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Dirty1 : <span class="number">1</span>;              <span class="comment">// 1 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Owner : <span class="number">1</span>;               <span class="comment">// 2 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       WriteThrough : <span class="number">1</span>;        <span class="comment">// 3 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       CacheDisable : <span class="number">1</span>;        <span class="comment">// 4 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Accessed : <span class="number">1</span>;            <span class="comment">// 5 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Dirty : <span class="number">1</span>;               <span class="comment">// 6 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       LargePage : <span class="number">1</span>;           <span class="comment">// 7 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Global : <span class="number">1</span>;              <span class="comment">// 8 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       CopyOnWrite : <span class="number">1</span>;         <span class="comment">// 9 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Unused : <span class="number">1</span>;              <span class="comment">// 10 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Write : <span class="number">1</span>;               <span class="comment">// 11 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       PageFrameNumber : <span class="number">36</span>;    <span class="comment">// 12 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       ReservedForHardware : <span class="number">4</span>; <span class="comment">// 48 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       ReservedForSoftware : <span class="number">4</span>; <span class="comment">// 52 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       WsleAge : <span class="number">4</span>;             <span class="comment">// 56 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       WsleProtection : <span class="number">3</span>;      <span class="comment">// 60 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       NoExecute : <span class="number">1</span>;           <span class="comment">// 63 BitPosition                  </span></span><br><span class="line">	&#125;MMPTE_HARDWARE, * PMMPTE_HARDWARE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">ULONG_PTR <span class="title">GetPteBase</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">GetLineAddrPteTable</span><span class="params">(_Inout_ PteTable* Table)</span></span>;</span><br><span class="line">	<span class="comment">//改变0x1000范围内线性地址的VAD属性</span></span><br><span class="line">	<span class="comment">//修改原型PTE, 不影响真正的PTE,但是无法通过API读写执行检查</span></span><br><span class="line">	<span class="function"><span class="type">void</span>  <span class="title">ChangeVadAttributes</span><span class="params">(ULONG_PTR uAddr, UINT32 Attributes, HANDLE ProcessId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PageAttrHide.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PageAttrHide.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> PageAttrHide;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过页表自定位来确定PTEBASE</span></span><br><span class="line"><span class="comment">//遍历PML4E,找到其指向CR3的下标 左移39位 | 0xFFFF 0000 0000 0000就是PTEBASE</span></span><br><span class="line"><span class="comment">//为什么这样?</span></span><br><span class="line"><span class="comment">//解释起来很复杂 要首先按照映射的思想</span></span><br><span class="line"><span class="comment">//最后到PML4E </span></span><br><span class="line"><span class="function">ULONG_PTR <span class="title">PageAttrHide::GetPteBase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UINT64 cr3=__readcr3();</span><br><span class="line"></span><br><span class="line">	PHYSICAL_ADDRESS _cr3;</span><br><span class="line"></span><br><span class="line">	_cr<span class="number">3.</span>QuadPart = cr3;</span><br><span class="line"></span><br><span class="line">	UINT64* pml4e_va=(UINT64*)<span class="built_in">MmGetVirtualForPhysical</span>(_cr3);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//DbgBreakPoint();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//其实Cr3本质上是PML4E的指针,但是因为Windows为了方便,就在这PML4E数组里面有cr3</span></span><br><span class="line">	<span class="comment">//所以找到PML4E指向cr3的index</span></span><br><span class="line">	UINT64 index = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//512</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">		UINT64 Pte = *(pml4e_va+i);</span><br><span class="line"></span><br><span class="line">		Pte &amp;= <span class="number">0xFFFFFFFFF000</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Pte == cr3) &#123;</span><br><span class="line">			<span class="comment">//找到PML4E Index 直接左移39位就是PTEBASE</span></span><br><span class="line"></span><br><span class="line">			index = i;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;Num==0x%d&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//DbgPrintEx(77, 0, &quot;PML4E Phyaddr:0x%x cr3=0x%x\r\n&quot;, Pte,cr3);</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:fatal err, cr3 err\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	UINT64 PteBase =  (index + <span class="number">0x1FFFE00</span>) &lt;&lt; <span class="number">39</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//DbgPrintEx(77, 0, &quot;[OxygenDriver]info: PteBase=0x%p\r\n&quot;, PteBase);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> PteBase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PageAttrHide::GetLineAddrPteTable</span><span class="params">(_Inout_ PteTable* Table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//首先获取PteBase</span></span><br><span class="line">	ULONG_PTR PteBase=<span class="built_in">GetPteBase</span>();</span><br><span class="line"></span><br><span class="line">	UINT64 LineAddr = Table-&gt;pLineAddr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//&gt;&gt;12第几个Pte  &lt;&lt;3代表8个字节</span></span><br><span class="line"></span><br><span class="line">	PteBase &amp;= <span class="number">0x0000FFFFFFFFFFFF</span>; <span class="comment">//先清除前16位</span></span><br><span class="line"></span><br><span class="line">	Table-&gt;Pte = ((LineAddr &gt;&gt; <span class="number">12</span>)&lt;&lt;<span class="number">3</span>) + PteBase;</span><br><span class="line"></span><br><span class="line">	Table-&gt;Pde = ((Table-&gt;Pte &gt;&gt; <span class="number">12</span>) &lt;&lt; <span class="number">3</span>) + PteBase;</span><br><span class="line"></span><br><span class="line">	Table-&gt;PdPte = ((Table-&gt;Pde &gt;&gt; <span class="number">12</span>) &lt;&lt; <span class="number">3</span>) + PteBase;</span><br><span class="line"></span><br><span class="line">	Table-&gt;Pml4e = ((Table-&gt;PdPte &gt;&gt; <span class="number">12</span>) &lt;&lt; <span class="number">3</span>) + PteBase;</span><br><span class="line"></span><br><span class="line">	Table-&gt;Pte |= <span class="number">0xFFFF000000000000</span>;</span><br><span class="line"></span><br><span class="line">	Table-&gt;Pde |= <span class="number">0xFFFF000000000000</span>;</span><br><span class="line"></span><br><span class="line">	Table-&gt;PdPte |= <span class="number">0xFFFF000000000000</span>;</span><br><span class="line"></span><br><span class="line">	Table-&gt;Pml4e |= <span class="number">0xFFFF000000000000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//DbgPrintEx(77, 0, &quot;vPte=0x%p,vPde=0x%p,vPdpte=0x%p,vPml4e=0x%p\r\n&quot;, Table-&gt;Pte, Table-&gt;Pde, Table-&gt;PdPte, Table-&gt;Pml4e);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4189)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PageAttrHide::ChangeVadAttributes</span><span class="params">(ULONG_PTR uAddr,UINT32 Attributes,HANDLE ProcessId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	UINT64 phPteIndex;</span><br><span class="line">	PteTable Table;</span><br><span class="line">	Table.pLineAddr = uAddr;</span><br><span class="line">	ULONG_PTR uOrginPte = Global::<span class="built_in">GetInstance</span>()-&gt;uOriginPte;</span><br><span class="line">	PEPROCESS Process = <span class="number">0</span>;</span><br><span class="line">	KAPC_STATE Apc = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//修改进程要进行挂靠</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(<span class="built_in">PsLookupProcessByProcessId</span>(ProcessId, &amp;Process))) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to get process to change page attributes\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">KeStackAttachProcess</span>(Process, &amp;Apc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//有可能找不到</span></span><br><span class="line">	<span class="keyword">if</span>(!uOrginPte)</span><br><span class="line">	uOrginPte = <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这个地方出错了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ULONG_PTR MmPfnDataBase = *(ULONG_PTR*)(Global::<span class="built_in">GetInstance</span>()-&gt;uMmpfnDatabase);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//x64 mmpfn 大小 0x30</span></span><br><span class="line">	<span class="comment">//OriginalPte 在0x28偏移处</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">GetLineAddrPteTable</span>(&amp;Table);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取物理地址</span></span><br><span class="line">	phPteIndex = *(UINT64*)(Table.Pte);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取物理地址索引</span></span><br><span class="line">	phPteIndex &amp;= <span class="number">0x0000fffffffff000</span>;</span><br><span class="line">	phPteIndex =phPteIndex&gt;&gt; <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//解析原型PTE</span></span><br><span class="line">	MMPTE_SOFTWARE* pOriginPte = (MMPTE_SOFTWARE*)(MmPfnDataBase + uMmpfnSize * phPteIndex + uOrginPte);</span><br><span class="line">	<span class="comment">//修改属性</span></span><br><span class="line">	pOriginPte-&gt;Protection = Attributes;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">KeUnstackDetachProcess</span>(&amp;Apc);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Injector.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntimage.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X64 0x8664</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86 0x14c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Injector_x64 &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确定是否需要重定位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RELOC_FLAG64(RelInfo) ((RelInfo &gt;&gt; 0x0C) == IMAGE_REL_BASED_DIR64)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RELOC_FLAG RELOC_FLAG64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> PVOID HINSTANCE, HMODULE;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_RUNTIME_FUNCTION_ENTRY</span> &#123;</span><br><span class="line">		DWORD32 BeginAddress;</span><br><span class="line">		DWORD32 EndAddress;</span><br><span class="line">		<span class="keyword">union</span> &#123;</span><br><span class="line">			DWORD32 UnwindInfoAddress;</span><br><span class="line">			DWORD32 UnwindData;</span><br><span class="line">		&#125; DUMMYUNIONNAME;</span><br><span class="line">	&#125; *PRUNTIME_FUNCTION;</span><br><span class="line">	<span class="keyword">using</span> f_LoadLibraryA = <span class="built_in">HINSTANCE</span>(__stdcall*)(<span class="type">const</span> <span class="type">char</span>* lpLibFilename);</span><br><span class="line">	<span class="keyword">using</span> f_GetProcAddress = <span class="built_in">PVOID</span>(__stdcall*)(HMODULE hModule, LPCSTR lpProcName);</span><br><span class="line">	<span class="keyword">using</span> f_DLL_ENTRY_POINT = <span class="built_in">BOOLEAN</span>(__stdcall*)(<span class="type">void</span>* hDll, DWORD32 dwReason, <span class="type">void</span>* pReserved);</span><br><span class="line">	<span class="keyword">using</span> f_RtlAddFunctionTable = <span class="built_in">BOOLEAN</span>(__stdcall*)(PRUNTIME_FUNCTION FunctionTable, DWORD32 EntryCount, DWORD64 BaseAddress);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Manual_Mapping_data</span><span class="comment">//内存映射dll对象</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//用于重定位IAT</span></span><br><span class="line">		f_LoadLibraryA pLoadLibraryA;</span><br><span class="line">		f_GetProcAddress pGetProcAddress;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//x64专有</span></span><br><span class="line">		f_RtlAddFunctionTable pRtlAddFunctionTable;</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span>* pBase;</span><br><span class="line">		HINSTANCE hMod;</span><br><span class="line">		DWORD32 dwReadson;</span><br><span class="line">		PVOID reservedParam;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">BOOLEAN <span class="title">MmInjector_x64_BypassProtect</span><span class="params">(HANDLE ProcessId, <span class="type">const</span> <span class="type">wchar_t</span>* wszDllPath,BOOLEAN bPassAce)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*BOOLEAN MemInject_PassTp_x64(HANDLE ProcessId,const wchar_t* wszDllPath);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	BOOLEAN MmInject_PassTp_x86(HANDLE ProcessId, const wchar_t* wszDllPath);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	BOOLEAN MmInject_PsssBe_x64(HANDLE ProcessId, const wchar_t* wszDllPath);*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Injector_x86 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Injector.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Injector.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ReadWrite.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PageAttrHide.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Injector_x64;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方便释放</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_DLL_TAGS 0x5556</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Dll映射的内存</span></span><br><span class="line">PVOID g_pMemDll;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去除ACE对于R3 的Hook</span></span><br><span class="line"><span class="function">ULONG_PTR  <span class="title">BanACELdrInitializeThunkHook</span><span class="params">(HANDLE ProcessId, <span class="type">char</span>* OriBytes)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于Dll重定位的ShellCode</span></span><br><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">ShellCode</span><span class="params">(Manual_Mapping_data* pData)</span></span>;</span><br><span class="line"><span class="function">BOOLEAN <span class="title">MmMapDll</span><span class="params">(HANDLE ProcessId, PVOID pFileData, UINT64 FileSize,BOOLEAN bPassAce)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">Injector_x64::MmInjector_x64_BypassProtect</span><span class="params">(HANDLE ProcessId,<span class="type">const</span> <span class="type">wchar_t</span>* wszDllPath,BOOLEAN bPassAce)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">UNREFERENCED_PARAMETER</span>(wszDllPath);</span><br><span class="line">	<span class="built_in">UNREFERENCED_PARAMETER</span>(ProcessId);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	HANDLE	hFile = <span class="number">0</span>;</span><br><span class="line">	OBJECT_ATTRIBUTES	objattr;</span><br><span class="line">	NTSTATUS	status=STATUS_SUCCESS;</span><br><span class="line">	<span class="comment">//因为穿的参数都是0环地址 所以要改一下PreviousMode</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4267)</span></span><br><span class="line"></span><br><span class="line">	UNICODE_STRING		usR0DllPath = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	usR0DllPath.Buffer = (PWCH)wszDllPath;</span><br><span class="line"></span><br><span class="line">	usR0DllPath.Length = <span class="built_in">wcslen</span>(wszDllPath)*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	usR0DllPath.MaximumLength = usR0DllPath.Length;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//DbgBreakPoint();</span></span><br><span class="line"></span><br><span class="line">	IO_STATUS_BLOCK		IoStatusBlock = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	LARGE_INTEGER		lainter = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	FILE_STANDARD_INFORMATION	fileinfo = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	UINT64 FileSize=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//初始化Attributes</span></span><br><span class="line">	<span class="built_in">InitializeObjectAttributes</span>(&amp;objattr,&amp;usR0DllPath,<span class="number">0x40</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	ReadWrite::<span class="built_in">ChangePreviousMode</span>();<span class="comment">//修改PreviosuMode</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	status = <span class="built_in">NtCreateFile</span>(&amp;hFile, GENERIC_WRITE | GENERIC_READ, &amp;objattr, &amp;IoStatusBlock, &amp;lainter, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//NtReadFile()</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//err</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to create file\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		ReadWrite::<span class="built_in">ResumePreviousMode</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	status=<span class="built_in">NtQueryInformationFile</span>(hFile, &amp;IoStatusBlock, &amp;fileinfo,<span class="built_in">sizeof</span>(fileinfo), FileStandardInformation);</span><br><span class="line"></span><br><span class="line">	FileSize = fileinfo.AllocationSize.QuadPart;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//err</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to query file\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		ReadWrite::<span class="built_in">ResumePreviousMode</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4244)</span></span><br><span class="line">	<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]file size:0x%x\r\n&quot;</span>, FileSize));</span><br><span class="line"></span><br><span class="line">	FileSize += <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">	FileSize &amp;= <span class="number">0xfffffffffffff000</span>;</span><br><span class="line"></span><br><span class="line">	g_pMemDll=<span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, FileSize, MEM_DLL_TAGS);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(g_pMemDll, <span class="number">0</span>, fileinfo.AllocationSize.QuadPart);</span><br><span class="line"></span><br><span class="line">	LARGE_INTEGER byteoffset = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	status = <span class="built_in">NtReadFile</span>(hFile, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;IoStatusBlock, g_pMemDll, FileSize,&amp;byteoffset, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//刷新一下 不然要等待</span></span><br><span class="line">	<span class="built_in">ZwFlushBuffersFile</span>(hFile, &amp;IoStatusBlock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//err</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to read file\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">ExFreePool</span>(g_pMemDll);</span><br><span class="line"></span><br><span class="line">		ReadWrite::<span class="built_in">ResumePreviousMode</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ReadWrite::<span class="built_in">ResumePreviousMode</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">MmMapDll</span>(ProcessId, g_pMemDll, FileSize,bPassAce)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to Mm map dll\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">ExFreePool</span>(g_pMemDll);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//NtClose(hFile);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BOOLEAN Injector::MemInject_PassTp_x64(HANDLE ProcessId, const wchar_t* wszDllPath) &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	return TRUE;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//BOOLEAN Injector::MmInject_PassTp_x86(HANDLE ProcessId, const wchar_t* wszDllPath)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	return TRUE;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//BOOLEAN Injector::MmInject_PsssBe_x64(HANDLE ProcessId, const wchar_t* wszDllPath)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	return TRUE;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//this func aim to Map a section to process,and relocate</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">MmMapDll</span><span class="params">(HANDLE ProcessId, PVOID pFileData, UINT64 FileSize,BOOLEAN bPassAce)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">UNREFERENCED_PARAMETER</span>(FileSize);</span><br><span class="line"></span><br><span class="line">	IMAGE_NT_HEADERS* pNtHeader = <span class="literal">nullptr</span>;</span><br><span class="line">	IMAGE_OPTIONAL_HEADER* pOptHeader = <span class="literal">nullptr</span>;</span><br><span class="line">	IMAGE_FILE_HEADER* pFileHeader = <span class="literal">nullptr</span>;</span><br><span class="line">	NTSTATUS status=STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开始Map的地址</span></span><br><span class="line">	<span class="type">char</span>* pStartMapAddr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">reinterpret_cast</span>&lt;IMAGE_DOS_HEADER*&gt;(pFileData)-&gt;e_magic != <span class="number">0x5A4D</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//MZ DOS Head</span></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Unvalid Pe file!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pNtHeader = (IMAGE_NT_HEADERS*)((ULONG_PTR)pFileData + <span class="built_in">reinterpret_cast</span>&lt;IMAGE_DOS_HEADER*&gt;(pFileData)-&gt;e_lfanew);</span><br><span class="line">	pFileHeader = &amp;pNtHeader-&gt;FileHeader;</span><br><span class="line">	pOptHeader = &amp;pNtHeader-&gt;OptionalHeader;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pFileHeader-&gt;Machine != X64) &#123;</span><br><span class="line">		<span class="comment">//不是x64文件</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:File archtrue not match\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> size = (<span class="type">size_t</span>)pOptHeader-&gt;SizeOfImage;</span><br><span class="line"></span><br><span class="line">	status=ReadWrite::<span class="built_in">MyAllocMem</span>(ProcessId,(PVOID*)&amp;pStartMapAddr,<span class="number">0</span>,&amp;size,MEM_COMMIT, PAGE_EXECUTE_READWRITE,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//修改原型PTE 规避检查</span></span><br><span class="line"></span><br><span class="line">	PageAttrHide::<span class="built_in">ChangeVadAttributes</span>((ULONG_PTR)pStartMapAddr, MM_READONLY,ProcessId);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//分配失败</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to alloc mem\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建Mem_Map_Dll结构体</span></span><br><span class="line"></span><br><span class="line">	Manual_Mapping_data* ManualMapData=(Manual_Mapping_data*)<span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool,<span class="built_in">sizeof</span>(ManualMapData)<span class="number">+2</span>,<span class="string">&#x27;MMD&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	ManualMapData-&gt;dwReadson = <span class="number">0</span>;</span><br><span class="line">	ManualMapData-&gt;pGetProcAddress = (f_GetProcAddress)Global::<span class="built_in">GetInstance</span>()-&gt;pGetProcAddress;</span><br><span class="line">	ManualMapData-&gt;pLoadLibraryA = (f_LoadLibraryA)Global::<span class="built_in">GetInstance</span>()-&gt;pLoadLibraryA;</span><br><span class="line">	ManualMapData-&gt;pBase = pStartMapAddr;</span><br><span class="line">	ManualMapData-&gt;reservedParam = <span class="number">0</span>;</span><br><span class="line">	ManualMapData-&gt;pRtlAddFunctionTable = (f_RtlAddFunctionTable)Global::<span class="built_in">GetInstance</span>()-&gt;pRtlAddFunctionTable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//开始写入PE文件结构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//写入PE头</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(ReadWrite::<span class="built_in">MyWriteMem</span>(ProcessId, pStartMapAddr, pFileData, <span class="number">0x1000</span>, <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to Write PE head\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//写入PE结构的各节区</span></span><br><span class="line"></span><br><span class="line">	IMAGE_SECTION_HEADER* pSectionHeader = <span class="built_in">IMAGE_FIRST_SECTION</span>(pNtHeader);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//因为Section紧密排列 所以可以直接++</span></span><br><span class="line">	<span class="comment">//VirtualAddress=RVA PointerToRawData==FOA</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pFileHeader-&gt;NumberOfSections; i++,pSectionHeader++) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (pSectionHeader-&gt;SizeOfRawData) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(ReadWrite::<span class="built_in">MyWriteMem</span>(ProcessId, pStartMapAddr + pSectionHeader-&gt;VirtualAddress, (PVOID)((ULONG_PTR)pFileData + (ULONG_PTR)pSectionHeader-&gt;PointerToRawData), pSectionHeader-&gt;SizeOfRawData, <span class="number">0</span>))) &#123;</span><br><span class="line">				<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to write sections\r\n&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将ManulMapData给写入到内存</span></span><br><span class="line"></span><br><span class="line">	PVOID pManulMapData=<span class="number">0</span>;</span><br><span class="line">	<span class="type">size_t</span> ManuaMapDataSize = <span class="built_in">sizeof</span>(Manual_Mapping_data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(ReadWrite::<span class="built_in">MyAllocMem</span>(ProcessId,&amp;pManulMapData,<span class="number">0</span>,&amp;ManuaMapDataSize,MEM_COMMIT,PAGE_READWRITE,<span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to alloc manual map data\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//修改原型PTE规避检查</span></span><br><span class="line"></span><br><span class="line">	PageAttrHide::<span class="built_in">ChangeVadAttributes</span>((ULONG_PTR)pManulMapData, MM_READONLY, ProcessId);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(ReadWrite::<span class="built_in">MyWriteMem</span>(ProcessId, pManulMapData, ManualMapData, ManuaMapDataSize, <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to write manul map data\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ExFreePool</span>(ManualMapData);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ShellCode给映射过去 ShellCode用于自定位</span></span><br><span class="line"></span><br><span class="line">	PVOID pShellCode = <span class="number">0</span>;</span><br><span class="line">	<span class="type">size_t</span> ShellCodeSize = <span class="number">0x1000</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(ReadWrite::<span class="built_in">MyAllocMem</span>(ProcessId, &amp;pShellCode, <span class="number">0</span>, &amp;ShellCodeSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE, <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>,<span class="number">0</span>,<span class="string">&quot;[OxygenDriver]err:Failed  to alloc mem for Shellcode\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//修改原型PTE 规避检查</span></span><br><span class="line"></span><br><span class="line">	PageAttrHide::<span class="built_in">ChangeVadAttributes</span>((ULONG_PTR)pShellCode, MM_READONLY, ProcessId);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(ReadWrite::<span class="built_in">MyWriteMem</span>(ProcessId, pShellCode, ShellCode, ShellCodeSize, <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to write mem for shellcode\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建新线程</span></span><br><span class="line"></span><br><span class="line">	HANDLE ThreadId;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指定了过ace的话 需要</span></span><br><span class="line">	<span class="comment">////过TP需要去除 去R3的 LdrInitializeThunk的Hook</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bPassAce) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> OriBytes[<span class="number">14</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">BanACELdrInitializeThunkHook</span>(ProcessId, OriBytes)) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to ban ace&#x27;s r3 hook at ldrinitializethunk\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(ReadWrite::<span class="built_in">MyCreateThread</span>(ProcessId, (UINT64)pShellCode, (UINT64)pManulMapData, <span class="number">0</span>, <span class="number">0</span>, &amp;ThreadId))) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to setup new thread\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]info:Create Thread Successly ThreadId:0x%x\r\n&quot;</span>, ThreadId);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注入程序的ShellCode</span></span><br><span class="line"><span class="comment">//用于重定位</span></span><br><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">ShellCode</span><span class="params">(Manual_Mapping_data* pData)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* pBase = pData-&gt;pBase;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span>* pOpt = &amp;<span class="built_in">reinterpret_cast</span>&lt;IMAGE_NT_HEADERS*&gt;(pBase + <span class="built_in">reinterpret_cast</span>&lt;IMAGE_DOS_HEADER*&gt;((<span class="type">uintptr_t</span>)pBase)-&gt;e_lfanew)-&gt;OptionalHeader;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//auto _LoadLibraryA = pData-&gt;pLoadLibraryA;</span></span><br><span class="line">	<span class="comment">//auto _GetProcAddress = pData-&gt;pGetProcAddress;</span></span><br><span class="line">	<span class="comment">//auto _RtlAddFunctionTable = pData-&gt;pRtlAddFunctionTable;</span></span><br><span class="line">	<span class="comment">//auto _DllMain = (f_DLL_ENTRY_POINT)(pBase + pOpt-&gt;AddressOfEntryPoint);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//重定位表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* LocationDelta = pBase - pOpt-&gt;ImageBase;</span><br><span class="line">	<span class="keyword">if</span> (LocationDelta) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pOpt-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size) &#123;</span><br><span class="line">			<span class="keyword">auto</span>* pRelocData = <span class="built_in">reinterpret_cast</span>&lt;IMAGE_BASE_RELOCATION*&gt;(pBase + pOpt-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);</span><br><span class="line">			<span class="type">const</span> <span class="keyword">auto</span>* pRelocEnd = <span class="built_in">reinterpret_cast</span>&lt;IMAGE_BASE_RELOCATION*&gt;(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(pRelocData) + pOpt-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);</span><br><span class="line">			<span class="keyword">while</span> (pRelocData &lt; pRelocEnd &amp;&amp; pRelocData-&gt;SizeOfBlock) &#123;</span><br><span class="line">				<span class="comment">//重定位表有很多个</span></span><br><span class="line">				<span class="comment">//重定位的个数不包括IMAGE_BASE_RELOCATION这个地方</span></span><br><span class="line">				<span class="comment">//重定位的偏移的大小是WORD</span></span><br><span class="line">				UINT64 AmountOfEntries = (pRelocData-&gt;SizeOfBlock - <span class="built_in">sizeof</span>(IMAGE_BASE_RELOCATION)) / <span class="built_in">sizeof</span>(<span class="type">short</span>);</span><br><span class="line">				<span class="comment">//指向重定位的偏移</span></span><br><span class="line">				<span class="comment">//typedef struct _IMAGE_BASE_RELOCATION &#123;</span></span><br><span class="line">				<span class="comment">//	DWORD   VirtualAddress; //重定位表起始地址的RVA</span></span><br><span class="line">				<span class="comment">//	DWORD   SizeOfBlock;</span></span><br><span class="line">				<span class="comment">//	//  WORD    TypeOffset[1];</span></span><br><span class="line">				<span class="comment">//Windows重定位表是按页涉及的</span></span><br><span class="line">				<span class="comment">//相近的地址,都放在了这一个RVA里面.</span></span><br><span class="line">				<span class="comment">//TypeOffset中高4位是这个重定表项的类型</span></span><br><span class="line">				<span class="comment">//低12位 表示在这个一页(4KB)的偏移</span></span><br><span class="line">				<span class="type">unsigned</span> <span class="type">short</span>* pRelativeInfo = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">short</span>*&gt;(pRelocData + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">for</span> (UINT64 i = <span class="number">0</span>; i != AmountOfEntries; ++i, ++pRelativeInfo) &#123;</span><br><span class="line">					<span class="comment">//遍历重定表的TypeOffset</span></span><br><span class="line">					<span class="keyword">if</span> (<span class="built_in">RELOC_FLAG</span>(*pRelativeInfo)) &#123;</span><br><span class="line">						<span class="comment">//判断高4位 是否需要重定位</span></span><br><span class="line"></span><br><span class="line">						<span class="comment">//只有直接寻址才需要重定位</span></span><br><span class="line">						<span class="comment">//pBase+RVA==需要重定位页面</span></span><br><span class="line">						<span class="comment">//页面+0xfff &amp; TypeOffset 就是要重定位的地址(一个直接地址)</span></span><br><span class="line">						UINT_PTR* pPatch = <span class="built_in">reinterpret_cast</span>&lt;UINT_PTR*&gt;(pBase + pRelocData-&gt;VirtualAddress + ((*pRelativeInfo) &amp; <span class="number">0xFFF</span>));</span><br><span class="line">						<span class="comment">//所以我们要把这个地址加上真正装载地址减去ImageBase</span></span><br><span class="line">						*pPatch += <span class="built_in">reinterpret_cast</span>&lt;UINT_PTR&gt;(LocationDelta);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//下一个重定位表(毕竟不止一个页面需要重定位)</span></span><br><span class="line">				pRelocData = <span class="built_in">reinterpret_cast</span>&lt;IMAGE_BASE_RELOCATION*&gt;(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(pRelocData) + pRelocData-&gt;SizeOfBlock);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//修复IAT表</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pOpt-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size) &#123;</span><br><span class="line">		</span><br><span class="line">		IMAGE_IMPORT_DESCRIPTOR * pImportDescr = (IMAGE_IMPORT_DESCRIPTOR*)(pBase + pOpt-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (pImportDescr-&gt;Name) &#123;</span><br><span class="line">			<span class="comment">//Name是RVA 指向Dll名称</span></span><br><span class="line"></span><br><span class="line">			HMODULE hDll = pData-&gt;<span class="built_in">pLoadLibraryA</span>(pBase + pImportDescr-&gt;Name);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//INT</span></span><br><span class="line">			ULONG_PTR* pInt = (ULONG_PTR*)(pBase + pImportDescr-&gt;OriginalFirstThunk);</span><br><span class="line">			<span class="comment">//IAT</span></span><br><span class="line">			ULONG_PTR* pIat = (ULONG_PTR*)(pBase + pImportDescr-&gt;FirstThunk);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!pInt) pInt = pIat;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (; *pIat; ++pIat, ++pInt) &#123;</span><br><span class="line"></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">IMAGE_SNAP_BY_ORDINAL</span>(*pInt)) &#123;</span><br><span class="line">					<span class="comment">//如果是序号填充</span></span><br><span class="line">					*pIat = (ULONG_PTR)pData-&gt;<span class="built_in">pGetProcAddress</span>(hDll,(<span class="type">char</span>*)(*pInt &amp; <span class="number">0xffff</span>));</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//按照名称填充</span></span><br><span class="line">					IMAGE_IMPORT_BY_NAME* pImport = (IMAGE_IMPORT_BY_NAME*)(pBase + *pInt);</span><br><span class="line"></span><br><span class="line">					*pIat = (ULONG_PTR)pData-&gt;<span class="built_in">pGetProcAddress</span>(hDll, pImport-&gt;Name);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			pImportDescr++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//填充TLS回调</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_PROCESS_ATTACH 1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pOpt-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">auto</span>* pTLS = <span class="built_in">reinterpret_cast</span>&lt;IMAGE_TLS_DIRECTORY*&gt;(pBase + pOpt-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//注意 这里要进行重定位</span></span><br><span class="line">		<span class="comment">//TLS表的CallBack要加LocationDelta</span></span><br><span class="line">		<span class="keyword">auto</span>* pCallback = <span class="built_in">reinterpret_cast</span>&lt;PIMAGE_TLS_CALLBACK*&gt;(pTLS-&gt;AddressOfCallBacks);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (; pCallback &amp;&amp; *pCallback; ++pCallback)</span><br><span class="line">			(*pCallback)(pBase, DLL_PROCESS_ATTACH, <span class="literal">nullptr</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//修复x64下异常表</span></span><br><span class="line">	<span class="keyword">auto</span> excep = pOpt-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION];</span><br><span class="line">	<span class="keyword">if</span> (excep.Size) &#123;</span><br><span class="line">		pData-&gt;<span class="built_in">pRtlAddFunctionTable</span>((PRUNTIME_FUNCTION)(pBase + excep.VirtualAddress),excep.Size / <span class="built_in">sizeof</span>(IMAGE_RUNTIME_FUNCTION_ENTRY), (DWORD64)pBase);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//执行DllMain函数</span></span><br><span class="line"></span><br><span class="line">	((f_DLL_ENTRY_POINT)(pBase + pOpt-&gt;AddressOfEntryPoint))(pBase, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ULONG_PTR  <span class="title">BanACELdrInitializeThunkHook</span><span class="params">(HANDLE ProcessId,<span class="type">char</span>* OriBytes)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ULONG_PTR uLdrInitializeThunk = Global::<span class="built_in">GetInstance</span>()-&gt;fLdrInitializeThunk;</span><br><span class="line">	ULONG_PTR uZwContinue = (ULONG_PTR)Global::<span class="built_in">GetInstance</span>()-&gt;fZwContinue;</span><br><span class="line">	ULONG_PTR uRtlRaiseStatus = (ULONG_PTR)Global::<span class="built_in">GetInstance</span>()-&gt;fRtlRaiseStatus;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	CHAR OldBytes[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(ReadWrite::<span class="built_in">MyReadMem</span>(ProcessId, (PVOID)uLdrInitializeThunk, OldBytes, <span class="built_in">sizeof</span>(OldBytes), <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>,<span class="number">0</span>,<span class="string">&quot;[OxygenDriver]err:Failed to read ldrinitializethunk\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	DWORD32 dwOldProtect;</span><br><span class="line">	<span class="type">size_t</span> ProtectSize = <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取ACE HOOK的真正地址</span></span><br><span class="line">	ULONG_PTR uCurAddress = uLdrInitializeThunk;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">KdPrint</span>((<span class="string">&quot;LdrInitialzeThunk=0x%p\r\n&quot;</span>, uCurAddress));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		BOOLEAN bDone = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//ACE不知道有多少层指针 所以需要循环测试</span></span><br><span class="line">		<span class="type">char</span> bDef;<span class="comment">//来确定是不是Hook</span></span><br><span class="line">		ReadWrite::<span class="built_in">MyReadMem</span>(ProcessId,(PVOID)(uCurAddress), &amp;bDef, <span class="built_in">sizeof</span>(bDef), <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">switch</span> (bDef)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0xff</span>: &#123;<span class="comment">//FF 25调用</span></span><br><span class="line">			ULONG_PTR uTemp;</span><br><span class="line">			ReadWrite::<span class="built_in">MyReadMem</span>(ProcessId, (PVOID)(uCurAddress + <span class="number">6</span>), &amp;uTemp, <span class="built_in">sizeof</span>(uTemp), <span class="number">0</span>);</span><br><span class="line">			uCurAddress = uTemp;</span><br><span class="line">			<span class="built_in">KdPrint</span>((<span class="string">&quot;现在uCurrent=0x%p\r\n&quot;</span>, uCurAddress));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0xe9</span>: &#123;<span class="comment">//E9 四字节偏移调用</span></span><br><span class="line">			<span class="type">int</span> offset;</span><br><span class="line">			ReadWrite::<span class="built_in">MyReadMem</span>(ProcessId, (PVOID)(uCurAddress + <span class="number">1</span>), &amp;offset, <span class="built_in">sizeof</span>(<span class="type">int</span>), <span class="number">0</span>);</span><br><span class="line">			uCurAddress += <span class="number">5</span> + offset;</span><br><span class="line">			<span class="built_in">KdPrint</span>((<span class="string">&quot;现在uCurrent=0x%p\r\n&quot;</span>, uCurAddress));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">//如果都不是 说明已经找到地址了 返回即可</span></span><br><span class="line">			bDone = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bDone == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ULONG_PTR uSavedCurAddress = uCurAddress;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[ACE Hook的地方]:0x%p\r\n&quot;</span>, uCurAddress);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//if (uCurAddress == uLdrInitializeThunk) &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//	//没被Hook</span></span><br><span class="line">	<span class="comment">//	return 1;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4838)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4309)</span></span><br><span class="line">		<span class="comment">//修改 Hook的地址 然后ShellCode</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">//00007FF8FC244C60 &lt;ntdll.LdrInitializeThunk&gt; | 40:53 | push rbx |</span></span><br><span class="line">	<span class="comment">//00007FF8FC244C62 | 48 : 83EC 20 | sub rsp, 0x20 |</span></span><br><span class="line">	<span class="comment">//00007FF8FC244C66 | 48 : 8BD9 | mov rbx, rcx |</span></span><br><span class="line">	<span class="comment">//00007FF8FC244C69 | E8 1A000000 | call ntdll.7FF8FC244C88 |</span></span><br><span class="line">	<span class="comment">//00007FF8FC244C6E | B2 01 | mov dl, 0x1 |</span></span><br><span class="line">	<span class="comment">//00007FF8FC244C70 | 48 : 8BCB | mov rcx, rbx |</span></span><br><span class="line">	<span class="comment">//00007FF8FC244C73 | E8 588D0200 | call &lt;ntdll.ZwContinue&gt; |</span></span><br><span class="line">	<span class="comment">//00007FF8FC244C78 | 8BC8 | mov ecx, eax |</span></span><br><span class="line">	<span class="comment">//00007FF8FC244C7A | E8 81DC0800 | call &lt;ntdll.RtlRaiseStatus&gt; |</span></span><br><span class="line">	CHAR LdrInitializeThunkShellCode[] = &#123; <span class="number">0x40</span>,<span class="number">0x53</span>,<span class="comment">//push rbx</span></span><br><span class="line">	<span class="number">0x48</span>,<span class="number">0x83</span>,<span class="number">0xec</span>,<span class="number">0x20</span>,<span class="comment">//sub rsp, 0x20</span></span><br><span class="line">	<span class="number">0x48</span>,<span class="number">0x8b</span>,<span class="number">0xd9</span>,<span class="comment">//mov rbx, rcx</span></span><br><span class="line">	<span class="number">0x48</span>,<span class="number">0x83</span>,<span class="number">0xec</span>,<span class="number">0x08</span>,<span class="comment">//sub rsp,8 index=13</span></span><br><span class="line">	<span class="number">0xC7</span>,<span class="number">0x44</span>,<span class="number">0x24</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC7</span>,<span class="number">0x04</span>,<span class="number">0x24</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>, <span class="comment">//push rip(自己计算) index=28</span></span><br><span class="line">	<span class="number">0xff</span>,<span class="number">0x25</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">//jmp到LdrInit的第一个call index=42</span></span><br><span class="line">	<span class="number">0xb2</span>,<span class="number">0x01</span>,<span class="comment">//mov dl,0x1 index=44</span></span><br><span class="line">	<span class="number">0x48</span>,<span class="number">0x8b</span>,<span class="number">0xcb</span>,<span class="comment">//mov rcx,rbx index = 47</span></span><br><span class="line">	<span class="number">0x48</span>,<span class="number">0x83</span>,<span class="number">0xec</span>,<span class="number">0x08</span>,<span class="comment">//sub rsp,8 index =51</span></span><br><span class="line">	<span class="number">0xC7</span>,<span class="number">0x44</span>,<span class="number">0x24</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC7</span>,<span class="number">0x04</span>,<span class="number">0x24</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>, <span class="comment">//push rip(自己计算) index=66</span></span><br><span class="line">	<span class="number">0xff</span>,<span class="number">0x25</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">//jmp到ZwContinue 自己填充 index=80</span></span><br><span class="line">	<span class="number">0x8b</span>,<span class="number">0xc8</span>,<span class="comment">//mov ecx,eax index=82</span></span><br><span class="line">	<span class="number">0x48</span>,<span class="number">0x83</span>,<span class="number">0xec</span>,<span class="number">0x08</span>,<span class="comment">//sub rsp,8 index=86</span></span><br><span class="line">	<span class="number">0xC7</span>,<span class="number">0x44</span>,<span class="number">0x24</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC7</span>,<span class="number">0x04</span>,<span class="number">0x24</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>, <span class="comment">//push rip(自己计算) index=101</span></span><br><span class="line">	<span class="number">0xff</span>,<span class="number">0x25</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">//jmp到RtlRaiseStatus 自己填充 index=155</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取那三个Call</span></span><br><span class="line">	ULONG_PTR uSecondCall = uZwContinue;</span><br><span class="line">	ULONG_PTR uThirdCall = uRtlRaiseStatus;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]info:进程传过来的Call:0x%p\r\n&quot;</span>, Global::<span class="built_in">GetInstance</span>()-&gt;uLdrFirstCall));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//填充三个Call</span></span><br><span class="line">	*(ULONG_PTR*)(&amp;LdrInitializeThunkShellCode[<span class="number">34</span>]) = Global::<span class="built_in">GetInstance</span>()-&gt;uLdrFirstCall;</span><br><span class="line">	*(ULONG_PTR*)(&amp;LdrInitializeThunkShellCode[<span class="number">72</span>]) = uSecondCall;</span><br><span class="line">	*(ULONG_PTR*)(&amp;LdrInitializeThunkShellCode[<span class="number">107</span>]) = uThirdCall;</span><br><span class="line"></span><br><span class="line">	PVOID pAllocAddr=<span class="number">0</span>;</span><br><span class="line">	<span class="type">size_t</span> AllocSize=<span class="number">0x1000</span>;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(ReadWrite::<span class="built_in">MyAllocMem</span>(ProcessId, &amp;pAllocAddr, <span class="number">0</span>, &amp;AllocSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE, <span class="number">0</span>))) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]info:Alloc mem for Ldrinitializethunk err!\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//修改原型PTE修改属性 规避BE检查</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//PageAttrHide::ChangeVadAttributes((ULONG_PTR)pAllocAddr, MM_READONLY, ProcessId);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//填充RIP返回地址</span></span><br><span class="line"></span><br><span class="line">	ULONG_PTR uFirstRet = (ULONG_PTR)pAllocAddr + <span class="number">42</span>;</span><br><span class="line">	ULONG_PTR uSecondRet = (ULONG_PTR)pAllocAddr + <span class="number">80</span>;</span><br><span class="line">	ULONG_PTR uThiredRet = (ULONG_PTR)pAllocAddr + <span class="number">115</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIDWORD(l)           ((DWORD32)((((ULONG_PTR)(l)) &gt;&gt; 32) &amp; 0xffffffff)) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOWDWORD(l)           ((DWORD32)((((ULONG_PTR)(l))) &amp; 0xffffffff)) </span></span><br><span class="line"></span><br><span class="line">	* (PDWORD32)(&amp;LdrInitializeThunkShellCode[<span class="number">17</span>]) = <span class="built_in">HIDWORD</span>(uFirstRet);</span><br><span class="line">	*(PDWORD32)(&amp;LdrInitializeThunkShellCode[<span class="number">24</span>]) = <span class="built_in">LOWDWORD</span>(uFirstRet);</span><br><span class="line"></span><br><span class="line">	*(PDWORD32)(&amp;LdrInitializeThunkShellCode[<span class="number">55</span>]) = <span class="built_in">HIDWORD</span>(uSecondRet);</span><br><span class="line">	*(PDWORD32)(&amp;LdrInitializeThunkShellCode[<span class="number">62</span>]) = <span class="built_in">LOWDWORD</span>(uSecondRet);</span><br><span class="line"></span><br><span class="line">	*(PDWORD32)(&amp;LdrInitializeThunkShellCode[<span class="number">90</span>]) = <span class="built_in">HIDWORD</span>(uThiredRet);</span><br><span class="line">	*(PDWORD32)(&amp;LdrInitializeThunkShellCode[<span class="number">97</span>]) = <span class="built_in">LOWDWORD</span>(uThiredRet);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(ReadWrite::<span class="built_in">MyWriteMem</span>(ProcessId, pAllocAddr, LdrInitializeThunkShellCode, <span class="built_in">sizeof</span>(LdrInitializeThunkShellCode), <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>,<span class="number">0</span>,<span class="string">&quot;[OxygenDriver]info:Failed to write mem for Ldrinitializethunk\r\n&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//修改ACE Hook的地方</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]:SavedCurAddress==0x%p\r\n&quot;</span>, uSavedCurAddress));</span><br><span class="line"></span><br><span class="line">	ReadWrite::<span class="built_in">MyProtectMem</span>(ProcessId, (PVOID*)&amp;uCurAddress, &amp;ProtectSize, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意 这个时候uCurAddress已经改变了</span></span><br><span class="line">	<span class="comment">//所以保存一下 因为ProtectMem会修改</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//CHAR aHookOriBytes[14];</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOOKSIZE 14</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(ReadWrite::<span class="built_in">MyReadMem</span>(ProcessId, (PVOID)uSavedCurAddress, OriBytes, HOOKSIZE, <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to write mem for hook addr\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CHAR JmpShellCode[] = &#123; <span class="number">0xff</span>, <span class="number">0x25</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	*(ULONG_PTR*)(&amp;JmpShellCode[<span class="number">6</span>]) = (ULONG_PTR)pAllocAddr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(ReadWrite::<span class="built_in">MyWriteMem</span>(ProcessId, (PVOID)uSavedCurAddress, JmpShellCode, <span class="built_in">sizeof</span>(JmpShellCode), <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to write mem for hook addr\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DriverInit.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;APC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ReadWrite.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Injector.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PageAttrHide.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4100)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UNICODE_STRING usDevname = <span class="built_in">RTL_CONSTANT_STRING</span>(<span class="string">L&quot;\\Device\\OxygenDriver&quot;</span>);</span><br><span class="line">UNICODE_STRING usSymlink = <span class="built_in">RTL_CONSTANT_STRING</span>(<span class="string">L&quot;\\??\\OxygenDriver&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject,PUNICODE_STRING RegPath)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span>;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">DispatchFuncDeviceControl</span><span class="params">(PDEVICE_OBJECT DeviceObject, PIRP Irp)</span></span>;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">DispatchFuncCreateClose</span><span class="params">(PDEVICE_OBJECT DriverObject, PIRP Irp)</span></span>;</span><br><span class="line"><span class="comment">//初始化设备和符号便于通信</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">LoadDevAndSymLink</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span>;</span><br><span class="line"><span class="comment">//获取本机Ntosknrl的基质</span></span><br><span class="line"><span class="function">ULONG_PTR <span class="title">GetNtOskrnlBase</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegPath)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">UNREFERENCED_PARAMETER</span>(RegPath);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">LoadDevAndSymLink</span>(DriverObject);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">IoDeleteDevice</span>(DriverObject-&gt;DeviceObject);</span><br><span class="line">	<span class="built_in">IoDeleteSymbolicLink</span>(&amp;usSymlink);</span><br><span class="line">	<span class="built_in">ExFreePool</span>(Global::<span class="built_in">GetInstance</span>());</span><br><span class="line"></span><br><span class="line">	<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]info:Unload Driver successly\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DispatchFuncCreateClose</span><span class="params">(PDEVICE_OBJECT DriverObject, PIRP Irp)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">UNREFERENCED_PARAMETER</span>(DriverObject);</span><br><span class="line">	NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Irp-&gt;IoStatus.Status = status;</span><br><span class="line">	Irp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">IoCompleteRequest</span>(Irp, IO_NO_INCREMENT);</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DispatchFuncDeviceControl</span><span class="params">(PDEVICE_OBJECT DeviceObject, PIRP Irp)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">UNREFERENCED_PARAMETER</span>(DeviceObject);</span><br><span class="line"></span><br><span class="line">	PIO_STACK_LOCATION stack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(Irp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (stack-&gt;Parameters.DeviceIoControl.IoControlCode)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> CTL_CODE_INIT: &#123;</span><br><span class="line">		<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">		InitPdb* buffer=(InitPdb*)Irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">MmIsAddressValid</span>(buffer)) &#123;</span><br><span class="line">			<span class="comment">//err</span></span><br><span class="line"></span><br><span class="line">			<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]err:InitPdb system buffer err\n&quot;</span>));</span><br><span class="line">			<span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ULONG_PTR uNtosnrlBase= <span class="built_in">GetNtOskrnlBase</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!uNtosnrlBase) &#123;</span><br><span class="line">			<span class="comment">//err</span></span><br><span class="line">			<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]err:failed to get ntoskrnlbase\n&quot;</span>));</span><br><span class="line">			<span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//初始化Global</span></span><br><span class="line">		Global::<span class="built_in">GetInstance</span>()-&gt;uNtosnrlBase = uNtosnrlBase;</span><br><span class="line">		Global::<span class="built_in">GetInstance</span>()-&gt;pNtAlloc = (pNtAllocateVirtualMemory)(uNtosnrlBase + buffer-&gt;uRvaNtAlloc);</span><br><span class="line">		Global::<span class="built_in">GetInstance</span>()-&gt;pNtCreateThread = (pNtCreateThreadEx)(uNtosnrlBase + buffer-&gt;uRvaNtCreateThread);</span><br><span class="line">		Global::<span class="built_in">GetInstance</span>()-&gt;pNtProtect = (pNtProtectVirtualMemory)(uNtosnrlBase + buffer-&gt;uRvaNtProtect);</span><br><span class="line">		Global::<span class="built_in">GetInstance</span>()-&gt;pNtWrite = (pNtWriteVirtualMemory)(uNtosnrlBase + buffer-&gt;uRvaNtWrite);</span><br><span class="line">		Global::<span class="built_in">GetInstance</span>()-&gt;pNtRead = (pNtReadVirtualMemory)(uNtosnrlBase + buffer-&gt;uRvaNtRead);</span><br><span class="line">		Global::<span class="built_in">GetInstance</span>()-&gt;uPspNotifyEnableMask = buffer-&gt;uPspNotifyEnableMaskRva + uNtosnrlBase;</span><br><span class="line">		Global::<span class="built_in">GetInstance</span>()-&gt;uMmpfnDatabase = buffer-&gt;uRvaMmpfndatabase + uNtosnrlBase;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		Global::<span class="built_in">GetInstance</span>()-&gt;uVadRoot = buffer-&gt;uVadRoot;</span><br><span class="line">		Global::<span class="built_in">GetInstance</span>()-&gt;uThreadPreviouMode = buffer-&gt;uThreadPreviouMode;</span><br><span class="line">		Global::<span class="built_in">GetInstance</span>()-&gt;uApcState = buffer-&gt;uApcState;</span><br><span class="line">		Global::<span class="built_in">GetInstance</span>()-&gt;uApcUserPendingAll = buffer-&gt;uUserApcPendingAll;</span><br><span class="line">		Global::<span class="built_in">GetInstance</span>()-&gt;pGetProcAddress = buffer-&gt;pGetProcAddress;</span><br><span class="line">		Global::<span class="built_in">GetInstance</span>()-&gt;pLoadLibraryA = buffer-&gt;pLoadLibraryA;</span><br><span class="line">		Global::<span class="built_in">GetInstance</span>()-&gt;pRtlAddFunctionTable = buffer-&gt;pRtlAddFunctionTable;</span><br><span class="line">		Global::<span class="built_in">GetInstance</span>()-&gt;uOriginPte = buffer-&gt;uOriginPte;</span><br><span class="line">		Global::<span class="built_in">GetInstance</span>()-&gt;uLdrFirstCall = buffer-&gt;uLdrFirstCall;</span><br><span class="line"></span><br><span class="line">		Global::<span class="built_in">GetInstance</span>()-&gt;fLdrInitializeThunk = buffer-&gt;fLdrInitializeThunk;</span><br><span class="line">		Global::<span class="built_in">GetInstance</span>()-&gt;fZwContinue = buffer-&gt;fZwContinue;</span><br><span class="line">		Global::<span class="built_in">GetInstance</span>()-&gt;fRtlRaiseStatus = buffer-&gt;fRtlRaiseStatus;</span><br><span class="line"></span><br><span class="line">		Global::<span class="built_in">GetInstance</span>()-&gt;pKeServiceDescriptorTable = buffer-&gt;pKeServiceDescriptorTable+uNtosnrlBase;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;KeServiceDescriptorTable==0x%p\r\n&quot;</span>, Global::<span class="built_in">GetInstance</span>()-&gt;pKeServiceDescriptorTable);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//DbgBreakPoint();</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//已经初始化过</span></span><br><span class="line">		Global::<span class="built_in">GetInstance</span>()-&gt;bInitPdb = <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]info:Init Success!\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]info:pNtAlloc=0x%p,pNtCreateThread=0x%p,pNtProtect=0x%p,pNtWrite=0x%p,pNtRead=0x%p,pPspEnbaleNotifyMask=0x%p,uVadRoot=0x%x,uThreadPreviouMode=0x%d\n&quot;</span>, Global::<span class="built_in">GetInstance</span>()-&gt;pNtAlloc, Global::<span class="built_in">GetInstance</span>()-&gt;pNtCreateThread, Global::<span class="built_in">GetInstance</span>()-&gt;pNtProtect, Global::<span class="built_in">GetInstance</span>()-&gt;pNtWrite, Global::<span class="built_in">GetInstance</span>()-&gt;pNtRead, Global::<span class="built_in">GetInstance</span>()-&gt;uPspNotifyEnableMask, Global::<span class="built_in">GetInstance</span>()-&gt;uVadRoot, Global::<span class="built_in">GetInstance</span>()-&gt;uThreadPreviouMode));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]info:uApcState=0x%x,uUserApcPending=0x%x\n&quot;</span>, buffer-&gt;uApcState, buffer-&gt;uUserApcPendingAll));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4838)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span>  <span class="keyword">warning</span>(disable : 4309)</span></span><br><span class="line">		<span class="comment">//读写测试</span></span><br><span class="line">		<span class="comment">//char* shellcode = (char*)ExAllocatePoolWithTag(NonPagedPool, 2, &#x27;Test&#x27;);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//shellcode[0] = 0x90;</span></span><br><span class="line">		<span class="comment">//shellcode[1] = 0x88;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//WriteByMdl(reinterpret_cast&lt;HANDLE&gt;(9392), reinterpret_cast&lt;PVOID&gt;(0x000002214CCE0000), shellcode, 2, 0);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//ExFreePool(shellcode);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//启动线程Test</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//		HANDLE ProcessId = (HANDLE)3736;</span></span><br><span class="line">		<span class="comment">//		PVOID pAllocAddress = 0;</span></span><br><span class="line">		<span class="comment">//		size_t sAllocSize;</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">//		NTSTATUS status=ReadWrite::MyAllocMem(ProcessId, &amp;pAllocAddress, 0, &amp;sAllocSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE, 0);</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">//		if(!NT_SUCCESS(status))&#123;</span></span><br><span class="line">		<span class="comment">//			DbgPrintEx(77, 0, &quot;ALloc err\n&quot;);</span></span><br><span class="line">		<span class="comment">//			return STATUS_UNSUCCESSFUL;</span></span><br><span class="line">		<span class="comment">//		&#125;</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">//		PVOID pAllocToWrite = ExAllocatePoolWithTag(NonPagedPool, 0x10, &#x27;WRIE&#x27;);</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">//#pragma warning(disable : 4309)</span></span><br><span class="line">		<span class="comment">//#pragma warning(disable : 4838)</span></span><br><span class="line">		<span class="comment">//		//死循环</span></span><br><span class="line">		<span class="comment">//		CHAR ShellCode[] = &#123; 0X90, 0XEB,0XFD &#125;;</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">//		memcpy(pAllocToWrite, ShellCode, 3);</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">//		status = ReadWrite::MyWriteMem(ProcessId, pAllocAddress, pAllocToWrite,0x10,0);</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">//		if (!NT_SUCCESS(status)) &#123;</span></span><br><span class="line">		<span class="comment">//			DbgPrintEx(77, 0, &quot;WRITE ERR\n&quot;);</span></span><br><span class="line">		<span class="comment">//			ExFreePool(pAllocToWrite);</span></span><br><span class="line">		<span class="comment">//			return STATUS_UNSUCCESSFUL;</span></span><br><span class="line">		<span class="comment">//		&#125;</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">//		HANDLE hThread=0;</span></span><br><span class="line">		<span class="comment">//		status = ReadWrite::MyCreateThread(ProcessId, (UINT64)pAllocAddress, 0, 0, 0x1000, &amp;hThread);</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">//		if (!NT_SUCCESS(status)) DbgPrintEx(77, 0, &quot;Create Err!\n&quot;);</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">//		KdPrint((&quot;Hanlde=0x%x\n&quot;, hThread));</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">//		ExFreePool(pAllocToWrite);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//用户APC立刻执行测试</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">////shellcode</span></span><br><span class="line">		<span class="comment">////mov rcx,0</span></span><br><span class="line">		<span class="comment">////mov rdx,0</span></span><br><span class="line">		<span class="comment">////mov r8,0</span></span><br><span class="line">		<span class="comment">////mov r9,0</span></span><br><span class="line">		<span class="comment">//char ShellCode[] = &#123; 0xB9,0X00,0X00,0X00,0X00,0XBA,0X00,0X00,0X00,0X00,0X41,0XB8,0X00,0X00,0X00,0X00,0X41,0XB9,0X00,0X00,0X00,0X00,0x48,0xB8,0x50,0xA0,0xBE,0x58, 0xF8 ,0x7F, 0x00 ,0x00,0xFF,0xE0,0xC3 &#125;;</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">//auto bInsert = APC::InsertAndDeliverUserApc(ThreadId, ShellCode, sizeof(ShellCode), &amp;ThreadId);</span></span><br><span class="line">		<span class="comment">//if (bInsert) &#123;</span></span><br><span class="line">		<span class="comment">//	DbgPrintEx(77, 0, &quot;[OxygenDriver]info:Insert Apc Success\n&quot;);</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//Dll注入测试</span></span><br><span class="line">		Injector_x64::<span class="built_in">MmInjector_x64_BypassProtect</span>((HANDLE)<span class="number">6400</span>, <span class="string">L&quot;\\??\\C:\\Users\\Administrator\\Desktop\\InjectorTest.dll&quot;</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		Irp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">		Irp-&gt;IoStatus.Information = <span class="built_in">sizeof</span>(InitPdb);</span><br><span class="line">		<span class="built_in">IoCompleteRequest</span>(Irp, IO_NO_INCREMENT);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Irp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">	Irp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">IoCompleteRequest</span>(Irp, IO_NO_INCREMENT);</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">LoadDevAndSymLink</span><span class="params">(PDRIVER_OBJECT DriverObject)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化派遣函数</span></span><br><span class="line"></span><br><span class="line">	DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">	DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchFuncDeviceControl;</span><br><span class="line"></span><br><span class="line">	DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = DispatchFuncCreateClose;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历找到Ntoskrnl</span></span><br><span class="line">	Global::<span class="built_in">GetInstance</span>()-&gt;uDriverSection = (PLDR_DATA_TABLE_ENTRY)DriverObject-&gt;DriverSection;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化符号链接</span></span><br><span class="line"></span><br><span class="line">	PDEVICE_OBJECT pdeoj;</span><br><span class="line"></span><br><span class="line">	NTSTATUS status= <span class="built_in">IoCreateDevice</span>(DriverObject,<span class="number">0</span>,&amp;usDevname,FILE_DEVICE_UNKNOWN,<span class="number">0</span>,<span class="number">0</span>,&amp;pdeoj);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">		<span class="comment">//ERR</span></span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]Err:Failed to create device\n&quot;</span>));</span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;ErrCode=0x%x&quot;</span>, status));</span><br><span class="line">		<span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	status = <span class="built_in">IoCreateSymbolicLink</span>(&amp;usSymlink, &amp;usDevname);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">		<span class="comment">//ERR</span></span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]Err:Failed to create symbolic link\n&quot;</span>));</span><br><span class="line">		<span class="built_in">IoDeleteDevice</span>(pdeoj);</span><br><span class="line">		<span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ULONG_PTR <span class="title">GetNtOskrnlBase</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	PLIST_ENTRY pPsLoadedModuleList = *(PLIST_ENTRY*)Global::<span class="built_in">GetInstance</span>()-&gt;uDriverSection;<span class="comment">//这个其实是指向LIST_ENTRY的结构</span></span><br><span class="line">	PLIST_ENTRY Next = pPsLoadedModuleList-&gt;Flink;</span><br><span class="line">	UNICODE_STRING usNtoskrnl = <span class="built_in">RTL_CONSTANT_STRING</span>(<span class="string">L&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pPsLoadedModuleList) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		PLDR_DATA_TABLE_ENTRY CurrentEntry = <span class="built_in">CONTAINING_RECORD</span>(Next, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);</span><br><span class="line">		<span class="keyword">if</span> (!CurrentEntry) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//err</span></span><br><span class="line">			<span class="built_in">KdPrint</span>((<span class="string">&quot;LDR_DATA err Line:%d\n&quot;</span>, __LINE__));</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (CurrentEntry-&gt;DllBase == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">//排除空</span></span><br><span class="line">			Next = Next-&gt;Flink;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">wcscmp</span>(CurrentEntry-&gt;BaseDllName.Buffer, usNtoskrnl.Buffer) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">//find</span></span><br><span class="line">			<span class="keyword">return</span> (ULONG_PTR)CurrentEntry-&gt;DllBase;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		Next = Next-&gt;Flink;</span><br><span class="line">	&#125; <span class="keyword">while</span> (Next != pPsLoadedModuleList);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">KdPrint</span>((<span class="string">&quot;[OxygenDriver]err:Failed to find this kernelmodule you submit\n&quot;</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lab2-instcallback仪器回调注入"><a href="#lab2-instcallback仪器回调注入" class="headerlink" title="lab2-instcallback仪器回调注入"></a>lab2-instcallback仪器回调注入</h3><p>用到<a href="https://njmxye.de5.net/内核驱动常用的库与头文件.zip">Hde与ia32库</a>。</p>
<p>此代码很可能有bug。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Global.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CTL_CODE_INIT CTL_CODE(0x8000,0x801,0,0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于进线程创建的AttributeList 0环要转成CreateProcessContext 变长数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SECURITY_ATTRIBUTES</span> &#123;</span><br><span class="line">	DWORD32 nLength;</span><br><span class="line">	PVOID lpSecurityDescriptor;</span><br><span class="line">	BOOLEAN bInheritHandle;</span><br><span class="line">&#125; SECURITY_ATTRIBUTES, * PSECURITY_ATTRIBUTES, * LPSECURITY_ATTRIBUTES;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_NT_PROC_THREAD_ATTRIBUTE_ENTRY</span> &#123;</span><br><span class="line">	UINT64 Attribute;</span><br><span class="line">	SIZE_T size;</span><br><span class="line">	UINT64 Vaule;</span><br><span class="line">	UINT64 Unknown;</span><br><span class="line">&#125;NT_PROC_THREAD_ATTRIBUTE_ENTRY,* PNT_PROC_THREAD_ATTRIBUTE_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_NT_PROC_THREAD_ATTRIBUTE_LIST</span> &#123;</span><br><span class="line">	UINT64 Length;</span><br><span class="line">	_NT_PROC_THREAD_ATTRIBUTE_ENTRY Entry[<span class="number">1</span>];</span><br><span class="line">&#125;NT_PROC_THREAD_ATTRIBUTE_LIST,*PNT_PROC_THREAD_ATTRIBUTE_LIST;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LDR_DATA</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*0x000*/</span>     <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> InLoadOrderLinks;</span><br><span class="line">	<span class="comment">/*0x010*/</span>     <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> InMemoryOrderLinks;</span><br><span class="line">	<span class="comment">/*0x020*/</span>     <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> InInitializationOrderLinks;</span><br><span class="line">	<span class="comment">/*0x030*/</span>     VOID* DllBase;</span><br><span class="line">	<span class="comment">/*0x038*/</span>     VOID* EntryPoint;</span><br><span class="line">	<span class="comment">/*0x040*/</span>     ULONG32      SizeOfImage;</span><br><span class="line">	<span class="comment">/*0x044*/</span>     UINT8        _PADDING0_[<span class="number">0x4</span>];</span><br><span class="line">	<span class="comment">/*0x048*/</span>     <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING</span> FullDllName;</span><br><span class="line">	<span class="comment">/*0x058*/</span>     <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING</span> BaseDllName;</span><br><span class="line">	<span class="comment">/*0x068*/</span>     ULONG32      Flags;</span><br><span class="line">	<span class="comment">/*0x06C*/</span>     UINT16       LoadCount;</span><br><span class="line">	<span class="comment">/*0x06E*/</span>     UINT16       TlsIndex;</span><br><span class="line">	<span class="keyword">union</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*0x070*/</span>         <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> HashLinks;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">a</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*0x070*/</span>             VOID* SectionPointer;</span><br><span class="line">			<span class="comment">/*0x078*/</span>             ULONG32      CheckSum;</span><br><span class="line">			<span class="comment">/*0x07C*/</span>             UINT8        _PADDING1_[<span class="number">0x4</span>];</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">union</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*0x080*/</span>         ULONG32      TimeDateStamp;</span><br><span class="line">		<span class="comment">/*0x080*/</span>         VOID* LoadedImports;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">/*0x088*/</span>     <span class="keyword">struct</span> <span class="title class_">_ACTIVATION_CONTEXT</span>* EntryPointActivationContext;</span><br><span class="line">	<span class="comment">/*0x090*/</span>     VOID* PatchInformation;</span><br><span class="line">	<span class="comment">/*0x098*/</span>     <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> ForwarderLinks;</span><br><span class="line">	<span class="comment">/*0x0A8*/</span>     <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> ServiceTagLinks;</span><br><span class="line">	<span class="comment">/*0x0B8*/</span>     <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> StaticLinks;</span><br><span class="line">	<span class="comment">/*0x0C8*/</span>     VOID* ContextInformation;</span><br><span class="line">	<span class="comment">/*0x0D0*/</span>     UINT64       OriginalBase;</span><br><span class="line">	<span class="comment">/*0x0D8*/</span>     <span class="keyword">union</span> <span class="title class_">_LARGE_INTEGER</span> LoadTime;</span><br><span class="line">&#125;LDR_DATA, * PLDR_DATA;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里字节对齐要采用默认，不要按1对齐，这样才符合32位和64位结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LDR_DATA_TABLE_ENTRY</span></span><br><span class="line">&#123;</span><br><span class="line">	LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">	LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">	LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">	PVOID DllBase;</span><br><span class="line">	PVOID EntryPoint;</span><br><span class="line">	ULONG SizeOfImage;</span><br><span class="line">	UNICODE_STRING FullDllName;</span><br><span class="line">	UNICODE_STRING BaseDllName;</span><br><span class="line">	ULONG Flags;</span><br><span class="line">	USHORT LoadCount;</span><br><span class="line">	USHORT TlsIndex;</span><br><span class="line">	<span class="keyword">union</span> <span class="title class_">b</span></span><br><span class="line">	&#123;</span><br><span class="line">		LIST_ENTRY HashLinks;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">e</span></span><br><span class="line">		&#123;</span><br><span class="line">			PVOID SectionPointer;</span><br><span class="line">			ULONG CheckSum;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">union</span> <span class="title class_">e</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">c</span></span><br><span class="line">		&#123;</span><br><span class="line">			ULONG TimeDateStamp;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">d</span></span><br><span class="line">		&#123;</span><br><span class="line">			PVOID LoadedImports;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">_ACTIVATION_CONTEXT</span>* EntryPointActivationContext;</span><br><span class="line">	PVOID PatchInformation;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">InitPdb</span></span><br><span class="line">&#123;</span><br><span class="line">	ULONG_PTR uRvaNtWrite;</span><br><span class="line">	ULONG_PTR uRvaNtAlloc;</span><br><span class="line">	ULONG_PTR uRvaNtCreateThread;</span><br><span class="line">	ULONG_PTR uRvaNtRead;</span><br><span class="line">	ULONG_PTR uRvaNtProtect;</span><br><span class="line">	ULONG_PTR uThreadPreviouMode;</span><br><span class="line">	ULONG_PTR uVadRoot;</span><br><span class="line">	ULONG_PTR uPspNotifyEnableMaskRva;</span><br><span class="line">	ULONG_PTR uApcState;</span><br><span class="line">	ULONG_PTR uUserApcPendingAll;</span><br><span class="line">	ULONG_PTR uRvaMmpfndatabase;</span><br><span class="line">	ULONG_PTR uOriginPte;</span><br><span class="line">	ULONG_PTR fLdrInitializeThunk = <span class="number">0</span>;</span><br><span class="line">	ULONG_PTR fZwContinue = <span class="number">0</span>;</span><br><span class="line">	ULONG_PTR fRtlRaiseStatus = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//Shellcode 加载DLl</span></span><br><span class="line">	ULONG_PTR pLoadLibraryA=<span class="number">0</span>;</span><br><span class="line">	ULONG_PTR pGetProcAddress=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//x64专属</span></span><br><span class="line">	ULONG_PTR pRtlAddFunctionTable=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//因为是在对方Hook里面 所以把LdrInitializeThunk的第一个Call地址传一下</span></span><br><span class="line">	ULONG_PTR uLdrFirstCall = <span class="number">0</span>;</span><br><span class="line">	ULONG_PTR pKeServiceDescriptorTable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内核函数函数指针定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(__fastcall* pNtReadVirtualMemory)</span><span class="params">(IN HANDLE ProcessHandle, IN PVOID BaseAddress, OUT PVOID Buffer, IN ULONG BufferLength, OUT PULONG ReturnLength OPTIONAL)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(__fastcall* pNtWriteVirtualMemory)</span><span class="params">(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, <span class="type">size_t</span> BufferLength, PULONG ReturnLength OPTIONAL)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">INT64</span><span class="params">(__fastcall* pNtAllocateVirtualMemory)</span><span class="params">(INT64 hProcess, PVOID* plpAddress, INT64 Zero, INT64* pSize, INT64 flAllocationType, INT64 flProtect)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(__fastcall* pNtCreateThreadEx)</span><span class="params">(HANDLE phNewThreadHandle, DWORD32 Access, LPSECURITY_ATTRIBUTES ThreadAttribute, HANDLE hProcess, UINT64 lpStartAddress, UINT64 lpParameter, DWORD32 CreateFlags, UINT64 ZeroBit, UINT64 StackSize, UINT64 ZeroBit2, _NT_PROC_THREAD_ATTRIBUTE_LIST* pAttributeList)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(__fastcall* pNtProtectVirtualMemory)</span><span class="params">(HANDLE hProcess, PVOID* plpAddress, SIZE_T* pSize_t, DWORD32 dwNewProtect, PDWORD32 OldProtect)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Global</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//是否已经初始化</span></span><br><span class="line">	<span class="type">bool</span> bInitPdb=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pNtWriteVirtualMemory pNtWrite=<span class="number">0</span>;</span><br><span class="line">	pNtAllocateVirtualMemory pNtAlloc=<span class="number">0</span>;</span><br><span class="line">	pNtCreateThreadEx pNtCreateThread=<span class="number">0</span>;</span><br><span class="line">	pNtReadVirtualMemory pNtRead=<span class="number">0</span>;</span><br><span class="line">	pNtProtectVirtualMemory pNtProtect=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ULONG_PTR fLdrInitializeThunk=<span class="number">0</span>;</span><br><span class="line">	ULONG_PTR fZwContinue=<span class="number">0</span>;</span><br><span class="line">	ULONG_PTR fRtlRaiseStatus=<span class="number">0</span>;</span><br><span class="line">	ULONG_PTR uThreadPreviouMode=<span class="number">0</span>;</span><br><span class="line">	ULONG_PTR uApcState = <span class="number">0</span>;</span><br><span class="line">	ULONG_PTR uApcUserPendingAll = <span class="number">0</span>;</span><br><span class="line">	ULONG_PTR uVadRoot=<span class="number">0</span>;</span><br><span class="line">	PLDR_DATA_TABLE_ENTRY uDriverSection = <span class="number">0</span>;<span class="comment">//遍历Ldr_table_list_entry 找到ntosknrl基质</span></span><br><span class="line">	ULONG_PTR uNtosnrlBase = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//Shellcode 加载DLl</span></span><br><span class="line">	ULONG_PTR pLoadLibraryA=<span class="number">0</span>;</span><br><span class="line">	ULONG_PTR pGetProcAddress=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//x64专属</span></span><br><span class="line">	ULONG_PTR pRtlAddFunctionTable=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	ULONG_PTR uPspNotifyEnableMask = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//物理页帧数据库</span></span><br><span class="line">	ULONG_PTR uMmpfnDatabase = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//原型PTE的偏移</span></span><br><span class="line">	ULONG_PTR uOriginPte=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ULONG_PTR uLdrFirstCall = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ssdt</span></span><br><span class="line">	ULONG_PTR pKeServiceDescriptorTable = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//c++单例设计模式</span></span><br><span class="line">	<span class="function"><span class="type">static</span> Global* <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> Global* m_pInstance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Global.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Global* Global::m_pInstance;</span><br><span class="line"></span><br><span class="line"><span class="function">Global* <span class="title">Global::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m_pInstance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		m_pInstance = (Global*)<span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, <span class="built_in">sizeof</span>(Global), <span class="string">&#x27;Inst&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m_pInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//utils.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntimage.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Hde/hde64.h&quot;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable: 4201)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_HOOK_COUNT 0x100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="type">uint64_t</span> = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">uint16_t</span> = <span class="type">unsigned</span> <span class="type">short</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">uint8_t</span> = <span class="type">unsigned</span> <span class="type">char</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SYSTEM_MODULE</span> </span><br><span class="line">&#123;</span><br><span class="line">    ULONG_PTR Reserved[<span class="number">2</span>];</span><br><span class="line">    PVOID Base;</span><br><span class="line">    ULONG Size;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    USHORT Index;</span><br><span class="line">    USHORT Unknown;</span><br><span class="line">    USHORT LoadCount;</span><br><span class="line">    USHORT ModuleNameOffset;</span><br><span class="line">    CHAR ImageName[<span class="number">256</span>];</span><br><span class="line">&#125; SYSTEM_MODULE, *PSYSTEM_MODULE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SYSTEM_MODULE_INFORMATION</span> </span><br><span class="line">&#123;</span><br><span class="line">    ULONG_PTR ulModuleCount;</span><br><span class="line">    SYSTEM_MODULE Modules[<span class="number">1</span>];</span><br><span class="line">&#125; SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_OBJECT_TYPE_INITIALIZER</span> </span><br><span class="line">&#123;</span><br><span class="line">    UINT16 Length;</span><br><span class="line">    <span class="keyword">union</span> </span><br><span class="line">    &#123;</span><br><span class="line">        UINT8 ObjectTypeFlags;</span><br><span class="line">        <span class="keyword">struct</span> </span><br><span class="line">        &#123;</span><br><span class="line">            UINT8 CaseInsensitive : <span class="number">1</span>;</span><br><span class="line">            UINT8 UnnamedObjectsOnly : <span class="number">1</span>;</span><br><span class="line">            UINT8 UseDefaultObject : <span class="number">1</span>;</span><br><span class="line">            UINT8 SecurityRequired : <span class="number">1</span>;</span><br><span class="line">            UINT8 MaintainHandleCount : <span class="number">1</span>;</span><br><span class="line">            UINT8 MaintainTypeList : <span class="number">1</span>;</span><br><span class="line">            UINT8 SupportsObjectCallbacks : <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    UINT32 ObjectTypeCode;</span><br><span class="line">    UINT32 InvalidAttributes;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_GENERIC_MAPPING</span> GenericMapping;</span><br><span class="line">    UINT32 ValidAccessMask;</span><br><span class="line">    UINT32 RetainAccess;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">POOL_TYPE</span> PoolType;</span><br><span class="line">    UINT32 DefaultPagedPoolCharge;</span><br><span class="line">    UINT32 DefaultNonPagedPoolCharge;</span><br><span class="line">    PVOID DumpProcedure;</span><br><span class="line">    PVOID OpenProcedure;</span><br><span class="line">    PVOID CloseProcedure;</span><br><span class="line">    PVOID DeleteProcedure;</span><br><span class="line">    PVOID ParseProcedure;</span><br><span class="line">    PVOID SecurityProcedure;</span><br><span class="line">    PVOID QueryNameProcedure;</span><br><span class="line">    PVOID OkayToCloseProcedure;</span><br><span class="line">&#125; OBJECT_TYPE_INITIALIZER, *POBJECT_TYPE_INITIALIZER;</span><br><span class="line"><span class="comment">//OBJECT_TYPE基本没怎么变过</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_MOBJECT_TYPE</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> TypeList;                <span class="comment">//0x0</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING</span> Name;                <span class="comment">//0x10   </span></span><br><span class="line">    VOID* DefaultObject;                        <span class="comment">//0x20</span></span><br><span class="line">    UCHAR Index;                                <span class="comment">//0x28</span></span><br><span class="line">    ULONG TotalNumberOfObjects;                 <span class="comment">//0x2c</span></span><br><span class="line">    ULONG TotalNumberOfHandles;                 <span class="comment">//0x30</span></span><br><span class="line">    ULONG HighWaterNumberOfObjects;             <span class="comment">//0x34</span></span><br><span class="line">    ULONG HighWaterNumberOfHandles;             <span class="comment">//0x38</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_OBJECT_TYPE_INITIALIZER</span> TypeInfo;   <span class="comment">//0x40</span></span><br><span class="line">    EX_PUSH_LOCK TypeLock;                      <span class="comment">//0xb0</span></span><br><span class="line">    ULONG Key;                                  <span class="comment">//0xb8</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> CallbackList;            <span class="comment">//0xc0</span></span><br><span class="line">&#125; MOBJECT_TYPE, *PMOBJECT_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">ZwQuerySystemInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD32 systemInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID systemInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG systemInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    PULONG returnLength)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_HOOK_INFO_</span> &#123;</span><br><span class="line"></span><br><span class="line">    HANDLE hook_pid; </span><br><span class="line">    <span class="type">void</span>* ori_hook_addr;</span><br><span class="line">    <span class="type">void</span>* target_hook_addr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> old_bytes[<span class="number">14</span>]; <span class="comment">//一般是FF 25 00 00 00 00 JMP 因此损坏14个字节 保存方便恢复</span></span><br><span class="line"></span><br><span class="line">&#125; HOOK_INFO, *PHOOK_INFO;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> Utils* m_Instance;</span><br><span class="line">    <span class="function"><span class="type">static</span> Utils* <span class="title">fn_get_instance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">fn_get_os_build_number</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取指定获取系统模块的基质</span></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">fn_get_moudle_address</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">unsigned</span> <span class="type">long</span>* size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">fn_find_pattern</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> size, <span class="type">const</span> <span class="type">char</span>* pattern, <span class="type">const</span> <span class="type">char</span>* mask)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">fn_find_pattern_image</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr, <span class="type">const</span> <span class="type">char</span>* pattern, <span class="type">const</span> <span class="type">char</span>* mask, <span class="type">const</span> <span class="type">char</span>* name)</span></span>;</span><br><span class="line">    <span class="comment">//获取镜像基质</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">fn_get_image_address</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr, <span class="type">const</span> <span class="type">char</span>* name, <span class="type">unsigned</span> <span class="type">long</span>* size)</span></span>;</span><br><span class="line">    <span class="comment">//获取ObjetType通过名字</span></span><br><span class="line">    <span class="function">POBJECT_TYPE <span class="title">fn_get_type_by_name</span><span class="params">(<span class="type">wchar_t</span>* name)</span></span>;</span><br><span class="line">    <span class="comment">//内核内联Hook(PG)</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">fn_hook_by_address</span><span class="params">(<span class="type">void</span>** ori_func_addr, <span class="type">void</span>* target_func_addr)</span></span>;</span><br><span class="line">    <span class="comment">//移除内核内联Hook</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">fn_remove_hook_by_address</span><span class="params">(<span class="type">void</span>* ori_func_addr)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">uint64_t</span> m_count;</span><br><span class="line">    <span class="type">uint8_t</span>* m_tramp_line;     <span class="comment">//存放蹦床的</span></span><br><span class="line">    <span class="type">uint64_t</span> m_tramp_line_used; </span><br><span class="line">    </span><br><span class="line">    HOOK_INFO m_hook_info_table[MAX_HOOK_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模式匹配</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">fn_pattern_check</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, <span class="type">const</span> <span class="type">char</span>* pattern, <span class="type">const</span> <span class="type">char</span>* mask)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fn_logger</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* log_str, <span class="type">bool</span> is_err, <span class="type">long</span> err_code)</span></span>;</span><br><span class="line">    <span class="function">KIRQL <span class="title">fn_wp_bit_off</span><span class="params">()</span></span>;<span class="comment">//强制读写开启</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fn_wp_bit_on</span><span class="params">(KIRQL irql)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">fn_tramp_line_init</span><span class="params">(<span class="type">void</span>* ret_address, <span class="type">uint64_t</span> break_bytes_count, <span class="type">unsigned</span> <span class="type">char</span>* break_bytes)</span></span>;<span class="comment">//初始化蹦床</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PageAttrHide.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_ZERO_ACCESS         0  <span class="comment">// this value is not used.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_READONLY            1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_EXECUTE             2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_EXECUTE_READ        3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_READWRITE           4  <span class="comment">// bit 2 is set if this is writable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_WRITECOPY           5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_EXECUTE_READWRITE   6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_EXECUTE_WRITECOPY   7</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_NOCACHE            0x8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_GUARD_PAGE         0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_DECOMMIT           0x10   <span class="comment">// NO_ACCESS, Guard page</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_NOACCESS           0x18   <span class="comment">// NO_ACCESS, Guard_page, nocache.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_UNKNOWN_PROTECTION 0x100  <span class="comment">// bigger than 5 bits!</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PageAttrHide&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> ULONG_PTR uMmpfnSize = <span class="number">0x30</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">PteTable</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//传入的线性地址</span></span><br><span class="line">		ULONG_PTR pLineAddr;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取的</span></span><br><span class="line">		ULONG_PTR Pte;</span><br><span class="line">		ULONG_PTR Pde;</span><br><span class="line">		ULONG_PTR PdPte;</span><br><span class="line">		ULONG_PTR Pml4e;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//软件解析PTE</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_MMPTE_SOFTWARE</span>              <span class="comment">// 13 elements, 0x8 bytes (sizeof) </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Valid : <span class="number">1</span>;                 <span class="comment">// 0 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       PageFileReserved : <span class="number">1</span>;      <span class="comment">// 1 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       PageFileAllocated : <span class="number">1</span>;     <span class="comment">// 2 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       ColdPage : <span class="number">1</span>;              <span class="comment">// 3 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       SwizzleBit : <span class="number">1</span>;            <span class="comment">// 4 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Protection : <span class="number">5</span>;            <span class="comment">// 5 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Prototype : <span class="number">1</span>;             <span class="comment">// 10 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Transition : <span class="number">1</span>;            <span class="comment">// 11 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       PageFileLow : <span class="number">4</span>;           <span class="comment">// 12 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       UsedPageTableEntries : <span class="number">10</span>; <span class="comment">// 16 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       ShadowStack : <span class="number">1</span>;           <span class="comment">// 26 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Unused : <span class="number">5</span>;                <span class="comment">// 27 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       PageFileHigh : <span class="number">32</span>;         <span class="comment">// 32 BitPosition                  </span></span><br><span class="line">	&#125;MMPTE_SOFTWARE, * PMMPTE_SOFTWARE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//硬件解析PTE</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_MMPTE_HARDWARE</span>            <span class="comment">// 18 elements, 0x8 bytes (sizeof) </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Valid : <span class="number">1</span>;               <span class="comment">// 0 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Dirty1 : <span class="number">1</span>;              <span class="comment">// 1 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Owner : <span class="number">1</span>;               <span class="comment">// 2 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       WriteThrough : <span class="number">1</span>;        <span class="comment">// 3 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       CacheDisable : <span class="number">1</span>;        <span class="comment">// 4 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Accessed : <span class="number">1</span>;            <span class="comment">// 5 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Dirty : <span class="number">1</span>;               <span class="comment">// 6 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       LargePage : <span class="number">1</span>;           <span class="comment">// 7 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Global : <span class="number">1</span>;              <span class="comment">// 8 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       CopyOnWrite : <span class="number">1</span>;         <span class="comment">// 9 BitPosition                   </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Unused : <span class="number">1</span>;              <span class="comment">// 10 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       Write : <span class="number">1</span>;               <span class="comment">// 11 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       PageFrameNumber : <span class="number">36</span>;    <span class="comment">// 12 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       ReservedForHardware : <span class="number">4</span>; <span class="comment">// 48 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       ReservedForSoftware : <span class="number">4</span>; <span class="comment">// 52 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       WsleAge : <span class="number">4</span>;             <span class="comment">// 56 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       WsleProtection : <span class="number">3</span>;      <span class="comment">// 60 BitPosition                  </span></span><br><span class="line">		<span class="comment">/*0x000*/</span>     UINT64       NoExecute : <span class="number">1</span>;           <span class="comment">// 63 BitPosition                  </span></span><br><span class="line">	&#125;MMPTE_HARDWARE, * PMMPTE_HARDWARE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">ULONG_PTR <span class="title">GetPteBase</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">GetLineAddrPteTable</span><span class="params">(_Inout_ PteTable* Table)</span></span>;</span><br><span class="line">	<span class="comment">//改变0x1000范围内线性地址的VAD属性</span></span><br><span class="line">	<span class="comment">//修改原型PTE, 不影响真正的PTE,但是无法通过API读写执行检查</span></span><br><span class="line">	<span class="function"><span class="type">void</span>  <span class="title">ChangeVadAttributes</span><span class="params">(ULONG_PTR uAddr, UINT32 Attributes, HANDLE ProcessId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PageAttrHide.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PageAttrHide.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> PageAttrHide;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过页表自定位来确定PTEBASE</span></span><br><span class="line"><span class="comment">//遍历PML4E,找到其指向CR3的下标 左移39位 | 0xFFFF 0000 0000 0000就是PTEBASE</span></span><br><span class="line"><span class="comment">//为什么这样?</span></span><br><span class="line"><span class="comment">//解释起来很复杂 要首先按照映射的思想</span></span><br><span class="line"><span class="comment">//最后到PML4E </span></span><br><span class="line"><span class="function">ULONG_PTR <span class="title">PageAttrHide::GetPteBase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UINT64 cr3=__readcr3();</span><br><span class="line"></span><br><span class="line">	PHYSICAL_ADDRESS _cr3;</span><br><span class="line"></span><br><span class="line">	_cr<span class="number">3.</span>QuadPart = cr3;</span><br><span class="line"></span><br><span class="line">	UINT64* pml4e_va=(UINT64*)<span class="built_in">MmGetVirtualForPhysical</span>(_cr3);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//DbgBreakPoint();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//其实Cr3本质上是PML4E的指针,但是因为Windows为了方便,就在这PML4E数组里面有cr3</span></span><br><span class="line">	<span class="comment">//所以找到PML4E指向cr3的index</span></span><br><span class="line">	UINT64 index = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//512</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">		UINT64 Pte = *(pml4e_va+i);</span><br><span class="line"></span><br><span class="line">		Pte &amp;= <span class="number">0xFFFFFFFFF000</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Pte == cr3) &#123;</span><br><span class="line">			<span class="comment">//找到PML4E Index 直接左移39位就是PTEBASE</span></span><br><span class="line"></span><br><span class="line">			index = i;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;Num==0x%d&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//DbgPrintEx(77, 0, &quot;PML4E Phyaddr:0x%x cr3=0x%x\r\n&quot;, Pte,cr3);</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:fatal err, cr3 err\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	UINT64 PteBase =  (index + <span class="number">0x1FFFE00</span>) &lt;&lt; <span class="number">39</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//DbgPrintEx(77, 0, &quot;[OxygenDriver]info: PteBase=0x%p\r\n&quot;, PteBase);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> PteBase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PageAttrHide::GetLineAddrPteTable</span><span class="params">(_Inout_ PteTable* Table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//首先获取PteBase</span></span><br><span class="line">	ULONG_PTR PteBase=<span class="built_in">GetPteBase</span>();</span><br><span class="line"></span><br><span class="line">	UINT64 LineAddr = Table-&gt;pLineAddr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//&gt;&gt;12第几个Pte  &lt;&lt;3代表8个字节</span></span><br><span class="line"></span><br><span class="line">	PteBase &amp;= <span class="number">0x0000FFFFFFFFFFFF</span>; <span class="comment">//先清除前16位</span></span><br><span class="line"></span><br><span class="line">	Table-&gt;Pte = ((LineAddr &gt;&gt; <span class="number">12</span>)&lt;&lt;<span class="number">3</span>) + PteBase;</span><br><span class="line"></span><br><span class="line">	Table-&gt;Pde = ((Table-&gt;Pte &gt;&gt; <span class="number">12</span>) &lt;&lt; <span class="number">3</span>) + PteBase;</span><br><span class="line"></span><br><span class="line">	Table-&gt;PdPte = ((Table-&gt;Pde &gt;&gt; <span class="number">12</span>) &lt;&lt; <span class="number">3</span>) + PteBase;</span><br><span class="line"></span><br><span class="line">	Table-&gt;Pml4e = ((Table-&gt;PdPte &gt;&gt; <span class="number">12</span>) &lt;&lt; <span class="number">3</span>) + PteBase;</span><br><span class="line"></span><br><span class="line">	Table-&gt;Pte |= <span class="number">0xFFFF000000000000</span>;</span><br><span class="line"></span><br><span class="line">	Table-&gt;Pde |= <span class="number">0xFFFF000000000000</span>;</span><br><span class="line"></span><br><span class="line">	Table-&gt;PdPte |= <span class="number">0xFFFF000000000000</span>;</span><br><span class="line"></span><br><span class="line">	Table-&gt;Pml4e |= <span class="number">0xFFFF000000000000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//DbgPrintEx(77, 0, &quot;vPte=0x%p,vPde=0x%p,vPdpte=0x%p,vPml4e=0x%p\r\n&quot;, Table-&gt;Pte, Table-&gt;Pde, Table-&gt;PdPte, Table-&gt;Pml4e);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4189)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PageAttrHide::ChangeVadAttributes</span><span class="params">(ULONG_PTR uAddr,UINT32 Attributes,HANDLE ProcessId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	UINT64 phPteIndex;</span><br><span class="line">	PteTable Table;</span><br><span class="line">	Table.pLineAddr = uAddr;</span><br><span class="line">	ULONG_PTR uOrginPte = Global::<span class="built_in">GetInstance</span>()-&gt;uOriginPte;</span><br><span class="line">	PEPROCESS Process = <span class="number">0</span>;</span><br><span class="line">	KAPC_STATE Apc = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//修改进程要进行挂靠</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(<span class="built_in">PsLookupProcessByProcessId</span>(ProcessId, &amp;Process))) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:Failed to get process to change page attributes\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">KeStackAttachProcess</span>(Process, &amp;Apc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//有可能找不到</span></span><br><span class="line">	<span class="keyword">if</span>(!uOrginPte)</span><br><span class="line">	uOrginPte = <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这个地方出错了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ULONG_PTR MmPfnDataBase = *(ULONG_PTR*)(Global::<span class="built_in">GetInstance</span>()-&gt;uMmpfnDatabase);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//x64 mmpfn 大小 0x30</span></span><br><span class="line">	<span class="comment">//OriginalPte 在0x28偏移处</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">GetLineAddrPteTable</span>(&amp;Table);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取物理地址</span></span><br><span class="line">	phPteIndex = *(UINT64*)(Table.Pte);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取物理地址索引</span></span><br><span class="line">	phPteIndex &amp;= <span class="number">0x0000fffffffff000</span>;</span><br><span class="line">	phPteIndex =phPteIndex&gt;&gt; <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//解析原型PTE</span></span><br><span class="line">	MMPTE_SOFTWARE* pOriginPte = (MMPTE_SOFTWARE*)(MmPfnDataBase + uMmpfnSize * phPteIndex + uOrginPte);</span><br><span class="line">	<span class="comment">//修改属性</span></span><br><span class="line">	pOriginPte-&gt;Protection = Attributes;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">KeUnstackDetachProcess</span>(&amp;Apc);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//logger.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">logger_info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* sz_info, <span class="type">bool</span> is_error, ULONG err_code)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//logger.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logger_info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* sz_info, <span class="type">bool</span> is_error, ULONG err_code)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_error) <span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[inst_callback_err]:%s err_code:%x\r\n&quot;</span>, sz_info, err_code);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[inst_callback_info]:%s\r\n&quot;</span>, sz_info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;instcallbackasm.asm</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line"></span><br><span class="line">get_rip proc</span><br><span class="line">    call $0</span><br><span class="line">$0:</span><br><span class="line">    pop rax</span><br><span class="line">    ret</span><br><span class="line">get_rip endp</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//instcallback_Gemini.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntimage.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ia32.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PageAttrHide.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Hde/hde64.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntdef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用特定警告</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable : 4838)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable : 4309)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针类型定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">UINT64</span><span class="params">(__stdcall* f_GetProcAddress)</span><span class="params">(UINT64, <span class="type">const</span> <span class="type">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">UINT64</span><span class="params">(__stdcall* f_LoadLibraryA)</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">UINT64</span><span class="params">(__stdcall* f_RtlAddFunctionTable)</span><span class="params">(<span class="type">const</span> <span class="type">void</span>*, DWORD, DWORD64)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动映射所需数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_Manual_Mapping_data</span> &#123;</span><br><span class="line">    DWORD dwReadson;                  <span class="comment">// 保留字段</span></span><br><span class="line">    f_GetProcAddress pGetProcAddress; <span class="comment">// GetProcAddress函数指针</span></span><br><span class="line">    f_LoadLibraryA pLoadLibraryA;     <span class="comment">// LoadLibraryA函数指针</span></span><br><span class="line">    f_RtlAddFunctionTable pRtlAddFunctionTable; <span class="comment">// RtlAddFunctionTable函数指针</span></span><br><span class="line">    PVOID pBase;                      <span class="comment">// DLL映射基地址</span></span><br><span class="line">    ULONG reservedParam;              <span class="comment">// 保留参数</span></span><br><span class="line">    BOOLEAN bContinue;                <span class="comment">// 映射是否继续</span></span><br><span class="line">    BOOLEAN bStart;                   <span class="comment">// 映射是否启动</span></span><br><span class="line">    BOOLEAN bFirst;                   <span class="comment">// 是否首次映射</span></span><br><span class="line">    SIZE_T DllSize;                   <span class="comment">// DLL总大小</span></span><br><span class="line">    BOOLEAN bEnableChange;            <span class="comment">// 是否启用内存属性修改</span></span><br><span class="line">&#125; Manual_Mapping_data, * PManual_Mapping_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数指针（后续会赋值为内核中获取的用户态函数地址）</span></span><br><span class="line">UINT64 g_fnLoadLibraryA[] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">UINT64 g_fnGetProcAddress[] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">UINT64 g_fnAddFunctionTable[] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSYSAPI</span></span><br><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function">NTAPI</span></span><br><span class="line"><span class="function"><span class="title">ZwSetInformationProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    __in HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    __in PROCESSINFOCLASS ProcessInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">    __in_bcount(ProcessInformationLength) PVOID ProcessInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">    __in ULONG ProcessInformationLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS NTAPI <span class="title">MmCopyVirtualMemory</span><span class="params">(PEPROCESS SourceProcess, PVOID SourceAddress, PEPROCESS TargetProcess, PVOID TargetAddress, SIZE_T BufferSize, KPROCESSOR_MODE PreviousMode, PSIZE_T ReturnSize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShellCode回调函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">ShellCode</span><span class="params">(Manual_Mapping_data* pData)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">uint64_t</span> <span class="title">get_rip</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;HideMemory.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存映射的shellcode</span></span><br><span class="line"><span class="comment">// 回调 Shellcode 定义</span></span><br><span class="line"><span class="comment">// 这里的汇编代码负责保存寄存器环境，调用我们的Payload，然后恢复环境并跳回</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g_InstCallBackShellCode[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x51</span>, <span class="comment">// push rcx</span></span><br><span class="line">    <span class="number">0x52</span>, <span class="comment">// push rdx</span></span><br><span class="line">    <span class="number">0x53</span>, <span class="comment">// push rbx</span></span><br><span class="line">    <span class="number">0x55</span>, <span class="comment">// push rbp</span></span><br><span class="line">    <span class="number">0x56</span>, <span class="comment">// push rsi</span></span><br><span class="line">    <span class="number">0x57</span>, <span class="comment">// push rdi</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x50</span>, <span class="comment">// push r8</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x51</span>, <span class="comment">// push r9</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x52</span>, <span class="comment">// push r10</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x53</span>, <span class="comment">// push r11</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x54</span>, <span class="comment">// push r12</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x55</span>, <span class="comment">// push r13</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x56</span>, <span class="comment">// push r14</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x57</span>, <span class="comment">// push r15</span></span><br><span class="line">    <span class="comment">// 上面都是保存寄存器</span></span><br><span class="line">    <span class="comment">// sub rsp, 0x20 (Shadow Space)</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xEC</span>, <span class="number">0x28</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 00000217F568001 | 48:83EC 20 | sub rsp, 0x20</span></span><br><span class="line">    <span class="comment">// Call ShellCode 进行重定位</span></span><br><span class="line">    <span class="comment">// mov rcx, 重定位数据 (ManualMapData 指针)</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0xB9</span>, <span class="number">0x11</span>, <span class="number">0x11</span>, <span class="number">0x11</span>, <span class="number">0x11</span>, <span class="number">0x11</span>, <span class="number">0x11</span>, <span class="number">0x11</span>, <span class="number">0x11</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call 地址 (ShellCode 函数地址)</span></span><br><span class="line">    <span class="number">0xFF</span>, <span class="number">0x15</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add rsp, 0x20</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xC4</span>, <span class="number">0x28</span>,</span><br><span class="line">    <span class="comment">// pop 寄存器</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x5F</span>, <span class="comment">// pop r15</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x5E</span>, <span class="comment">// pop r14</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x5D</span>, <span class="comment">// pop r13</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x5C</span>, <span class="comment">// pop r12</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x5B</span>, <span class="comment">// pop r11</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x5A</span>, <span class="comment">// pop r10</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x59</span>, <span class="comment">// pop r9</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x58</span>, <span class="comment">// pop r8</span></span><br><span class="line">    <span class="number">0x5F</span>, <span class="comment">// pop rdi</span></span><br><span class="line">    <span class="number">0x5E</span>, <span class="comment">// pop rsi</span></span><br><span class="line">    <span class="number">0x5D</span>, <span class="comment">// pop rbp</span></span><br><span class="line">    <span class="number">0x5B</span>, <span class="comment">// pop rbx</span></span><br><span class="line">    <span class="number">0x5A</span>, <span class="comment">// pop rdx</span></span><br><span class="line">    <span class="number">0x59</span>, <span class="comment">// pop rcx</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0xFF</span>, <span class="number">0xE2</span>, <span class="comment">// jmp r10 返回 (Instrumentation Callback 机制通常需要跳回 r10)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 71个 绝对地址在这个地方 (占位符)</span></span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X64 0x8664</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86 0x14c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 Instrumentation Callback</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">inst_callback_set_callback</span><span class="params">(PVOID inst_callback)</span> </span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    PACCESS_TOKEN Token = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PULONG TokenMask = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PVOID InstCallBack = inst_callback; <span class="comment">// instcallback地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前进程令牌</span></span><br><span class="line">    Token = <span class="built_in">PsReferencePrimaryToken</span>(<span class="built_in">IoGetCurrentProcess</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置调试位</span></span><br><span class="line">    <span class="comment">// 这里的偏移 0x40 依赖于特定的 Windows 版本 (EPROCESS/TOKEN 结构)</span></span><br><span class="line">    TokenMask = (PULONG)((ULONG_PTR)Token + <span class="number">0x40</span>);</span><br><span class="line">    <span class="comment">// 21位是DEBUG权限 (位20)</span></span><br><span class="line">    TokenMask[<span class="number">0</span>] |= <span class="number">0x100000</span>;</span><br><span class="line">    TokenMask[<span class="number">1</span>] |= <span class="number">0x100000</span>;</span><br><span class="line">    TokenMask[<span class="number">2</span>] |= <span class="number">0x100000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 InstCallBack</span></span><br><span class="line">    <span class="comment">// 利用 ZwSetInformationProcess 调用 ProcessInstrumentationCallback 类</span></span><br><span class="line">    status = <span class="built_in">ZwSetInformationProcess</span>(<span class="built_in">NtCurrentProcess</span>(), ProcessInstrumentationCallback, &amp;InstCallBack, <span class="built_in">sizeof</span>(InstCallBack)); <span class="comment">// [补全] Size通常是指针大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) <span class="built_in">logger_info</span>(<span class="string">&quot;failed to set instcall back&quot;</span>, <span class="literal">true</span>, status);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">logger_info</span>(<span class="string">&quot;set instcall back success&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// R0环打开文件流，读取DLL到内存</span></span><br><span class="line"><span class="function">PUCHAR <span class="title">inst_callback_get_dll_memory</span><span class="params">(PUNICODE_STRING us_dll_path)</span> </span>&#123;</span><br><span class="line">    HANDLE hFile = <span class="number">0</span>;</span><br><span class="line">    OBJECT_ATTRIBUTES objattr;</span><br><span class="line">    IO_STATUS_BLOCK IoStatusBlock = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    LARGE_INTEGER lainter = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    FILE_STANDARD_INFORMATION fileinfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ULONG FileSize = <span class="number">0</span>;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    PUCHAR pDllMemory = <span class="number">0</span>;</span><br><span class="line">    LARGE_INTEGER byteoffset = &#123; <span class="number">0</span> &#125;; <span class="comment">// 读取文件的偏移开始</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Attributes</span></span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(&amp;objattr, us_dll_path, <span class="number">0x40</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    status = <span class="built_in">ZwCreateFile</span>(&amp;hFile, GENERIC_WRITE | GENERIC_READ, &amp;objattr, &amp;IoStatusBlock, <span class="number">0</span>, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// [补全] 常用参数补全</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to create file&quot;</span>, <span class="literal">true</span>, status);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">    status = <span class="built_in">ZwQueryInformationFile</span>(hFile, &amp;IoStatusBlock, &amp;fileinfo, <span class="built_in">sizeof</span>(fileinfo), FileStandardInformation);</span><br><span class="line">    FileSize = (ULONG)fileinfo.AllocationSize.QuadPart;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to get file size&quot;</span>, <span class="literal">true</span>, status);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存对齐</span></span><br><span class="line">    FileSize += <span class="number">0x1000</span>;</span><br><span class="line">    FileSize = (UINT64)<span class="built_in">PAGE_ALIGN</span>(FileSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配分页内存池</span></span><br><span class="line">    pDllMemory = (PUCHAR)<span class="built_in">ExAllocatePoolWithTag</span>(PagedPool, FileSize, <span class="string">&#x27;Dllp&#x27;</span>);</span><br><span class="line">    <span class="built_in">RtlSecureZeroMemory</span>(pDllMemory, FileSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件内容</span></span><br><span class="line">    status = <span class="built_in">ZwReadFile</span>(hFile, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;IoStatusBlock, pDllMemory, FileSize, &amp;byteoffset, <span class="literal">NULL</span>); <span class="comment">// [补全] 最后一个参数 Key 通常为 NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新一下 不然要等待</span></span><br><span class="line">    <span class="built_in">ZwFlushBuffersFile</span>(hFile, &amp;IoStatusBlock);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">ExFreePool</span>(pDllMemory);</span><br><span class="line">        <span class="built_in">ZwClose</span>(hFile);</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to read file content&quot;</span>, <span class="literal">true</span>, status);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ZwClose</span>(hFile);</span><br><span class="line">    <span class="keyword">return</span> pDllMemory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在目标进程中分配内存 将未重定位dll映射进去</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">inst_callback_alloc_memory</span><span class="params">(PUCHAR p_dll_memory, OUT PVOID* inst_callback_addr, OUT PVOID* p_manual_data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 已经挂靠了 (上下文暗示外部已经 KeStackAttachProcess)</span></span><br><span class="line">    IMAGE_NT_HEADERS* pNtHeader = <span class="literal">nullptr</span>;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER* pOptHeader = <span class="literal">nullptr</span>;</span><br><span class="line">    IMAGE_FILE_HEADER* pFileHeader = <span class="literal">nullptr</span>;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    Manual_Mapping_data ManualMapData&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">char</span>* pStartMapAddr = <span class="literal">nullptr</span>; <span class="comment">// R3 Dll从PE头开始的地址</span></span><br><span class="line">    <span class="type">size_t</span> AllocSize = <span class="number">0</span>, RetSize;</span><br><span class="line">    PEPROCESS Process&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PVOID pManualMapData = <span class="number">0</span>, pShellCode = <span class="number">0</span>; <span class="comment">// 分配的内存，一个是映射结构地址，一个是ShellCode地址</span></span><br><span class="line">    <span class="type">size_t</span> DllSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证 DOS Header Magic</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">reinterpret_cast</span>&lt;IMAGE_DOS_HEADER*&gt;(p_dll_memory)-&gt;e_magic != <span class="number">0x5A4D</span>) &#123;</span><br><span class="line">        status = STATUS_INVALID_PARAMETER; <span class="comment">// [补全]</span></span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;the dll is not an valid file structure&quot;</span>, <span class="literal">true</span>, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pNtHeader = (IMAGE_NT_HEADERS*)((ULONG_PTR)p_dll_memory + <span class="built_in">reinterpret_cast</span>&lt;IMAGE_DOS_HEADER*&gt;(p_dll_memory)-&gt;e_lfanew); <span class="comment">// [补全] e_lfanew</span></span><br><span class="line">    pFileHeader = &amp;pNtHeader-&gt;FileHeader;</span><br><span class="line">    pOptHeader = &amp;pNtHeader-&gt;OptionalHeader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pFileHeader-&gt;Machine != X64) &#123;</span><br><span class="line">        status = STATUS_NOT_SUPPORTED;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;the dll is x86 structure, not support&quot;</span>, <span class="literal">true</span>, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据PE头计算映像大小</span></span><br><span class="line">    AllocSize = pOptHeader-&gt;SizeOfImage;</span><br><span class="line">    <span class="comment">// 在当前进程(实际上是挂靠后的目标进程)分配内存</span></span><br><span class="line">    status = <span class="built_in">ZwAllocateVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), (PVOID*)&amp;pStartMapAddr, <span class="number">0</span>, &amp;AllocSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE); <span class="comment">// [补全] PAGE_EXECUTE_READWRITE</span></span><br><span class="line">    DllSize = AllocSize;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to alloc memory&quot;</span>, <span class="literal">true</span>, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(pStartMapAddr, <span class="number">0</span>, AllocSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 ManualMapData</span></span><br><span class="line">    ManualMapData.dwReadson = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 注意：这里的硬编码地址非常危险，通常仅用于特定环境测试</span></span><br><span class="line">    ManualMapData.pGetProcAddress = (f_GetProcAddress)g_fnGetProcAddress;</span><br><span class="line">    ManualMapData.pLoadLibraryA = (f_LoadLibraryA)g_fnLoadLibraryA;</span><br><span class="line">    ManualMapData.pRtlAddFunctionTable = (f_RtlAddFunctionTable)g_fnAddFunctionTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面几行是具体的硬编码地址，可能是作者调试时留下的</span></span><br><span class="line">    <span class="comment">// ManualMapData.pGetProcAddress = (f_GetProcAddress)0x00007FFD29C6AEC0;</span></span><br><span class="line">    <span class="comment">// ... (省略了被注释掉的硬编码)</span></span><br><span class="line"></span><br><span class="line">    ManualMapData.pBase = pStartMapAddr;</span><br><span class="line">    ManualMapData.reservedParam = <span class="number">0</span>;</span><br><span class="line">    ManualMapData.bContinue = <span class="number">0</span>;</span><br><span class="line">    ManualMapData.bStart = <span class="number">0</span>;</span><br><span class="line">    ManualMapData.bFirst = <span class="literal">true</span>;</span><br><span class="line">    ManualMapData.DllSize = AllocSize;</span><br><span class="line">    ManualMapData.bEnableChange = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入PE头进刚刚申请的空间</span></span><br><span class="line">    Process = <span class="built_in">IoGetCurrentProcess</span>();</span><br><span class="line">    status = <span class="built_in">MmCopyVirtualMemory</span>(Process, p_dll_memory, Process, pStartMapAddr, PAGE_SIZE, KernelMode, &amp;RetSize);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to write pe header!&quot;</span>, <span class="literal">true</span>, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写PE结构的各节区 (Sections)</span></span><br><span class="line">    IMAGE_SECTION_HEADER* pSectionHeader = <span class="built_in">IMAGE_FIRST_SECTION</span>(pNtHeader);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pFileHeader-&gt;NumberOfSections; i++, pSectionHeader++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pSectionHeader-&gt;SizeOfRawData) &#123;</span><br><span class="line">            <span class="comment">// 这一步将各节区的数据写入到虚拟地址，且已经对齐 FOV-&gt;RVA转换</span></span><br><span class="line">            <span class="comment">// [补全] 目标地址应为 pStartMapAddr + pSectionHeader-&gt;VirtualAddress</span></span><br><span class="line">            status = <span class="built_in">MmCopyVirtualMemory</span>(Process, p_dll_memory + pSectionHeader-&gt;PointerToRawData, Process, pStartMapAddr + pSectionHeader-&gt;VirtualAddress, pSectionHeader-&gt;SizeOfRawData, KernelMode, &amp;RetSize);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">                <span class="built_in">logger_info</span>(<span class="string">&quot;failed to write sections&quot;</span>, <span class="literal">true</span>, status);</span><br><span class="line">                <span class="keyword">return</span> status;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配 ManualMapData 的内存</span></span><br><span class="line">    AllocSize = PAGE_SIZE;</span><br><span class="line">    <span class="comment">// 将映射结构映射过去</span></span><br><span class="line">    status = <span class="built_in">ZwAllocateVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), &amp;pManualMapData, <span class="number">0</span>, &amp;AllocSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE); <span class="comment">// [补全]</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to alloc mem for manualdata&quot;</span>, <span class="literal">true</span>, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(pManualMapData, <span class="number">0</span>, AllocSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入 ManualMapData</span></span><br><span class="line">    status = <span class="built_in">MmCopyVirtualMemory</span>(Process, &amp;ManualMapData, Process, pManualMapData, <span class="built_in">sizeof</span>(ManualMapData), KernelMode, &amp;RetSize); <span class="comment">// [补全]</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to write mem for manualdata&quot;</span>, <span class="literal">true</span>, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AllocSize = PAGE_SIZE;</span><br><span class="line">    <span class="comment">// 分配 ShellCode 内存</span></span><br><span class="line">    status = <span class="built_in">ZwAllocateVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), &amp;pShellCode, <span class="number">0</span>, &amp;AllocSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE); <span class="comment">// [补全]</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to alloc mem for shellcode&quot;</span>, <span class="literal">true</span>, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(pShellCode, <span class="number">0</span>, AllocSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入 ShellCode (这里指的是Payload Shellcode，不是Callback Shellcode)</span></span><br><span class="line">    <span class="comment">// 注意：这里代码逻辑有点跳跃，似乎有个 ShellCode 变量在外部定义或传入</span></span><br><span class="line">    status = <span class="built_in">MmCopyVirtualMemory</span>(Process, ShellCode, Process, pShellCode, AllocSize, KernelMode, &amp;RetSize); <span class="comment">// ShellCode 可能是外部传入的函数指针或数组</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to write mem for shellcode&quot;</span>, <span class="literal">true</span>, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一切就绪，修改Inst Call的ShellCode (Runtime Patching)</span></span><br><span class="line">    *(PULONG64)&amp;g_InstCallBackShellCode[<span class="number">28</span>] = (UINT64)pManualMapData; <span class="comment">// 填入参数RCX</span></span><br><span class="line">    *(PULONG64)&amp;g_InstCallBackShellCode[<span class="number">79</span>] = (UINT64)pShellCode;     <span class="comment">// 填入Call的地址</span></span><br><span class="line">    g_InstCallBackShellCode[<span class="number">38</span>] = <span class="number">37</span>; <span class="comment">// FF 15 Call的偏移 (修改指令机器码，可能是修正相对/绝对调用)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请内存, 写入 Instrumentation Callback Hook Stub</span></span><br><span class="line">    AllocSize = PAGE_SIZE;</span><br><span class="line">    status = <span class="built_in">ZwAllocateVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), inst_callback_addr, <span class="number">0</span>, &amp;AllocSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE); <span class="comment">// [补全]</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to alloc mem for instcall shellcode&quot;</span>, <span class="literal">true</span>, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(*inst_callback_addr, <span class="number">0</span>, AllocSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入InstCallBack ShellCode</span></span><br><span class="line">    status = <span class="built_in">MmCopyVirtualMemory</span>(Process, g_InstCallBackShellCode, Process, *inst_callback_addr, <span class="built_in">sizeof</span>(g_InstCallBackShellCode), KernelMode, &amp;RetSize);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to write mem for instcall shellcode&quot;</span>, <span class="literal">true</span>, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *p_manual_data = pManualMapData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐藏属性 (VAD Hiding)</span></span><br><span class="line">    <span class="comment">// 这个太大了，要多次隐藏</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> index = <span class="number">0</span>; index &lt; DllSize; index += PAGE_SIZE)</span><br><span class="line">    PageAttrHide::<span class="built_in">ChangeVadAttributes</span>((UINT64)pStartMapAddr + index, MM_NOACCESS,<span class="literal">NULL</span>); <span class="comment">// 将映射的DLL内存设为不可访问以隐藏</span></span><br><span class="line">    PageAttrHide::<span class="built_in">ChangeVadAttributes</span>((UINT64)pManualMapData, MM_NOACCESS, <span class="literal">NULL</span>);</span><br><span class="line">    PageAttrHide::<span class="built_in">ChangeVadAttributes</span>((UINT64)pShellCode, MM_NOACCESS, <span class="literal">NULL</span>);</span><br><span class="line">    PageAttrHide::<span class="built_in">ChangeVadAttributes</span>((UINT64)*inst_callback_addr, MM_NOACCESS, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;pStartMapAddr:%llx, pManualMapData:%llx, pShellCode:%llx, inst_call_addr:%llx&quot;</span>, pStartMapAddr, pManualMapData, pShellCode, *inst_callback_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... (接上一部分 inst_callback_alloc_memory 函数末尾)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 注入主逻辑函数</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">inst_callback_inject</span><span class="params">(HANDLE process_id, <span class="type">wchar_t</span>* ws_dll_path)</span> </span>&#123;</span><br><span class="line">    PEPROCESS Process&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    KAPC_STATE Apc&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    UNICODE_STRING usR0DllPath = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PUCHAR pDllMem = <span class="number">0</span>;</span><br><span class="line">    PVOID InstCallBack = <span class="number">0</span>; <span class="comment">// 分配R3的InstCallBackShellCode地址</span></span><br><span class="line">    PVOID ManualData = <span class="number">0</span>;   <span class="comment">// R3分配的 ManualMapping_data 结构地址</span></span><br><span class="line"></span><br><span class="line">    status = <span class="built_in">PsLookupProcessByProcessId</span>(process_id, &amp;Process);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to get process&quot;</span>, <span class="literal">true</span>, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂靠进程，进行申请内存</span></span><br><span class="line">    <span class="built_in">KeStackAttachProcess</span>(Process, &amp;Apc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 把Dll路径复制过去 (构造UNICODE_STRING)</span></span><br><span class="line">        usR0DllPath.Buffer = (PWCH)ws_dll_path;</span><br><span class="line">        usR0DllPath.Length = (USHORT)(<span class="built_in">wcslen</span>(ws_dll_path) * <span class="number">2</span>);</span><br><span class="line">        usR0DllPath.MaximumLength = usR0DllPath.Length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Dll内存 (Read File)</span></span><br><span class="line">        pDllMem = <span class="built_in">inst_callback_get_dll_memory</span>(&amp;usR0DllPath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pDllMem) &#123;</span><br><span class="line">            status = STATUS_UNSUCCESSFUL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配dll内存，返回InstCallBack的shellcode地址</span></span><br><span class="line">        InstCallBack = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// [补全] 调用 alloc_memory，传入 pDllMem, 接收 InstCallBack 和 ManualData</span></span><br><span class="line">        status = <span class="built_in">inst_callback_alloc_memory</span>(pDllMem, &amp;InstCallBack, &amp;ManualData);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置完毕，进行设置InstCallBack (Hook)</span></span><br><span class="line">        status = <span class="built_in">inst_callback_set_callback</span>(InstCallBack);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断什么时候可以去掉CallBack</span></span><br><span class="line">    <span class="comment">// 驱动在这里等待 R3 ShellCode 开始执行 (bStart = true)</span></span><br><span class="line">    <span class="keyword">if</span> (ManualData &amp;&amp; <span class="built_in">MmIsAddressValid</span>(ManualData)) &#123;</span><br><span class="line">        <span class="comment">// [风险点] 这是一个死循环等待，如果ShellCode没执行，驱动会卡死线程</span></span><br><span class="line">        <span class="keyword">while</span> (!((Manual_Mapping_data*)ManualData)-&gt;bStart);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 卸载 CallBack (恢复为NULL或原始值，这里直接给0)</span></span><br><span class="line">        <span class="built_in">inst_callback_set_callback</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ManualData &amp;&amp; <span class="built_in">MmIsAddressValid</span>(ManualData)) &#123;</span><br><span class="line">            <span class="comment">// 执行为只可执行 (修改VAD属性防止被查)</span></span><br><span class="line">            <span class="comment">// DbgBreakPoint();</span></span><br><span class="line">            <span class="comment">// 同时抹除掉PE头的特征</span></span><br><span class="line">            *(PUCHAR)((((Manual_Mapping_data*)ManualData)-&gt;pBase)) = <span class="number">0</span>; <span class="comment">// [补全] 清零 PE Header Magic &quot;MZ&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// PVOID Base = ... (注释代码)</span></span><br><span class="line">            <span class="comment">// ZwProtectVirtualMemory ... (注释代码)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 可以继续执行了 (通知 ShellCode 继续执行 DllMain)</span></span><br><span class="line">            ((Manual_Mapping_data*)ManualData)-&gt;bContinue = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    <span class="keyword">if</span> (pDllMem &amp;&amp; <span class="built_in">MmIsAddressValid</span>(pDllMem)) <span class="built_in">ExFreePool</span>(pDllMem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除挂靠</span></span><br><span class="line">    <span class="built_in">KeUnstackDetachProcess</span>(&amp;Apc);</span><br><span class="line">    <span class="built_in">ObDereferenceObject</span>(Process); <span class="comment">// [补全] 减少引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------------</span></span><br><span class="line"><span class="comment">// ShellCode: 运行在目标进程(R3)环境中的Payload</span></span><br><span class="line"><span class="comment">// 负责：重定位、IAT修复、TLS、DllMain</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">ShellCode</span><span class="params">(Manual_Mapping_data* pData)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DbgBreakPoint();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pData-&gt;bFirst) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功 立刻设置 防止重入 (Instrumentation Callback 可能会被频繁触发)</span></span><br><span class="line">    pData-&gt;bFirst = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知驱动层：我已经开始运行了</span></span><br><span class="line">    pData-&gt;bStart = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* pBase = (<span class="type">char</span>*)(pData-&gt;pBase);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 PE 头</span></span><br><span class="line">    <span class="keyword">auto</span>* pOpt = &amp;<span class="built_in">reinterpret_cast</span>&lt;IMAGE_NT_HEADERS*&gt;(pBase + <span class="built_in">reinterpret_cast</span>&lt;IMAGE_DOS_HEADER*&gt;(pBase)-&gt;e_lfanew)-&gt;OptionalHeader; <span class="comment">// [补全]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 重定位表处理 (Base Relocations)</span></span><br><span class="line">    <span class="comment">// -----------------------------------------------------</span></span><br><span class="line">    <span class="type">char</span>* LocationDelta = pBase - pOpt-&gt;ImageBase; <span class="comment">// 计算实际加载地址与首选基址的差值</span></span><br><span class="line">    <span class="keyword">if</span> (LocationDelta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pOpt-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size) &#123;</span><br><span class="line">            <span class="comment">// [补全] 获取重定位表地址</span></span><br><span class="line">            <span class="keyword">auto</span>* pRelocData = <span class="built_in">reinterpret_cast</span>&lt;IMAGE_BASE_RELOCATION*&gt;(pBase + pOpt-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span>* pRelocEnd = <span class="built_in">reinterpret_cast</span>&lt;IMAGE_BASE_RELOCATION*&gt;(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(pRelocData) + pOpt-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size); <span class="comment">// [补全] 计算结束地址</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (pRelocData &lt; pRelocEnd &amp;&amp; pRelocData-&gt;SizeOfBlock) &#123;</span><br><span class="line">                <span class="comment">// 重定位的个数不包括IMAGE_BASE_RELOCATION这个地方</span></span><br><span class="line">                <span class="comment">// 重定位的偏移的大小是WORD (2字节)</span></span><br><span class="line">                UINT64 AmountOfEntries = (pRelocData-&gt;SizeOfBlock - <span class="built_in">sizeof</span>(IMAGE_BASE_RELOCATION)) / <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span>); <span class="comment">// [补全]</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 指向重定位数据的数组</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span>* pRelativeInfo = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">short</span>*&gt;(pRelocData + <span class="number">1</span>); <span class="comment">// +1 移动 sizeof(IMAGE_BASE_RELOCATION)</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (UINT64 i = <span class="number">0</span>; i != AmountOfEntries; ++i, ++pRelativeInfo) &#123;</span><br><span class="line">                    <span class="comment">// 遍历重定位表的TypeOffset</span></span><br><span class="line">                    <span class="comment">// 判断高4位 是否需要重定位 (通常是 IMAGE_REL_BASED_HIGHLOW 或 IMAGE_REL_BASED_DIR64)</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">RELOC_FLAG</span>(*pRelativeInfo)) &#123; <span class="comment">// 宏假设：取高4位</span></span><br><span class="line">                        <span class="comment">// 只有直接寻址才需要重定位</span></span><br><span class="line">                        <span class="comment">// pBase + RVA == 需要重定位页面</span></span><br><span class="line">                        <span class="comment">// 页面 + (TypeOffset &amp; 0xFFF) 就是要重定位的地址</span></span><br><span class="line">                        UINT_PTR* pPatch = <span class="built_in">reinterpret_cast</span>&lt;UINT_PTR*&gt;(pBase + pRelocData-&gt;VirtualAddress + (*pRelativeInfo &amp; <span class="number">0xFFF</span>)); <span class="comment">// [补全] Offset 低12位</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 所以我们要把这个地址加上真正装载地址减去ImageBase (LocationDelta)</span></span><br><span class="line">                        *pPatch += <span class="built_in">reinterpret_cast</span>&lt;UINT_PTR&gt;(LocationDelta);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 下一个重定位表 (SizeOfBlock 决定了块的大小)</span></span><br><span class="line">                pRelocData = <span class="built_in">reinterpret_cast</span>&lt;IMAGE_BASE_RELOCATION*&gt;(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(pRelocData) + pRelocData-&gt;SizeOfBlock); <span class="comment">// [补全] 指针偏移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 修复 IAT 表 (Import Address Table)</span></span><br><span class="line">    <span class="comment">// -----------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (pOpt-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size) &#123;</span><br><span class="line"></span><br><span class="line">        IMAGE_IMPORT_DESCRIPTOR* pImportDescr = (IMAGE_IMPORT_DESCRIPTOR*)(pBase + pOpt-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); <span class="comment">// [补全]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pImportDescr-&gt;Name) &#123;</span><br><span class="line">            <span class="comment">// Name是RVA 指向Dll名称</span></span><br><span class="line">            <span class="type">char</span>* szModName = (<span class="type">char</span>*)(pBase + pImportDescr-&gt;Name);</span><br><span class="line">            HMODULE hDll = (HMODULE)(pData-&gt;<span class="built_in">pLoadLibraryA</span>(szModName)); <span class="comment">// [补全] 使用传入的 LoadLibraryA 加载依赖模块</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// INT (Import Name Table / OriginalFirstThunk)</span></span><br><span class="line">            ULONG_PTR* pInt = (ULONG_PTR*)(pBase + pImportDescr-&gt;OriginalFirstThunk);</span><br><span class="line">            <span class="comment">// IAT (Import Address Table / FirstThunk)</span></span><br><span class="line">            ULONG_PTR* pIat = (ULONG_PTR*)(pBase + pImportDescr-&gt;FirstThunk);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!pInt) pInt = pIat; <span class="comment">// 有些编译器不生成 OriginalFirstThunk</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (; *pInt; ++pInt, ++pIat) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">IMAGE_SNAP_BY_ORDINAL</span>(*pInt)) &#123;</span><br><span class="line">                    <span class="comment">// 如果是序号填充 (Ordinal Import)</span></span><br><span class="line">                    *pIat = (ULONG_PTR)pData-&gt;<span class="built_in">pGetProcAddress</span>((UINT64)hDll, (<span class="type">char</span>*)(*pInt &amp; <span class="number">0xFFFF</span>)); <span class="comment">// [补全] 取低16位作为序号</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 按照名称填充 (Named Import)</span></span><br><span class="line">                    IMAGE_IMPORT_BY_NAME* pImport = (IMAGE_IMPORT_BY_NAME*)(pBase + (*pInt)); <span class="comment">// *pInt 是 RVA</span></span><br><span class="line">                    *pIat = (ULONG_PTR)pData-&gt;<span class="built_in">pGetProcAddress</span>((UINT64)hDll, pImport-&gt;Name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pImportDescr++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 填充 TLS 回调 (Thread Local Storage)</span></span><br><span class="line">    <span class="comment">// -----------------------------------------------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_PROCESS_ATTACH 1</span></span><br><span class="line">    <span class="keyword">if</span> (pOpt-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size) &#123;</span><br><span class="line">        <span class="keyword">auto</span>* pTLS = <span class="built_in">reinterpret_cast</span>&lt;IMAGE_TLS_DIRECTORY*&gt;(pBase + pOpt-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress); <span class="comment">// [补全]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意 这里要进行重定位 (TLS Callbacks 数组通常是 VA)</span></span><br><span class="line">        <span class="keyword">auto</span>* pCallback = <span class="built_in">reinterpret_cast</span>&lt;PIMAGE_TLS_CALLBACK*&gt;(pTLS-&gt;AddressOfCallBacks);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; pCallback &amp;&amp; *pCallback; ++pCallback) &#123;</span><br><span class="line">            <span class="comment">// 执行 TLS Callback</span></span><br><span class="line">            (*pCallback)((PVOID)pBase, DLL_PROCESS_ATTACH, <span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 修复 x64 下异常表 (Exception Directory) - 用于支持 C++ 异常处理</span></span><br><span class="line">    <span class="comment">// -----------------------------------------------------</span></span><br><span class="line">    <span class="keyword">auto</span> excep = pOpt-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION];</span><br><span class="line">    <span class="keyword">if</span> (excep.Size) &#123;</span><br><span class="line">        <span class="comment">// 注册动态函数表</span></span><br><span class="line">        pData-&gt;<span class="built_in">pRtlAddFunctionTable</span>(</span><br><span class="line">            (<span class="built_in">reinterpret_cast</span>&lt;IMAGE_RUNTIME_FUNCTION_ENTRY*&gt;(pBase + excep.VirtualAddress)), <span class="comment">// FunctionTable</span></span><br><span class="line">            excep.Size / <span class="built_in">sizeof</span>(IMAGE_RUNTIME_FUNCTION_ENTRY), <span class="comment">// EntryCount [补全]</span></span><br><span class="line">            (DWORD64)pBase <span class="comment">// BaseAddress [补全]</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 开始 设置，让驱动卸载掉 CallBack</span></span><br><span class="line">    <span class="comment">// -----------------------------------------------------</span></span><br><span class="line">    <span class="keyword">while</span> (!pData-&gt;bContinue); <span class="comment">// 自旋等待驱动层将 bContinue 设为 true (表示驱动已完成清理)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 DllMain 函数</span></span><br><span class="line">    <span class="comment">// pOpt-&gt;AddressOfEntryPoint 是 RVA</span></span><br><span class="line">    <span class="keyword">if</span> (pOpt-&gt;AddressOfEntryPoint) &#123;</span><br><span class="line">        ((f_DLL_ENTRY_POINT)(pBase + pOpt-&gt;AddressOfEntryPoint))((HINSTANCE)pBase, DLL_PROCESS_ATTACH, <span class="number">0</span>); <span class="comment">// [补全] 调用 DllMain</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//instcallback_Doubao.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntimage.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ia32.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PageAttrHide.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Hde/hde64.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wdm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntdef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用特定警告</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable : 4838)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable : 4309)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针类型定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">UINT64</span><span class="params">(__stdcall* f_GetProcAddress)</span><span class="params">(UINT64, <span class="type">const</span> <span class="type">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">UINT64</span><span class="params">(__stdcall* f_LoadLibraryA)</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">UINT64</span><span class="params">(__stdcall* f_RtlAddFunctionTable)</span><span class="params">(<span class="type">const</span> <span class="type">void</span>*, DWORD, DWORD64)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动映射所需数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_Manual_Mapping_data</span> &#123;</span><br><span class="line">    DWORD dwReadson;                  <span class="comment">// 保留字段</span></span><br><span class="line">    f_GetProcAddress pGetProcAddress; <span class="comment">// GetProcAddress函数指针</span></span><br><span class="line">    f_LoadLibraryA pLoadLibraryA;     <span class="comment">// LoadLibraryA函数指针</span></span><br><span class="line">    f_RtlAddFunctionTable pRtlAddFunctionTable; <span class="comment">// RtlAddFunctionTable函数指针</span></span><br><span class="line">    PVOID pBase;                      <span class="comment">// DLL映射基地址</span></span><br><span class="line">    ULONG reservedParam;              <span class="comment">// 保留参数</span></span><br><span class="line">    BOOLEAN bContinue;                <span class="comment">// 映射是否继续</span></span><br><span class="line">    BOOLEAN bStart;                   <span class="comment">// 映射是否启动</span></span><br><span class="line">    BOOLEAN bFirst;                   <span class="comment">// 是否首次映射</span></span><br><span class="line">    SIZE_T DllSize;                   <span class="comment">// DLL总大小</span></span><br><span class="line">    BOOLEAN bEnableChange;            <span class="comment">// 是否启用内存属性修改</span></span><br><span class="line">&#125; Manual_Mapping_data, * PManual_Mapping_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数指针（后续会赋值为内核中获取的用户态函数地址）</span></span><br><span class="line">UINT64 g_fnLoadLibraryA[] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">UINT64 g_fnGetProcAddress[] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">UINT64 g_fnAddFunctionTable[] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSYSAPI</span></span><br><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function">NTAPI</span></span><br><span class="line"><span class="function"><span class="title">ZwSetInformationProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    __in HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    __in PROCESSINFOCLASS ProcessInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">    __in_bcount(ProcessInformationLength) PVOID ProcessInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">    __in ULONG ProcessInformationLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS NTAPI <span class="title">MmCopyVirtualMemory</span><span class="params">(PEPROCESS SourceProcess, PVOID SourceAddress, PEPROCESS TargetProcess, PVOID TargetAddress, SIZE_T BufferSize, KPROCESSOR_MODE PreviousMode, PSIZE_T ReturnSize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShellCode回调函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">ShellCode</span><span class="params">(Manual_Mapping_data* pData)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调ShellCode（x64汇编指令，用于寄存器保护+重定位调用）</span></span><br><span class="line"><span class="type">char</span> g_InstCallBackShellCode[] = &#123;</span><br><span class="line">    <span class="comment">// 保存通用寄存器</span></span><br><span class="line">    <span class="number">0x51</span>, <span class="comment">// push rcx</span></span><br><span class="line">    <span class="number">0x52</span>, <span class="comment">// push rdx</span></span><br><span class="line">    <span class="number">0x53</span>, <span class="comment">// push rbx</span></span><br><span class="line">    <span class="number">0x55</span>, <span class="comment">// push rbp</span></span><br><span class="line">    <span class="number">0x56</span>, <span class="comment">// push rsi</span></span><br><span class="line">    <span class="number">0x57</span>, <span class="comment">// push rdi</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x50</span>, <span class="comment">// push r8</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x51</span>, <span class="comment">// push r9</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x52</span>, <span class="comment">// push r10</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x53</span>, <span class="comment">// push r11</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x54</span>, <span class="comment">// push r12</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x55</span>, <span class="comment">// push r13</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x56</span>, <span class="comment">// push r14</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x57</span>, <span class="comment">// push r15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈空间分配（0x20字节）</span></span><br><span class="line">    <span class="number">0x48</span>,<span class="number">0x83</span>,<span class="number">0xec</span>,<span class="number">0x28</span>, <span class="comment">// sub rsp, 0x28 (等价于sub rsp,0x20 + 8字节对齐)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备ShellCode参数：rcx = 重定位数据地址</span></span><br><span class="line">    <span class="number">0x48</span>,<span class="number">0xB9</span>,<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x11</span>, <span class="comment">// mov rcx, 0x1111111111111111 (占位，后续替换为Manual_Mapping_data地址)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用ShellCode（FF 15是call [rip + 偏移]，偏移后续替换为ShellCode地址）</span></span><br><span class="line">    <span class="number">0xFF</span>, <span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x90</span>,<span class="number">0x90</span>,<span class="number">0x90</span>,<span class="number">0x90</span>,<span class="number">0x90</span>,<span class="number">0x90</span>,<span class="number">0x90</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放栈空间</span></span><br><span class="line">    <span class="number">0x48</span>,<span class="number">0x83</span>,<span class="number">0xc4</span>,<span class="number">0x28</span>, <span class="comment">// add rsp, 0x28</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复寄存器</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x5F</span>, <span class="comment">// pop r15</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x5E</span>, <span class="comment">// pop r14</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x5D</span>, <span class="comment">// pop r13</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x5C</span>, <span class="comment">// pop r12</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x5B</span>, <span class="comment">// pop r11</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x5A</span>, <span class="comment">// pop r10</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x59</span>, <span class="comment">// pop r9</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x58</span>, <span class="comment">// pop r8</span></span><br><span class="line">    <span class="number">0x5F</span>, <span class="comment">// pop rdi</span></span><br><span class="line">    <span class="number">0x5E</span>, <span class="comment">// pop rsi</span></span><br><span class="line">    <span class="number">0x5D</span>, <span class="comment">// pop rbp</span></span><br><span class="line">    <span class="number">0x5B</span>, <span class="comment">// pop rbx</span></span><br><span class="line">    <span class="number">0x5A</span>, <span class="comment">// pop rdx</span></span><br><span class="line">    <span class="number">0x59</span>, <span class="comment">// pop rcx</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0xFF</span>, <span class="number">0xE2</span>, <span class="comment">// jmp r10 (返回，r10保存原始返回地址)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 占位（71个绝对地址填充区，用于后续重定位）</span></span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 架构定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X64 0x8664</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86 0x14c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 设置进程Instrumentation回调</span></span><br><span class="line"><span class="comment"> * @param inst_callback 回调函数地址</span></span><br><span class="line"><span class="comment"> * @return NTSTATUS 操作状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">inst_callback_set_callback</span><span class="params">(PVOID inst_callback)</span> </span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    ACCESS_TOKEN Token = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PULONG TokenMask = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PVOID InstCallBack = inst_callback; <span class="comment">// 回调地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前进程主令牌</span></span><br><span class="line">    Token = <span class="built_in">PsReferencePrimaryToken</span>(<span class="built_in">IoGetCurrentProcess</span>());</span><br><span class="line">    <span class="keyword">if</span> (!Token) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;Failed to get process token&quot;</span>, TRUE, STATUS_INVALID_HANDLE);</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_HANDLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置调试权限位（令牌偏移0x40处为权限掩码，21位是DEBUG权限）</span></span><br><span class="line">    TokenMask = (PULONG)((ULONG_PTR)Token + <span class="number">0x40</span>);</span><br><span class="line">    TokenMask[<span class="number">0</span>] |= <span class="number">0x100000</span>;</span><br><span class="line">    TokenMask[<span class="number">1</span>] |= <span class="number">0x100000</span>;</span><br><span class="line">    TokenMask[<span class="number">2</span>] |= <span class="number">0x100000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置Instrumentation回调</span></span><br><span class="line">    status = <span class="built_in">ZwSetInformationProcess</span>(<span class="built_in">NtCurrentProcess</span>(),</span><br><span class="line">        ProcessInstrumentationCallback,</span><br><span class="line">        &amp;InstCallBack,</span><br><span class="line">        <span class="built_in">sizeof</span>(InstCallBack));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to set install back&quot;</span>, TRUE, status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;set install back success&quot;</span>, FALSE, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 以只读方式读取DLL文件到内存</span></span><br><span class="line"><span class="comment"> * @param us_dll_path DLL文件路径（Unicode）</span></span><br><span class="line"><span class="comment"> * @return PUCHAR 加载到内存的DLL数据，失败返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">PUCHAR <span class="title">inst_callback_get_dll_memory</span><span class="params">(PUNICODE_STRING us_dll_path)</span> </span>&#123;</span><br><span class="line">    HANDLE hFile = <span class="literal">NULL</span>;</span><br><span class="line">    OBJECT_ATTRIBUTES objattr;</span><br><span class="line">    IO_STATUS_BLOCK IoStatusBlock;</span><br><span class="line">    LARGE_INTEGER laInter = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    FILE_STANDARD_INFORMATION fileinfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ULONG FileSize = <span class="number">0</span>;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    PUCHAR pDllMemory = <span class="literal">NULL</span>;</span><br><span class="line">    LARGE_INTEGER byteoffset = &#123; <span class="number">0</span> &#125;; <span class="comment">// 文件读取偏移</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化对象属性</span></span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(&amp;objattr, us_dll_path, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件（GENERIC_READ | GENERIC_WRITE，同步打开）</span></span><br><span class="line">    status = <span class="built_in">ZwCreateFile</span>(&amp;hFile,</span><br><span class="line">        GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">        &amp;objattr,</span><br><span class="line">        &amp;IoStatusBlock,</span><br><span class="line">        &amp;laInter,</span><br><span class="line">        FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">        FILE_SHARE_READ,</span><br><span class="line">        FILE_OPEN,</span><br><span class="line">        FILE_SYNCHRONOUS_IO_NONALERT,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to create file&quot;</span>, TRUE, status);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">    status = <span class="built_in">ZwQueryInformationFile</span>(hFile,</span><br><span class="line">        &amp;IoStatusBlock,</span><br><span class="line">        &amp;fileinfo,</span><br><span class="line">        <span class="built_in">sizeof</span>(FILE_STANDARD_INFORMATION),</span><br><span class="line">        FileStandardInformation);</span><br><span class="line">    FileSize = (ULONG)fileinfo.AllocationSize.QuadPart;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to get file size&quot;</span>, TRUE, status);</span><br><span class="line">        <span class="built_in">ZwClose</span>(hFile);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存大小按页对齐</span></span><br><span class="line">    FileSize += <span class="number">0x1000</span>;</span><br><span class="line">    FileSize = (UINT64)<span class="built_in">PAGE_ALIGN</span>(FileSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配非分页池内存（标签&#x27;Dllp&#x27;）</span></span><br><span class="line">    pDllMemory = (PUCHAR)<span class="built_in">ExAllocatePoolWithTag</span>(PagedPool, FileSize, <span class="string">&#x27;Dllp&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pDllMemory) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to allocate pool memory&quot;</span>, TRUE, STATUS_INSUFFICIENT_RESOURCES);</span><br><span class="line">        <span class="built_in">ZwClose</span>(hFile);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存清零</span></span><br><span class="line">    <span class="built_in">RtlSecureZeroMemory</span>(pDllMemory, FileSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件内容到内存</span></span><br><span class="line">    status = <span class="built_in">ZwReadFile</span>(hFile,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        &amp;IoStatusBlock,</span><br><span class="line">        pDllMemory,</span><br><span class="line">        FileSize,</span><br><span class="line">        &amp;byteoffset,</span><br><span class="line">        <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 刷新文件缓冲区</span></span><br><span class="line">    <span class="built_in">ZwFlushBuffersFile</span>(hFile, &amp;IoStatusBlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to read file content&quot;</span>, TRUE, status);</span><br><span class="line">        <span class="built_in">ExFreePool</span>(pDllMemory);</span><br><span class="line">        <span class="built_in">ZwClose</span>(hFile);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件句柄</span></span><br><span class="line">    <span class="built_in">ZwClose</span>(hFile);</span><br><span class="line">    <span class="keyword">return</span> pDllMemory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在目标进程中分配内存并手动映射DLL</span></span><br><span class="line"><span class="comment"> * @param p_dll_memory 已读取的DLL内存数据</span></span><br><span class="line"><span class="comment"> * @param inst_callbak_addr 输出：回调ShellCode的分配地址</span></span><br><span class="line"><span class="comment"> * @param p_manual_data 输出：手动映射数据结构的地址</span></span><br><span class="line"><span class="comment"> * @return NTSTATUS 操作状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">inst_callback_alloc_memory</span><span class="params">(PUCHAR p_dll_memory, OUT PVOID* inst_callbak_addr, OUT PVOID* p_manual_data)</span> </span>&#123;</span><br><span class="line">    IMAGE_DOS_HEADER* pDosHeader = <span class="literal">NULL</span>;</span><br><span class="line">    IMAGE_NT_HEADERS* pNtHeader = <span class="literal">NULL</span>;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER* pOptHeader = <span class="literal">NULL</span>;</span><br><span class="line">    IMAGE_FILE_HEADER* pFileHeader = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    Manual_Mapping_data ManualMapData = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">char</span>* pStartMapAddr = <span class="literal">NULL</span>; <span class="comment">// DLL映射基地址</span></span><br><span class="line">    SIZE_T AllocSize = <span class="number">0</span>, RetSize = <span class="number">0</span>;</span><br><span class="line">    PEPROCESS Process = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID pManualMapData = <span class="literal">NULL</span>, pShellCode = <span class="literal">NULL</span>; <span class="comment">// 映射数据/ShellCode内存地址</span></span><br><span class="line">    SIZE_T DllSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验DOS头（MZ标识）</span></span><br><span class="line">    pDosHeader = <span class="built_in">reinterpret_cast</span>&lt;IMAGE_DOS_HEADER*&gt;(p_dll_memory);</span><br><span class="line">    <span class="keyword">if</span> (pDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) &#123; <span class="comment">// 0x5A4D</span></span><br><span class="line">        status = STATUS_INVALID_PARAMETER;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;the dll is not an valid file structure&quot;</span>, TRUE, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析PE头</span></span><br><span class="line">    pNtHeader = (IMAGE_NT_HEADERS*)((ULONG_PTR)p_dll_memory + pDosHeader-&gt;e_lfanew);</span><br><span class="line">    pFileHeader = &amp;pNtHeader-&gt;FileHeader;</span><br><span class="line">    pOptHeader = &amp;pNtHeader-&gt;OptionalHeader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅支持x64架构</span></span><br><span class="line">    <span class="keyword">if</span> (pFileHeader-&gt;Machine != X64) &#123;</span><br><span class="line">        status = STATUS_NOT_SUPPORTED;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;the dll is x86 structure,not support&quot;</span>, TRUE, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配DLL映射内存（按ImageSize分配，可执行）</span></span><br><span class="line">    AllocSize = pOptHeader-&gt;SizeOfImage;</span><br><span class="line">    status = <span class="built_in">ZwAllocateVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(),</span><br><span class="line">        (PVOID*)&amp;pStartMapAddr,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        &amp;AllocSize,</span><br><span class="line">        MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">        PAGE_EXECUTE_READWRITE);</span><br><span class="line">    DllSize = AllocSize;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to alloc memory&quot;</span>, TRUE, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射内存清零</span></span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(pStartMapAddr, AllocSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化手动映射数据结构</span></span><br><span class="line">    ManualMapData.dwReadson = <span class="number">0</span>;</span><br><span class="line">    ManualMapData.pGetProcAddress = (f_GetProcAddress)g_fnGetProcAddress;</span><br><span class="line">    ManualMapData.pLoadLibraryA = (f_LoadLibraryA)g_fnLoadLibraryA;</span><br><span class="line">    ManualMapData.pRtlAddFunctionTable = (f_RtlAddFunctionTable)g_fnAddFunctionTable;</span><br><span class="line">    ManualMapData.pBase = pStartMapAddr;</span><br><span class="line">    ManualMapData.reservedParam = <span class="number">0</span>;</span><br><span class="line">    ManualMapData.bContinue = FALSE;</span><br><span class="line">    ManualMapData.bStart = FALSE;</span><br><span class="line">    ManualMapData.bFirst = TRUE;</span><br><span class="line">    ManualMapData.DllSize = AllocSize;</span><br><span class="line">    ManualMapData.bEnableChange = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入PE头到映射内存</span></span><br><span class="line">    Process = <span class="built_in">IoGetCurrentProcess</span>();</span><br><span class="line">    status = <span class="built_in">MmCopyVirtualMemory</span>(Process,</span><br><span class="line">        p_dll_memory,</span><br><span class="line">        Process,</span><br><span class="line">        pStartMapAddr,</span><br><span class="line">        PAGE_SIZE,</span><br><span class="line">        KernelMode,</span><br><span class="line">        &amp;RetSize);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to write pe header!&quot;</span>, TRUE, status);</span><br><span class="line">        <span class="built_in">ZwFreeVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), (PVOID*)&amp;pStartMapAddr, &amp;AllocSize, MEM_RELEASE);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入PE节区数据</span></span><br><span class="line">    IMAGE_SECTION_HEADER* pSectionHeader = <span class="built_in">IMAGE_FIRST_SECTION</span>(pNtHeader);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pFileHeader-&gt;NumberOfSections; i++, pSectionHeader++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pSectionHeader-&gt;SizeOfRawData &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算节区文件偏移 -&gt; 虚拟地址的映射</span></span><br><span class="line">            PUCHAR pFileData = p_dll_memory + pSectionHeader-&gt;PointerToRawData;</span><br><span class="line">            PUCHAR pVirtualData = (PUCHAR)pStartMapAddr + pSectionHeader-&gt;VirtualAddress;</span><br><span class="line"></span><br><span class="line">            status = <span class="built_in">MmCopyVirtualMemory</span>(Process,</span><br><span class="line">                pFileData,</span><br><span class="line">                Process,</span><br><span class="line">                pVirtualData,</span><br><span class="line">                pSectionHeader-&gt;SizeOfRawData,</span><br><span class="line">                KernelMode,</span><br><span class="line">                &amp;RetSize);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">                <span class="built_in">logger_info</span>(<span class="string">&quot;failed to write sections&quot;</span>, TRUE, status);</span><br><span class="line">                <span class="built_in">ZwFreeVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), (PVOID*)&amp;pStartMapAddr, &amp;AllocSize, MEM_RELEASE);</span><br><span class="line">                <span class="keyword">return</span> status;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配手动映射数据结构的内存（PAGE_SIZE大小，可执行）</span></span><br><span class="line">    AllocSize = PAGE_SIZE;</span><br><span class="line">    status = <span class="built_in">ZwAllocateVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(),</span><br><span class="line">        (PVOID*)&amp;pManualMapData,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        &amp;AllocSize,</span><br><span class="line">        MEM_COMMIT,</span><br><span class="line">        PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to alloc mem for manualdata&quot;</span>, TRUE, status);</span><br><span class="line">        <span class="built_in">ZwFreeVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), (PVOID*)&amp;pStartMapAddr, &amp;DllSize, MEM_RELEASE);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(pManualMapData, AllocSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入手动映射数据到分配的内存</span></span><br><span class="line">    status = <span class="built_in">MmCopyVirtualMemory</span>(Process,</span><br><span class="line">        &amp;ManualMapData,</span><br><span class="line">        Process,</span><br><span class="line">        pManualMapData,</span><br><span class="line">        <span class="built_in">sizeof</span>(Manual_Mapping_data),</span><br><span class="line">        KernelMode,</span><br><span class="line">        &amp;RetSize);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to write mem for manualdata&quot;</span>, TRUE, status);</span><br><span class="line">        <span class="built_in">ZwFreeVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), (PVOID*)&amp;pManualMapData, &amp;AllocSize, MEM_RELEASE);</span><br><span class="line">        <span class="built_in">ZwFreeVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), (PVOID*)&amp;pStartMapAddr, &amp;DllSize, MEM_RELEASE);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配ShellCode内存（PAGE_SIZE大小，可执行）</span></span><br><span class="line">    AllocSize = PAGE_SIZE;</span><br><span class="line">    status = <span class="built_in">ZwAllocateVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(),</span><br><span class="line">        (PVOID*)&amp;pShellCode,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        &amp;AllocSize,</span><br><span class="line">        MEM_COMMIT,</span><br><span class="line">        PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to alloc mem for shellcode&quot;</span>, TRUE, status);</span><br><span class="line">        <span class="built_in">ZwFreeVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), (PVOID*)&amp;pManualMapData, &amp;PAGE_SIZE, MEM_RELEASE);</span><br><span class="line">        <span class="built_in">ZwFreeVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), (PVOID*)&amp;pStartMapAddr, &amp;DllSize, MEM_RELEASE);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(pShellCode, AllocSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入ShellCode到分配的内存</span></span><br><span class="line">    status = <span class="built_in">MmCopyVirtualMemory</span>(Process,</span><br><span class="line">        ShellCode,</span><br><span class="line">        Process,</span><br><span class="line">        pShellCode,</span><br><span class="line">        AllocSize,</span><br><span class="line">        KernelMode,</span><br><span class="line">        &amp;RetSize);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to write mem for shellcode&quot;</span>, TRUE, status);</span><br><span class="line">        <span class="built_in">ZwFreeVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), (PVOID*)&amp;pShellCode, &amp;AllocSize, MEM_RELEASE);</span><br><span class="line">        <span class="built_in">ZwFreeVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), (PVOID*)&amp;pManualMapData, &amp;PAGE_SIZE, MEM_RELEASE);</span><br><span class="line">        <span class="built_in">ZwFreeVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), (PVOID*)&amp;pStartMapAddr, &amp;DllSize, MEM_RELEASE);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修正回调ShellCode中的地址（重定位）</span></span><br><span class="line">    *(PULONG64)&amp;g_InstCallBackShellCode[<span class="number">28</span>] = (UINT64)pManualMapData;  <span class="comment">// 替换rcx的占位地址</span></span><br><span class="line">    *(PULONG64)&amp;g_InstCallBackShellCode[<span class="number">79</span>] = (UINT64)pShellCode;      <span class="comment">// 替换call的目标地址</span></span><br><span class="line">    g_InstCallBackShellCode[<span class="number">38</span>] = <span class="number">37</span>;                                  <span class="comment">// 修正FF 15的偏移量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配回调ShellCode的最终内存</span></span><br><span class="line">    AllocSize = PAGE_SIZE;</span><br><span class="line">    status = <span class="built_in">ZwAllocateVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(),</span><br><span class="line">        inst_callbak_addr,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        &amp;AllocSize,</span><br><span class="line">        MEM_COMMIT,</span><br><span class="line">        PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to alloc mem for install shellcode&quot;</span>, TRUE, status);</span><br><span class="line">        <span class="built_in">ZwFreeVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), (PVOID*)&amp;pShellCode, &amp;PAGE_SIZE, MEM_RELEASE);</span><br><span class="line">        <span class="built_in">ZwFreeVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), (PVOID*)&amp;pManualMapData, &amp;PAGE_SIZE, MEM_RELEASE);</span><br><span class="line">        <span class="built_in">ZwFreeVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), (PVOID*)&amp;pStartMapAddr, &amp;DllSize, MEM_RELEASE);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(*inst_callbak_addr, AllocSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入最终的回调ShellCode</span></span><br><span class="line">    status = <span class="built_in">MmCopyVirtualMemory</span>(Process,</span><br><span class="line">        g_InstCallBackShellCode,</span><br><span class="line">        Process,</span><br><span class="line">        *inst_callbak_addr,</span><br><span class="line">        <span class="built_in">sizeof</span>(g_InstCallBackShellCode),</span><br><span class="line">        KernelMode,</span><br><span class="line">        &amp;RetSize);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to write mem for install shellcode&quot;</span>, TRUE, status);</span><br><span class="line">        <span class="built_in">ZwFreeVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), (PVOID*)inst_callbak_addr, &amp;AllocSize, MEM_RELEASE);</span><br><span class="line">        <span class="built_in">ZwFreeVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), (PVOID*)&amp;pShellCode, &amp;PAGE_SIZE, MEM_RELEASE);</span><br><span class="line">        <span class="built_in">ZwFreeVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), (PVOID*)&amp;pManualMapData, &amp;PAGE_SIZE, MEM_RELEASE);</span><br><span class="line">        <span class="built_in">ZwFreeVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), (PVOID*)&amp;pStartMapAddr, &amp;DllSize, MEM_RELEASE);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出手动映射数据地址</span></span><br><span class="line">    *p_manual_data = pManualMapData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐藏内存属性（设置为MM_NOACCESS，防检测）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> index = <span class="number">0</span>; index &lt; DllSize; index += PAGE_SIZE) &#123;</span><br><span class="line">        PageAttrHide::<span class="built_in">ChangeVadAttributes</span>((UINT64)pStartMapAddr + index, MM_NOACCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    PageAttrHide::<span class="built_in">ChangeVadAttributes</span>((UINT64)pManualMapData, MM_NOACCESS);</span><br><span class="line">    PageAttrHide::<span class="built_in">ChangeVadAttributes</span>((UINT64)pShellCode, MM_NOACCESS);</span><br><span class="line">    PageAttrHide::<span class="built_in">ChangeVadAttributes</span>((UINT64)*inst_callbak_addr, MM_NOACCESS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调试输出关键地址</span></span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;pStartMapAddr:%llx,pManualMapData:%llx,pShellCode:%llx,inst_call_addr:%llx&quot;</span>,</span><br><span class="line">        pStartMapAddr, pManualMapData, pShellCode, *inst_callbak_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShellCode实现（空实现，需根据实际重定位逻辑补充）</span></span><br><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">ShellCode</span><span class="params">(Manual_Mapping_data* pData)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(pData);</span><br><span class="line">    <span class="comment">// 此处需实现DLL重定位、导入表解析、入口点执行等逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 向目标进程注入DLL（内核态手动映射）</span></span><br><span class="line"><span class="comment"> * @param process_id 目标进程PID</span></span><br><span class="line"><span class="comment"> * @param ws_dll_path DLL路径（宽字符）</span></span><br><span class="line"><span class="comment"> * @return NTSTATUS 操作状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">inst_callback_inject</span><span class="params">(HANDLE process_id, <span class="type">wchar_t</span>* ws_dll_path)</span> </span>&#123;</span><br><span class="line">    PEPROCESS Process = <span class="literal">NULL</span>;</span><br><span class="line">    KAPC_STATE Apc = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    UNICODE_STRING usR0DllPath = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PUCHAR pDllMem = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID InstCallBack = <span class="literal">NULL</span>;  <span class="comment">// R3回调ShellCode的地址</span></span><br><span class="line">    PVOID ManualData = <span class="literal">NULL</span>;    <span class="comment">// 手动映射数据结构地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过PID查找目标进程对象</span></span><br><span class="line">    status = <span class="built_in">PsLookupProcessByProcessId</span>(process_id, &amp;Process);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">logger_info</span>(<span class="string">&quot;failed to get process&quot;</span>, TRUE, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂接目标进程（切换到目标进程地址空间）</span></span><br><span class="line">    <span class="built_in">KeStackAttachProcess</span>(Process, &amp;Apc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环执行（确保内存操作完成）</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化DLL路径的UNICODE_STRING</span></span><br><span class="line">        usR0DllPath.Buffer = (PWCH)ws_dll_path;</span><br><span class="line">        usR0DllPath.Length = (USHORT)(<span class="built_in">wcslen</span>(ws_dll_path) * <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>));</span><br><span class="line">        usR0DllPath.MaximumLength = usR0DllPath.Length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取DLL到内存</span></span><br><span class="line">        pDllMem = <span class="built_in">inst_callback_get_dll_memory</span>(&amp;usR0DllPath);</span><br><span class="line">        <span class="keyword">if</span> (!pDllMem) &#123;</span><br><span class="line">            status = STATUS_UNSUCCESSFUL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配内存+手动映射DLL，获取回调ShellCode地址</span></span><br><span class="line">        InstCallBack = <span class="literal">NULL</span>;</span><br><span class="line">        status = <span class="built_in">inst_callback_alloc_memory</span>(pDllMem, &amp;InstCallBack, &amp;ManualData);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置进程Instrumentation回调</span></span><br><span class="line">        status = <span class="built_in">inst_callback_set_callback</span>(InstCallBack);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待ShellCode标记“启动完成”</span></span><br><span class="line">    <span class="keyword">if</span> (ManualData &amp;&amp; <span class="built_in">MmIsAddressValid</span>(ManualData)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!((Manual_Mapping_data*)ManualData)-&gt;bStart);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除回调（避免残留）</span></span><br><span class="line">    <span class="built_in">inst_callback_set_callback</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理DLL特征（抹除PE头）+ 设置可执行权限</span></span><br><span class="line">    <span class="keyword">if</span> (ManualData &amp;&amp; <span class="built_in">MmIsAddressValid</span>(ManualData)) &#123;</span><br><span class="line">        Manual_Mapping_data* pMapData = (Manual_Mapping_data*)ManualData;</span><br><span class="line">        <span class="comment">// 抹除PE头第一个字节（破坏MZ标识）</span></span><br><span class="line">        *(PUCHAR)pMapData-&gt;pBase = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// （可选）设置内存为仅执行</span></span><br><span class="line">        SIZE_T ReProtectSize = pMapData-&gt;DllSize;</span><br><span class="line">        ULONG OldProtect;</span><br><span class="line">        <span class="comment">//ZwProtectVirtualMemory(NtCurrentProcess(),</span></span><br><span class="line">        <span class="comment">//    &amp;pMapData-&gt;pBase,</span></span><br><span class="line">        <span class="comment">//    &amp;ReProtectSize,</span></span><br><span class="line">        <span class="comment">//    PAGE_EXECUTE,</span></span><br><span class="line">        <span class="comment">//    &amp;OldProtect);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知ShellCode可以继续执行</span></span><br><span class="line">        pMapData-&gt;bContinue = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解挂进程+释放资源</span></span><br><span class="line">    <span class="built_in">KeUnstackDetachProcess</span>(&amp;Apc);</span><br><span class="line">    <span class="built_in">ObDereferenceObject</span>(Process);</span><br><span class="line">    <span class="keyword">if</span> (pDllMem &amp;&amp; <span class="built_in">MmIsAddressValid</span>(pDllMem)) &#123;</span><br><span class="line">        <span class="built_in">ExFreePool</span>(pDllMem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief ShellCode核心逻辑：完成DLL重定位、导入表修复、TLS回调、入口点执行</span></span><br><span class="line"><span class="comment"> * @param pData 手动映射数据结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">ShellCode</span><span class="params">(Manual_Mapping_data* pData)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 防止重入（仅执行一次）</span></span><br><span class="line">    <span class="keyword">if</span> (!pData-&gt;bFirst) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pData-&gt;bFirst = FALSE;</span><br><span class="line">    pData-&gt;bStart = TRUE;  <span class="comment">// 标记“启动完成”，通知驱动可以移除回调</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取DLL基地址+解析PE头</span></span><br><span class="line">    <span class="type">char</span>* pBase = (<span class="type">char</span>*)pData-&gt;pBase;</span><br><span class="line">    IMAGE_DOS_HEADER* pDosHeader = (IMAGE_DOS_HEADER*)pBase;</span><br><span class="line">    IMAGE_NT_HEADERS* pNtHeader = (IMAGE_NT_HEADERS*)(pBase + pDosHeader-&gt;e_lfanew);</span><br><span class="line">    IMAGE_OPTIONAL_HEADER* pOptHeader = &amp;pNtHeader-&gt;OptionalHeader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 1. 基址重定位 ==========</span></span><br><span class="line">    <span class="type">char</span>* LocationDelta = (<span class="type">char</span>*)(pBase - pOptHeader-&gt;ImageBase);  <span class="comment">// 实际基址与期望基址的偏移</span></span><br><span class="line">    <span class="keyword">if</span> (LocationDelta != <span class="number">0</span> &amp;&amp; pOptHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size != <span class="number">0</span>) &#123;</span><br><span class="line">        IMAGE_BASE_RELOCATION* pRelocData = (IMAGE_BASE_RELOCATION*)(pBase + pOptHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);</span><br><span class="line">        <span class="type">const</span> IMAGE_BASE_RELOCATION* pRelocEnd = (IMAGE_BASE_RELOCATION*)(</span><br><span class="line">            (<span class="type">char</span>*)pRelocData + pOptHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有重定位块</span></span><br><span class="line">        <span class="keyword">while</span> (pRelocData &lt; pRelocEnd &amp;&amp; pRelocData-&gt;SizeOfBlock != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算当前块的重定位项数量</span></span><br><span class="line">            UINT64 AmountOfEntries = (pRelocData-&gt;SizeOfBlock - <span class="built_in">sizeof</span>(IMAGE_BASE_RELOCATION)) / <span class="built_in">sizeof</span>(USHORT);</span><br><span class="line">            USHORT* pRelativeInfo = (USHORT*)((<span class="type">char</span>*)pRelocData + <span class="built_in">sizeof</span>(IMAGE_BASE_RELOCATION));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历当前块的所有重定位项</span></span><br><span class="line">            <span class="keyword">for</span> (UINT64 i = <span class="number">0</span>; i &lt; AmountOfEntries; ++i, ++pRelativeInfo) &#123;</span><br><span class="line">                <span class="comment">// 高4位是重定位类型，低12位是偏移</span></span><br><span class="line">                USHORT RelocType = *pRelativeInfo &gt;&gt; <span class="number">12</span>;</span><br><span class="line">                USHORT RelocOffset = *pRelativeInfo &amp; <span class="number">0x0FFF</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 仅处理“直接地址”类型的重定位</span></span><br><span class="line">                <span class="keyword">if</span> (RelocType == IMAGE_REL_BASED_DIR64) &#123;</span><br><span class="line">                    UINT_PTR* pPatchAddr = (UINT_PTR*)(pBase + pRelocData-&gt;VirtualAddress + RelocOffset);</span><br><span class="line">                    *pPatchAddr += (UINT_PTR)LocationDelta;  <span class="comment">// 修正地址</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理下一个重定位块</span></span><br><span class="line">            pRelocData = (IMAGE_BASE_RELOCATION*)((<span class="type">char</span>*)pRelocData + pRelocData-&gt;SizeOfBlock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 2. 修复导入表（IAT） ==========</span></span><br><span class="line">    <span class="keyword">if</span> (pOptHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size != <span class="number">0</span>) &#123;</span><br><span class="line">        IMAGE_IMPORT_DESCRIPTOR* pImportDescr = (IMAGE_IMPORT_DESCRIPTOR*)(</span><br><span class="line">            pBase + pOptHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有导入的DLL</span></span><br><span class="line">        <span class="keyword">while</span> (pImportDescr-&gt;Name != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 加载导入的DLL</span></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span>* szDllName = pBase + pImportDescr-&gt;Name;</span><br><span class="line">            HMODULE hDll = pData-&gt;<span class="built_in">pLoadLibraryA</span>(szDllName);</span><br><span class="line">            <span class="keyword">if</span> (hDll == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                pImportDescr++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取INT（导入名称表）和IAT（导入地址表）</span></span><br><span class="line">            ULONG_PTR* pINT = (ULONG_PTR*)(pBase + pImportDescr-&gt;OriginalFirstThunk);</span><br><span class="line">            ULONG_PTR* pIAT = (ULONG_PTR*)(pBase + pImportDescr-&gt;FirstThunk);</span><br><span class="line">            <span class="keyword">if</span> (pINT == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                pINT = pIAT;  <span class="comment">// 若INT为空，则直接使用IAT</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历导入的函数</span></span><br><span class="line">            <span class="keyword">while</span> (*pIAT != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">IMAGE_SNAP_BY_ORDINAL</span>(*pINT)) &#123;</span><br><span class="line">                    <span class="comment">// 按序号导入</span></span><br><span class="line">                    UINT16 uOrdinal = (UINT16)(*pINT &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">                    *pIAT = (ULONG_PTR)pData-&gt;<span class="built_in">pGetProcAddress</span>(hDll, (<span class="type">char</span>*)uOrdinal);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 按名称导入</span></span><br><span class="line">                    IMAGE_IMPORT_BY_NAME* pImportName = (IMAGE_IMPORT_BY_NAME*)(pBase + *pINT);</span><br><span class="line">                    *pIAT = (ULONG_PTR)pData-&gt;<span class="built_in">pGetProcAddress</span>(hDll, pImportName-&gt;Name);</span><br><span class="line">                &#125;</span><br><span class="line">                pINT++;</span><br><span class="line">                pIAT++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pImportDescr++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 3. 执行TLS回调 ==========</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_PROCESS_ATTACH 1</span></span><br><span class="line">    <span class="keyword">if</span> (pOptHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size != <span class="number">0</span>) &#123;</span><br><span class="line">        IMAGE_TLS_DIRECTORY* pTlsDir = (IMAGE_TLS_DIRECTORY*)(</span><br><span class="line">            pBase + pOptHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress</span><br><span class="line">            );</span><br><span class="line">        <span class="comment">// TLS回调地址需要先重定位</span></span><br><span class="line">        PIMAGE_TLS_CALLBACK* pTlsCallbacks = (PIMAGE_TLS_CALLBACK*)(pTlsDir-&gt;AddressOfCallbacks + (UINT_PTR)LocationDelta);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有TLS回调并执行</span></span><br><span class="line">        <span class="keyword">while</span> (pTlsCallbacks &amp;&amp; *pTlsCallbacks) &#123;</span><br><span class="line">            (*pTlsCallbacks)(pBase, DLL_PROCESS_ATTACH, <span class="literal">NULL</span>);</span><br><span class="line">            pTlsCallbacks++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 4. 注册x64异常表 ==========</span></span><br><span class="line">    <span class="keyword">if</span> (pOptHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size != <span class="number">0</span>) &#123;</span><br><span class="line">        IMAGE_RUNTIME_FUNCTION_ENTRY* pExceptionTable = (IMAGE_RUNTIME_FUNCTION_ENTRY*)(</span><br><span class="line">            pBase + pOptHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress</span><br><span class="line">            );</span><br><span class="line">        <span class="comment">// 注册异常表（用于SEH处理）</span></span><br><span class="line">        pData-&gt;<span class="built_in">pRtlAddFunctionTable</span>(pExceptionTable,</span><br><span class="line">            pOptHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size / <span class="built_in">sizeof</span>(IMAGE_RUNTIME_FUNCTION_ENTRY),</span><br><span class="line">            (UINT64)pBase);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 5. 等待驱动通知，执行DLL入口点 ==========</span></span><br><span class="line">    <span class="keyword">while</span> (!pData-&gt;bContinue);  <span class="comment">// 等待驱动设置bContinue为TRUE</span></span><br><span class="line">    <span class="keyword">if</span> (pOptHeader-&gt;AddressOfEntryPoint != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行DLL入口点（DllMain）</span></span><br><span class="line">        f_DLL_ENTRY_POINT pDllMain = (f_DLL_ENTRY_POINT)(pBase + pOptHeader-&gt;AddressOfEntryPoint);</span><br><span class="line">        <span class="built_in">pDllMain</span>(pBase, DLL_PROCESS_ATTACH, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Gemini有话说"><a href="#Gemini有话说" class="headerlink" title="Gemini有话说"></a>Gemini有话说</h4><p>这是一个非常典型的、技术含量较高的 Windows 内核级无模块注入（Manual Mapping）配合 Instrumentation Callback 劫持执行流的代码。你的这段代码展示了 Rootkit 开发中的几个高级概念：<strong>手动映射（脱离 LoadLibrary 监控）</strong>、<strong>系统回调劫持（无线程注入）</strong> 以及 <strong>VAD 属性篡改（对抗内存扫描）</strong>。</p>
<h5 id="1-核心原理流程分析"><a href="#1-核心原理流程分析" class="headerlink" title="1. 核心原理流程分析"></a>1. 核心原理流程分析</h5><ol>
<li><strong>右侧补全逻辑：</strong></li>
</ol>
<ul>
<li>在 <code>ZwAllocateVirtualMemory</code> 中，通常配合 <code>MEM_COMMIT</code> 使用的是 <code>PAGE_EXECUTE_READWRITE</code>，这是 Manual Map 需要修改内存的标准权限。</li>
<li>在 <code>MmCopyVirtualMemory</code> 中，复制各 Section 时，目标地址一定是 <code>BaseAddress + VirtualAddress</code>（RVA），所以我补全了 <code>+ pSectionHeader-&gt;VirtualAddress</code>。</li>
<li>在 <code>ZwSetInformationProcess</code> 处，最后一个参数通常是输入数据的长度，所以补全了 <code>sizeof(InstCallBack)</code>。</li>
</ul>
<ol>
<li><strong>核心技术点：</strong></li>
</ol>
<ul>
<li><strong>Manual Mapping (手动映射)：</strong> 代码不使用 <code>LoadLibrary</code>，而是手动解析 PE 头，分配内存，并按 Section 复制数据。这可以避开部分反作弊对模块加载的监控。</li>
<li><strong>Instrumentation Callback：</strong> 这是一种较新的注入/Hook技术。Windows 允许设置一个回调，当进程发生特定事件（如线程切换或从内核返回用户态时）会执行该回调。利用这一点，可以将执行流劫持到我们的 <code>g_InstCallBackShellCode</code>，从而在无需创建新线程的情况下执行代码。</li>
<li><strong>VAD Hiding：</strong> 代码最后调用了 <code>PageAttrHide::ChangeVadAttributes</code> 将分配的内存 VAD 属性设为 <code>MM_NOACCESS</code>，这是为了对抗内存扫描（Memory Scan）。</li>
</ul>
<ol>
<li><strong>准备阶段</strong>：驱动读取DLL文件到内核分页内存。</li>
<li><strong>分配阶段</strong> (<code>inst_callback_alloc_memory</code>)：</li>
</ol>
<ul>
<li>在目标进程申请内存，手动解析PE头，按Section复制DLL内容。</li>
<li>分配 <code>Manual_Mapping_data</code> 结构体，填入 <code>LoadLibrary</code>/<code>GetProcAddress</code> 等关键API的地址（这些地址通常是硬编码或通过其他方式获取，图片中代码有硬编码注释，实际运行必须动态获取，否则极易蓝屏）。</li>
<li>分配 ShellCode 内存并写入。</li>
</ul>
<ol>
<li><strong>Hook阶段</strong> (<code>inst_callback_set_callback</code>)：</li>
</ol>
<ul>
<li>修改当前进程（已挂靠到目标进程）的 <code>ProcessInstrumentationCallback</code>。</li>
<li>Hook的目标是一个汇编桩 (<code>g_InstCallBackShellCode</code>)，它保存寄存器 -&gt; 调用 <code>ShellCode</code> (payload) -&gt; 恢复寄存器 -&gt; 跳回 <code>R10</code>。</li>
</ul>
<ol>
<li><strong>执行阶段</strong> (<code>ShellCode</code>)：</li>
</ol>
<ul>
<li>运行在用户模式（R3）。</li>
<li>修复自身基址重定位 (Relocations)。</li>
<li>修复导入表 (IAT)，加载依赖DLL。</li>
<li>执行 TLS Callbacks。</li>
<li>执行 <code>DllMain</code>。</li>
</ul>
<ol>
<li><strong>清理阶段</strong>：</li>
</ol>
<ul>
<li>驱动检测到 ShellCode 启动 (<code>bStart=true</code>) 后，卸载 Hook (<code>inst_callback_set_callback(0)</code>).</li>
<li>通知 ShellCode 继续运行 (<code>bContinue=true</code>).</li>
<li>抹除 PE 头特征。</li>
</ul>
<p>这段代码的执行流程非常精妙，它避免了使用 <code>CreateRemoteThread</code> 这种容易被杀毒软件监控的 API，而是利用 Windows 的 Instrumentation Callback 机制。</p>
<ol>
<li><strong>准备阶段</strong>：驱动读取 DLL 文件，解析 PE 头。</li>
<li><strong>分配内存</strong>：在目标进程中通过 <code>ZwAllocateVirtualMemory</code> 分配内存，并手动将 DLL 的 PE 头和各节区（Section）复制进去。</li>
<li><strong>Shellcode 植入</strong>：</li>
</ol>
<ul>
<li>分配一块内存写入 <code>g_InstCallBackShellCode</code>（汇编桩）。</li>
<li>分配一块内存写入 <code>ShellCode</code>（C++ 载荷处理函数）。</li>
</ul>
<ol>
<li><strong>设置 Hook (<code>inst_callback_set_callback</code>)</strong>：</li>
</ol>
<ul>
<li>修改目标进程的 <code>ProcessInstrumentationCallback</code>。</li>
<li><strong>原理</strong>：当该进程中的任何线程从内核态返回用户态（Ring0 -&gt; Ring3）时，Windows 内核会先跳转到你设置的 <code>g_InstCallBackShellCode</code> 地址执行，然后再返回原本的 RIP。</li>
</ul>
<ol>
<li><strong>Payload 执行 (<code>ShellCode</code>)</strong>：</li>
</ol>
<ul>
<li>汇编桩保存寄存器，调用 C++ 的 <code>ShellCode</code>。</li>
<li><code>ShellCode</code> 在用户态执行：<strong>重定位修复 -&gt; IAT 表修复 -&gt; TLS 回调 -&gt; 执行 DllMain</strong>。</li>
</ul>
<ol>
<li><strong>清理与隐藏</strong>：</li>
</ol>
<ul>
<li>驱动检测到 Shellcode 启动后，移除 Callback（防止无限递归）。</li>
<li>修改 VAD 属性为 <code>MM_NOACCESS</code>（试图让内存不可读，从而躲避扫描）。</li>
</ul>
<h5 id="2-代码逻辑检查与风险点"><a href="#2-代码逻辑检查与风险点" class="headerlink" title="2. 代码逻辑检查与风险点"></a>2. 代码逻辑检查与风险点</h5><ol>
<li><strong>并发与死锁风险 (High Risk)</strong>：</li>
</ol>
<ul>
<li>在 <code>inst_callback_inject</code> 中，驱动使用了 <code>while (!((Manual_Mapping_data*)ManualData)-&gt;bStart);</code> 进行死循环等待。</li>
<li><strong>问题</strong>：<code>ProcessInstrumentationCallback</code> 只有在线程从内核态返回用户态时才会触发。如果在挂靠期间 (<code>KeStackAttachProcess</code>) 目标进程的线程被挂起，或者当前线程没有触发回调的时机，驱动就会<strong>无限期卡死在内核</strong>，导致系统冻结（BSOD）。</li>
<li><strong>修复建议</strong>：应该增加超时机制（Timeout），如果几秒内没启动，则强制退出并清理。</li>
</ul>
<ol>
<li><strong>Instrumentation Callback 递归风暴</strong>：</li>
</ol>
<ul>
<li><code>ShellCode</code> 函数中调用了 <code>LoadLibraryA</code> 和 <code>GetProcAddress</code>。这些 API 底层可能会产生系统调用或引发新的回调事件。</li>
<li>如果 Callback 没有被及时卸载，或者 <code>bFirst</code> 检查机制失效，会导致无限递归调用 <code>ShellCode</code>，最终栈溢出崩溃。</li>
<li><strong>当前处理</strong>：代码中使用了 <code>if (!pData-&gt;bFirst) return;</code> 并立即设为 <code>false</code>。这是正确的防护措施，但只防住了重入，没防住多线程并发触发（如果有多个线程同时返回 R3）。</li>
</ul>
<ol>
<li><strong>API 硬编码问题 (Context Dependant)</strong>：</li>
</ol>
<ul>
<li>图片 <code>8445e...a89.jpg</code> 和 <code>9dc73...184.jpg</code> 中可以看到 <code>pLoadLibraryA</code> 等地址被赋值为 <code>g_fnLoadLibrary</code>。</li>
<li>如果 <code>g_fnLoadLibrary</code> 是通过硬编码（如代码注释中看到的 <code>0x7FFD...</code>）获取的，那么在不同版本的 Windows 或重启后地址改变时，代码必定崩溃。</li>
<li><strong>正确做法</strong>：驱动需要解析 <code>ntdll.dll</code> / <code>kernel32.dll</code> 的导出表来动态获取这些系统函数的 R3 地址。</li>
</ul>
<ol>
<li><strong>VAD 隐藏的不完整性</strong>：</li>
</ol>
<ul>
<li>代码使用了 <code>PageAttrHide::ChangeVadAttributes</code> 将 VAD 设为 <code>MM_NOACCESS</code>。</li>
<li>虽然这能骗过简单的 <code>VirtualQuery</code> 扫描，但高级反作弊（如 BE/EAC）会遍历物理页表或根据 PTE 属性发现这块内存是 <code>Execute</code> 权限，从而标记为可疑内存（因为它不在任何加载模块的范围内）。</li>
</ul>
<ol>
<li><strong>32位/64位 兼容性</strong>：</li>
</ol>
<ul>
<li>代码明确检查了 <code>if (pFileHeader-&gt;Machine != X64)</code>。这意味着该驱动<strong>不支持</strong>向 32位进程（WOW64）注入 x64 DLL，也不支持注入 x86 DLL。这是设计预期，不算 Bug。</li>
</ul>
<h6 id="A-PageAttrHide-调用参数错误（导致隐藏失效）"><a href="#A-PageAttrHide-调用参数错误（导致隐藏失效）" class="headerlink" title="A. PageAttrHide 调用参数错误（导致隐藏失效）"></a>A. <code>PageAttrHide</code> 调用参数错误（导致隐藏失效）</h6><p>在 <code>inst_callback_alloc_memory</code> 函数末尾，你调用了隐藏内存的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 你的代码</span></span><br><span class="line">PageAttrHide::<span class="built_in">ChangeVadAttributes</span>((UINT64)pStartMapAddr + index, MM_NOACCESS, <span class="literal">NULL</span>); </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>问题分析</strong>：<br>查看 <code>PageAttrHide.cpp</code>，函数的定义是 <code>void ChangeVadAttributes(..., HANDLE ProcessId)</code>。内部第一件事就是：<br><code>if (!NT_SUCCESS(PsLookupProcessByProcessId(ProcessId, &amp;Process))) ... return;</code></p>
<p>你传入了 <code>NULL</code> 作为 <code>ProcessId</code>。<code>PsLookupProcessByProcessId(0)</code> 会失败。<br><strong>结果</strong>：隐藏功能完全不会生效，代码会直接 return。</p>
<p><strong>修复建议</strong>：<br><code>inst_callback_alloc_memory</code> 应该增加一个 <code>HANDLE ProcessId</code> 参数，或者因为外层已经挂靠（KeStackAttachProcess），<code>PageAttrHide</code> 应该修改为支持直接使用当前进程（<code>IoGetCurrentProcess</code>），而不是重新去 Lookup。</p>
<p><strong>修改方案（最简单）：</strong><br>在 <code>inst_callback_inject</code> 调用 <code>alloc</code> 时传入 PID，并透传给 <code>ChangeVadAttributes</code>。</p>
<h6 id="B-全局函数指针未初始化（必崩点）"><a href="#B-全局函数指针未初始化（必崩点）" class="headerlink" title="B. 全局函数指针未初始化（必崩点）"></a>B. 全局函数指针未初始化（必崩点）</h6><p>在 <code>instcallback.cpp</code> 中定义了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UINT64 g_fnLoadLibraryA[] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">UINT64 g_fnGetProcAddress[] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">UINT64 g_fnAddFunctionTable[] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后在 <code>inst_callback_alloc_memory</code> 中赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ManualMapData.pGetProcAddress = (f_GetProcAddress)g_fnGetProcAddress;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>问题分析</strong>：<br>这些数组里的值是 <code>0</code>。代码中<strong>没有任何地方</strong>去获取 <code>kernel32.dll</code> 或 <code>ntdll.dll</code> 中这些 API 的真实用户态地址并填入这些数组。<br>当 <code>ShellCode</code> 在 R3 运行并试图修复 IAT 时：<br><code>pData-&gt;pLoadLibraryA(szModName)</code> -&gt; 实际上是跳到了地址 <code>0</code> 执行 -&gt; <strong>立即产生访问违规（Access Violation），导致宿主进程崩溃。</strong></p>
<p><strong>修复建议</strong>：<br>你需要在驱动初始化或注入前，利用 <code>Global</code> 类或 <code>utils</code> 类中的功能，遍历系统模块（如 <code>ntdll.dll</code> 和 <code>kernel32.dll</code>）的导出表，获取这些 API 的 R3 地址，并赋值给 <code>g_fn...</code> 变量。</p>
<h6 id="C-死锁风险（无限等待）"><a href="#C-死锁风险（无限等待）" class="headerlink" title="C. 死锁风险（无限等待）"></a>C. 死锁风险（无限等待）</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 驱动层等待</span></span><br><span class="line"><span class="keyword">while</span> (!((Manual_Mapping_data*)ManualData)-&gt;bStart);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户层等待</span></span><br><span class="line"><span class="keyword">while</span> (!pData-&gt;bContinue); </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>问题分析</strong>：<br>这是一个同步等待。</p>
<ol>
<li><strong>驱动层</strong>：如果目标进程处于挂起状态，或者没有任何线程正在运行（无法触发 Instrumentation Callback），驱动线程就会死循环卡在内核里。这会导致整个系统卡顿甚至看门狗蓝屏（DPC_WATCHDOG_VIOLATION）。</li>
<li><strong>Instrumentation Callback 递归</strong>：如果 <code>ShellCode</code> 中调用 <code>LoadLibrary</code> 触发了新的系统调用，可能会导致 Callback 再次被触发。虽然你加了 <code>bFirst</code> 锁，但仍需极度小心。</li>
</ol>
<p><strong>修复建议</strong>：<br>驱动层的 <code>while</code> 循环必须加上<strong>超时机制</strong>（比如等待 5 秒），如果超时则强制清理并退出，防止死机。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LARGE_INTEGER Timeout;</span><br><span class="line">Timeout.QuadPart = <span class="number">-10000000</span> * <span class="number">5</span>; <span class="comment">// 5秒</span></span><br><span class="line"><span class="comment">// 使用 KeDelayExecutionThread 配合计数器，或者用事件通知机制代替死循环</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="3-代码细节审计与优化"><a href="#3-代码细节审计与优化" class="headerlink" title="3. 代码细节审计与优化"></a>3. 代码细节审计与优化</h5><h6 id="关于-ShellCode-中的类型转换"><a href="#关于-ShellCode-中的类型转换" class="headerlink" title="关于 ShellCode 中的类型转换"></a>关于 <code>ShellCode</code> 中的类型转换</h6><p>你修正后的代码中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HMODULE hDll = (HMODULE)(pData-&gt;<span class="built_in">pLoadLibraryA</span>(szModName));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是正确的。因为手动映射的数据在 R3 执行，函数指针返回的是 <code>UINT64</code>，强转为 <code>HMODULE</code> 是安全的。</p>
<h6 id="关于-IAT-修复逻辑"><a href="#关于-IAT-修复逻辑" class="headerlink" title="关于 IAT 修复逻辑"></a>关于 IAT 修复逻辑</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">IMAGE_SNAP_BY_ORDINAL</span>(*pInt)) &#123;</span><br><span class="line">    <span class="comment">// 序号导入</span></span><br><span class="line">    *pIat = (ULONG_PTR)pData-&gt;<span class="built_in">pGetProcAddress</span>((UINT64)hDll, (<span class="type">char</span>*)(*pInt &amp; <span class="number">0xFFFF</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>逻辑正确。<code>GetProcAddress</code> 的第二个参数如果是低位序号，高位必须为0，这里处理得当。</p>
<h6 id="关于-VAD-隐藏-PageAttrHide"><a href="#关于-VAD-隐藏-PageAttrHide" class="headerlink" title="关于 VAD 隐藏 (PageAttrHide)"></a>关于 VAD 隐藏 (<code>PageAttrHide</code>)</h6><p>这段代码使用的是修改 <strong>PTE (Page Table Entry)</strong> 的方式。</p>
<ul>
<li>它通过修改 <code>MMPTE</code> 的 <code>Protection</code> 字段来欺骗系统。</li>
<li><code>Global</code> 中的 <code>uMmpfnDatabase</code> 和 <code>uOriginPte</code> 是非常敏感的内核偏移。</li>
<li><strong>警告</strong>：这些偏移在不同版本的 Windows (1809, 1903, 2004, 21H1, Win11) 中是<strong>不同</strong>的。如果 <code>Global::GetInstance</code> 没有根据 <code>fn_get_os_build_number</code> 动态获取正确的偏移，这段代码会导致严重的内核破坏（BSOD: <code>PFN_LIST_CORRUPT</code>）。</li>
</ul>
<p><strong>下一步你应该做的事（按顺序）：</strong></p>
<ol>
<li><strong>解决 API 地址问题</strong>：<br>在 <code>inst_callback_inject</code> 之前，编写一个函数，利用 <code>utils.h</code> 里的 <code>fn_get_moudle_address</code> 或类似功能，获取 <code>LoadLibraryA</code>、<code>GetProcAddress</code>、<code>RtlAddFunctionTable</code> 的地址，填入全局变量。不要依赖硬编码。</li>
<li><strong>修复 VAD 隐藏调用</strong>：<br>将 <code>inst_callback_inject</code> 中的 <code>process_id</code> 传递给 <code>alloc</code>，再传递给 <code>ChangeVadAttributes</code>。</li>
<li><strong>增加超时保护</strong>：<br>把驱动里的 <code>while(1)</code> 改成带 <code>KeDelayExecutionThread</code> 的有限次循环。</li>
<li><strong>测试环境</strong>：<br><strong>绝对不要在主机上运行</strong>。请在虚拟机中测试，并开启内核调试（WinDbg），因为调试这种 PTE 操作的代码必定会蓝屏很多次。</li>
</ol>
<h3 id="lab2-其他开源注入器"><a href="#lab2-其他开源注入器" class="headerlink" title="lab2-其他开源注入器"></a>lab2-其他开源注入器</h3><p><a target="_blank" rel="noopener" href="https://github.com/njmxye/drv_demo/tree/main/inject">inject</a></p>
<h2 id="cap3：x64句柄回调和内核对象"><a href="#cap3：x64句柄回调和内核对象" class="headerlink" title="cap3：x64句柄回调和内核对象"></a>cap3：x64句柄回调和内核对象</h2><p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzA5ODA0NDE2MA==&amp;mid=2649733877&amp;idx=1&amp;sn=812b0c3e90cb1bc34c39a4bed2e12cf9&amp;chksm=888c8a9abffb038c329e31c48b598c089f31ec64a8a51f78f0b3a2aaf45a53b8ec3ea6eff15b&amp;scene=21#wechat_redirect">Windows内核对象管理全景解析前奏</a></p>
<p><a target="_blank" rel="noopener" href="https://rayanfam.com/topics/reversing-windows-internals-part1/">Reversing Windows Internals (Part 1) - Digging Into Handles, Callbacks &amp; ObjectTypes</a></p>
<h3 id="句柄-1"><a href="#句柄-1" class="headerlink" title="句柄"></a>句柄</h3><p>Windows在内核用结构体(内核对象)指针,而在R3,每个程序则使用句柄。</p>
<p>简而言之，句柄是Windows内核返回给用户模式应用程序的一个值（如果您需要特权或拥有未被DACL拒绝的帐户）并且该句柄可用于对该对象进行进一步的操作。</p>
<p>也就是,在内核,我拥有内核对象的指针,可以对他进行任何操作。但是在R3,我想要对内核对象进行操作要同时有用句柄以及在句柄表相应的操作特权。</p>
<p>但是最终的原理是,syscall进入系统调用,根据句柄查询+对应的权限找到内核对象的指针(如果权限不够,那么这一步是失败的,即找不到内核对象的指针),使用各种API对该内核对象进一步操作。</p>
<h3 id="r0下的句柄管理"><a href="#r0下的句柄管理" class="headerlink" title="r0下的句柄管理"></a>r0下的句柄管理</h3><p>私有句柄的管理是以进程为单位的。<br>在<code>EPROCESS.ObjectTable</code>中字段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt nt!_EPROCESS -y object</span><br><span class="line">   +0x418 ObjectTable : Ptr64 _HANDLE_TABLE</span><br></pre></td></tr></table></figure>
<p>ObjectTable的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt nt!_HANDLE_TABLE</span><br><span class="line">   +0x000 NextHandleNeedingPool : Uint4B</span><br><span class="line">   +0x004 ExtraInfoPages      : Int4B</span><br><span class="line">   +0x008 TableCode           : Uint8B</span><br><span class="line">   +0x010 QuotaProcess        : Ptr64 _EPROCESS</span><br><span class="line">   +0x018 HandleTableList     : _LIST_ENTRY</span><br><span class="line">   +0x028 UniqueProcessId     : Uint4B</span><br><span class="line">   +0x02c Flags               : Uint4B</span><br><span class="line">   +0x02c StrictFIFO          : Pos 0, 1 Bit</span><br><span class="line">   +0x02c EnableHandleExceptions : Pos 1, 1 Bit</span><br><span class="line">   +0x02c Rundown             : Pos 2, 1 Bit</span><br><span class="line">   +0x02c Duplicated          : Pos 3, 1 Bit</span><br><span class="line">   +0x02c RaiseUMExceptionOnInvalidHandleClose : Pos 4, 1 Bit</span><br><span class="line">   +0x030 HandleContentionEvent : _EX_PUSH_LOCK</span><br><span class="line">   +0x038 HandleTableLock     : _EX_PUSH_LOCK</span><br><span class="line">   +0x040 FreeLists           : [1] _HANDLE_TABLE_FREE_LIST</span><br><span class="line">   +0x040 ActualEntry         : [1] UChar</span><br><span class="line">   +0x060 DebugInfo           : Ptr64 _HANDLE_TRACE_DEBUG_INFO</span><br></pre></td></tr></table></figure>
<h4 id="私有句柄表的遍历"><a href="#私有句柄表的遍历" class="headerlink" title="私有句柄表的遍历"></a>私有句柄表的遍历</h4><p>通常,在R0,句柄表的遍历是通过 <code>+0x008 TableCode</code></p>
<h5 id="通过tablecode-句柄当作索引进行遍历"><a href="#通过tablecode-句柄当作索引进行遍历" class="headerlink" title="通过tablecode+句柄当作索引进行遍历"></a>通过tablecode+句柄当作索引进行遍历</h5><p>句柄实际上是一个索引，Handle/4得到索引。</p>
<p>TableCode是一个多级指针,如果他为0,那么直接执行一个HANDLE_TABLE_ENTRY结构。<br>最后一位是几,就是几级指针.多级指针中指针数为512。最后一级指针只有256个成员.因为HANDLE_TABLE_ENTRY是128位的。一个指针是一页4096字节。</p>
<p>寻找方法如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _HANDLE_TABLE ffff83029315cf40</span><br><span class="line">nt!_HAIDLE_TABLE</span><br><span class="line"> +0x000 NextHandleNeedingPool : 0xc00</span><br><span class="line"> +0x004 ExtraInfoPages   : 0n0</span><br><span class="line"> +0x008 TableCode        : 0xfffff8302&#x27;93dff001</span><br><span class="line"> +0x008 NoRightsUpgrade   : 0y0</span><br><span class="line"> +0x008 Spare1           : 0y001100 (0xc)</span><br><span class="line"> +0x00c Spare2           : 0xba8d3977</span><br></pre></td></tr></table></figure>
<p>定位到,可以找到Object，以及GrantedAccess。但是ObjectPointerBits是加密的,需要进行解密。<br>解密ObjectPointerBits的方法为:<br>如对上面0xba8d3b7a10e,前面加上四个ffff,然后后面补上0，即可得到nt!Object_Header结构。<br>即<code>0xffffba8d3b7a10e0</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _object_header 0xffffba8d3b7a10e0</span><br><span class="line">nt!_OBJECT_HEADER</span><br><span class="line"> +0x000 PointerCount     : 0n32769</span><br><span class="line"> +0x008 HandleCount      : 0n1</span><br><span class="line"> +0x008 NextToFree       : 0x00000000`00000001 Void</span><br><span class="line"> +0x010 Lock             : _EX_PUSH_LOCK</span><br><span class="line"> +0x018 TypeIndex        : 0x99 &#x27;&#x27;</span><br><span class="line"> +0x019 TraceFlags       : 0 &#x27;&#x27;</span><br><span class="line"> +0x019 DbgRefTrace      : 0y0</span><br><span class="line"> +0x019 DbgTracePermanent : 0y0</span><br><span class="line"> +0x01a InfoMask         : 0x8 &#x27;&#x27;</span><br><span class="line"> +0x01b Flags            : 0 &#x27;&#x27;</span><br><span class="line"> +0x01b NewObject        : 0y0</span><br><span class="line"> +0x01b KernelObject     : 0y0</span><br><span class="line"> +0x01b KernelOnlyAccess : 0y0</span><br><span class="line"> +0x01b ExclusiveObject  : 0y0</span><br><span class="line"> +0x01b PermanentObject  : 0y0</span><br><span class="line"> +0x01b DefaultSecurityQuota : 0y0</span><br><span class="line"> +0x01b SingleHandleEntry : 0y0</span><br><span class="line"> +0x01b DeletedInline    : 0y0</span><br><span class="line"> +0x01c Reserved         : 0xfffffba8d</span><br><span class="line"> +0x020 ObjectCreateInfo : 0xfffff802&#x27;1b6538c0 _OBJECT_CREATE_INFORMATION</span><br><span class="line"> +0x020 QuotaBlockCharged : 0xfffff802&#x27;1b6538c0 Void</span><br><span class="line"> +0x028 SecurityDescriptor : (null)</span><br><span class="line"> +0x030 Body             : _QUAD</span><br></pre></td></tr></table></figure>
<p>Body指向的就是Object了。</p>
<h4 id="grantedaccess以及windows句柄权限验证机制"><a href="#grantedaccess以及windows句柄权限验证机制" class="headerlink" title="grantedaccess以及windows句柄权限验证机制"></a>grantedaccess以及windows句柄权限验证机制</h4><p>句柄的作用是找到结构体和根据句柄表中的权限进一步操作内核对象。权限即GrantedAccess。<br>他在HANDLE_TABLE_ENTRY这个结构体中。修改句柄表的这个权限,就是修改这个值。</p>
<p>0x1ffff表示完全控制。内核对句柄权限的验证是通过。</p>
<p>ObReferenceObjectByHandle()进行的，这个函数内部就是通过遍历句柄表实现的。</p>
<blockquote>
<p>笔记截止在这。</p>
</blockquote>
<p>以上摘自<code>NtReadVirtualMemory</code>，他会自动地把<code>Access</code>赋值成读所具有的权限。</p>
<p>只有权限大于<code>Access</code>，<code>Object</code>才会被赋值。</p>
<p>值得一提的是，<code>AccessMode==KernelMode</code>，无论大于小于，无视句柄权限。<code>AccessMode</code>来自<code>ETHREAD.PreviousMode</code></p>
<h4 id="全局句柄表"><a href="#全局句柄表" class="headerlink" title="全局句柄表"></a>全局句柄表</h4><p>全局句柄表中，只存在<code>Process</code>和<code>Thread</code>对象。用于标识线程对象。<br>线程的<code>TID</code>，进程的<code>PID</code>，则是全局句柄表的句柄。</p>
<p>全局句柄表位于<code>PspCidTable</code>中。他也是一个<code>HANDLE_TABLE</code>结构，也具有多级指针。<br>唯一区别是经过解密后，他直接指向<code>Body</code>而非<code>Object_Header</code></p>
<h3 id="句柄回调"><a href="#句柄回调" class="headerlink" title="句柄回调"></a>句柄回调</h3><p>句柄回调是指为了在请求进程句柄或与线程或进程句柄相关的任何内容时设置的回调。</p>
<p>简而言之，通过OpenProcess、OpenThread以及DuplicateHandle来进行创建句柄，都会被回调拦截。</p>
<p>使用ObRegisterCallbacks()进行注册回调。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ObRegisterCallbacks</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    [in]  POB_CALLBACK_REGISTRATION CallbackRegistration,</span></span></span><br><span class="line"><span class="params"><span class="function">    [out] PVOID                     *RegistrationHandle</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果想要在驱动使用这个函数，必须如下这样做。<br>因此您可以在编译驱动程序时将<code>/INTEGRITYCHECK</code>添加到链接器</p>
<h4 id="ob-callback-registration"><a href="#ob-callback-registration" class="headerlink" title="ob_callback_registration"></a>ob_callback_registration</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_OB_CALLBACK_REGISTRATION</span> &#123;</span><br><span class="line">    USHORT                      Version;</span><br><span class="line">    USHORT                      OperationRegistrationCount;</span><br><span class="line">    UNICODE_STRING              Altitude;</span><br><span class="line">    PVOID                       RegistrationContext;</span><br><span class="line">    OB_OPERATION_REGISTRATION   *OperationRegistration;</span><br><span class="line">&#125; OB_CALLBACK_REGISTRATION, *POB_CALLBACK_REGISTRATION;</span><br></pre></td></tr></table></figure>
<h5 id="字段说明"><a href="#字段说明" class="headerlink" title="字段说明"></a>字段说明</h5><ul>
<li><p><strong>Version</strong><br>请求的对象回调注册的版本。驱动程序应指定 <code>OB_FLT_REGISTRATION_VERSION</code>。</p>
</li>
<li><p><strong>OperationRegistrationCount</strong><br><code>OperationRegistration</code> 数组中的条目数。</p>
</li>
<li><p><strong>Altitude</strong><br>指定驱动程序高度的 Unicode 字符串。有关海拔高度的更多信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ifs/load-order-groups-and-altitudes-for-minifilter-drivers">加载顺序组和微过滤器驱动程序的海拔高度</a>。</p>
</li>
<li><p><strong>RegistrationContext</strong><br>当回调例程运行时，系统将 <code>RegistrationContext</code> 值传递给回调例程。该值的含义由驱动程序定义。</p>
</li>
<li><p><strong>OperationRegistration</strong><br>指向 <code>OB_OPERATION_REGISTRATION</code> 结构数组的指针。每个结构指定 <code>ObjectPreCallback</code> 和 <code>ObjectPostCallback</code> 回调例程以及调用例程的操作类型。</p>
</li>
</ul>
<h4 id="回调被加载的过程"><a href="#回调被加载的过程" class="headerlink" title="回调被加载的过程"></a>回调被加载的过程</h4><p><code>OpenProcess</code>（用户模式）→ <code>NtOpenProcess</code>（用户模式）→ <code>NtOpenProcess</code>（内核模式）→ <code>PsOpenProcess</code> → <code>ObOpenObjectByPointer</code> → <code>ObpCreateHandle</code>→<code>ObpPreInterceptHandleCreate</code></p>
<p>这是 <code>OpenProcess</code> 的全过程。</p>
<p>而回调是在 <code>ObpPreInterceptHandleCreate</code> 被调用的，在 <code>ObpCallPreOperationCallbacks()</code> 中被调用。</p>
<blockquote>
<p>笔记截止到这。</p>
</blockquote>
<h5 id="句柄创建在psopenprocess中的检查"><a href="#句柄创建在psopenprocess中的检查" class="headerlink" title="句柄创建在psopenprocess中的检查"></a>句柄创建在psopenprocess中的检查</h5><p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12170855.png" alt="描述符4"></p>
<h6 id="rundownprotect机制"><a href="#rundownprotect机制" class="headerlink" title="rundownprotect机制"></a>rundownprotect机制</h6><p>防止创建句柄时进程结束，导致的进程清理空间，最终出现错误。本质上是一把锁。获取之后进程结束不会清理空间。</p>
<h5 id="句柄回调支持的判断"><a href="#句柄回调支持的判断" class="headerlink" title="句柄回调支持的判断"></a>句柄回调支持的判断</h5><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12170849.png" alt="描述符4"></p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12170850.png" alt="描述符4"></p>
<h4 id="typeinfo"><a href="#typeinfo" class="headerlink" title="typeinfo"></a>typeinfo</h4><p>+0x040 TypeInfo ：<code>_OBJECT_TYPE_INITIALIZER</code><br>这个结构里面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1. kd&gt; dt nt!_OBJECT_TYPE_INITIALIZER</span><br><span class="line">2. +0x000 Length ：Uint2B</span><br><span class="line">3. +0x002 ObjectTypeFlags ：Uint2B</span><br><span class="line">4. +0x002 CaseInsensitive ：Pos 0, 1 Bit</span><br><span class="line">5. +0x002 UnnamedObjectsOnly ：Pos 1, 1 Bit</span><br><span class="line">6. +0x002 UseDefaultObject ：Pos 2, 1 Bit</span><br><span class="line">7. +0x002 SecurityRequired ：Pos 3, 1 Bit</span><br><span class="line">8. +0x002 MaintainHandleCount ：Pos 4, 1 Bit</span><br><span class="line">9. +0x002 MaintainTypeList ：Pos 5, 1 Bit</span><br><span class="line">10. +0x002 SupportsObjectCallbacks ：Pos 6, 1 Bit</span><br><span class="line">11. +0x002 CacheAligned ：Pos 7, 1 Bit</span><br><span class="line">12. +0x003 UseExtendedParameters ：Pos 0, 1 Bit</span><br><span class="line">13. +0x003 Reserved ：Pos 1, 7 Bits</span><br><span class="line">14. +0x004 ObjectTypeCode ：Uint4B</span><br><span class="line">15. +0x008 InvalidAttributes ：Uint4B</span><br><span class="line">16. +0x00c GenericMapping ：\_GENERIC_MAPPING</span><br><span class="line">17. +0x01c ValidAccessMask ：Uint4B</span><br><span class="line">18. +0x020 RetainAccess ：Uint4B</span><br><span class="line">19. +0x024 PoolType ：\_POOL_TYPE</span><br><span class="line">20. +0x028 DefaultPagedPoolCharge ：Uint4B</span><br><span class="line">21. +0x02c DefaultNonPagedPoolCharge ：Uint4B</span><br><span class="line">22. +0x030 DumpProcedure ：Ptr64  void</span><br><span class="line">23. +0x038 OpenProcedure ：Ptr64  long</span><br><span class="line">24. +0x040 CloseProcedure ：Ptr64  void</span><br><span class="line">25. +0x048 DeleteProcedure ：Ptr64  void</span><br><span class="line">26. +0x050 ParseProcedure ：Ptr64  long</span><br><span class="line">27. +0x050 ParseProcedureEx ：Ptr64  long</span><br><span class="line">28. +0x058 SecurityProcedure ：Ptr64  long</span><br><span class="line">29. +0x060 QueryNameProcedure ：Ptr64  long</span><br><span class="line">30. +0x068 OkayToCloseProcedure ：Ptr64  unsigned char</span><br><span class="line">31. +0x070 WaitObjectFlagMask ：Uint4B</span><br><span class="line">32. +0x074 WaitObjectFlagOffset ：Uint2B</span><br><span class="line">33. +0x076 WaitObjectPointerOffset ：Uint2B</span><br></pre></td></tr></table></figure>
<p>+0x002 SupportsObjectCallbacks ：Pos 6, 1 Bit这个位代表这个内核对象是否支持回调。</p>
<p>ValidAccessMask，有的时候打开反作弊之后,不能调试,原因是修改了这个位,使权限掩码无效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[+0x01c] ValidAccessMask : 0x1fffffff [Type: unsigned long]</span><br></pre></td></tr></table></figure>
<h2 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h2><h3 id="lab3：get-all-handles-用户模式下枚举所有句柄"><a href="#lab3：get-all-handles-用户模式下枚举所有句柄" class="headerlink" title="lab3：get_all_handles 用户模式下枚举所有句柄"></a>lab3：get_all_handles 用户模式下枚举所有句柄</h3><p>我们只需要调用ntdll的NtQuerySystemInformation()就能枚举所有的进程所有的句柄,而且在R3下,甚至可以找到该句柄对应的内核对象地址。</p>
<p>实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SystemHandleInformation 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ObjectBasicInformation 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ObjectNameInformation 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ObjectTypeInformation 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NT_SUCCESS(x) ((x) &gt;= 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATUS_INFO_LENGTH_MISMATCH 0xc0000004</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_SYSTEM_INFORMATION_CLASS</span> &#123;</span><br><span class="line">    SystemBasicInformation = <span class="number">0</span>,                    </span><br><span class="line">    SystemPerformanceInformation = <span class="number">2</span>,               </span><br><span class="line">    SystemTimeOfDayInformation = <span class="number">3</span>,                 </span><br><span class="line">    SystemProcessInformation = <span class="number">5</span>,                   </span><br><span class="line">    SystemProcessorPerformanceInformation = <span class="number">8</span>,     </span><br><span class="line">    SystemInterruptInformation = <span class="number">23</span>,                </span><br><span class="line">    SystemExceptionInformation = <span class="number">33</span>,               </span><br><span class="line">    SystemRegistryQuotaInformation = <span class="number">37</span>,           </span><br><span class="line">    SystemLookasideInformation = <span class="number">45</span>               </span><br><span class="line">&#125; SYSTEM_INFORMATION_CLASS;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* _NtQuerySystemInformation)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG SystemInformationClass,     </span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID SystemInformation,         </span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG SystemInformationLength,    </span></span></span><br><span class="line"><span class="params"><span class="function">    PULONG ReturnLength              </span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"></span><br><span class="line">_NtQuerySystemInformation NtQuerySystemInformation = (_NtQuerySystemInformation)<span class="built_in">GetProcAddress</span>(<span class="built_in">LoadLibraryA</span>(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;NtQuerySystemInformation&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SYSTEM_HANDLE</span></span><br><span class="line">&#123;</span><br><span class="line">    ULONG ProcessId;        </span><br><span class="line">    BYTE ObjectTypeNumber;  </span><br><span class="line">    BYTE Flags;            </span><br><span class="line">    USHORT Handle;        </span><br><span class="line">    PVOID Object;          </span><br><span class="line">    ACCESS_MASK GrantedAccess; </span><br><span class="line">&#125; SYSTEM_HANDLE, * PSYSTEM_HANDLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SYSTEM_HANDLE_INFORMATION</span></span><br><span class="line">&#123;</span><br><span class="line">    ULONG HandleCount;             </span><br><span class="line">    SYSTEM_HANDLE Handles[<span class="number">1</span>];       </span><br><span class="line">&#125; SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ULONG guess_size = PAGE_SIZE, real_size = <span class="number">0</span>;</span><br><span class="line">    SYSTEM_HANDLE_INFORMATION* handle_information = (SYSTEM_HANDLE_INFORMATION*)<span class="built_in">malloc</span>(PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">NtQuerySystemInformation</span>(SystemHandleInformation, handle_information, guess_size, &amp;real_size) == STATUS_INFO_LENGTH_MISMATCH)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(handle_information);      </span><br><span class="line">        guess_size = real_size;           </span><br><span class="line">        handle_information= (SYSTEM_HANDLE_INFORMATION*)<span class="built_in">malloc</span>(guess_size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;real size&quot;</span> &lt;&lt; guess_size &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int32_t</span> idx = <span class="number">0</span>;  idx &lt; handle_information-&gt;HandleCount;  idx++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> info = handle_information-&gt;Handles[idx]; </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;pid:&quot;</span> &lt;&lt;info.ProcessId &lt;&lt; <span class="string">&quot;\t\thandle:&quot;</span> &lt;&lt; info.Handle &lt;&lt; <span class="string">&quot;\t\tobject:&quot;</span> &lt;&lt; info.Object &lt;&lt; <span class="string">&quot;\t\taccess&quot;</span> &lt;&lt; info.GrantedAccess &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lab3-开源句柄回调练习"><a href="#lab3-开源句柄回调练习" class="headerlink" title="lab3-开源句柄回调练习"></a>lab3-开源句柄回调练习</h3><p><a target="_blank" rel="noopener" href="https://github.com/njmxye/drv_demo/tree/main/Handle_Derank">Handle_Derank</a></p>
<h2 id="cap4：x64windows内存"><a href="#cap4：x64windows内存" class="headerlink" title="cap4：x64windows内存"></a>cap4：x64windows内存</h2><h3 id="windows内存管理概论"><a href="#windows内存管理概论" class="headerlink" title="windows内存管理概论"></a>windows内存管理概论</h3><p>对于内存管理的不同，本质是算法的不同。如位图法、链表法、slab等等。</p>
<p>首先，对于Windows来说，在x64 windows下，仍然采取低半空间规范地址为用户独立空间，其本质是PML4表中低256个PML4E各异，内核空间全进程共享、本质是高256个PML4E相同。x64弱化了段的概念、直接得到线性地址、没有逻辑地址。因为强制平坦。<br>其次，Windows的虚拟地址分配与收回按照严格方式进行。进程使用内存必须申请，因此OS根据申请与释放进行维护每个进程的虚拟空间使用情况。</p>
<p>同时，Windows使用按需分配策略，即只有虚拟地址真正使用，才会被分配页表，俗称挂物理页。</p>
<p><strong>对于虚拟内存</strong></p>
<ul>
<li>Windows采取每个进程有一颗AVL的一组VAD虚拟地址描述符，这些描述可以根据虚拟地址快速定位到指定的描述符上。</li>
<li>来判断R3空间的使用清空，方便分配和进程销毁时候的清理。</li>
</ul>
<p><strong>对于物理内存</strong></p>
<ul>
<li>Windows要实现页面的换出与换入。Windows采取了MMPFNDATABASE页帧数据库的管理方式用于描述每个页面的状态。页帧数据库是一个MMPFN的结构体的数组。<br>而这个数据库，管理0-0xFFFF的物理地址就是第一个MMPFN，以此类推，即0x30+PFN</li>
<li>同时，Windows维护了一个链表，将所有相同属性的物理地址链接起来。</li>
</ul>
<p>同时，对于页面错误，Windows提供Page Fault Handler，把换出的数据重新读到内存。</p>
<blockquote>
<p>什么时候页面被换出呢? 当系统认为内存紧缺, 或者一个进程由于工作集的限制而不允许拥有更多的物理页面时, Windows 会替换工作集中的页面。这项工作是由一个称为工作集管理器（working set manager）的组件来完成的, 它运行在一个称为平衡集管理器（balance set manager）的系统线程中。工作集缩减的过程称为修剪（trim）。Windows 实现了全面的工作集模型, 包括控制进程的工作集, 以及与页面替换算法结合起来管理物理内存的全局分配。</p>
</blockquote>
<h4 id="系统地址的空间内存管理"><a href="#系统地址的空间内存管理" class="headerlink" title="系统地址的空间内存管理"></a>系统地址的空间内存管理</h4><p>对于系统内存，Windows采取池的概念进行维护。<br>出了特殊的模块，大部分都是建立在内核池中。在初始化时，windows建立两种内存池，分别是可以被换入磁盘的分页内存池和不能换入的非分页内存池。</p>
<p>非分页池由保证始终驻留在物理内存中的系统虚拟地址范围组成。因此，可以随时访问它们，而不会导致页面错误。这意味着可以从任何IRQL访问它们，需要非分页池的原因之一是因为在DPC调度级别或更高级别上无法满足页面错误。因此，任何可能在DPC分派级别或更高级别执行或访问的代码和数据都必须位于不可分页内存中。分页池这是系统空间中的一个虚拟内存区域，可以分页到系统内外。不需要从DPC调度级别或更高级别访问内存的设备驱动程序可以使用分页池。它可以从任何流程上下文访问。</p>
<p>可以通过某些API来把内存常驻进改地址空间：</p>
<ul>
<li>R3可以使用VirtualLock；</li>
<li>R0驱动中用MmProbeAndLockPages</li>
</ul>
<p>对于这些内存的分配和回收，可以通过ExAllocatePool、ExAllocate-PoolWithTag和ExFreePool来进行分配。</p>
<h5 id="系统空间管理情况"><a href="#系统空间管理情况" class="headerlink" title="系统空间管理情况"></a>系统空间管理情况</h5><p>通过<code>结构_MI_SYSTEM_INFORMATION</code>（MIState）和<code>结构_MI_VISIBLE_STATE</code>（MIVisibleState）可查看Windows系统内存空间管理情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _MI_VISIBLE_STATE ffff802`1b64ed40</span><br><span class="line">nt!_MI_VISIBLE_STATE</span><br><span class="line">  +0x000 SessionList        : _LIST_ENTRY [ 0xffffcb80`6e2dc080 - 0xffffcb80`6efbe080 ]</span><br><span class="line">  +0x010 SessionIdBitmap    : 0xfffff8302`f8ab5000 _RTL_BITMAP</span><br><span class="line">  +0x018 PagedPoolInfo      : _MI_PAGED_POOL_INFO</span><br><span class="line">  +0x030 MaximumNonPagedPoolInPages : 0x00000001`00000000</span><br><span class="line">  +0x038 SizeOfPagedPoolInPages : 0x00000001`00000000</span><br><span class="line">  +0x040 SystemPteInfo      : _MI_SYSTEM_PTE_TYPE</span><br><span class="line">  +0x0a0 NonPagedPoolCommit : 0xd4a9</span><br><span class="line">  +0x0a8 SmallNonPagedPtesCommit : 6</span><br><span class="line">  +0x0b0 BootCommit         : 0x128b</span><br><span class="line">  +0x0b8 MiPagesAllocated   : 0x578</span><br><span class="line">  +0x0c0 SystemPageTableCommit : 0x8a8</span><br><span class="line">  +0x0c8 ProcessCommit      : 0x263a</span><br><span class="line">  +0x0d0 DriverCommit       : 0x12446</span><br><span class="line">  +0x0d4 PagingLevels       : 0x4 &#x27;&#x27;</span><br><span class="line">  +0x0d8 PfnDatabaseCommit  : 0x3221</span><br><span class="line">  +0x100 SystemMls          : [6] _MMSUPPORT_FULL</span><br><span class="line">  +0x880 SystemCacheShared  : _MMSUPPORT_SHARED</span><br><span class="line">  +0x900 AggregateSystemMls : [1] _MMSUPPORT_AGGREGATION</span><br><span class="line">  +0x920 MapCacheFailures   : 0</span><br><span class="line">  +0x928 PageFileHashPages  : 0</span><br><span class="line">  +0x930 PteHeader          : _SYSPTES_HEADER</span><br><span class="line">  +0xea8 SystemVaTypeCount  : [16] 0</span><br><span class="line">  +0xac8 SystemVaType       : [256] &quot;&quot;</span><br><span class="line">  +0xbc8 SystemVaRegions    : [13] _MI_SYSTEM_VA_ASSIGNMENT</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">nt!_MI_SYSTEM_INFORMATION</span><br><span class="line">  +0x000 Pools              : _MI_POOL_STATE</span><br><span class="line">  +0x0c0 Sections           : _MI_SECTION_STATE</span><br><span class="line">  +0x400 SystemImages       : _MI_SYSTEM_IMAGE_STATE</span><br><span class="line">  +0x4a8 Sessions           : _MI_SESSION_STATE</span><br><span class="line">  +0x1550 Processes         : _MI_PROCESS_STATE</span><br><span class="line">  +0x15c0 Hardware          : _MI_HARDWARE_STATE</span><br><span class="line">  +0x1780 SystemVa          : _MI_SYSTEM_VA_STATE</span><br><span class="line">  +0x1c40 PageCombines      : _MI_COMBINE_STATE</span><br><span class="line">  +0x1c60 Pagelists         : _MI_PAGELIST_STATE</span><br><span class="line">  +0x1d00 Partitions        : _MI_PARTITION_STATE</span><br><span class="line">  +0x1dc0 Shutdowns         : _MI_SHUTDOWN_STATE</span><br><span class="line">  +0x1e38 Errors            : _MI_ERROR_STATE</span><br><span class="line">  +0x1f00 AccessLog         : _MI_ACCESS_LOG_STATE</span><br><span class="line">  +0x1f80 Debugger          : _MI_DEBUGGER_STATE</span><br><span class="line">  +0x20a0 Standby           : _MI_STANDBY_STATE</span><br><span class="line">  +0x2140 SystemPtes        : _MI_SYSTEM_PTE_STATE</span><br><span class="line">  +0x2340 IoPages           : _MI_IO_PAGE_STATE</span><br><span class="line">  +0x23b0 PagingIo          : _MI_PAGING_IO_STATE</span><br><span class="line">  +0x2460 CommonPages       : _MI_COMMON_PAGE_STATE</span><br><span class="line">  +0x2540 Trims             : _MI_SYSTEM_TRIM_STATE</span><br><span class="line">  +0x2580 Enclaves          : _MI_ENCLAVE_STATE</span><br><span class="line">  +0x25c8 Cookie            : 0</span><br><span class="line">  +0x25d0 BootRegistryRuns  : (null)</span><br><span class="line">  +0x25d8 ZeroingDisabled   : 0n0</span><br><span class="line">  +0x25dc FullyInitialized  : 0 &#x27;&#x27;</span><br><span class="line">  +0x25dd SafeBooted        : 0 &#x27;&#x27;</span><br><span class="line">  +0x25e0 Tracelogging      : (null)</span><br><span class="line">  +0x2600 Vs                : _MI_VISIBLE_STATE</span><br></pre></td></tr></table></figure>
<p>使用windbg<code>!poolused 2</code>命令查看结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !poolused 2</span><br><span class="line">Using a machine size of fff7d pages to configure the kd cache</span><br><span class="line">*** CacheSize too low - increasing to 81 MB</span><br><span class="line"></span><br><span class="line">Max cache size is        : 85884928 bytes (0x147a0 KB)</span><br><span class="line">Total memory in cache    : 261680 bytes (0x400 KB)</span><br><span class="line">Number of regions cached: 2283</span><br><span class="line">52044 full reads broken into 52083 partial reads</span><br><span class="line">      counts: 49797 cached/2286 uncached, 95.61% cached</span><br><span class="line">      bytes: 1009831 cached/115552 uncached, 89.73% cached</span><br><span class="line">** Transition PTEs are implicitly decoded</span><br><span class="line">** Prototype PTEs are implicitly decoded</span><br><span class="line">.</span><br><span class="line">Sorting by NonPaged Pool Consumed</span><br><span class="line"></span><br><span class="line">                              NonPaged                      Paged</span><br><span class="line">Tag      Allocs      Used      Allocs      Used</span><br><span class="line">ConT     535         5935104   0           0           UNKNOWN pooltag &#x27;ConT&#x27;, please update pooltag.txt</span><br><span class="line">EtwB     148         5206272   16          442368      Etw Buffer , Binary: ntletw</span><br><span class="line">Thre     1725        4416000   0           0           Thread objects , Binary: ntlps</span><br><span class="line">File     9386        3741536   0           0           File objects</span><br><span class="line">EtwR     14617       3229088   0           0           Etw KN RegEntry , Binary: ntletw</span><br><span class="line">Ntxf     7350        2704800   0           0           NTFS FcbNonpagedDatalookasideList , Binary: ntfs.sys</span><br><span class="line">AmlH     5           2621440   0           0           ACPI AML Pooltags</span><br><span class="line">Fms1     11963       2296896   0           0           STREAM_LIST_CTRL structure , Binary: fltmgr.sys</span><br><span class="line">Vad      13703       2192480   0           0           Mm virtual address descriptors , Binary: nt!mm</span><br><span class="line">MmCa     5932        2184080   0           0           Mm control areas for mapped files , Binary: nt!mm</span><br><span class="line">Even     14230       1833088   0           0           Event objects</span><br><span class="line">AlPc     3044        1811224   0           0           ALPC port objects , Binary: nt!alpc</span><br><span class="line">MmpB     3           1672720   0           0           Paging file bitmaps , Binary: nt!mm</span><br><span class="line">MmCi     2111        1298848   0           0           Mm control areas for images , Binary: nt!mm</span><br><span class="line">NtXI     4900        1254400   0           0           FCB_NONPAGED_INDEX</span><br><span class="line">NTFS FcbNonpagedIndexlookasideList , Binary: ntfs.sys</span><br><span class="line">smSt     93          1205440   0           0           ReadyBoost various store allocations , Binary: nt!store or rdboot.sys</span><br><span class="line">Pool     5           1060864   0           0           Pool tables, etc.</span><br><span class="line">ScPC     9           1009712   0           0           reset bus code</span><br><span class="line">AcpD     992         979968    0           0           ACPI device data , Binary: acpi.sys</span><br><span class="line">EtwG     2029        908992    0           0           Etw Guid , Binary: ntletw</span><br></pre></td></tr></table></figure>
<p>总之，系统空间大部分空间都是共享的（因为每个<code>Cr3</code>的<code>PML4E</code>相同），且系统空间分配采用“看内存池”机制：物理内存预先分配并挂接物理页，使用时通过<code>Alloc</code>调用。</p>
<h4 id="用户空间的管理"><a href="#用户空间的管理" class="headerlink" title="用户空间的管理"></a>用户空间的管理</h4><p>对于用户空间，Windows采取VAD树的方式进行管理。<br>而对于VAD树中的结点，进行管理的内存属性不一样，分为Mapped和Private的内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !VAD ffffba8d3ee512300+7D8</span><br><span class="line">VAD</span><br><span class="line">Level  Start  End  Commit</span><br><span class="line">ffffba8d3ee4d620 10 10 0 Mapped  READONLY</span><br><span class="line">    Pagefile section, shared commit 0x1</span><br><span class="line">ffffba8d3ee4f100 6 20 20 0 Mapped  READONLY</span><br><span class="line">    Pagefile section, shared commit 0x1</span><br><span class="line">ffffba8d3ee4f240 7 30 30 0 Mapped  READONLY</span><br><span class="line">    Pagefile section, shared commit 0x1</span><br><span class="line">ffffba8d3ee4e020 5 40 5c 0 Mapped  READONLY</span><br><span class="line">    Pagefile section, shared commit 0x1d</span><br><span class="line">ffffba8d3e8716b0 7 60 9f 18 Private  READWRITE</span><br><span class="line">ffffba8d3e871b00 6 a0 19f 7 Private  READWRITE</span><br><span class="line">ffffba8d3ee4e160 4 1a0 1a3 0 Mapped  READONLY</span><br><span class="line">    Pagefile section, shared commit 0x4</span><br><span class="line">ffffba8d3e872140 6 1b0 1b1 2 Private  READWRITE</span><br><span class="line">ffffba8d3ee4ecao 5 1c0 1c0 0 Mapped  READONLY</span><br><span class="line">    Pagefile section, shared commit 0x1</span><br><span class="line">ffffba8d3ee4f6a0 7 1d0 1d0 0 Mapped  READONLY</span><br><span class="line">    Pagefile section, shared commit 0x1</span><br><span class="line">ffffba8d3ee4f2e0 6 1e0 1e0 0 Mapped  READONLY</span><br><span class="line">    Pagefile section, shared commit 0x1</span><br><span class="line">ffffba8d3ee4e980 7 1f0 1ff 0 Mapped  READWRITE</span><br><span class="line">    Pagefile section, shared commit 0x10</span><br><span class="line">ffffba8d3e871d80 3 200 3ff 5 Private  READWRITE</span><br><span class="line">ffffba8d3ee484d0 7 400 407 2 Mapped Exe  EXECUTE_WRITECOPY</span><br><span class="line">    \Users\admin\Desktop\InstDrv.exe</span><br><span class="line">ffffba8d3ee4e700 6 410 4d8 0 Mapped  READONLY</span><br><span class="line">    \Windows\System32\locale.nls</span><br><span class="line">ffffba8d3e871dd0 5 4e0 4e3 1 Private  READWRITE</span><br><span class="line">ffffba8d3ee4fba0 6 530 537 0 Mapped  READONLY</span><br><span class="line">    Pagefile section, shared commit 0xd</span><br><span class="line">ffffba8d3e8794e0 7 540 540 1 Private  READWRITE</span><br><span class="line">ffffba8d3ee50280 4 550 556 0 Mapped  READONLY</span><br><span class="line">    \Program Files\WindowsApps\Microsoft.LanguageExperiencePackzh-CN_19041.52.157.0_neutral__8wekyb3d8bbwe\Windows\System32\zh-CN\MFC42.dll.mui</span><br><span class="line">ffffba8d3e87b240 7 560 560 1 Private  READWRITE</span><br><span class="line">ffffba8d3ee4d8a0 6 570 580 0 Mapped  READONLY</span><br><span class="line">    \Windows\System32\C_1252.NLS</span><br><span class="line">ffffba8d3ee50500 7 590 593 0 Mapped  READONLY</span><br><span class="line">    Pagefile section, shared commit 0x4</span><br><span class="line">ffffba8d3e876e20 5 5a0 5af 6 Private  READWRITE</span><br><span class="line">ffffba8d3ee50780 6 6b0 6b5 0 Mapped  READONLY</span><br><span class="line">    \Program Files\WindowsApps\Microsoft.LanguageExperiencePackzh-CN_19041.52.157.0_neutral__8wekyb3d8bbwe\Windows\System32\zh-CN\user32.dll.mui</span><br><span class="line">ffffba8d3e876fb0 2 6c0 7bf 104 Private  READWRITE</span><br><span class="line">ffffba8d3ee50640 7 7c0 940 0 Mapped  READONLY</span><br><span class="line">    Pagefile section, shared commit 0x181</span><br></pre></td></tr></table></figure>
<p>对于进程地址空间，使用需要用<strong>保留+提交</strong>两个阶段才可以使用一段内存：</p>
<ul>
<li>保留：只在VAD树中进行属性挂载，不会挂物理页，以后会用。</li>
<li>提交：挂上物理页。</li>
</ul>
<h5 id="vad的结构"><a href="#vad的结构" class="headerlink" title="vad的结构"></a>vad的结构</h5><p>VAD的作用仅仅是对进程的虚拟内存进行占位和描述。它不会操控任何读写属性，但可以表示。真正能够读写进行的是段和页的属性，即段的读写属性和PTE的读写属性。</p>
<p>对Windows API进行限制的读写属性是MMFNDATA中每个MMPFN的OriginalPte，通过修改这个可以欺骗API。最终决定读写的是硬件PTE，也就是页表中的PTE属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _mmvad fffffba8d3ee4d620</span><br><span class="line">nt!_MMVAD</span><br><span class="line">   +0x000 Core           : _MMVAD_SHORT</span><br><span class="line">   +0x040 u2             : &lt;anonymous-tag&gt;</span><br><span class="line">   +0x048 Subsection     : 0xfffffba8d`396a0580 _SUBSECTION</span><br><span class="line">   +0x050 FirstPrototypePte : 0xfffff8302`8fc02350 _MMPTE</span><br><span class="line">   +0x058 LastContiguousPte : 0xfffff8302`8fc02350 _MMPTE</span><br><span class="line">   +0x060 ViewLinks      : _LIST_ENTRY [ 0xfffffba8d`3ee529a0 - 0xfffffba8d`3ee4f2a0 ]</span><br><span class="line">   +0x070 VadsProcess    : 0xfffffba8d`3e512301 _EPROCESS</span><br><span class="line">   +0x078 u4             : &lt;anonymous-tag&gt;</span><br><span class="line">   +0x080 FileObject     : (null)</span><br></pre></td></tr></table></figure>
<h6 id="mmvad-short"><a href="#mmvad-short" class="headerlink" title="mmvad_short"></a>mmvad_short</h6><p>是VAD的主要结构，后面则是Mapped类型的VAD结点专用的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dx -id 0,0,fffffba8d396a9a40 -r1 (*((ntkrnlmp!_MMVAD_SHORT *)0xfffffba8d3ee4d620))</span><br><span class="line">(*((ntkrnlmp!_MMVAD_SHORT *)0xfffffba8d3ee4d620))                 [Type: _MMVAD_SHORT]</span><br><span class="line">   [+0x000] NextVad          : 0x0 [Type: _MMVAD_SHORT *]</span><br><span class="line">   [+0x008] ExtraCreateInfo  : 0x0 [Type: void *]</span><br><span class="line">   [+0x000] VadNode          [Type: _RTL_BALANCED_NODE]</span><br><span class="line">   [+0x018] StartingVpn      : 0x10 [Type: unsigned long]</span><br><span class="line">   [+0x01c] EndingVpn        : 0x10 [Type: unsigned long]</span><br><span class="line">   [+0x020] StartingVpnHigh  : 0x0 [Type: unsigned char]</span><br><span class="line">   [+0x021] EndingVpnHigh    : 0x0 [Type: unsigned char]</span><br><span class="line">   [+0x022] CommitChargeHigh : 0x0 [Type: unsigned char]</span><br><span class="line">   [+0x023] SpareNT64VadUChar : 0x0 [Type: unsigned char]</span><br><span class="line">   [+0x024] ReferenceCount   : 0 [Type: long]</span><br><span class="line">   [+0x028] PushLock         [Type: _EX_PUSH_LOCK]</span><br><span class="line">   [+0x030] u                [Type: &lt;anonymous-tag&gt;]</span><br><span class="line">   [+0x034] u1               [Type: &lt;anonymous-tag&gt;]</span><br><span class="line">   [+0x038] EventList        : 0x0 [Type: _MI_VAD_EVENT_BLOCK *]</span><br></pre></td></tr></table></figure>
<p><strong>StartingVpn</strong>即开始虚拟地址帧，<strong>End</strong>为结束。</p>
<p>u.VadFlags中的成员：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[+0x000 ( 0: 0)] Lock              : 0x0 [Type: unsigned long]</span><br><span class="line">[+0x000 ( 1: 1)] LockContended     : 0x0 [Type: unsigned long]</span><br><span class="line">[+0x000 ( 2: 2)] DeleteInProgress  : 0x0 [Type: unsigned long]</span><br><span class="line">[+0x000 ( 3: 3)] NoChange          : 0x0 [Type: unsigned long]</span><br><span class="line">[+0x000 ( 6: 4)] VadType           : 0x0 [Type: unsigned long]</span><br><span class="line">[+0x000 (11: 7)] Protection        : 0x1 [Type: unsigned long]</span><br><span class="line">[+0x000 (17:12)] PreferredNode     : 0x0 [Type: unsigned long]</span><br><span class="line">[+0x000 (19:18)] PageSize          : 0x0 [Type: unsigned long]</span><br><span class="line">[+0x000 (20:20)] PrivateMemory     : 0x0 [Type: unsigned long]</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><strong>PrivateMemory</strong>：用于显示内存是Mapped还是Private</li>
<li><strong>NoChange</strong>：可以用来锁页，但仅针对私有内存</li>
</ul>
<p>VadType定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_MI_VAD_TYPE</span> &#123;</span><br><span class="line">    VadNone,</span><br><span class="line">    VadDevicePhysicalMemory,</span><br><span class="line">    VadImageMap,</span><br><span class="line">    VadAwe,</span><br><span class="line">    VadWriteWatch,</span><br><span class="line">    VadLargePages,</span><br><span class="line">    VadRotatePhysical,</span><br><span class="line">    VadLargePageSection</span><br><span class="line">&#125; MI_VAD_TYPE, *PMI_VAD_TYPE;</span><br></pre></td></tr></table></figure>
<p>Protection没有任何作用，只是表示VAD的读写属性，对应关系：</p>
<ol>
<li>READONLY</li>
<li>EXECUTE</li>
<li>EXECUTE_READ</li>
<li>READWRITER</li>
<li>WRITCOPY</li>
<li>EXECUTE_READWRITER</li>
<li>EXECUTE_WRITCOPY</li>
</ol>
<p>VAD仅仅是用来管理确定用户空间哪些分配、哪些未分配，这是它最大的作用。</p>
<p>还有一个作用是对Private内存的锁页，可进行限制操作。但它不能承担任何关于页面属性的责任，用它来判断页面属性是不准确的。</p>
<p>另外，VAD对于共享内存会包含它的原型PTE，即如下，可以注意到，他是一个数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+0x050 FirstPrototypePte : 0xfffffd10f`1f203f50 _MMPTE</span><br><span class="line">+0x058 LastContiguousPte : 0xfffffd10f`1f203fff _MMPTE</span><br></pre></td></tr></table></figure>
<h6 id="内存区对象-section-与共享内存"><a href="#内存区对象-section-与共享内存" class="headerlink" title="内存区对象(_section)与共享内存"></a>内存区对象(_section)与共享内存</h6><p>实现共享内存的底层原语叫做SECTION对象；</p>
<p>实际上，内存区对象代表了一种物理存储资源，它可能在物理内存中，也可能在系统页面文件中，或者在其他的文件中。</p>
<p>它本质上就是描述了一块物理内存，它与其他对象的关系如下：</p>
<p>Section对象经常用于镜像文件（创建进程时的镜像）和共享内存。</p>
<p>如果Section表示的是一个文件镜像，如可以在VAD中查找EXE属性的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 fffffba8d3eea480 7 400 407 2 Mapped Exe EXECUTE_WRITECOPY \Users\admin\Desktop\InstDrv.exe</span><br></pre></td></tr></table></figure>
<p>查看它的_MMVAD：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 kd&gt; dt _mmvad fffffba8d3eea480</span><br><span class="line">2 ntl!_MMVAD</span><br><span class="line">3  +0x000 Core            : _MMVAD_SHORT</span><br><span class="line">4  +0x040 u2              : &lt;anonymous-tag&gt;</span><br><span class="line">5  +0x048 Subsection      : 0xfffffba8`d3d3f7390 _SUBSECTION</span><br><span class="line">6  +0x050 FirstPrototypePte : 0xfffff8302`95534880 _MMPTE</span><br><span class="line">7  +0x058 LastContiguousPte : 0xfffff8302`95534888 _MMPTE</span><br><span class="line">8  +0x060 ViewLinks       : _LIST_ENTRY [ 0xfffffba8`d3d3f7318 - 0xfffffba8`d3d3f7318 ]</span><br><span class="line">9  +0x070 VadsProcess     : 0xfffffba8`d3e512301 _EPROCESS</span><br><span class="line">10 +0x078 u4              : &lt;anonymous-tag&gt;</span><br><span class="line">11 +0x080 FileObject      : (null)</span><br></pre></td></tr></table></figure>
<p><code>ViewLinks</code>代表有多少进程链接了这个镜像文件；如果是DLL，可以遍历出所有的加载此DLL的进程。</p>
<p>配合VadsProcess：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1  +0x060 ViewLinks       : _LIST_ENTRY [ 0xfffffba8`d3d3f7318 - 0xfffffba8`d3d3f7318 ]</span><br><span class="line">2  +0x070 VadsProcess     : 0xfffffba8`d3e512301 _EPROCESS</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>ViewLinks</code>链接的是<code>EPROCESS+0x18</code>的位置。即这个结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 EPROCESS;</span><br><span class="line">2 +0x018 ProfileListHead : _LIST_ENTRY</span><br></pre></td></tr></table></figure>
<p>值得注意，前面一直强调SECTION对象是描述物理内存的。它是如何描述的呢？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1 2: kd&gt; dx -id 0,0,fffff8e89ff852080 -r1 ((ntkrnlmp!_SEGMENT *)0xfffffd10f28c8fd30)</span><br><span class="line">2 ((ntkrnlmp!_SEGMENT *)0xfffffd10f28c8fd30)       : 0xfffffd10f28c8fd30 [Type: _SEGMENT *]</span><br><span class="line">3  [+0x000] ControlArea     : 0xfffff8e89ff8a792c0 [Type: _CONTROL_AREA *]</span><br><span class="line">4  [+0x008] TotalNumberOfPtes : 0x286 [Type: unsigned long]</span><br><span class="line">5  [+0x00c] SegmentFlags    [Type: _SEGMENT_FLAGS]</span><br><span class="line">6  [+0x010] NumberOfCommittedPages : 0x0 [Type: unsigned __int64]</span><br><span class="line">7  [+0x018] SizeOfSegment   : 0x286000 [Type: unsigned __int64]</span><br><span class="line">8  [+0x020] ExtendInfo      : 0xffff615830000 [Type: _VMEXTEND_INFO *]</span><br><span class="line">9  [+0x020] BasedAddress    : 0x7Ff615830000 [Type: void *]</span><br><span class="line">10 [+0x028] SegmentLock     [Type: _EX_PUSH_LOCK]</span><br><span class="line">11 [+0x030] u1              [Type: &lt;anonymous-tag&gt;]</span><br><span class="line">12 [+0x038] u2              [Type: &lt;anonymous-tag&gt;]</span><br><span class="line">13 [+0x040] PrototypePte    : 0xfffffd10f2313f000 [Type: _MMPTE *]</span><br></pre></td></tr></table></figure></p>
<p>有一个<code>PrototypePte</code>原型Pte，这个是一个<code>MMPTE</code>列表，SECTION对象就是靠这个来描述物理内存的。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 2: kd&gt; dq 0xfffffd10f2313f000</span><br><span class="line">2 fffffd10f`2313f000 8a000000`0396b121 0a000000`bee26121</span><br><span class="line">3 fffffd10f`2313f010 0a0000001`33625121 0a000000`61724121</span><br><span class="line">4 fffffd10f`2313f020 0a000000`01723121 0a000000`b9322121</span><br><span class="line">5 fffffd10f`2313f030 0a000000`58a21121 0a000000`5ab020121</span><br><span class="line">6 fffffd10f`2313f040 0a000000`b011f121 0a000000`5f61e121</span><br><span class="line">7 fffffd10f`2313f050 0a000000`2f31d121 0a000000`4e81c121</span><br><span class="line">8 fffffd10f`2313f060 0a000000`b851b121 0a000000`4ed1a121</span><br><span class="line">9 fffffd10f`2313f070 0a000000`8ed30121 8e89ffa7`93780460</span><br></pre></td></tr></table></figure></p>
<p>即里面全都是Pte，Pte也是一种资源，但是这个和物理Pte（<code>Pre_Base</code>开始描述的Pte）地址是肯定不一样的。这个只是表示物理内存的。</p>
<p><code>FirstPrototypePte</code>：这是共享内存很重要的一个概念。<br>用于表示共享内存的页面是否有效。并且此PTE描述的是真实的物理地址，实际上，<code>FirstPrototypePte</code>就是在<code>ControlArea.Segment.PrototypePte</code>。</p>
<p>即原型PTE，是描述共享内存是否有效真正的PTE。</p>
<p>在<code>SubSection</code>中，对<code>Section</code>这个对象进行了分段。<br>Section结构中，最重要的是<code>ControlArea</code>，他描述了Section的一些内容。</p>
<p>SubSection同样有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1 kd&gt; dx -id 0,0,fffffba8d3969a040 -r1 ((ntkrnlmp!_SUBSECTION *)0xfffffba8d3d3f7390)</span><br><span class="line">2 ((ntkrnlmp!_SUBSECTION *)0xfffffba8d3d3f7390)       : 0xfffffba8d3d3f7390 [Type: _SUBSECTION *]</span><br><span class="line">3  [+0x000] ControlArea     : 0xfffffba8d3d3f7310 [Type: _CONTROL_AREA *]</span><br><span class="line">4  [+0x008] SubsectionBase  : 0xfffff830295534880 [Type: _MMPTE *]</span><br><span class="line">5  [+0x010] NextSubsection  : 0xfffffba8d3d3f73c8 [Type: _SUBSECTION *]</span><br><span class="line">6  [+0x018] GlobalPerSessionHead [Type: _RTL_AVL_TREE]</span><br><span class="line">7  [+0x018] CreationWaitList : 0x0 [Type: _MI_CONTROL_AREA_WAIT_BLOCK *]</span><br><span class="line">8  [+0x018] SessionDriverProtos : 0x0 [Type: _MI_PER_SESSION_PROTOS *]</span><br><span class="line">9  [+0x020] u               [Type: &lt;anonymous-tag&gt;]</span><br><span class="line">10 [+0x024] StartingSector  : 0x0 [Type: unsigned long]</span><br><span class="line">11 [+0x028] NumberOfFullSectors : 0x8 [Type: unsigned long]</span><br><span class="line">12 [+0x02c] PtesInSubsection : 0x1 [Type: unsigned long]</span><br><span class="line">13 [+0x030] u1              [Type: &lt;anonymous-tag&gt;]</span><br><span class="line">14 [+0x034 (29: 0)] UnusedPtes      : 0x0 [Type: unsigned long]</span><br><span class="line">15 [+0x034 (30:30)] ExtentQueryNeeded : 0x0 [Type: unsigned long]</span><br><span class="line">16 [+0x034 (31:31)] DirtyPages       : 0x0 [Type: unsigned long]</span><br><span class="line">17 kd&gt; dx -id 0,0,fffffba8d3969a040 -r1 ((ntkrnlmp!_SUBSECTION *)0xfffffba8d3d3f73c8)</span><br><span class="line">18 ((ntkrnlmp!_SUBSECTION *)0xfffffba8d3d3f73c8)       : 0xfffffba8d3d3f73c8 [Type: _SUBSECTION *]</span><br><span class="line">19  [+0x000] ControlArea     : 0xfffffba8d3d3f7310 [Type: _CONTROL_AREA *]</span><br><span class="line">20  [+0x008] SubsectionBase  : 0xfffff830295534888 [Type: _MMPTE *]</span><br><span class="line">21  [+0x010] NextSubsection  : 0xfffffba8d3d3f7400 [Type: _SUBSECTION *]</span><br><span class="line">22  [+0x018] GlobalPerSessionHead [Type: _RTL_AVL_TREE]</span><br><span class="line">23  [+0x018] CreationWaitList : 0x0 [Type: _MI_CONTROL_AREA_WAIT_BLOCK *]</span><br><span class="line">24  [+0x018] SessionDriverProtos : 0x0 [Type: _MI_PER_SESSION_PROTOS *]</span><br><span class="line">25  [+0x020] u               [Type: &lt;anonymous-tag&gt;]</span><br><span class="line">26  [+0x024] StartingSector  : 0x8 [Type: unsigned long]</span><br><span class="line">27  [+0x028] NumberOfFullSectors : 0x18 [Type: unsigned long]</span><br><span class="line">28  [+0x02c] PtesInSubsection : 0x3 [Type: unsigned long]</span><br><span class="line">29  [+0x030] u1              [Type: &lt;anonymous-tag&gt;]</span><br><span class="line">30  [+0x034 (29: 0)] UnusedPtes      : 0x0 [Type: unsigned long]</span><br><span class="line">31  [+0x034 (30:30)] ExtentQueryNeeded : 0x0 [Type: unsigned long]</span><br><span class="line">32  [+0x034 (31:31)] DirtyPages       : 0x0 [Type: unsigned long]</span><br></pre></td></tr></table></figure>
<p>其中<code>NextSubsection</code>指向下一个<code>SubSection</code>，所有的<code>SubSection</code>的<code>ControlArea</code>都相等，同时与真正的Section对象的<code>ControlArea</code>一样。</p>
<p>控制区即内存区对象的核心，也是找到内存区对象描述的内存的核心。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1 kd&gt; dx -id 0,0,fffffba8d3969a040 -r1 ((ntkrnlmp!_CONTROL_AREA *)0xfffffba8d3d3f7310)</span><br><span class="line">2 ((ntkrnlmp!_CONTROL_AREA *)0xfffffba8d3d3f7310)       : 0xfffffba8d3d3f7310 [Type: _CONTROL_AREA *]</span><br><span class="line">3  [+0x000] Segment         : 0xfffff83029553b00 [Type: _SEGMENT *]</span><br><span class="line">4  [+0x008] ListHead        : _LIST_ENTRY</span><br><span class="line">5  [+0x008] AweContext      : 0xfffffba8d3eea4dce0 [Type: void *]</span><br><span class="line">6  [+0x018] NumberOfSectionReferences : 0x1 [Type: unsigned __int64]</span><br><span class="line">7  [+0x020] NumberOfPfnReferences : 0x8 [Type: unsigned __int64]</span><br><span class="line">8  [+0x020] NumberOfMappedViews : 0x1 [Type: unsigned __int64]</span><br><span class="line">9  [+0x030] NumberOfUserReferences : 0x2 [Type: unsigned __int64]</span><br><span class="line">10 [+0x038] u               [Type: &lt;anonymous-tag&gt;]</span><br><span class="line">11 [+0x03c] u1              [Type: &lt;anonymous-tag&gt;]</span><br><span class="line">12 [+0x048] FilePointer     [Type: _EX_FAST_REF]</span><br><span class="line">13 [+0x048] ControlAreaLock : 0 [Type: long]</span><br><span class="line">14 [+0x04c] ModifiedWriteCount : 0x0 [Type: unsigned long]</span><br><span class="line">15 [+0x050] WaitList        : 0x0 [Type: _MI_CONTROL_AREA_WAIT_BLOCK *]</span><br><span class="line">16 [+0x050] u2              [Type: &lt;anonymous-tag&gt;]</span><br><span class="line">17 [+0x050] FileObjectLock  [Type: _EX_PUSH_LOCK]</span><br><span class="line">18 [+0x020] lockedPages     : 0x1 [Type: unsigned __int64]</span><br><span class="line">19 [+0x078] u3              [Type: &lt;anonymous-tag&gt;]</span><br></pre></td></tr></table></figure>
<p><code>FilePointer</code>：这是镜像文件特有的，如果共享内存是靠页面文件支撑的，那么此处为空。</p>
<h4 id="物理空间的管理"><a href="#物理空间的管理" class="headerlink" title="物理空间的管理"></a>物理空间的管理</h4><p>Windows对于物理空间的管理采用<code>MMPFNDATABASE+链表</code>构成。</p>
<h5 id="mmpfndatabase"><a href="#mmpfndatabase" class="headerlink" title="mmpfndatabase"></a>mmpfndatabase</h5><p>页帧数据库,物理地址1000,得到页帧,在MmPfnData中可以进行数组查找,每一个都是MMPFN的结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _mmpfn</span><br><span class="line">nt!_MMPFN</span><br><span class="line">   +0x000 ListEntry         : _LIST_ENTRY</span><br><span class="line">   +0x000 TreeNode          : _RTL_BALANCED_NODE</span><br><span class="line">   +0x000 u1                : &lt;anonymous-tag&gt;</span><br><span class="line">   +0x008 PteAddress        : Ptr64 _MMPTE</span><br><span class="line">   +0x008 PteLong           : Uint8B</span><br><span class="line">   +0x010 OriginalPte       : _MMPTE</span><br><span class="line">   +0x018 u2                : _MIPFNBLINK</span><br><span class="line">   +0x020 u3                : &lt;anonymous-tag&gt;</span><br><span class="line">   +0x024 NodeBlinkLow      : Uint2B</span><br><span class="line">   +0x026 Unused            : Pos 0, 4 Bits</span><br><span class="line">   +0x026 Unused2           : Pos 4, 4 Bits</span><br><span class="line">   +0x027 ViewCount         : UChar</span><br><span class="line">   +0x027 NodeFlinkLow      : UChar</span><br><span class="line">   +0x027 ModifiedListBucketIndex : Pos 0, 4 Bits</span><br><span class="line">   +0x027 AnchorLargePageSize : Pos 0, 2 Bits</span><br><span class="line">   +0x028 u4                : &lt;anonymous-tag&gt;</span><br><span class="line">kd&gt; dq mmpfndatabase</span><br><span class="line">fffff802`1b6fc508  fffff9700`00000000 00000000`00000000</span><br><span class="line">fffff802`1b6fc518  fffffba8d`396f7f00 00000000`00000006</span><br><span class="line">fffff802`1b6fc528  00000000`00000001 00000000`00000000</span><br><span class="line">fffff802`1b6fc538  fffffcb80`6c190000 fffffba8d`396f6a00</span><br><span class="line">fffff802`1b6fc548  00000001`00000000 00000000`0000001c</span><br><span class="line">fffff802`1b6fc558  0002625a`00000000 00000000`0002625a</span><br><span class="line">fffff802`1b6fc568  fffffba8d`396b6380 00000002`00000000</span><br><span class="line">fffff802`1b6fc578  00002320`00002710 00000000`00000000</span><br><span class="line">kd&gt; dt _mmpfn fffff9700`0000000+30*50</span><br><span class="line">nt!_MMPFN</span><br><span class="line">   +0x000 ListEntry         : _LIST_ENTRY [ 0x0f00436e`49400000 - 0xffffffffe80`000000 ]</span><br><span class="line">   +0x000 TreeNode          : _RTL_BALANCED_NODE</span><br><span class="line">   +0x000 u1                : &lt;anonymous-tag&gt;</span><br><span class="line">   +0x008 PteAddress        : 0xffffffffe80`000000 _MMPTE</span><br><span class="line">   +0x008 PteLong           : 0xffffffffe80`000000</span><br><span class="line">   +0x010 OriginalPte       : _MMPTE</span><br><span class="line">   +0x018 u2                : _MIPFNBLINK</span><br><span class="line">   +0x020 u3                : &lt;anonymous-tag&gt;</span><br><span class="line">   +0x024 NodeBlinkLow      : 0</span><br><span class="line">   +0x026 Unused            : 0y0000</span><br><span class="line">   +0x026 Unused2           : 0y0000</span><br><span class="line">   +0x027 ViewCount         : 0 &#x27;&#x27;</span><br><span class="line">   +0x027 NodeFlinkLow      : 0 &#x27;&#x27;</span><br><span class="line">   +0x027 ModifiedListBucketIndex : 0y0000</span><br><span class="line">   +0x027 AnchorLargePageSize : 0y00</span><br><span class="line">   +0x028 u4                : &lt;anonymous-tag&gt;</span><br></pre></td></tr></table></figure>
<p>如上.是找50000物理地址的MMPFN。我们可以验证一下,MMPFN的正确性。</p>
<p><strong>记住.下面的验证只适应私有内存:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !pte 600000</span><br><span class="line">VA 0000000000600000</span><br><span class="line">PXE at FFFFFEFFF7BFD000  PPE at FFFFFEFFF7BE0000  PDE at FFFFFEFFF7C00018  PTE at FFFFFE8000003000</span><br><span class="line">contains 0A0000009633B867 contains 0A0000009D93C867 contains 0A0000009C7C1867 contains 830000002ABAA867</span><br><span class="line">pfn 9633b  ---DA--UW-V pfn 9d93c  ---DA--UW-V pfn 9c7c1  ---DA--UW-V pfn 2abaa  ---DA--UW-V</span><br><span class="line"></span><br><span class="line">kd&gt; dt _mmpfn fffff9700`0000000+30*2abaa</span><br><span class="line">nt!_MMPFN</span><br><span class="line">   +0x000 ListEntry         : _LIST_ENTRY [ 0x00000000`00000001 - 0xffffffffe80`00003000 ]</span><br><span class="line">   +0x000 TreeNode          : _RTL_BALANCED_NODE</span><br><span class="line">   +0x000 u1                : &lt;anonymous-tag&gt;</span><br><span class="line">   +0x008 PteAddress        : 0xffffffffe80`00003000 _MMPTE</span><br><span class="line">   +0x008 PteLong           : 0xffffffffe80`00003000</span><br><span class="line">   +0x010 OriginalPte       : _MMPTE</span><br><span class="line">   +0x018 u2                : _MIPFNBLINK</span><br><span class="line">   +0x020 u3                : &lt;anonymous-tag&gt;</span><br><span class="line">   +0x024 NodeBlinkLow      : 0xffff</span><br><span class="line">   +0x026 Unused            : 0y0000</span><br><span class="line">   +0x026 Unused2           : 0y0000</span><br><span class="line">   +0x027 ViewCount         : 0xa1 &#x27;&#x27;</span><br><span class="line">   +0x027 NodeFlinkLow      : 0xa1 &#x27;&#x27;</span><br><span class="line">   +0x027 ModifiedListBucketIndex : 0y0001</span><br><span class="line">   +0x027 AnchorLargePageSize : 0y01</span><br><span class="line">   +0x028 u4                : &lt;anonymous-tag&gt;</span><br></pre></td></tr></table></figure>
<p>得出,找到PFN,发现,MMPFN的PteAddress=页表PteAddress,对于私有内存,MMPFN的PteAddress保存的就是进程PteBase区域的PteAddress。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dx -id 0,0xffffba8d3e512300 -r1 (*(ntkrnlmp!_MIPFNBLINK *)0xfffff970000802e18)</span><br><span class="line">(*(ntkrnlmp!_MIPFNBLINK *)0xfffff970000802e18) [Type: _MIPFNBLINK]</span><br><span class="line">    [+0x000 (35:0)] Blink            : 0x1 [Type: unsigned __int64]</span><br><span class="line">    [+0x000 (55:36)] NodeBlinkHigh    : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x000 (59:56)] TbFlushStamp     : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x000 (61:60)] Unused           : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x000 (62:62)] PageBlinkDeleteBit : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x000 (63:63)] PageBlinkLockBit : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x000 (61: 0)] ShareCount       : 0x1 [Type: unsigned __int64]</span><br><span class="line">    [+0x000 (62:62)] PageShareCountDeleteBit : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x000 (63:63)] PageShareCountLockBit : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x000] EntireField       : 0x1 [Type: unsigned __int64]</span><br><span class="line">    [+0x000] Lock              : 1 [Type: __int64]</span><br><span class="line">    [+0x000 (61: 0)] LockNotUsed      : 0x1 [Type: unsigned __int64]</span><br><span class="line">    [+0x000 (62:62)] DeleteBit        : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x000 (63:63)] LockBit          : 0x0 [Type: unsigned __int64]</span><br></pre></td></tr></table></figure>
<p>其中,ShareCount也印证了这是一块私有内存。</p>
<h6 id="MmGetVirtualForPhysical"><a href="#MmGetVirtualForPhysical" class="headerlink" title="MmGetVirtualForPhysical"></a>MmGetVirtualForPhysical</h6><p>Windows用它来从物理地址到虚拟地址的转换,本质上就是利用了MMPFN的性质。</p>
<p>即<strong>私有内存MMPFN的PteAddress等于页表的PteAddress</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Physical</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> __int64 __fastcall <span class="title">MmGetVirtualForPhysical</span><span class="params">(<span class="type">unsigned</span> __int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a1 &amp; <span class="number">0xFFF</span>) + (*(__QWORD *)(<span class="number">48</span> * (a1 &gt;&gt; <span class="number">12</span>) - <span class="number">6047313952760</span>i64) &lt;&lt; <span class="number">25</span> &gt;&gt; <span class="number">16</span>);<span class="comment">// FFFF FA80 0000 0008</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MmGetVirtualForPhysical proc near		; DATA XREF: .pdata:00000001400F4644↑o</span><br><span class="line">	mov	rax, rcx</span><br><span class="line">	shr	rax, 0Ch</span><br><span class="line">	lea	rdx, [rax+rax*2]	; (物理内存&gt;&gt;0c)*3</span><br><span class="line">	add	rdx, rdx		; PfnDataBase的索引*6</span><br><span class="line">	mov	rax, 0FFFFFFFA80000000008h ; MmPfnDataBase+8 但是实际上是固定的 收到ALSR制约</span><br><span class="line">							; (win10x 这个是固定地址)</span><br><span class="line">	mov	rax, [rax+rdx*8]	; 索引*48(48d=30h)</span><br><span class="line">	shl	rax, 19h			; 相当于去掉PteBase</span><br><span class="line">	mov	rdx, 0FFFFFF68000000000h	; PteBase</span><br><span class="line">	shl	rdx, 19h</span><br><span class="line">	and	ecx, 0FFFh</span><br><span class="line">	sub	rax, rdx</span><br><span class="line">	sar	rax, 10h</span><br><span class="line">	add	rax, rcx</span><br><span class="line">	retn</span><br><span class="line">; ---------------------------------------------------------------------------</span><br><span class="line">	align 10h</span><br><span class="line">MmGetVirtualForPhysical endpxxxxxxxx37 1.text:000000014052D2B0</span><br></pre></td></tr></table></figure>
<p>算法如上所述.本质上取了个巧,a1是物理地址.首先取得物理地址的低12算出页面偏移偏移。<br>然后根据物理地址取得PFN.MMPFN.PteAddress&lt;<25>&gt;16+偏移取得虚拟地址。</p>
<p>&lt;<25意义是去掉PTEBase,只留下距离PTEBase的索引,索引<<12>&gt;3就是PteAddress描述的虚拟地址,但是&lt;<25多移了16位,因此>&gt;16.刚好&lt;&lt;9位，根据物理地址算出虚拟地址。</p>
<p>这种算法决定了,对于共享物理内存,PteAddress到底是谁的进程的? 不清楚,因此共享物理内存无法计算.事实上,对于共享内存,这个地方是原型pte的地址。</p>
<p>另外,需要附加得到的值才有意义.因为返回的值是特定CR3的虚拟地址.这导致就算你不附加进程.假如你进程没有这块物理地址.所得到的虚拟地址也是无效的.简而言之,不附加,你是无法使用这块虚拟地址的。</p>
<h4 id="originalpte"><a href="#originalpte" class="headerlink" title="originalpte"></a>originalpte</h4><p>MMPFN.OriginalPte是一个叫做“原始页表项”的内存管理数据结构中的一个成员变量。它用于存储Windows API查询时的页面属性，以便在操作系统中正确管理页面。它由硬件管理器维护，当硬件发生变化时，硬件管理器会自动更新该值。</p>
<p>即API查询时返回的是OriginalPte。</p>
<p>对于共享内存是无效的。把Protection修改成0x18.NO_ACCESS。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MM_ZERO_ACCESS       0 <span class="comment">// this value is not used.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_READONLY          1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_EXECUTE           2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_EXECUTE_READ      3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_READWRITE         4 <span class="comment">// bit 2 is set if this is writable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_WRITECOPY         5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_EXECUTE_READWRITE 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_EXECUTE_WRITECOPY 7</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_NOCACHE           0x8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_GUARD_PAGE        0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_DECOMMIT          0x18 <span class="comment">// NO_ACCESS, Guard page</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_NOACCESS          0x18 <span class="comment">// NO_ACCESS, Guard_page, nocache.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_UNKNOWN_PROTECTION 0x100 <span class="comment">// bigger than 5 bits!</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dx -id 0,0xffffba8d3e512300 -r1 (*(nt!nt!_MMPTE_SOFTWARE *)0xffff970001846670)</span><br><span class="line">(*(nt!_MMPTE_SOFTWARE *)0xffff970001846670)                 [Type: _MMPTE_SOFTWARE]</span><br><span class="line">    [+0x000 (0:0)] Valid          : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x000 (1:1)] PageFileReserved : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x000 (2:2)] PageFileAllocated : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x000 (3:3)] ColdPage       : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x000 (4:4)] SwizzleBit     : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x000 (9:5)] Protection     : 0x18 [Type: unsigned __int64]</span><br><span class="line">    [+0x000 (10:10)] Prototype     : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x000 (11:11)] Transition    : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x000 (15:12)] PageFileLow   : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x000 (25:16)] UsedPageTableEntries : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x000 (26:26)] ShadowStack   : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x000 (31:27)] Unused        : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x000 (63:32)] PageFileHigh  : 0x4072c000 [Type: unsigned __int64]</span><br></pre></td></tr></table></figure>
<p>如上操作,用CE进行查看,发现已经是No_ACCESS了</p>
<p>但是仍然可以读出,此时我们使用WriteProcessMemory是失败的。</p>
<p>可以用于隐藏内存属性。</p>
<h3 id="原型pte"><a href="#原型pte" class="headerlink" title="原型pte"></a>原型pte</h3><p>原型PTE是共享内存特有的,对于共享内存,有可能会发生如下情况:</p>
<p>在处理可共享内存时，Windows 会为共享内存的每一页创建一种全局 PTE——称为原型 PTE。此原型始终表示共享页面的物理内存的真实状态。如果标记为Valid，则此原型 PTE 可以像在任何其他情况下一样充当硬件 PTE。如果标记为Not Valid，原型将向页面错误处理程序指示内存需要从磁盘调回。当给定内存页存在原型 PTE 时，该页的 PFN 数据库条目将始终指向原型 PTE。</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12171226.png" alt="描述符4"></p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12171227.png" alt="描述符4"></p>
<p>是因为,共享内存可能处于转换状态,也可能被换页出去硬件异常状态(意味着共享内存这个页被换到磁盘上),如果是转换状态,页面异常的处理只需要改变硬件PTE的V位即可,如果是硬件异常,则需要重新映射。</p>
<p>原型PTE就是风向标,特用来表面当硬件PTE无效(软异常或者是硬异常导致的)的页面是软还是硬异常。</p>
<p>如下图,硬件PTE无效,但是原型PTE有效,因此Page Fault Handler处理时只需要把无效的硬件PTE修改V位即可。不必重新映射。</p>
<p>前文提到,对于私有内存,MMPFN.PteAddress就是硬件Pte的地址,这一点已经验证过,而对于共享内存,MMPFN.PteAddress是原型PTE, 是Section对象ControlArea.Segment.PrototypePte。</p>
<p>验证如下:</p>
<p>使用这个VAD进行验证。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffffba8d3ee51040  5       75020       7502e           3 Mapped  Exe  EXECUTE_WRITECOPY  \Windows\SysWOW64\kernel.appcore.dll</span><br></pre></td></tr></table></figure>
<p>发现,硬件PteAddress的地址并不等于PteAddress。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !pte 75020000</span><br><span class="line">                        VA 0000000075020000</span><br><span class="line">PXE at FFFFFFF7FBFDF000    PPE at FFFFFFF7FBE00008    PDE at FFFFFFF7C0001D40    PTE at FFFFFFF80003A8100</span><br><span class="line">contains 0A000000934B867    contains 0A00000093B45867    contains 0A00000097AA9867    contains 82000000218DB000</span><br><span class="line">pfn 9643b    ---DA--UWEV    pfn 93b45    ---DA--UWEV    pfn 97a9a    ---DA--UWEV    pfn 218db    ------UR-V</span><br><span class="line"></span><br><span class="line">kd&gt; dt _mmpfn ffff9700&#x27;00000000+30*218db</span><br><span class="line">nt!_MMPFN</span><br><span class="line">   +0x000 ListEntry          : _LIST_ENTRY [ 0x00000000`00000001 - 0xfffff830`925453b60 ]</span><br><span class="line">   +0x010 TreeNode           : _RTL_BALANCED_NODE</span><br><span class="line">   +0x000 u1                 : &lt;anonymous-tag&gt;</span><br><span class="line">   +0x008 PteAddress         : 0xfffff830`925453b60 _MMPTE</span><br><span class="line">   +0x008 PteLong            : 0xfffff830`925453b60</span><br><span class="line">   +0x010 OriginalPte        : _MMPTE</span><br><span class="line">   +0x018 u2                 : _MPFNBLINK</span><br><span class="line">   +0x020 u3                 : &lt;anonymous-tag&gt;</span><br><span class="line">   +0x024 NodeBlinkLow       : 0x18dc</span><br><span class="line">   +0x026 Unused             : 0y0000</span><br><span class="line">   +0x026 Unused2            : 0y0000 &#x27;&#x27;</span><br><span class="line">   +0x027 ViewCount          : 0xd7 &#x27;&#x27;</span><br><span class="line">   +0x027 NodeFlinkLow       : 0xd7 &#x27;&#x27;</span><br><span class="line">   +0x027 ModifiedListBucketIndex : 0y0111</span><br><span class="line">   +0x027 AnchorLargePageSize : 0y11</span><br><span class="line">   +0x028 u4                 : &lt;anonymous-tag&gt;</span><br></pre></td></tr></table></figure>
<p>查看PteAddress的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dq 0xfffff830925453b60</span><br><span class="line">fffff830`925453b60  a8000000`218db121</span><br></pre></td></tr></table></figure>
<p>可以看出,都是表述的同一块物理地址,但是硬件PTE的属性和原型PTE属性是不一样的。</p>
<p>查看原型PTE：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[+0x000 ( 0: 0)] Valid                 : 0x1 [Type: unsigned __int64]</span><br><span class="line">[+0x000 ( 1: 1)] DemandFillProto       : 0x0 [Type: unsigned __int64]</span><br><span class="line">[+0x000 ( 2: 2)] HiberVerifyConverted  : 0x0 [Type: unsigned __int64]</span><br><span class="line">[+0x000 ( 3: 3)] ReadOnly              : 0x0 [Type: unsigned __int64]</span><br><span class="line">[+0x000 ( 4: 4)] SwizzleBit            : 0x0 [Type: unsigned __int64]</span><br><span class="line">[+0x000 ( 9: 5)] Protection            : 0x9 [Type: unsigned __int64]</span><br><span class="line">[+0x000 (10:10)] Prototype             : 0x0 [Type: unsigned __int64]</span><br><span class="line">[+0x000 (11:11)] Combined              : 0x0 [Type: unsigned __int64]</span><br><span class="line">[+0x000 (15:12)] Unused1               : 0xb [Type: unsigned __int64]</span><br><span class="line">[+0x000 (63:16)] ProtoAddress          : -129742372068979 [Type: __int64]</span><br></pre></td></tr></table></figure>
<p><code>[+0x000 ( 9: 5)] Protection      : 0x9 [Type: unsigned __int64]</code>意味着是写拷贝属性。</p>
<p>而对于私有内存,不需要原型PTE这个概念。因为私有内存不会转换,修建工作集。</p>
<h3 id="ptebase和页表自映射"><a href="#ptebase和页表自映射" class="headerlink" title="ptebase和页表自映射"></a>ptebase和页表自映射</h3><h4 id="ptebase"><a href="#ptebase" class="headerlink" title="ptebase"></a>ptebase</h4><p>所谓PTEBASE是指PML4表中某一个值为CR3之后形成的连锁反应。</p>
<p>即某个PML4E是CR3,这样线性地址解析最终得到的物理地址就是PTE,而这个线性地址就是PteBase。<br>为Index&lt;&lt;39==PteBase,修改这个地方的线性地址就是修改PTE,可以实现挂物理页的效果。</p>
<p>同理，解析时，CR3解析到第几层影响了最后线性地址解析到物理地址到底是什么。</p>
<h4 id="页表自映射"><a href="#页表自映射" class="headerlink" title="页表自映射"></a>页表自映射</h4><p>页表自映射原理就是PTEBASE的求法,在win10中,页表基质是变动的。</p>
<p>即通过GetVirtualForPhysical获取CR3 Base,遍历,找到一块内存==CR3的Index，Index&lt;&lt;39找到页目录基质。</p>
<p>代码实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ULONG_PTR <span class="title">PageAttrHide::GetPteBase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UINT64 cr3=_readcr3();</span><br><span class="line"></span><br><span class="line">    PHYSICAL_ADDRESS __cr3;</span><br><span class="line"></span><br><span class="line">    __cr<span class="number">3.</span>QuadPart = cr3;</span><br><span class="line"></span><br><span class="line">    UINT64* pml4e_va=(UINT64*)<span class="built_in">MmGetVirtualForPhysical</span>(__cr3);</span><br><span class="line">    <span class="comment">//DbgBreakPoint();</span></span><br><span class="line">    <span class="comment">//其实cr3本质上是PML4E的指针,但是因为Windows为了方便,就在这PML4E数组里面有cr3</span></span><br><span class="line">    <span class="comment">//所以找到PML4E指向cr3的index</span></span><br><span class="line">    UINT64 index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//512</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        UINT64 Pte = *(pml4e_va+i);</span><br><span class="line"></span><br><span class="line">        Pte &amp;= <span class="number">0xFFFFFFFFF000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Pte == cr3) &#123;</span><br><span class="line">            <span class="comment">//找到PML4E Index 直接左移39位就是PTEBASE</span></span><br><span class="line">            index = i;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;Num==0x%x&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//DbgPrintEx(77, 0, &quot;PML4E Phyaddr:0x%x cr3=0x%x\r\n&quot;, Pte,cr3);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[OxygenDriver]err:fatal err, cr3 err\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UINT64 PteBase = (index + <span class="number">0x1FFFE00</span>) &lt;&lt; <span class="number">39</span>;</span><br><span class="line">    <span class="comment">//DbgPrintEx(77, 0, &quot;[OxygenDriver]info: PteBase=0x%p\r\n&quot;, PteBase);</span></span><br><span class="line">    <span class="keyword">return</span> PteBase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="突破限制映射pagetable的两种方法"><a href="#突破限制映射pagetable的两种方法" class="headerlink" title="突破限制映射pagetable的两种方法"></a>突破限制映射pagetable的两种方法</h3><h4 id="physicalmemory-section对象映射"><a href="#physicalmemory-section对象映射" class="headerlink" title="physicalmemory section对象映射"></a>physicalmemory section对象映射</h4><p>在Win10之前,使用MmMapIoSpace：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID</span></span><br><span class="line"><span class="function"><span class="title">MmMapIoSpace</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PHYSICAL_ADDRESS PhysicalAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ SIZE_T NumberOfBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ MEMORY_CACHING_TYPE CacheType</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure>
<p>是可以映射页表相关的内存的比如CR3,Win10则不行。</p>
<p>采用另一种方法,内存区对象进行映射。前文讲过,内存区对象可以表述一块物理地址。Windows用名称为“PhysicalMemory”这个内存区对象表示了全部的物理内存。ZwMap即可以映射。值得一提,这个内存区对象只能在内核打开。</p>
<blockquote>
<p>实际上, 内存区对象代表了一种物理存储资源, 它可能在物理内存中, 也可能在系统页面文件中, 或者在其他的文件中。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Cr3 = *(PULONG_PTR)((UINT64)Process + Cr30ffset);</span></span><br><span class="line">Offset.QuadPart = Cr3;</span><br><span class="line"><span class="comment">//mapp cr3</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(<span class="built_in">ZwMapViewOfSection</span>(hSection,</span><br><span class="line">    <span class="built_in">NtCurrentProcess</span>(),</span><br><span class="line">    &amp;Cr3Page, <span class="number">0</span>, PAGE_SIZE,</span><br><span class="line">    &amp;Offset, &amp;nSize, ViewUnmap, MEM_TOP_DOWN, PAGE_READWRITE</span><br><span class="line">    ))) &#123;</span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;[+]unable to map cr3\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中Offset就是物理地址的偏移。映射之后Cr3Page就是映射的地址。</p>
<p>通过这个可以实现无附加读写,但是目前EAC会检查进程是否有PhysicalMemory这个节区对象的句柄。</p>
<h4 id="伪造pteaddress过MmMapIoSpace"><a href="#伪造pteaddress过MmMapIoSpace" class="headerlink" title="伪造pteaddress过MmMapIoSpace"></a>伪造pteaddress过MmMapIoSpace</h4><p>这个需要逆MmMapIoSpace;</p>
<p>MmMapIoSpace是一个可以把物理地址变成物理地址的API,而且导出。</p>
<p>然而,高版本Win10,是禁止用这个来映射CR3相关的物理内存的。</p>
<p>简而言之,改函数校验是通过<code>MmPfnDataBase.PteAddress</code>。</p>
<p>这是因为所有进程的Cr3物理内存所对应的映射到虚拟地址的地址都是一样的。</p>
<p>这是重点,每个进程的Cr3的物理地址都是不一样,但是最终这个Cr3映射到的线性地址是一样的。(这是因为页表自映射);</p>
<p>这一点可以去MmPfnDataBase.PteAddress验证。</p>
<p>而MmMapIoSpace就是验证,通过改物理地址,找到PteAddress,看看是不是PML4E_BASE。</p>
<p>如果是,那就不给映射。同样,MmMapIoSpace也用这种方法验证其他BASE(比如PteBase实际上是Pt物理地址),也是这种方法。</p>
<p>因此破除方法很简单,创建一个4kb空间,然后修改Cr3对应的MmPfnDataBase.PteAddress给新的分配空间的PteAddress即可。</p>
<p>这时候,Mm这个内存就不会失败了。</p>
<p>但是,这种方法实际上意义不大,因为只要是和页表有关的(PTE_BASE开始到结束),全都在MmMapIoSpace的屏蔽范围,也就是物理地址的PfnDataBase的PteAddress在上面的范围,通通不可映射。</p>
<p>而只改Cr3对应的PteAddress,也是只能够映射Cr3,没用实际意义。</p>
<h2 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h2><h2 id="cap5：x64apc机制和挂靠"><a href="#cap5：x64apc机制和挂靠" class="headerlink" title="cap5：x64apc机制和挂靠"></a>cap5：x64apc机制和挂靠</h2><p><a target="_blank" rel="noopener" href="https://github.com/ayyucedemirbas/Windows-Research-Kernel-WRK-">《wrk源码》</a><br><a target="_blank" rel="noopener" href="https://inarn.microsoft.com/zh-cn/sysinternals/resources/windows-internals">《windows internals 第七版》</a></p>
<h3 id="apc定义及其相关结构"><a href="#apc定义及其相关结构" class="headerlink" title="apc定义及其相关结构"></a>apc定义及其相关结构</h3><h4 id="apc定义"><a href="#apc定义" class="headerlink" title="apc定义"></a>apc定义</h4><p>APC全程异步过程调用,重点是异步和调用:是windows提供的一种基于线程的回调机制。</p>
<p>APC应用场景入下:</p>
<p>考虑如下情况,OS中存在两个线程,线程A和线程B:CPU正在执行线程A.但是线程A此时想要进行一些只有在线程B才能进行的操作,比如退出和获取线程CONTEXT。此时他可以插入APC.APC这个调用中是退出或者是获取/修改线程CONTEXT的操作。一旦线程切换,线程A插入的线程B的APC就会被执行.而这个APC不会被线程C执行，从而完成这个操作。</p>
<p>从上面描述,不难看出,APC其实有三大特征。</p>
<ul>
<li>基于特定线程环境的</li>
<li>异步的</li>
<li>一个调用</li>
</ul>
<p>事实上,因为APC的这三个性质,APC还有一个很大的用处。</p>
<p>考虑以下情况:</p>
<p>线程A正在读取一个很大的文件.大的一时半会读不完,这个时候可以使用APC,在IO硬件读完通知之后,向特定线程插入一个中断APC.这是一个和普通APC不一样的,他的IRQL=1.从而在这个APC中完成已经读写成功的操作。</p>
<h5 id="apc应用"><a href="#apc应用" class="headerlink" title="apc应用"></a>apc应用</h5><p>总的来说,APC应用大概分为两种场景：</p>
<ul>
<li><p>在不同的线程环境想要对特定的线程环境进行只有处于该特定环境才能做得事。</p>
<ul>
<li>比如退出,修改获取线程的CONTEXT。</li>
</ul>
</li>
<li><p>IO异步中断处理。</p>
<ul>
<li>即涉及IO异步操作。</li>
</ul>
</li>
</ul>
<h4 id="apc相关结构"><a href="#apc相关结构" class="headerlink" title="apc相关结构"></a>apc相关结构</h4><h5 id="kapc-state"><a href="#kapc-state" class="headerlink" title="kapc_state"></a>kapc_state</h5><p>Windows在ETHREAD中的成员，提供了两个APC链表（实际上算上备用APCState有四个），一个是内核APC的链表，一个是用户APC的链表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[+0x098] ApcState     : [Type: _KAPC_STATE]</span><br></pre></td></tr></table></figure>
<p>这个是当前正在使用的Apc状态。</p>
<p>他的结构成员如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[0x0000] ApcListHead        [Type: _LIST_ENTRY [2]]</span><br><span class="line">[0x0020] Process            : 0xfffff8e9fd780340 [Type: _KPROCESS *]</span><br><span class="line">[0x0028] InProgressFlags    : 0x0 [Type: unsigned char]</span><br><span class="line">[0x0028 (0: 0)] KernelApcInProgress : 0x0 [Type: unsigned char]</span><br><span class="line">[0x0028 (1: 1)] SpecialApcInProgress : 0x0 [Type: unsigned char]</span><br><span class="line">[0x0029] KernelApcPending   : 0x0 [Type: unsigned char]</span><br><span class="line">[0x002a] UserApcPendingAll  : 0x0 [Type: unsigned char]</span><br><span class="line">[0x002a (0: 0)] SpecialUserApcPending : 0x0 [Type: unsigned char]</span><br><span class="line">[0x002a (1: 1)] UserApcPending      : 0x0 [Type: unsigned char]</span><br></pre></td></tr></table></figure>
<p>不难看出,第一个成员就是ApcListHead,一个链表头。实际上,他链接的是一个_KAPC的结构。</p>
<p>而这个链表头有两个,其中Idx=0是内核链表,Idx=1是用户链表。</p>
<p>InProgressFlags代表是否正在处理APC；</p>
<p>UserApcPendingAll代表有用户APC正在等待。</p>
<p>而根据其成员可以看出,用户APC其实分为特殊用户APC和UserApc。</p>
<h5 id="alerted-2-和alertable"><a href="#alerted-2-和alertable" class="headerlink" title="alerted[2]和alertable"></a>alerted[2]和alertable</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+0x072] Alerted                [Type: unsigned char [2]]</span><br><span class="line">[+0x074 (4:4)] Alertable       : 0x0 [Type: unsigned long]</span><br></pre></td></tr></table></figure>
<p>Alertable代表是否可以唤醒，可以理解为一种开关，即在KeWaitSingleObject中，是否可以被APC打断。</p>
<p>而Alerted则是状态，即如果我在等待的时候被唤醒了，那么我就把这个位置1。</p>
<p>这个位决定了APC是否可以在被等待的时候执行，如果使用WaitXXEx，最后一个参数就是用来填写是否可以唤醒的。</p>
<h5 id="apcqueueable-apcstatepointer与apcstateindex"><a href="#apcqueueable-apcstatepointer与apcstateindex" class="headerlink" title="apcqueueable,apcstatepointer与apcstateindex"></a>apcqueueable,apcstatepointer与apcstateindex</h5><p>这属于时代的眼泪，x64已经无了。但是ApcStateIndex还是有的，0则代表没有附加，1代表有附加；</p>
<h5 id="savedapcstate"><a href="#savedapcstate" class="headerlink" title="savedapcstate"></a>savedapcstate</h5><p>这是备用的ApcState,挂靠会用到,挂靠可以简单理解为</p>
<p>假设有两个进程,P1和P2,线程T1属于P1,线程T2属于P2;</p>
<p>CPU正在运行P1的T1,但是想要读写下P2的内存,CR3是不一样的,因此T1使用<strong>线程挂靠</strong>来进行切换T1所属的进程。</p>
<p>事实上,一旦挂靠,如何恢复是个问题。因为每个进程的线程空间不一样,因此,Windows使用ApcState.Process来标志当前线程到底属于哪个进程。</p>
<p>如果涉及挂靠,那么T1的进程就是P2,但是总要恢复的,因此把APC_STATE整个复制到SavedApcState。等待恢复,再复原回来。</p>
<h5 id="kapc"><a href="#kapc" class="headerlink" title="kapc"></a>kapc</h5><p>这个便是APC的结构了,即插入APC链表的结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">nt!_KAPC</span><br><span class="line">  <span class="number">+0x000</span> Type            : UChar</span><br><span class="line">  <span class="number">+0x001</span> SpareByte0      : UChar</span><br><span class="line">  <span class="number">+0x002</span> Size            : UChar</span><br><span class="line">  <span class="number">+0x003</span> SpareByte1      : UChar</span><br><span class="line">  <span class="number">+0x004</span> SpareLong0      : UInt4B</span><br><span class="line">  <span class="number">+0x008</span> Thread          : Ptr64 _KTHREAD</span><br><span class="line">  <span class="number">+0x010</span> ApcListEntry    : _LIST_ENTRY</span><br><span class="line">  <span class="number">+0x020</span> KernelRoutine   : Ptr64    <span class="type">void</span></span><br><span class="line">  <span class="number">+0x028</span> RundownRoutine  : Ptr64    <span class="type">void</span></span><br><span class="line">  <span class="number">+0x030</span> NormalRoutine   : Ptr64    <span class="type">void</span></span><br><span class="line">  <span class="number">+0x020</span> Reserved        : [<span class="number">3</span>] Ptr64 Void</span><br><span class="line">  <span class="number">+0x038</span> NormalContext   : Ptr64 Void</span><br><span class="line">  <span class="number">+0x040</span> SystemArgument1 : Ptr64 Void</span><br><span class="line">  <span class="number">+0x048</span> SystemArgument2 : Ptr64 Void</span><br><span class="line">  <span class="number">+0x050</span> ApcStateIndex   : Char</span><br><span class="line">  <span class="number">+0x051</span> ApcMode         : Char</span><br><span class="line">  <span class="number">+0x052</span> Inserted        : UChar</span><br></pre></td></tr></table></figure>
<p>ApcListEntry就是链表挂入的地方。</p>
<p>KernelRoutine是内核APC;而RundownRoutine是APC执行完之后,会执行,一般用来清楚APC占用的空间。注意.APC是一定要是非分页的。</p>
<p>NormalRoutine则是正常去执行的,一般来说.用户APC必须有NormalRoutine.内核APC可以没有。</p>
<p>如果没有NormalRoutine,那么就是一个特殊的内核APC(中断APC);</p>
<p>ApcStateIndex:事实上,线程也有一个ApcStateIndex。如果是0,代表当前没有挂靠。如果是1,代表当前挂靠。但是KAPC.ApcStateIndex的取值是0-3;</p>
<p>这是因为,APC初始化和APC插入并不一定代表着这个线程挂靠没有发生变化。</p>
<p>通常</p>
<ol>
<li>无论你挂靠还是不挂靠,都插入原始环境(亲生父母)</li>
<li>挂靠则插挂靠环境,不挂靠则插原始环境</li>
<li>选择插入,初始APC的时候,判断一下,看线程的KTHREAD.ApcStateIndex，如果=0，插入原始环境,=1,插入挂靠环境。</li>
<li>选择插入,初始APC，不判断.只要插入一瞬间,进行判断。判断原理与2一样。(防止初始化和创建时候APC环境不一样)</li>
</ol>
<h5 id="apc控制位"><a href="#apc控制位" class="headerlink" title="apc控制位"></a>apc控制位</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[+0x1e4] KernelApcDisable : 0 [Type: short]</span><br><span class="line">[+0x1e6] SpecialApcDisable : 0 [Type: short]</span><br><span class="line">[+0x1e4] CombinedApcDisable : 0x0 [Type: unsigned long]</span><br></pre></td></tr></table></figure>
<p>看名字似乎是各管各的,其实是SpecialApcDisable是个超级开关,掌管一切APC。</p>
<p>其次,KernelApcDisable也不能关闭,一旦关闭就会蓝屏。</p>
<h3 id="apc从初始化到插入过程"><a href="#apc从初始化到插入过程" class="headerlink" title="apc从初始化到插入过程"></a>apc从初始化到插入过程</h3><h4 id="apc的初始化"><a href="#apc的初始化" class="headerlink" title="apc的初始化"></a>apc的初始化</h4><p>APC初始化是一个导出的内核API：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line"><span class="title function_">KeInitializeApc</span><span class="params">(</span></span><br><span class="line"><span class="params">    _out PRKAPC Apc,</span></span><br><span class="line"><span class="params">    _in PRKTHREAD Thread,</span></span><br><span class="line"><span class="params">    _in KAPC_ENVIRONMENT Environment,</span></span><br><span class="line"><span class="params">    _in PKKERNEL_ROUTINE KernelRoutine,</span></span><br><span class="line"><span class="params">    _in_opt PKRUNDOWN_ROUTINE RundownRoutine,</span></span><br><span class="line"><span class="params">    _in_opt PKNORMAL_ROUTINE NormalRoutine,</span></span><br><span class="line"><span class="params">    _in_opt KPROCESSOR_MODE ApcMode,</span></span><br><span class="line"><span class="params">    _in_opt PVOID NormalContext</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>实际上,这个函数很简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __stdcall <span class="title function_">KeInitializeApc</span><span class="params">(_KAPC *Apc, _ETHREAD *Thread, <span class="type">char</span> Environment, PVOID KernelRoutine, PVOID RundownRoutine, PVOID NormalRoutine, <span class="type">char</span> ApcMode, PVOID NormalContext)</span></span><br><span class="line">&#123;</span><br><span class="line">    Apc-&gt;Type = <span class="number">18</span>;                 <span class="comment">// 固定的</span></span><br><span class="line">    Apc-&gt;Size = <span class="number">88</span>;                 <span class="comment">// 申请的KAPC一定要是非分页的</span></span><br><span class="line">    <span class="keyword">if</span> ( Environment == <span class="number">2</span> )</span><br><span class="line">        Environment = Thread-&gt;Tcb._union_190.Affinity.Reserved[<span class="number">0</span>];<span class="comment">// ApcIndex</span></span><br><span class="line">                                    <span class="comment">// 可以看到 如果是2,那么永远是初始化的时候的亲生父母</span></span><br><span class="line">    Apc-&gt;ApcStateIndex = Environment;</span><br><span class="line">    Apc-&gt;RundownRoutine = RundownRoutine;</span><br><span class="line">    Apc-&gt;Thread = (__int64)Thread;</span><br><span class="line">    Apc-&gt;NormalRoutine = NormalRoutine;</span><br><span class="line">    Apc-&gt;KernelRoutine = KernelRoutine;</span><br><span class="line">    Apc-&gt;ApcMode = NormalRoutine != <span class="number">0</span>i64 ? ApcMode : <span class="number">0</span>;</span><br><span class="line">    Apc-&gt;NormalContext = (<span class="type">unsigned</span> __int64)NormalContext &amp; -(<span class="type">signed</span> __int64)(NormalRoutine != <span class="number">0</span>i64);</span><br><span class="line">    Apc-&gt;Inserted = <span class="number">0</span>;              <span class="comment">// 代表还未插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只是把参数给填入。<br>值得注意的时候,当插入环境是2,那么会进行一次判断。</p>
<h4 id="apc插入过程"><a href="#apc插入过程" class="headerlink" title="apc插入过程"></a>apc插入过程</h4><h5 id="keinsertqueueapc"><a href="#keinsertqueueapc" class="headerlink" title="keinsertqueueapc"></a>keinsertqueueapc</h5><p>插入APC的内核api也是导出的，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOLEAN</span><br><span class="line"><span class="title function_">KeInsertQueueApc</span> <span class="params">(</span></span><br><span class="line"><span class="params">    __inout PRKAPC Apc,</span></span><br><span class="line"><span class="params">    __in_opt PVOID SystemArgument1,</span></span><br><span class="line"><span class="params">    __in_opt PVOID SystemArgument2,</span></span><br><span class="line"><span class="params">    __in KPRIORITY Increment</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>在初始化完毕之后,就将以及初始化好的KAPC给插入到用户APC或者内核APC链表中。<br>实际上,KeInsertQueueApc是调用KiInsertQueueApc。<br>KeInsertQueueApc的大体过程如下：<br>首先获取线程的APC锁,因为插入APC涉及链表操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">cur_irql = KeGetCurrentIrql();</span><br><span class="line">  __writecr8(<span class="number">2u</span>i64);                          <span class="comment">// 提升到DPC_LEVEL,这就是为什么APC必须在非分页</span></span><br><span class="line">  <span class="keyword">if</span> ( KiIrqlFlags &amp;&amp; KiIrqlFlags &amp; <span class="number">1</span> &amp;&amp; cur_irql &lt;= <span class="number">0xFu</span> )<span class="comment">// 下面是获取APC_LOCK,因为APC是个链表 需要同步</span></span><br><span class="line">  &#123;</span><br><span class="line">      SchedulerAssist = KeGetCurrentPrcb()-&gt;SchedulerAssist;</span><br><span class="line">      *(DWORD *)(SchedulerAssist + <span class="number">20</span>) |= (<span class="number">-1</span> &lt;&lt; (cur_irql + <span class="number">1</span>)) &amp; <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  kpcr = KeGetCurrentPrcb();</span><br><span class="line">  v26 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v18 = kpcr-&gt;SchedulerAssist;</span><br><span class="line">    <span class="keyword">if</span> ( v18 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( kpcr-&gt;NestingLevel &lt;= <span class="number">1u</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            v24 = *(_DWORD *)(v18 + <span class="number">24</span>);</span><br><span class="line">            *(_DWORD *)(v18 + <span class="number">24</span>) = v24 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ( v24 == <span class="number">-1</span> )</span><br><span class="line">                KiRemoveSystemWorkPriorityKick(kpcr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !_interlockedbittestandset64((<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)&amp;InsertThread-&gt;Tcb.ThreadLock, <span class="number">0</span>i64) )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    v22 = kpcr-&gt;SchedulerAssist;</span><br><span class="line">    <span class="keyword">if</span> ( v22 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( kpcr-&gt;NestingLevel &lt;= <span class="number">1u</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            v25 = *(_DWORD *)(v22 + <span class="number">24</span>) - <span class="number">1</span>;</span><br><span class="line">            *(_DWORD *)(v22 + <span class="number">24</span>) = v25;</span><br><span class="line">            <span class="keyword">if</span> ( !v25 )</span><br><span class="line">                KiRemoveSystemWorkPriorityKick(kpcr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="title function_">KeYieldProcessorEx</span><span class="params">(&amp;v26)</span>;</span><br><span class="line">    <span class="keyword">while</span> ( InsertThread-&gt;Tcb.ThreadLock );  <span class="comment">// 一直获取才能结束</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>涉及到上述代码, 基本就是APC锁。<br>然后判断APC是否已经加入以及判断线程的MiscFlags是否允许插入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !(InsertThread-&gt;Tcb._union_17.MiscFlags &amp; <span class="number">0x4000</span>) || Apc_1-&gt;Inserted )<span class="comment">// 如果不可以插入APC或者APC已经被插入</span></span><br><span class="line">  &#123;                                                                          <span class="comment">// ApcQueueable:1;</span></span><br><span class="line">      insert_success = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">      Apc_1-&gt;Inserted = <span class="number">1</span>;</span><br><span class="line">      Apc_1-&gt;SystemArgument1 = (__int64)SystemArgument1_1;</span><br><span class="line">      Apc_1-&gt;SystemArgument2 = (__int64)SystemArgument2_1;</span><br><span class="line">      KiInsertQueueApc(Apc_1);                   <span class="comment">// 插入APC的核心函数</span></span><br><span class="line">      LOBYTE(v19) = cur_irql;</span><br><span class="line">      KiSignalThreadForApc(kpcr, Apc_1, v19);</span><br><span class="line">      insert_success = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  KiReleaseThreadLockSafe(InsertThread);         <span class="comment">// 释放ApcLock</span></span><br><span class="line">  KiExitDispatcher((<span class="type">char</span>)kpcr);</span><br><span class="line">  <span class="keyword">if</span> ( etw_open )                                <span class="comment">// 如果开了ETW 记录并且APC插入成功 进行记录</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span> ( insert_success )</span><br><span class="line">          EtwTiLogInsertQueueUserApc(</span><br><span class="line">              KeGetCurrentThread()-&gt;_union_171.UserAffinity.Reserved[<span class="number">0</span>],</span><br><span class="line">              (_DWORD)InsertThread,</span><br><span class="line">              (<span class="type">char</span>)NormalRoutine,</span><br><span class="line">              NormalContext,</span><br><span class="line">              (<span class="type">char</span>)SystemArgument1_1);</span><br><span class="line">      ObfDereferenceObjectWithTag((ULONG_PTR)InsertThread);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> insert_success;</span><br></pre></td></tr></table></figure>
<p>如果允许,则调用KiInsertQueueApc将APC插入。</p>
<h5 id="kiinsertqueueapc"><a href="#kiinsertqueueapc" class="headerlink" title="kiinsertqueueapc"></a>kiinsertqueueapc</h5><p>此函数首先验证APC.ApcIndex，正如上文所讲述那样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread = (PETHREAD)Apc-&gt;Thread;</span><br><span class="line"><span class="keyword">if</span> ( !Apc-&gt;ApcStateIndex &amp;&amp; LOBYTE(Thread-&gt;Tcb._union_190.Affinity.Reserved[<span class="number">0</span>]) )<span class="comment">// 此时ApcIndex 0 1 3</span></span><br><span class="line">&#123;                                                                                  <span class="comment">// 0进入</span></span><br><span class="line">    apc_offset = <span class="number">0x258</span>i64;                     <span class="comment">// SavedApcState</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;                                                                                  <span class="comment">// 3</span></span><br><span class="line">    Apc-&gt;ApcStateIndex = Thread-&gt;Tcb._union_190.Affinity.Reserved[<span class="number">0</span>];</span><br><span class="line">    apc_offset = <span class="number">0x98</span>i64;                      <span class="comment">// ApcState</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是3,则代表插入时候的环境。</p>
<p>接着就是插入判断逻辑了,简而言之就是：<br>特殊apc-内核特殊,用户特殊,以及退出线程APC,通通插在链表头, 同时因为退出线程APC和特殊用户APC本质上还是用户APC,因此需要把Pending置位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( Apc-&gt;NormalRoutine )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !(_BYTE)ApcMode )</span><br><span class="line">        <span class="keyword">goto</span> common_apc_insert;</span><br><span class="line">    kernel_routine = (<span class="type">void</span> (__noreturn *)())Apc-&gt;KernelRoutine;</span><br><span class="line">    <span class="keyword">if</span> ( kernel_routine == KiSchedulerApcTerminate )<span class="comment">// 特殊的apc</span></span><br><span class="line">                    <span class="comment">// 这是要退出了 需要插入头部</span></span><br><span class="line">    &#123;                                              </span><br><span class="line">        Thread-&gt;Tcb._union_90.ApcState._union_11.UserApcPendingAll |= <span class="number">2u</span>;<span class="comment">// +0x02a UserApcPending : Pos 1, 1 Bit 赶紧处理</span></span><br><span class="line">        apc_list = &amp;Apc-&gt;ApcListEntry;</span><br><span class="line">        apc_list_head = &amp;insert_apc_state-&gt;ApcListHead[ApcMode];</span><br><span class="line">        head_1 = (LIST_ENTRY *)apc_list_head-&gt;Flink;</span><br><span class="line">        <span class="keyword">if</span> ( *(PLIST_ENTRY *)(apc_list_head-&gt;Flink + <span class="number">8</span>) != apc_list_head )</span><br><span class="line">            <span class="keyword">goto</span> list_err;</span><br><span class="line">        apc_list-&gt;Flink = (__int64)head_1;        <span class="comment">// 头插法 说明这个还是比较特殊的 直接插到第一个位置</span></span><br><span class="line">        apc_list-&gt;Blink = (__int64)apc_list_head;</span><br><span class="line">        head_1-&gt;Blink = (__int64)apc_list;</span><br><span class="line">        apc_list_head-&gt;Flink = (__int64)apc_list;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">char</span> *)kernel_routine != (<span class="type">char</span> *)KeSpecialUserApcKernelRoutine )<span class="comment">// 不是特殊的用户APC</span></span><br><span class="line">    &#123;</span><br><span class="line">common_apc_insert:</span><br><span class="line">        apc_list_1 = &amp;Apc-&gt;ApcListEntry.Flink;</span><br><span class="line">        list_head = &amp;insert_apc_state-&gt;ApcListHead[ApcMode];</span><br><span class="line">        Tail = (LIST_ENTRY *)list_head-&gt;Blink;</span><br><span class="line">        <span class="keyword">if</span> ( (LIST_ENTRY *)Tail-&gt;Flink == list_head )</span><br><span class="line">        &#123;</span><br><span class="line">            *apc_list_1 = list_head;             <span class="comment">// 尾插 说明普通用户APC和普通内核都不是很紧急</span></span><br><span class="line">            apc_list_1[<span class="number">1</span>] = Tail;</span><br><span class="line">            Tail-&gt;Flink = (__int64)apc_list_1;</span><br><span class="line">            list_head-&gt;Blink = (__int64)apc_list_1;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">list_err:</span><br><span class="line">        __fastfail(<span class="number">3u</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    list_head_1 = &amp;insert_apc_state-&gt;ApcListHead[ApcMode];<span class="comment">// 能走到这 说明是特殊的用户APC</span></span><br><span class="line">    <span class="keyword">for</span> ( list_head_2 = (_LIST_ENTRY *)list_head_1-&gt;Flink;</span><br><span class="line">          list_head_2 != list_head_1;</span><br><span class="line">          list_head_2 = (_LIST_ENTRY *)list_head_2-&gt;Flink )</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread-&gt;Tcb._union_90.ApcState._union_11.UserApcPendingAll |= <span class="number">1u</span>;<span class="comment">// 把Pending置位,说明有APC</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;                                                   <span class="comment">// 能走到这,说明是特殊的内核APC</span></span><br><span class="line">    v12 = &amp;insert_apc_state-&gt;ApcListHead[ApcMode];</span><br><span class="line">    <span class="keyword">for</span> ( list_head_2 = (_LIST_ENTRY *)v12-&gt;Blink;</span><br><span class="line">          list_head_2 != v12 &amp;&amp; list_head_2[<span class="number">2</span>].Flink;</span><br><span class="line">          list_head_2 = (_LIST_ENTRY *)list_head_2-&gt;Blink )</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    head = (_LIST_ENTRY *)list_head_2-&gt;Flink;</span><br><span class="line">    apc_list_2 = &amp;Apc-&gt;ApcListEntry;</span><br><span class="line">    <span class="keyword">if</span> ( *(_LIST_ENTRY **)(list_head_2-&gt;Flink + <span class="number">8</span>) != list_head_2 )</span><br><span class="line">        <span class="keyword">goto</span> list_err;</span><br><span class="line">    apc_list_2-&gt;Flink = (__int64)head;             <span class="comment">// 头插法</span></span><br><span class="line">    apc_list_2-&gt;Blink = (__int64)list_head_2;</span><br><span class="line">    head-&gt;Blink = (__int64)apc_list_2;</span><br><span class="line">    list_head_2-&gt;Flink = (__int64)apc_list_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之,普通和特殊很大程度上就是插入APC链表需不需要排队的区别。</p>
<h3 id="apc执行过程"><a href="#apc执行过程" class="headerlink" title="apc执行过程"></a>apc执行过程</h3><p>apc执行，是调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line"><span class="title function_">KiDeliverApc</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN KPROCESSOR_MODE PreviousMode,</span></span><br><span class="line"><span class="params">    IN PEXCEPTION_FRAME ExceptionFrame,</span></span><br><span class="line"><span class="params">    IN PKTRAP_FRAME TrapFrame</span></span><br><span class="line"><span class="params">    )</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12181853.png" alt="描述符4"></p>
<p>通过交叉引用不难看出,此函数是经常被调用的。<br>比如等待,换线程,系统调用退出,因此,插入的APC一般是很快被执行的。<br>KiDeliverApc函数内部把用户APC和内核APC都给执行了。<br>但是参数不同,可能不会执行用户APC;因为有时候会发生APC中断,这个时候只能执行内核的中断APC;<br>如在系统调用完成之后的APC检查。</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12181854.png" alt="描述符4"></p>
<p>如果UserPending置位,可以看出,他就会进行APC执行。</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12181855.png" alt="描述符4"></p>
<p>有点类似于APC中断,在这个函数里面有KiDeliverApc。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B9 01 00 00 00          mov     ecx, 1</span><br><span class="line">48 8B D4                mov     rdx, rsp</span><br><span class="line">4C 8D 45 80             lea     r8, [rbp-80h]</span><br><span class="line">E8 E0 7C E1 FF          call    KiDeliverApc</span><br></pre></td></tr></table></figure>
<p>注意第一个参数是1,UserMode,这个很重要;<br>KiDeliverApc的参数如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line"><span class="title function_">KiDeliverApc</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN KPROCESSOR_MODE PreviousMode,</span></span><br><span class="line"><span class="params">    IN PEXCEPTION_FRAME ExceptionFrame,</span></span><br><span class="line"><span class="params">    IN PKTRAP_FRAME TrapFrame</span></span><br><span class="line"><span class="params">    )</span>;</span><br></pre></td></tr></table></figure>
<p>首先,会判断SpecialApcDisable是否开启,如果开启,所有APC无法执行;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apc_disable = HIWORD(cur_thread-&gt;Tcb._union_108.WaitBlock[<span class="number">3</span>].SpareLong) == <span class="number">0</span>;<span class="comment">// +0x1e6 SpecialApcDisable</span></span><br><span class="line"><span class="keyword">if</span> ( apc_disable )             <span class="comment">// 总开关 一旦关了这个 APC不会被执行</span></span><br><span class="line">&#123;</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<h4 id="内核apc执行"><a href="#内核apc执行" class="headerlink" title="内核apc执行"></a>内核apc执行</h4><p>在一切无误之后(Lock获取,APC可以执行),先会找到Kernel APC的链表;<br>这是一个循环,直到链表中没值了;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )          <span class="comment">// 一个循环</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (_KAPC_STATE *)ApcState-&gt;ApcListHead[<span class="number">0</span>].Flink == ApcState )<span class="comment">// 内核APC链表是空的</span></span><br><span class="line">        <span class="keyword">goto</span> user_apc_deliver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有,找到之后,就会一次执行KernelRoutine和NormalRoutine(如果有):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__writecr8(<span class="number">1u</span>i64);          <span class="comment">// 提升IRQL=1</span></span><br><span class="line">    cur_thread-&gt;Tcb._union_90.ApcState._union_3.InProgressFlags = <span class="number">1</span>;<span class="comment">// 正在执行APC</span></span><br><span class="line">    SystemArgument2_1 = (ULONG_PTR)&amp;SystemArgument2;</span><br><span class="line">    kernel_routine(thread, &amp;normal_routine, &amp;NormalContext);<span class="comment">// 先执行KernelRoutine</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__writecr8(<span class="number">0</span>i64);</span><br><span class="line">normal_routine(NormalContext, SystemArgument1, SystemArgument2);<span class="comment">// 如果有NormalRoutine ,在IRQL=0完成</span></span><br><span class="line">__writecr8(<span class="number">1u</span>i64);</span><br></pre></td></tr></table></figure>
<p>值得一提的是,当APC去执行的时候，ApcState.InProgressFlag会被置位;<br>普通的APC是第一位,而特殊的APC是第二位;</p>
<h4 id="用户apc执行"><a href="#用户apc执行" class="headerlink" title="用户apc执行"></a>用户apc执行</h4><p>当所有的内核APC被执行完毕,会比较AccessMode,是否是1,是1才会顺带着执行UserApc;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">user_apc_deliver:</span><br><span class="line">    <span class="keyword">if</span> ( AccessMode_1 == <span class="number">1</span> )         <span class="comment">// 可以看到,只有当AccessMode是user的时候,才会顺带着执行用户APC</span></span><br><span class="line">    &#123;</span><br><span class="line">        user_apc_head = (APCLIST *) &amp;cur_thread-&gt;Tcb._union_90.ApcState.ApcListHead[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> ( (APC_LIST *)user_apc_head-&gt;List.Flink != user_apc_head )<span class="comment">// 不为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//寻找逻辑</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>而用户APC的寻找逻辑就两条</p>
<ul>
<li>是否APC UserPending 有 直接拿出来;</li>
<li>是否有特殊用户APC;</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )        <span class="comment">// 从头开始遍历 如果UserApcPending置位或者有特殊的用户APC</span></span><br><span class="line">&#123;</span><br><span class="line">    Apc = (KAPC *)&amp;cur_apc_node[<span class="number">-1</span>].SystemArgument2;</span><br><span class="line">    __asm &#123; prefetchw byte ptr [rdi] &#125;</span><br><span class="line">    <span class="keyword">if</span> ( ( __int64 (__fastcall *)(_int64))cur_apc_node-&gt;KernelRoutine_ == KeSpecialUserApcKernelRoutine || v29.UserApcPendingAall &amp; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;                          <span class="comment">// break去执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    cur_apc_node = (APCLIST *)cur_apc_node-&gt;List.Flink;</span><br><span class="line">    Apc = <span class="number">0x164</span>; </span><br><span class="line">    <span class="keyword">if</span> ( cur_apc_node == user_apc_head )</span><br><span class="line">    &#123;</span><br><span class="line">        KernelRoutine = zero;</span><br><span class="line">        <span class="keyword">goto</span> release_thread_lock;       <span class="comment">// 遍历一遍 说明啥都没有</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难看出,如果有的话,APC是不为0的;</p>
<p>查找完成,清空APC这个结点,然后依次执行kernelroutine和KiInitializeUserApc。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( Apc )       <span class="comment">// 如果能找到 这个是有值的</span></span><br><span class="line">&#123;</span><br><span class="line">      SystemArgument2_1 = (ULONG_PTR)&amp;SystemArgument2;</span><br><span class="line">      KernelRoutine(Apc, &amp;normal_routine, &amp;NormalContext);<span class="comment">// 先去执行用户APC的kernelRoutine</span></span><br><span class="line">      <span class="keyword">if</span> ( v29.UserApcPendingAall &amp; <span class="number">2</span> )   </span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !normal_routine )<span class="comment">// 如果用户APC 但是normal_routine是0</span></span><br><span class="line">        &#123;   KeTestAlertThread(<span class="number">1</span>);           <span class="comment">// 如果当前不是被休眠状态,并且传入是1(UserNode),且APC链表不为空 那么设置UserPending位</span></span><br><span class="line">            <span class="keyword">goto</span> LABEL_17;</span><br><span class="line">        &#125;</span><br><span class="line">      v35 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          v35 = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v64 = v35;</span><br><span class="line">      v63 = SystemArgument2;</span><br><span class="line">      SystemArgument2_1 = SystemArgument1;</span><br><span class="line">      KiInitializeUserApc((_int64)ExFrame_1, (_int64)TrapFrame_1, (<span class="type">char</span>)normal_routine);<span class="comment">// 设置TRAP_FRAME 去normal_routine执行</span></span><br><span class="line">      <span class="keyword">goto</span> LABEL_17;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而KiInitializeUserApc就是用来执行用户的NormalRoutine的;<br>因为NormalRoutine是R3空间的,因此需要回到R3;<br>而内核APC所有的Routine都是内核的,因此不需要回到R3;<br>事实上,回到R3之后,还会NtContinueEx,再次回到R0,然后再去执行用户APC,直到执行完毕。</p>
<p>而KiInitializeUserApc的作用就是：</p>
<ul>
<li>获取一个CONTEXT,这个CONTEXT在堆栈中;</li>
<li>设置RSP,指向CONTEXT最低端的PHOME域</li>
<li>修改RIP,修改为ntdll!KeUserApcDispatcher</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KeContextFromKframes((__m128i *)TrapFrame_1, (__m128i *)ExFrame_1, (_int64)Context);<span class="comment">// 改函数就是把ExFrame和TrapFrame的东西复制到Context中 非常重要,方便以后恢复</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Context-&gt;P1Home = (__int64)NormalContext_1;</span><br><span class="line">  Context-&gt;P2Home = SysArg1;</span><br><span class="line">  Context-&gt;P3Home = (__int64)SysArg2;</span><br><span class="line">  Context-&gt;P4Home = (__int64)NormalRoutine_1;</span><br><span class="line">  TrapFrame_1-&gt;Rsp = (ULONGLONG)Context;       <span class="comment">// 这里 返回R3的RSP等于Context最顶部</span></span><br><span class="line">  TrapFrame_1-&gt;Rip = KeUserApcDispatcher;      <span class="comment">// 修改Rip到这个函数去执行用户APC</span></span><br><span class="line">  TrapFrame_1-&gt;SegCs = <span class="number">0x33</span>;</span><br></pre></td></tr></table></figure>
<p>因此,此时返回三环之后,RIP是KeUserApcDispatcher, 而RSP是如下结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RSP---------&gt; NormalContext</span><br><span class="line">              SysArg1</span><br><span class="line">              SysArg2</span><br><span class="line">              NormalRoutine</span><br></pre></td></tr></table></figure>
<p>返回R3之后,调用这个函数。</p>
<p>KiUserApcDispatcher：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mov rcx, [rsp+18h]    ;normal routine</span><br><span class="line">mov  rax, rcx         ; 从0环返回 此时RSP-&gt;Context</span><br><span class="line">                      ; 因此+0x018 P4Home     : 0x00007ff8`5869de70</span><br><span class="line">                      ; ContextRecord-&gt;P4Home = NormalRoutine_1;</span><br><span class="line">mov  r9, rsp          ; pContext</span><br><span class="line">sar  rcx, 2</span><br><span class="line">mov  rdx, [rsp+8]     ; SysArg1</span><br><span class="line">neg  rcx</span><br><span class="line">mov  r8, [rsp+10h]    ; sysArg2</span><br><span class="line">shld rcx, rcx, 20h</span><br><span class="line">test ecx, ecx        ; 不难看出 wow64的APC 的NormalRoutine是加密的</span><br><span class="line">jz   short wow_64_apc</span><br><span class="line">mov  rcx, [rsp+0]    ; NormalContext</span><br><span class="line">call KiUserCallForwarder ; 在这个里面执行NormalRoutine</span><br></pre></td></tr></table></figure>
<p>在执行完Apc之后,调用ZwContinueEx返回0环,同时参数是刚才的那个Context!<br>那个Context保存了如果没有执行用户APC本来该返回的所有上下文环境;<br>而NtContinueEx(WRK)则进行了如下校验。<br>简而言之,如果返回了0环,进行APC测试(KeTestAlertThread),还有APC,那么就继续去执行;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((UserStack - <span class="keyword">sizeof</span>(CONTEXT)) == (ULONG64)ContextRecord) &amp;&amp;</span><br><span class="line">    (Thread-&gt;ApcState.UserApcPending != FALSE)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Save the context record and exception frame addresses</span></span><br><span class="line">    <span class="comment">// in the trap frame and deliver the user APC bypassing</span></span><br><span class="line">    <span class="comment">// the context copy.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    TrapFrame-&gt;ContextRecord = (ULONG64)ContextRecord;</span><br><span class="line">    TrapFrame-&gt;ExceptionFrame = (ULONG64)ExceptionFrame;</span><br><span class="line">    KiDeliverApc(UserMode, <span class="literal">NULL</span>, TrapFrame);</span><br><span class="line">    Status = STATUS_SUCCESS;</span><br><span class="line">    leave;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有APC了,那么就根据提供的CONTEXT进行复原。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KiContinuePreviousModeUser(ContextRecord,</span><br><span class="line">                          ExceptionFrame,</span><br><span class="line">                          TrapFrame);</span><br></pre></td></tr></table></figure>
<p>因此,形成了一个可以遍历所有用户APC的完美闭环;</p>
<h3 id="线程附加"><a href="#线程附加" class="headerlink" title="线程附加"></a>线程附加</h3><p>事实上,挂靠很简单:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID __fastcall <span class="title">KeStackAttachProcess</span><span class="params">(PEPROCESS Process, _KAPC_STATE *Apc)</span></span></span><br></pre></td></tr></table></figure>
<p>函数定义如上。<br>而传入的APC_STATE,可能会用到,也可能不会用到:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">LOBYTE</span>(cur_thread-&gt;union_<span class="number">190.</span>Affinity.Reserved[<span class="number">0</span>]) ) <span class="comment">// ApcIndex</span></span><br><span class="line">  &#123;</span><br><span class="line">    result.DpcRequestSummary = <span class="built_in">KiAttachProcess</span>((__int64)cur_thread, Process_1, v6, <span class="number">0</span>,(__int64)Apc_1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result.DpcRequestSummary = <span class="built_in">KiAttachProcess</span>(</span><br><span class="line">          (__int64)cur_thread,</span><br><span class="line">          Process_1,</span><br><span class="line">          v6,</span><br><span class="line">          <span class="number">0</span>,</span><br><span class="line">          (__int64)&amp;cur_thread-&gt;union_200);</span><br><span class="line">    Apc_1-&gt;Process = <span class="number">0</span>i64;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如果线程已经附加(SavedAPCState被用了),那么就用传来的,否则就用备用的;</p>
<p>然后调用KiAttachProcess来进行附加,在这个里面进行复制之前的APCSTATE到提供的APCSTATE;</p>
<p>同时切换CR3;</p>
<p>在进入KiAttachProcess之后;</p>
<p>首先就复制cur_apc_state到saved_apc_state:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">saved_apc-&gt;Process = cur_thread-&gt;Tcb.ApcState.Process;<span class="comment">// 把当前的APC_STATE保存到savedApc中</span></span><br><span class="line">  saved_apc_1-&gt;_union_<span class="number">3.</span>InProgressFlags = cur_thread-&gt;Tcb.ApcState._union_<span class="number">3.</span>InProgressFlags;</span><br><span class="line">  saved_apc_1-&gt;KernelApcPending = cur_thread-&gt;Tcb.ApcState.KernelApcPending;</span><br><span class="line">  saved_apc_1-&gt;_union_<span class="number">11.</span>UserApcPendingAll = cur_thread-&gt;Tcb.ApcState._union_<span class="number">11.</span>UserApcPendingAll;</span><br><span class="line">  ker_apc_list_head = cur_thread-&gt;Tcb.ApcState.ApcListHead[<span class="number">0</span>].Flink;</span><br></pre></td></tr></table></figure>
<p>其次就是复制用户链表和内核APC链表。</p>
<p>最后切换CR3，当然，因为特殊的机制,切换CR3也有了变化:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">new_cr3 = attach_process-&gt;Pcb.DirectoryTableBase;<span class="comment">// KiLoadDirectoryTableBase</span></span><br><span class="line">  <span class="keyword">if</span> ( KiKvaShadow )             <span class="comment">// KPTI开启</span></span><br><span class="line">  &#123;</span><br><span class="line">      no_flush_tlb_cr3 = attach_process-&gt;Pcb.DirectoryTableBase;</span><br><span class="line">      <span class="keyword">if</span> ( new_cr3 &amp; <span class="number">2</span> )         <span class="comment">// KernelCr3 如果是内核cr3 那就不会使TLB失效</span></span><br><span class="line">          no_flush_tlb_cr3 = new_cr3 | <span class="number">0x8000000000000000u</span>i64; <span class="comment">// 最高位,即不需要刷新TLB</span></span><br><span class="line">      __writesqword(<span class="number">0x9000u</span>, no_flush_tlb_cr3); <span class="comment">// KernelDirectoryTableBase</span></span><br><span class="line">      <span class="built_in">KiSetAddressPolicy</span>((<span class="type">unsigned</span> __int8)attach_process-&gt;Pcb.AddressPolicy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  result = (<span class="type">unsigned</span> <span class="type">int</span>)HvlEnlightenments; <span class="comment">// 是否开启hyper-V</span></span><br><span class="line">  <span class="keyword">if</span> ( HvlEnlightenments &amp; <span class="number">1</span> )   </span><br><span class="line">      result = <span class="built_in">HvlSwitchVirtualAddressSpace</span>(new_cr3);<span class="comment">// HV切换Cr3</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      __writecr3(new_cr3);</span><br><span class="line">  <span class="keyword">if</span> ( !KiFlushPcid &amp;&amp; KiKvaShadow ) <span class="comment">// 不支持自动刷新pcid 并且KPTI开启</span></span><br><span class="line">  &#123;</span><br><span class="line">      cr4 = __readcr4();</span><br><span class="line">      <span class="keyword">if</span> ( cr4 &amp; <span class="number">0x20080</span> )</span><br><span class="line">      &#123;</span><br><span class="line">          result = cr4 ^ <span class="number">0x80</span>;</span><br><span class="line">          __writecr4(cr4 ^ <span class="number">0x80</span>);</span><br><span class="line">          __writecr4(cr4);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          result = __readcr3();       <span class="comment">// 刷新TLB</span></span><br><span class="line">          __writecr3(result);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>简而言之.就是如果有PCIDE机制,那么为了更快的性能,Windows肯定是开PCIDE的,kernel的PCID是2,User的是1,因此他就不刷新TLB了;</p>
<h2 id="lab5"><a href="#lab5" class="headerlink" title="lab5"></a>lab5</h2><h2 id="cap6：x64异常处理"><a href="#cap6：x64异常处理" class="headerlink" title="cap6：x64异常处理"></a>cap6：x64异常处理</h2><p><a href="https://njmxye.de5.net/2025/12/14/x64%E4%BD%93%E7%B3%BB%E6%8E%A2%E7%B4%A2%E5%8F%8A%E7%BC%96%E7%A8%8B/">x86x64体系探索及编程</a><br><a target="_blank" rel="noopener" href="https://gitcode.com/Universal-Tool/6b12e">英特尔® 64和IA-32架构软件开发人员手册</a><br><a target="_blank" rel="noopener" href="https://inarn.microsoft.com/zh-cn/sysinternals/resources/windows-internals">《windows internals 第七版》</a></p>
<h3 id="中断与异常硬件概论"><a href="#中断与异常硬件概论" class="headerlink" title="中断与异常硬件概论"></a>中断与异常硬件概论</h3><h4 id="异常中断的区别"><a href="#异常中断的区别" class="headerlink" title="异常中断的区别"></a>异常中断的区别</h4><p>这里的中断与异常会一直区分，可以近似地讲二者理解为同一类事物；二者有些许区别，不必特别关注；<br>中断和异常使用相同的执行环境和机制，包括：</p>
<ul>
<li>IDT是一样的</li>
<li>Vector范围一样(0-255)</li>
<li>处理过程是类似的</li>
</ul>
<p>区别是：</p>
<ul>
<li>异常可能会出现ErrCode</li>
<li>内部外部的硬件中断请求，可以进行屏蔽(mask)，除了NMI；</li>
<li>异常不可屏蔽;</li>
</ul>
<h4 id="apic架构的中断分类"><a href="#apic架构的中断分类" class="headerlink" title="apic架构的中断分类"></a>apic架构的中断分类</h4><h5 id="硬件产生"><a href="#硬件产生" class="headerlink" title="硬件产生"></a>硬件产生</h5><p>这个和apic有关，下图是一张apic架构图：</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12182252.png" alt="描述符4"><br><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12182253.png" alt="描述符4"></p>
<p>事实上,现代的处理器中断框架=APIC=LAPIC+IO APIC:</p>
<ul>
<li><strong>IO APIC</strong>: I/O APIC负责接收由系统硬件和I/O设备生成的中断, 收集设备发来的中断,在此处建立中断请求于向量号的对应关系,并将它们作为中断消息转发到本地APIC。</li>
<li><strong>LOCAL APIC</strong>: 每个本地APIC由一组APIC寄存器和相关的硬件组成, 它们控制向处理器核心发送中断和IPI消息的生成。APIC寄存器是内存映射的, 可以使用MOV指令读取和写入。也可以通过读写MSR寄存器的方式对APIC提供的功能进行配置。</li>
</ul>
<p>一般来说,硬件产生的分为Maskable和NonMaskable:</p>
<ul>
<li>处理器的INTR pin接收到的都是MI,比如INTR链接APIC的LINT0上、LAPIC产生的本地中断、芯片组上来自IO APIC的中断都是可屏蔽中断;</li>
<li>而不可屏蔽中断包括CPU的NMI pin链接到APIC的LINT1上,来自这个地方的APIC信号;</li>
</ul>
<h5 id="软件产生"><a href="#软件产生" class="headerlink" title="软件产生"></a>软件产生</h5><p>可以理解为指令产生的,比如INT x;</p>
<h4 id="异常源与异常的修复"><a href="#异常源与异常的修复" class="headerlink" title="异常源与异常的修复"></a>异常源与异常的修复</h4><ul>
<li><p><strong>代码错误</strong><br>比如<code>#GP</code>(General Protected) <code>#PF</code> <code>#DE</code> <code>#UD</code>(Invalid Opcode)</p>
</li>
<li><p><strong>主动引发</strong><br>int3</p>
</li>
<li><p><strong>Machine-Check</strong><br>硬件提供了某些指令,可以用这个指令检测,一旦检查失败,触发Machine-Check异常;<br>无论如何,异常是无法频闭的,是CPU内部发生的;<br>这个和NMI的不可频闭原理是不同的,NMI不可频闭的原理是由于CPU的NMI pin接受到的中断,而异常是因为如果屏蔽,无法继续执行了;</p>
</li>
</ul>
<h5 id="异常恢复"><a href="#异常恢复" class="headerlink" title="异常恢复"></a>异常恢复</h5><p>通常来说,异常是可以恢复的,但是也有不可恢复的:</p>
<ul>
<li><strong>Fault(可以恢复)</strong><br>刚才所说的,<code>#GP</code>,<code>#PF</code></li>
<li><strong>Trap(一般不影响正常执行)</strong><br><code>#BP</code></li>
<li><strong>Abort(不可恢复)</strong><br><code>#MC</code>和<code>#DF</code>都是不可恢复的;</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>当调用下列的中断处理程序时</th>
<th>再次产生下列中断</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>#DE</code>异常<br><code>#TS</code>异常<br><code>#NP</code>异常<br><code>#SS</code>异常<br><code>#GP</code>异常</td>
<td><code>#DE</code>异常<br><code>#TS</code>异常<br><code>#NP</code>异常<br><code>#SS</code>异常<br><code>#GP</code>异常</td>
</tr>
<tr>
<td>2</td>
<td><code>#PF</code> 异常</td>
<td><code>#DE</code>异常<br><code>#TS</code>异常<br><code>#NP</code>异常<br><code>#SS</code>异常<br><code>#GP</code>异常<br><code>#PF</code>异常</td>
</tr>
</tbody>
</table>
</div>
<p><code>#DF</code>双重错误由于一个fault产生时,没有成功进入这个Handler,而在这个过程中,处理器又遇到另一种异常,导致CPU无法执行双重fault,产生<code>#DF</code>;</p>
<p>事实上,<code>#DF</code>触发多是因为cr3错误或者是IDT表错误引发的;</p>
<h4 id="中断vector"><a href="#中断vector" class="headerlink" title="中断vector"></a>中断vector</h4><p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12182324.png" alt="描述符4"></p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12182325.png" alt="描述符4"></p>
<p>32往后，就是Intel开放给用户(OS)用的了；每次触发中断，L APIC根据IO APIC的IRQ翻译成对应的IDT索引；</p>
<h4 id="中断的屏蔽"><a href="#中断的屏蔽" class="headerlink" title="中断的屏蔽"></a>中断的屏蔽</h4><ul>
<li>cli、sti</li>
<li>中断门自动频闭，陷阱门不频闭；</li>
</ul>
<h4 id="idtr和gate描述符"><a href="#idtr和gate描述符" class="headerlink" title="idtr和gate描述符"></a>idtr和gate描述符</h4><p>IA32E模式下、在IDT表中，存放中断门、陷阱门描述符；中断门和陷阱门其他地方都是一样，只有Type不一样；</p>
<p>Type域中，1111是Trap，1110是中断门。值得一提的是，win没有用陷阱门，IDT表里面所有的东西都是中断门；这样做的目的主要是为了防止中断被打断，造成中断响应不及时；</p>
<p>总之，现在APIC的CPU中，LAPIC会将中断转换成对应于IDT的索引，让CPU执行这个中断流程；</p>
<h4 id="irql和apic中断优先级"><a href="#irql和apic中断优先级" class="headerlink" title="irql和apic中断优先级"></a>irql和apic中断优先级</h4><p>中断优先级是硬件的概念，IRQL是MS自己根据硬件映射的概念。</p>
<p>事实上，APIC中断，每个由LAPIC—&gt;CPU都有一个优先级，而优先级是基于向量号的；<br>其中，中断向量是一个8比特的值（所以理论上有256个中断），但是高四位是中断优先权；<br>（而事实上，中断优先权只有14类，因为0-31是被CPU保存了，不能用于用户的；）所以，将中断向量除以16，商就是他的中断优先权。这也就解释了为什么3-F才是硬件(IO)的中断IRQL，而0 1 2是软件的IRQL；<br>不管中断优先级是多少，只要CPU空闲，都会得到处理；TPR用来设置优先级的阈值。</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12182355.png" alt="描述符4"></p>
<p>这个TRP是在LAPIC的某个偏移中，[7:4]是任务优先权类；[3:0]是任务优先权子类；<br>看起来很复杂，其实数值上就等于中断向量号；只要一个新的中断进入，那么只要有中断进来了，比这个寄存器小，那么这个中断就不会投递到CPU；</p>
<p>LAPIC还有一个寄存器叫做PPR（处理器优先级寄存器PPR）是只读的，由处理器负责写入，是用来纪录处理器当前的优先级；</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12182356.png" alt="描述符4"></p>
<p>它等于当前正在处理的中断的向量号，如果没有处理，那么就是等于TPR；</p>
<p>TPR[7:4]被映射为Cr8寄存器，软件通过设置当前中断优先级（通过读写Cr8）来阻塞中断。</p>
<p>The value of the PPR is based on the value of TPR and the value ISRV: ISRV is the vector number of the highest priority bit that is set in the ISR or 00h if no bit is set in the ISR. (See Section 10.8.4 for more details on the ISR.)<br>The value of the PPR is determined as follows:</p>
<ul>
<li>PPR[7:4] (the processor-priority class) is the maximum of TPR[7:4] (the task- priority class) and ISRV[7:4] (the priority of the highest priority interrupt in service).</li>
<li>PPR[3:0] (the processor-priority sub-class) is determined as follows:<ul>
<li>If TPR[7:4] &gt; ISRV[7:4], PPR[3:0] is TPR[3:0] (the task-priority sub-class).</li>
<li>If TPR[7:4] &lt; ISRV[7:4], PPR[3:0] is 0.</li>
<li>If TPR[7:4] = ISRV[7:4], PPR[3:0] may be either TPR[3:0] or 0. The actual behavior is model-specific.</li>
</ul>
</li>
</ul>
<h5 id="irql"><a href="#irql" class="headerlink" title="irql"></a>irql</h5><p>Windows使用APIC给每一个中断都赋值了一个IRQL。</p>
<p>事实上,IRQL就是CR8,而CR8是local APIC中的TPR（Task-Priority Register）寄存器，用于描述此local APIC所属核心的当前的中断优先级的<strong>阈值</strong>；是阈值而不是当前值,当前值在PPR中,而且是只读的；</p>
<p>而Win是给每个IO外部的ISR分配了与中断相关的中断对象；IRQL在这里面；下图是一个IO设备中断的典型流程：</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12190011.png" alt="描述符4"></p>
<p>为什么说IRQL&gt;=2不可以用非分页内存和线程切换？<br>以下均摘自参考《windows internals》。</p>
<blockquote>
<p>As mentioned earlier, on x64 systems,the IRQL is stored in the CR8 register that maps back to the TPR on the APIC.<br>when an interrupt occurs, the trap handler (or perhaps the processor, depending on its architecture) raises the processor’s IRQL to the assigned IRQL of the interrupt source.<br>This elevation masks all interrupts at and below that IRQL (on that processor only), which lower level. The masked interrupts are either handled by another processor or held back until the IRQL drops. Therefore, all components of the system, including the kernel and device drivers, attempt to keep the IRQL at passive level (sometimes called low level). They do this because device drivers can reperiods. Thus, when the system is not performing any interrupt work (or needs to synchronize with it) or handling a software interrupt such as a DPC or APC, the IRQL is always 0. This obviously includes any fects on system operation. In fact, returning to a user-mode thread with the IRQL above 0 results in an immediate system crash (bugcheck) and is a serious driver bug.<br>Finally, note that dispatcher operations themselves—such as context switching from one thread to another due to preemption—run at IRQL 2 (hence the name dispatch level), meaning that the processor behaves in a single-threaded, cooperative fashion at this level and above. It is, for example, illegal to wait on a dispatcher object (more on this in the “Synchronization” section that follows) at this IRQL, as a context switch to a different thread (or the idle thread) would never occur. Another restriction is that only nonpaged memory can be accessed at IRQL DPC/dispatch level or higher.<br>This rule is actually a side effect of the first restriction because attempting to access memory that isn’t resident results in a page fault. When a page fault occurs, the memory manager initiates a disk I/O and then needs to wait for the file system driver to read the page in from disk. This wait would, in turn, require the scheduler to perform a context switch (perhaps to the idle thread if no user thread is waiting to run), thus violating the rule that the scheduler can’t be invoked (because the IRQL is still DPC/dispatch level or higher at the time of the disk read). A further problem results in the fact that I/O completion typically occurs at APC_LEVEL, so even in cases where a wait wouldn’t be required, the I/O would never complete because the completion APC would not get a chance to run.<br>If either of these two restrictions is violated, the system crashes with an IRQL_NOT_LESS_OR_EQUAL or a DRIVER_IRQL_NOT_LESS_OR_EQUAL crash code. (See Chapter 10, “Management, diagnostics, and tracing” for a thorough discussion of system crashes.) Violating these restrictions is a common bug in device drivers. The Windows Driver Verifier has an option you can set to assist in finding this particular type of bug.</p>
</blockquote>
<p>总结就是,IRQL&gt;=2,会屏蔽线程切换,因为时钟中断用到了一个DISPATCH_LEVEL的软件中断，如果此时代码IRQL&gt;=2,是不会触发的,也就是IRQL&gt;=2,是不会进行线程切换;</p>
<p>而不能使用非分页内存则是因为一旦涉及分页,触发<code>#PF</code>,这个时候就会涉及IO操作,而一旦涉及IO,就会导致线程切换,这个IO插本线程一个内核特殊APC以触发这个软中断;但是此时不能线程切换,而且也不能受到APC的软中断;因此不能用非分页的内存;</p>
<h3 id="r0-r3异常派遣分析"><a href="#r0-r3异常派遣分析" class="headerlink" title="r0-r3异常派遣分析"></a>r0-r3异常派遣分析</h3><p>这里说的是异常派遣,而非中断.中断并不会走这个路径;<br>总体来说,一个异常派遣的路径是：<br>IDT的前置函数(KiXXXtrap.主要作用就是关stac,切gs)-&gt;KiExceptionDispatch(用于收集并设置ExceptionRecord)-&gt;KiExceptionDispatch(R0处理最重要的函数，涉及到R0异常的展开，R3异常的分配)<br>此时,根据previousMode处理,如果是R3,则会复制堆栈,修改RSP、RIP到对应的地方;此时RIP被换到ntdll!KiUserExceptionDispatcher中;<br>在进入R3的异常派遣的时候,RSP是这样的：</p>
<p><img src="https://gh-proxy.org/https://github.com/njmxye/cdn2/raw/refs/heads/main/12190945.png" alt="描述符4"></p>
<h4 id="x64veh逆向"><a href="#x64veh逆向" class="headerlink" title="x64veh逆向"></a>x64veh逆向</h4><h5 id="veh简介"><a href="#veh简介" class="headerlink" title="veh简介"></a>veh简介</h5><h4 id="x64原生seh逆向"><a href="#x64原生seh逆向" class="headerlink" title="x64原生seh逆向"></a>x64原生seh逆向</h4><h3 id="seh的修复"><a href="#seh的修复" class="headerlink" title="seh的修复"></a>seh的修复</h3><h4 id="正常加载dll无须加载修复"><a href="#正常加载dll无须加载修复" class="headerlink" title="正常加载dll无须加载修复"></a>正常加载dll无须加载修复</h4><h4 id="x86seh的修复"><a href="#x86seh的修复" class="headerlink" title="x86seh的修复"></a>x86seh的修复</h4><h4 id="x64seh的修复"><a href="#x64seh的修复" class="headerlink" title="x64seh的修复"></a>x64seh的修复</h4><h4 id="异常callbacks"><a href="#异常callbacks" class="headerlink" title="异常callbacks"></a>异常callbacks</h4><h5 id="RtlInstallFunctionTableCallback函数的实现"><a href="#RtlInstallFunctionTableCallback函数的实现" class="headerlink" title="RtlInstallFunctionTableCallback函数的实现"></a>RtlInstallFunctionTableCallback函数的实现</h5><blockquote>
<p>上面都没笔记。</p>
</blockquote>
<h3 id="传统veh"><a href="#传统veh" class="headerlink" title="传统veh"></a>传统veh</h3><ul>
<li>容易检测<br>LdrpVectoredList可以遍历链表查询到。</li>
<li>容易屏蔽<br>PEB.CrossProcessFlags.ProcessUsingVEH reset即可屏蔽。</li>
<li>会被KiUserExceptionDispatch的Hook影响<br>一旦反作弊Hook了KiUserExceptionDispatch-&gt;,VEH无法得到派遣。</li>
</ul>
<h3 id="超级VEH"><a href="#超级VEH" class="headerlink" title="超级VEH"></a>超级VEH</h3><ul>
<li>正常方式无法检测</li>
<li>对R3无驱动进程属于降维打击</li>
<li>不被检测就无法屏蔽</li>
<li>不会收到KiUserExceptionDispatch Hook的影响</li>
</ul>
<h2 id="lab6"><a href="#lab6" class="headerlink" title="lab6"></a>lab6</h2><h2 id="cap7：x64windows调试机制"><a href="#cap7：x64windows调试机制" class="headerlink" title="cap7：x64windows调试机制"></a>cap7：x64windows调试机制</h2><p><a target="_blank" rel="noopener" href="https://github.com/ayyucedemirbas/Windows-Research-Kernel-WRK-">《wrk源码》</a></p>
<h3 id="windows调试体系"><a href="#windows调试体系" class="headerlink" title="windows调试体系"></a>windows调试体系</h3><p>在Windows中,调试器是基于事件处理的,不是基于状态机的。<br>因此在内核中,是在进程与被调试进程之间建立通道进行通信的,即<strong>DebugPort:调试对象</strong>。<br>被调试进程中产生事件时,会把事件放在DebugPort的一个事件链表中。而调试器接受事件通知,去DebugPort拿调试事件。</p>
<p>常见的调试事件</p>
<ul>
<li>创建进线程</li>
<li>进线程结束</li>
<li>异常</li>
<li>模块加卸载</li>
<li>打印日志:OutputStringA</li>
</ul>
<p>最核心的便是异常，其他的调试事件一般是用记录的。</p>
<h4 id="调试对象的建立"><a href="#调试对象的建立" class="headerlink" title="调试对象的建立"></a>调试对象的建立</h4><p>Windows调试必须先建立管道,才能在调试进程和被调试进程传递信息。而管道就是调试对象。<br>调试器拥有调试对象句柄从而对被调试进程进行操作。被调试进程EPROCESS.DebugPort存值以便于往里面写入DeBugEvent。</p>
<h5 id="debugactiveprocess"><a href="#debugactiveprocess" class="headerlink" title="debugactiveprocess"></a>debugactiveprocess</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL __stdcall <span class="title function_">DebugActiveProcess</span><span class="params">(DWORD dwProcessId)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数是调试通道建立的开始，他的主要功能就是：</p>
<ul>
<li>创建调试对象(DEBUG_OBJECT)</li>
<li>根据传入的Pid打开句柄(权限问题),调用__imp_DbgUiDebugActiveProcess，把DebugPort挂上去。</li>
</ul>
<p>DbgUiConnectToDbg即创建调试对象,判断是否创建成功。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov     [rsp+arg_0], rbx</span><br><span class="line">push    rdi             ; 保留非易失寄存器</span><br><span class="line">sub     rsp, 20h</span><br><span class="line">mov     ebx, ecx</span><br><span class="line">call    cs:__imp_DbgUiConnectToDbg ; 先创建一个调试对象</span><br><span class="line">nop     dword ptr [rax+rax+00h]</span><br><span class="line">test    eax, eax</span><br><span class="line">jns     short DebugPortCreateSuccess ; 因此想要调试,首先得打开进程</span><br></pre></td></tr></table></figure>
<p>然后根据Pid打开进程获取句柄,调用__imp_DbgUiDebugActiveProcess()将被调试进程DEBUG_PORT端口和创建的调试对象句柄联系起来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DebugPortCreateSuccess: ; 因此想要调试,首先得打开进程</span><br><span class="line">mov     ecx, ebx</span><br><span class="line">call    ProcessIdToHandle ; 打开进程,获取句柄</span><br><span class="line">mov     rbx, rax</span><br><span class="line">test    rax, rax</span><br><span class="line">jz      short OpenFailed</span><br><span class="line">mov     rcx, rax         ; 被调试进程句柄</span><br><span class="line">call    cs:__imp_DbgUiDebugActiveProcess ; 初始化调试对象信息</span><br><span class="line">nop     dword ptr [rax+rax+00h]</span><br><span class="line">mov     edi, eax</span><br><span class="line">mov     rcx, rbx</span><br><span class="line">test    eax, eax</span><br><span class="line">jns     short InitDebugPortSuccess ; 关闭句柄返回</span><br><span class="line">OpenFaild:</span><br><span class="line">;清理资源,关闭句柄。</span><br></pre></td></tr></table></figure>
<h5 id="dbguiconnecttodbg"><a href="#dbguiconnecttodbg" class="headerlink" title="dbguiconnecttodbg"></a>dbguiconnecttodbg</h5><p>前文提到,这个用于创建调试对象,创建过程是ntdll!DbgUiConnectToDbg-&gt;nt!NtCreateDebugObject。<br>在这个函数中，进行了一些简单判断,判断是否已经在调试别的程序中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov     rax, gs:_TEB.NtTib.Self</span><br><span class="line">xor     ecx, ecx</span><br><span class="line">cmp     [rax+(_TEB.DbgSsReserved+8)], rcx ; 判断是否已经有调试</span><br><span class="line">jnz     short HasDebugge</span><br></pre></td></tr></table></figure>
<p>他判断是否有被调试进程是通过TEB.DbgSsReserved+8的位置，事实上,这个地方存的就是句柄。<br>如果没有，则调用NtCreateDebugObject进入内核进程创建对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mov     [rsp+28h], rcx</span><br><span class="line">lea     r8, [rsp+20h]   ; 传地址 其实是OBJECT_ATTRIBUTES</span><br><span class="line">mov     [rsp+38h], ecx</span><br><span class="line">xorps   xmm0, xmm0</span><br><span class="line">mov     [rsp+38h], rcx</span><br><span class="line">mov     r9d, 1           ; 传参</span><br><span class="line">movdqu  xmmword ptr [rsp+40h], xmm0</span><br><span class="line">mov     dword ptr [rsp+20h], 30h</span><br><span class="line">mov     edx, 1F000Fh    ; 传参</span><br><span class="line">mov     rcx, gs:_TEB.NtTib.Self</span><br><span class="line">add     rcx, _TEB.DbgSsReserved+8</span><br><span class="line">call    NtCreateDebugObject</span><br></pre></td></tr></table></figure>
<p>而NtCreateDebugObject函数声明是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">NtCreateDebugObject</span> <span class="params">(</span></span><br><span class="line"><span class="params">    OUT PHANDLE DebugObjectHandle,</span></span><br><span class="line"><span class="params">    IN ACCESS_MASK DesiredAccess,</span></span><br><span class="line"><span class="params">    IN POBJECT_ATTRIBUTES ObjectAttributes,</span></span><br><span class="line"><span class="params">    IN ULONG Flags</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>由参数推出,第一个参数,DebugObjectHandle就是_TEB.DbgSsReserved+8位置,也就是调试对象的句柄。<br>值得一提的是，DesiredAccess是对于调试对象句柄的权限。</p>
<h5 id="nt-ntcreatedebugobject"><a href="#nt-ntcreatedebugobject" class="headerlink" title="nt!ntcreatedebugobject"></a>nt!ntcreatedebugobject</h5><p>这个函数只有两个作用</p>
<ul>
<li>创建调试对象</li>
<li>根据参数DesiredAccess作为调试对象权限存入调试进程的句柄表中</li>
</ul>
<p>首先检查一些参数,这是R3-&gt;R0的常规操作。<br>然后创建调试对象,使用ObCreateObjectEx,所有内核对象都是通过它创建的,包括ETHREAD，EPROCESS等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CreateDebugObject:      ; 调试对象类型</span><br><span class="line">mov     rdx, cs:DbgkDebugObjectType</span><br><span class="line">and     qword ptr [rsp+48h], 0</span><br><span class="line">lea     rax, [rsp+88h+pObject]</span><br><span class="line">mov     [rsp+40h], rax  ; pObject</span><br><span class="line">and     dword ptr [rsp+38h], 0</span><br><span class="line">and     dword ptr [rsp+30h], 0</span><br><span class="line">mov     dword ptr [rsp+28h], 68h ; ObjectSize</span><br><span class="line">mov     r9b, r10b</span><br><span class="line">mov     cl, r10b        ; AccessMode</span><br><span class="line">call    ObCreateObjectEx ; 创建调试对象</span><br><span class="line">test    eax, eax</span><br><span class="line">js      Ret</span><br></pre></td></tr></table></figure>
<p>调试对象的结构如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEBUG_OBJECT</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Event that set when the EventList is populated.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    KEVENT EventsPresent;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Mutex to protect the structure</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    FAST_MUTEX Mutex;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Queue of events waiting for debugger intervention</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    LIST_ENTRY EventList;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Flags for the object</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    ULONG Flags;</span><br><span class="line"> &#125; DEBUG_OBJECT, *PDEBUG_OBJECT;</span><br></pre></td></tr></table></figure>
<p>其中EventsPresent的意义是方便让调试器的调试循环捕捉,一旦在链表中有了要处理的调试事件,就会用KeSetEvent设置事件信号(后面会有体现)。<br>而Mutex的意义便是多线程操作链表时候的同步作用。<br>EventList是链表头,链接DEBUG_EVENT所有事件。<br>flags则表明DebugObject属性,如下值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_OBJECT_DELETE_PENDING (0x1) <span class="comment">// Debug object is delete pending.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_OBJECT_KILL_ON_CLOSE (0x2) <span class="comment">// Kill all debugged processes on close</span></span></span><br></pre></td></tr></table></figure>
<p>若为1,说明DebugObject无效。<br>创建对象成功后,进行简单初始化,如链表清空操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mov     rbx, [rsp+88h+pObject] ; 调试对象进行赋值</span><br><span class="line">mov     [rbx+_DEBUG_PORT.Mutex.Count], 1 ; 参考WRK的DEBUG_PORT对象</span><br><span class="line">and     [rbx+_DEBUG_PORT.Mutex.Owner], 0 ; 初始化互斥体,用于插入链表时候的同步</span><br><span class="line">and     [rbx+_DEBUG_PORT.Mutex.Contention], 0</span><br><span class="line">lea     rcx, [rbx+_DEBUG_PORT.Mutex.Event] ; Event</span><br><span class="line">xor     r8d, r8d        ; State</span><br><span class="line">lea     edx, [r8+1]     ; Type</span><br><span class="line">call    KeInitializeEvent</span><br><span class="line">lea     rax, [rbx+_DEBUG_PORT.EventList]</span><br><span class="line">mov     [rax+8], rax</span><br><span class="line">mov     [rax], rax      ; 情况链表 自己指向自己</span><br><span class="line">xor     r8d, r8d        ; State</span><br><span class="line">xor     edx, edx        ; Type</span><br><span class="line">mov     rcx, rbx        ; Event</span><br><span class="line">call    KeInitializeEvent</span><br><span class="line">test    sil, 1          ; R3 flags</span><br><span class="line">jz      short Equal</span><br><span class="line">mov     dword ptr [rbx+_DEBUG_PORT.Flags], 2</span><br><span class="line">jmp     short loc_140883589</span><br><span class="line">Equal:</span><br><span class="line">and     dword ptr [rbx+_DEBUG_PORT.Flags], 0</span><br></pre></td></tr></table></figure>
<p>其中sil即R3-&gt;R0传入的flags,不难发现,如果传入1，则代表调试关闭时关闭所有调试进程(出现场景为调试子进程),如果传入0,则不会关闭所有被调试进程。<br>在创建完对象之后,进行wow64进程的判断,如果调试进程是32位的,那么flags | 4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov     rax, gs:188h</span><br><span class="line">mov     rcx, [rax+_ETHREAD.Tcb._union_90.ApcState.Process]</span><br><span class="line">mov     rax, [rcx+_EPROCESS.Wow64Process] ; 这是调试器的线程</span><br><span class="line">test    rax, rax</span><br><span class="line">jz      short x64Bit</span><br><span class="line">or      dword ptr [rbx+_DEBUG_PORT.Flags], 4 ; 即flags &amp; 4 就是wow64</span><br><span class="line">x64Bit:</span><br><span class="line">xxxxx</span><br></pre></td></tr></table></figure>
<p>然后把调试对象插入到调试进程的句柄表中,其中句柄的权限就是R3传入的DesriedAccess;<br>顺带也可以发现，产生的句柄确实放在了_TEB.DbgSsReserved+8这个位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov     r8d, r14d        ; r14就是R3传过来的DesriedAccess</span><br><span class="line">xor     edx, edx</span><br><span class="line">mov     rcx, [rsp+88h+pObject]</span><br><span class="line">call    ObInsertObjectEx ; InsertObject的作用就是把对象查到句柄表里面</span><br><span class="line">mov     ecx, eax</span><br><span class="line">test    eax, eax</span><br><span class="line">js      short Ret</span><br><span class="line">mov     rax, [rsp+88h+Handle]</span><br><span class="line">mov     [rdi], rax      ; 这是TEB的那个位置,用于保存句柄</span><br><span class="line">Ret:</span><br><span class="line">;进行释放资源的操作</span><br></pre></td></tr></table></figure>
<p>自此调试对象创建完毕。</p>
<h4 id="调试对象挂入被调试进程"><a href="#调试对象挂入被调试进程" class="headerlink" title="调试对象挂入被调试进程"></a>调试对象挂入被调试进程</h4><p>在<code>DebugActiveProcess</code>中，创建完调试对象之后，则开始进行与被调试对象挂入操作。</p>
<p>调用如下函数进行挂入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS __fastcall <span class="title function_">DbgUiDebugActiveProcess</span><span class="params">(__int64 ProcessHandle)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 hProcess; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> status; <span class="comment">// ebx</span></span><br><span class="line"></span><br><span class="line">  hProcess = ProcessHandle;</span><br><span class="line">  status = NtDebugActiveProcess(ProcessHandle, NtCurrentTeb()-&gt;DbgSsReserved[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">if</span> ( status &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    status = DbgUiIssueRemoteBreakin(hProcess);</span><br><span class="line">    <span class="keyword">if</span> ( status &lt; <span class="number">0</span> )</span><br><span class="line">      ZwRemoveProcessDebug(hProcess, NtCurrentTeb()-&gt;DbgSsReserved[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数主要功能即调用<code>NtDebugActiveProcess</code>，传入被调试进程句柄和调试对象句柄，在内核进行挂载。<br>在挂入成功之后，调用<code>DbgUiIssueRemoteBreakin()</code>。<br>这个函数的作用是创建一个远程线程，让远程线程指向<code>int3</code>产生异常，被调试器捕获。<br>这就是为什么用调试器附加进程，总是会断在一个系统断点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">DbgUiIssueRemoteBreakin</span><span class="params">(__int64 hProcess)</span></span><br><span class="line">&#123;</span><br><span class="line">  status = RtlpCreateUserThreadEx(</span><br><span class="line">             hProcess,</span><br><span class="line">             <span class="number">0</span>i64,</span><br><span class="line">             <span class="number">2</span>,</span><br><span class="line">             <span class="number">0</span>,</span><br><span class="line">             <span class="number">0</span>i64,</span><br><span class="line">             <span class="number">0x4000</span>i64,</span><br><span class="line">             v3,</span><br><span class="line">             (__int64)DbgUiRemoteBreakin,      <span class="comment">// 新建线程的地址</span></span><br><span class="line">             <span class="number">0</span>i64,</span><br><span class="line">             &amp;v5,</span><br><span class="line">             (__m128i *)&amp;v4);</span><br><span class="line">  <span class="keyword">if</span> ( (status &amp; <span class="number">0x80000000</span>) == <span class="number">0</span> )</span><br><span class="line">    NtClose(v5);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DbgUiRemoteBreakin</code>是新建线程的地址，在进行简单判断之后就会调用<code>DbgBreakPoint();</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">DbgUiRemoteBreakin</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (NtCurrentPeb()-&gt;BeingDebugged || MEMORY[<span class="number">0x7FFE02D4</span>] &amp; <span class="number">2</span>) &amp;&amp; !(NtCurrentTeb()-&gt;_union_108.SameTebFlags &amp; <span class="number">0x20</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( UseWOW64 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( g_LdrpWow64PrepareForDebuggerAttach )</span><br><span class="line">        g_LdrpWow64PrepareForDebuggerAttach();</span><br><span class="line">    &#125;</span><br><span class="line">    DbgBreakPoint();<span class="comment">//执行Int3</span></span><br><span class="line">  &#125;</span><br><span class="line">  RtlExitUserThread(<span class="number">0</span>i64);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，在<code>DbgUiDebugActiveProcess</code>中，如果<code>DbgUiIssueRemoteBreakin</code>执行失败，则会执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( status &lt; <span class="number">0</span> )</span><br><span class="line">    ZwRemoveProcessDebug(hProcess, NtCurrentTeb()-&gt;DbgSsReserved[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p>而<code>DbgUiIssueRemoteBreakin</code>执行失败只有一个原因，即创建远程线程失败。因此要调试还需要具有远程创建线程的句柄权限。</p>
<h5 id="nt-ntdebugactiveprocess"><a href="#nt-ntdebugactiveprocess" class="headerlink" title="nt!ntdebugactiveprocess"></a>nt!ntdebugactiveprocess</h5><p>它是被调试进程和调试对象建立起来联系核心函数。</p>
<p>声明如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">NtDebugActiveProcess</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN HANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">    IN HANDLE DebugObjectHandle</span></span><br><span class="line"><span class="params">    )</span>;</span><br></pre></td></tr></table></figure>
<p>函数首先根据句柄找到进程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov     r8, cs:PsProcessType</span><br><span class="line">and     qword ptr [r11+18h], 0</span><br><span class="line">mov     bpl, byte ptr [rax+_ETHREAD.Tcb._union_171.UserAffinity.Reserved] ; PreviousMode</span><br><span class="line">lea     rax, [r11+18h] ; pObject rsp+0x80</span><br><span class="line">and     qword ptr [r11-28h], 0</span><br><span class="line">mov     r9b, bpl</span><br><span class="line">mov     [r11-40h], rax</span><br><span class="line">mov     dword ptr [rsp+68h+0bject], 4F676244h</span><br><span class="line">call    ObReferenceObjectByHandleWithTag ; 获取进程对象</span><br></pre></td></tr></table></figure>
<p>然后根据进程进行一些判断，基本就是</p>
<ul>
<li>是否调试自己</li>
<li>是否是系统进程</li>
<li>是否是wow64</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mov     rax, gs:188h</span><br><span class="line">mov     rdi, [rsp+68h+pDebugProcess]</span><br><span class="line">mov     rsi, [rax+_ETHREAD.Tcb._union_90.ApcState.Process]</span><br><span class="line">cmp     rdi, rsi          ; 判断是不是在调试自己</span><br><span class="line">jz      DebugProcessErr</span><br><span class="line">cmp     rdi, cs:PsInitialSystemProcess ; 判断一下是不是这个进程 就是system进程</span><br><span class="line">jz      DebugProcessErr</span><br><span class="line">mov     rax, [rdi+_EPROCESS.WoW64Process]</span><br><span class="line">test    rax, rax</span><br><span class="line">jz      x64Bit</span><br><span class="line">; 进行调试进程被调试进程检查</span><br><span class="line">; 如果被调试64 调试32 无法调试</span><br></pre></td></tr></table></figure>
<p>检查无误之后，获取调试对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GetDebugObject:                      ; ObjectType</span><br><span class="line">mov     r8, cs:DbgkDebugObjectType   </span><br><span class="line">lea     rax, [rsp+68h+pDebugObject]</span><br><span class="line">and     [rsp+68h+var_40], 0</span><br><span class="line">mov     r9b, bpl                     ; AccessMode</span><br><span class="line">and     [rsp+68h+pDebugObject], 0</span><br><span class="line">mov     edx, 2                       ; DesiredAccess</span><br><span class="line">mov     rcx, r14                     ; Handle</span><br><span class="line">mov     [rsp+68h+0bject], rax        ; Object</span><br><span class="line">call    ObReferenceObjectByHandle</span><br></pre></td></tr></table></figure>
<p>此外，获取RunDown锁，防止进程结束。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lea     rbp, [rdi+_EPROCESS.RundownProtect]</span><br><span class="line">mov     rcx, rbp</span><br><span class="line">call    ExAcquireRundownProtection_0 ; 获取被调试对象的RunDown锁</span><br><span class="line">mov     rsi, [rsp+68h+pDebugObject]  ; 这个可以反调试 但是不要用</span><br><span class="line">test    al, al</span><br><span class="line">jz      short RunDownProtectErr</span><br></pre></td></tr></table></figure>
<p>之后进入核心代码，发送假消息模拟。<br>调试器消息的意义在于附加时进程已经创建，无法还原线程/进程创建时场景，因此采取模拟发送假消息方……</p>
<blockquote>
<p>这里断掉。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov     r8d, eax</span><br><span class="line">mov     rdx, rsi          ; DebugPort</span><br><span class="line">mov     rcx, rdi          ; DebugProcess</span><br><span class="line">call    DbgkpSetProcessDebugObject ; 把DebugPort写入被调试进程</span><br><span class="line">; 参考WRK</span><br><span class="line">; 并发送消息上一个函数模拟的假消息</span><br><span class="line">mov     rcx, rbp</span><br><span class="line">mov     ebx, eax</span><br><span class="line">call    ExReleaseRundownProtection_0 ; 释放锁</span><br><span class="line">jmp     short release</span><br></pre></td></tr></table></figure>
<p>核心函数便是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">DbgkpPostFakeProcessCreateMessages</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN PEPROCESS Process,</span></span><br><span class="line"><span class="params">    IN PDEBUG_OBJECT DebugObject,</span></span><br><span class="line"><span class="params">    IN PETHREAD *pLastThread</span></span><br><span class="line"><span class="params">    )</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">DbgkSetProcessDebugObject</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN PEPROCESS Process,</span></span><br><span class="line"><span class="params">    IN PDEBUG_OBJECT DebugObject,</span></span><br><span class="line"><span class="params">    IN NTSTATUS MsgStatus,</span></span><br><span class="line"><span class="params">    IN PETHREAD LastThread</span></span><br><span class="line"><span class="params">    )</span>;</span><br></pre></td></tr></table></figure>
<h4 id="发送假消息"><a href="#发送假消息" class="headerlink" title="发送假消息"></a>发送假消息</h4><p>在调试器附加之后,会发送假消息模拟进程创建。这时候DebugPort还没有挂入到被调试进程。无法直接将消息写入Process.DebugPort,Windows采取传入DebugPort变量,消息写入变量中,而非Process.DebugPort中。<br>然后在DbgkpSetProcessDebugObject中进行设置DebugPort挂入被调试进程。</p>
<h5 id="dbgkppostfakeprocesscreatemessages"><a href="#dbgkppostfakeprocesscreatemessages" class="headerlink" title="dbgkppostfakeprocesscreatemessages"></a>dbgkppostfakeprocesscreatemessages</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_int64 __fastcall <span class="title function_">DbgkpPostFakeProcessCreateMessages</span><span class="params">(_EPROCESS *DebugProcess,</span></span><br><span class="line"><span class="params">_DEBUG_PORT *DebugObject, _int64 *a3)</span></span><br><span class="line">&#123;</span><br><span class="line">    v3 = a3;</span><br><span class="line">    v4 = <span class="number">0</span>i64;</span><br><span class="line">    pFirstThread = <span class="number">0</span>i64;</span><br><span class="line">    v10 = <span class="number">0</span>i64;</span><br><span class="line">    pLastThread = <span class="number">0</span>i64;</span><br><span class="line">    DebugObject_1 = DebugObject;</span><br><span class="line">    v11 = <span class="number">0</span>i64;</span><br><span class="line">    DebugProcess_1 = DebugProcess;</span><br><span class="line">    v12 = <span class="number">0</span>i64;</span><br><span class="line">    result = DbgkpPostFakeThreadMessages(DebugProcess, DebugObject, <span class="number">0</span>i64, &amp;pFirstThread,</span><br><span class="line">&amp;pLastThread);<span class="comment">// 发送线程假消息</span></span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">signed</span> <span class="type">int</span>)result &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        KiStackAttachProcess((ULONG_PTR)DebugProcess_1, <span class="number">0</span>, ( _int64)&amp;v10);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此截断。</p>
</blockquote>
<h5 id="dbgkpqueuemessage"><a href="#dbgkpqueuemessage" class="headerlink" title="dbgkpqueuemessage"></a>dbgkpqueuemessage</h5><h5 id="dbgkpsetprocessdebugobject"><a href="#dbgkpsetprocessdebugobject" class="headerlink" title="dbgkpsetprocessdebugobject"></a>dbgkpsetprocessdebugobject</h5><p><strong>函数作用为：</strong></p>
<ul>
<li>设置被调试进程的DebugPort</li>
<li>遍历EventList,执行之前在DebugPort初始化的消息(发送假消息只是初始化了这个结构体,并没有设置KeSetEvent,参见上文)</li>
<li>清理无效的DebugEvent</li>
<li>再次遍历线程,双重保险，防止被调试进程又新建线程导致无法发送消息。</li>
</ul>
<p><strong>函数声明如下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">DbgkpSetProcessDebugObject</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN PEPROCESS Process,</span></span><br><span class="line"><span class="params">    IN PDEBUG_OBJECT DebugObject,</span></span><br><span class="line"><span class="params">    IN NTSTATUS MsgStatus,</span></span><br><span class="line"><span class="params">    IN PETHREAD LastThread</span></span><br><span class="line"><span class="params">    )</span>;</span><br></pre></td></tr></table></figure>
<p>以下函数代码来自WRK,非IDA逆出。<br>首先判断传入MsgStatus,这个值是DbgkpPostFakeProcessCreateMessages函数的返回值,标志这个函数是不是执行成功。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!NT_SUCCESS (MsgStatus)) &#123; <span class="comment">//这个是前面插入DebugObject List时候是否成功</span></span><br><span class="line">    LastThread = <span class="literal">NULL</span>;</span><br><span class="line">    Status = MsgStatus;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Status = STATUS_SUCCESS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>设置被调试进程的DebugPort。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Process-&gt;DebugPort != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Status = STATUS_PORT_ALREADY_SET;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Assign the debug port to the process to pick up any new threads</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Process-&gt;DebugPort = DebugObject;<span class="comment">//设置调试对象</span></span><br></pre></td></tr></table></figure>
<p>判断是否被调试进程新建线程，双重保险防止遗漏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Acquire the debug port mutex so we know that any new threads will</span></span><br><span class="line">    <span class="comment">// have to wait to behind us.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    GlobalHeld = TRUE;</span><br><span class="line"></span><br><span class="line">    ExAcquireFastMutex (&amp;DbgkpProcessDebugPortMutex);<span class="comment">//获取</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the port has been set then exit now.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (Process-&gt;DebugPort != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Status = STATUS_PORT_ALREADY_SET;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Assign the debug port to the process to pick up any new threads</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Process-&gt;DebugPort = DebugObject;<span class="comment">//设置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Reference the last thread so we can deref outside the lock</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    ObReferenceObject (LastThread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Search forward for new threads</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Thread = PsGetNextProcessThread (Process, LastThread);<span class="comment">//判断一下是否有新的线程,有的话再发线程消息.</span></span><br><span class="line">    <span class="keyword">if</span> (Thread != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Remove the debug port from the process as we are</span></span><br><span class="line">        <span class="comment">// about to drop the lock</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Process-&gt;DebugPort = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        ExReleaseFastMutex (&amp;DbgkpProcessDebugPortMutex);</span><br><span class="line"></span><br><span class="line">        GlobalHeld = FALSE;</span><br><span class="line"></span><br><span class="line">        ObDereferenceObject (LastThread);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Queue any new thread messages and repeat.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Status = DbgkpPostFakeThreadMessages (Process,</span><br><span class="line">                                              DebugObject,</span><br><span class="line">                                              Thread,</span><br><span class="line">                                              &amp;FirstThread,</span><br><span class="line">                                              &amp;LastThread);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS (Status)) &#123;</span><br><span class="line">            LastThread = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ObDereferenceObject (FirstThread);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历DebugObject-&gt;EventList链表,如果有值则KeSetEvent (&amp;DebugObject-&gt;EventsPresent, 0, FALSE);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Entry = DebugObject-&gt;EventList.Flink;<span class="comment">//遍历DebugObject链表</span></span><br><span class="line">     Entry != &amp;DebugObject-&gt;EventList;</span><br><span class="line">     ) &#123;</span><br><span class="line"></span><br><span class="line">    DebugEvent = CONTAINING_RECORD (Entry, DEBUG_EVENT, EventList);</span><br><span class="line">    Entry = Entry-&gt;Flink;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((DebugEvent-&gt;Flags&amp;DEBUG_EVENT_INACTIVE) != <span class="number">0</span> &amp;&amp; DebugEvent-&gt;BackoutThread == ThisThread) &#123;</span><br><span class="line">        Thread = DebugEvent-&gt;Thread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// If the thread has not been inserted by CreateThread yet then don&#x27;t</span></span><br><span class="line">        <span class="comment">// create a handle.  We skip system threads here also</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (NT_SUCCESS (Status) &amp;&amp; Thread-&gt;GrantedAccess != <span class="number">0</span> &amp;&amp; !IS_SYSTEM_THREAD (Thread)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// If we could not acquire rundown protection on this</span></span><br><span class="line">            <span class="comment">// thread then we need to suppress its exit message.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> ((DebugEvent-&gt;Flags&amp;DEBUG_EVENT_PROTECT_FAILED) != <span class="number">0</span>) &#123;</span><br><span class="line">                PS_SET_BITS (&amp;Thread-&gt;CrossThreadFlags,</span><br><span class="line">                             PS_CROSS_THREAD_FLAGS_SKIP_TERMINATION_MSG);</span><br><span class="line">                RemoveEntryList (&amp;DebugEvent-&gt;EventList);</span><br><span class="line">                InsertTailList (&amp;TempList, &amp;DebugEvent-&gt;EventList);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (First) &#123;<span class="comment">//只有第一次进入才设置</span></span><br><span class="line">                    DebugEvent-&gt;Flags &amp;= ~DEBUG_EVENT_INACTIVE;</span><br><span class="line">                    KeSetEvent (&amp;DebugObject-&gt;EventsPresent, <span class="number">0</span>, FALSE);<span class="comment">//设置DebugObject-&gt;Event,调试器的KeWait可以等待成功。</span></span><br><span class="line">                    First = FALSE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后释放资源，清理无效DebugEvent。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (GlobalHeld) &#123;</span><br><span class="line">    ExReleaseFastMutex (&amp;DbgkpProcessDebugPortMutex);<span class="comment">//可以用于反调试 占用这个全局变量导致所有调试器无法调试,链接DebugPort</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (LastThread != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ObDereferenceObject (LastThread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!IsListEmpty (&amp;TempList)) &#123;<span class="comment">//清空无效DebugEvent</span></span><br><span class="line">    Entry = RemoveHeadList (&amp;TempList);</span><br><span class="line">    DebugEvent = CONTAINING_RECORD (Entry, DEBUG_EVENT, EventList);</span><br><span class="line">    DbgkpWakeTarget (DebugEvent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> status;</span><br></pre></td></tr></table></figure>
<h3 id="调试器等待"><a href="#调试器等待" class="headerlink" title="调试器等待"></a>调试器等待</h3><h4 id="waitfordebugevent"><a href="#waitfordebugevent" class="headerlink" title="waitfordebugevent"></a>waitfordebugevent</h4><p>在建立了Debugport调试关系之后,调试器需要创立一个while循环。<br>在循环中使用WaitForDebugEvent()进行等待,也就是等待DEBUG_OBJECT的Event。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    DEBUG_EVENT debugEvent = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (WaitForDebugEvent(&amp;debugEvent, <span class="number">-1</span>))</span><br></pre></td></tr></table></figure>
<p>在WaitForDebugEvent()中,首先会调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>                     <span class="comment">// 也就是如果是用户APC或者Altered被唤醒 会一直让你等</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        STATUS = DbgUiWaitStateChange(&amp;WaitStateChange, WaitTime_1);</span><br><span class="line">    <span class="keyword">while</span> ( STATUS == <span class="number">0x101</span> );          <span class="comment">// #define STATUS_ALERTED ((NTSTATUS)0x00000101L)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( STATUS == <span class="number">0xC0</span> );              <span class="comment">// #define STATUS_USER_APC ((NTSTATUS)0x000000C0L)  // winnt</span></span><br><span class="line">  <span class="keyword">if</span> ( STATUS &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">goto</span> Failed;</span><br><span class="line">  <span class="keyword">if</span> ( STATUS == <span class="number">0x102</span> )                 <span class="comment">// 等待时间完了</span></span><br><span class="line">  &#123;</span><br><span class="line">      RtlSetLastWin32Error(<span class="number">0x79</span>i64);     <span class="comment">// #define STATUS_TIMEOUT ((NTSTATUS)0x00000102L)  // winnt</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>进行等待，如果等待打断会进行判断，如果是ALERTED或者APC这种的打断,则继续等待.如果是等待时间TimeOut,返回错误。<br>在进行等待成功之后,会调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">STATUS = v4 ? (<span class="type">unsigned</span> <span class="type">int</span>)DbgUiConvertStateChangeStructureEx(&amp;WaitStateChange, v3) : (<span class="type">unsigned</span> <span class="type">int</span>)DbgUiConvertStateChangeStructure(&amp;WaitStateChange, v3);</span><br><span class="line">  <span class="keyword">if</span> ( STATUS &lt; <span class="number">0</span> )                      <span class="comment">// 进行结构转换</span></span><br><span class="line">                                        <span class="comment">// 即把R0的WaitStateChnage转换成R3的</span></span><br><span class="line">DebugEvent</span><br><span class="line">  &#123;</span><br><span class="line">Failed:</span><br><span class="line">    BaseSetLastNtError((<span class="type">unsigned</span> <span class="type">int</span>)STATUS);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>是因为WaitStateChange结构是,而R3真正处理的是R3.DebugEvent,因此需要进行转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DBGUI_WAIT_STATE_CHANGE</span> &#123;</span></span><br><span class="line">    DBG_STATE NewState;</span><br><span class="line">    CLIENT_ID AppClientId;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DBGKM_EXCEPTION Exception;</span><br><span class="line">        DBGUI_CREATE_THREAD CreateThread;</span><br><span class="line">        DBGUI_CREATE_PROCESS CreateProcessInfo;</span><br><span class="line">        DBGKM_EXIT_THREAD ExitThread;</span><br><span class="line">        DBGKM_EXIT_PROCESS ExitProcess;</span><br><span class="line">        DBGKM_LOAD_DLL LoadDll;</span><br><span class="line">        DBGKM_UNLOAD_DLL UnloadDll;</span><br><span class="line">    &#125; StateInfo;</span><br></pre></td></tr></table></figure>
<p>在进行转换之后,判断dwDebugEventCode：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">dwDebugEventCode = DebugEvent_1-&gt;dwDebugEventCode;</span><br><span class="line">  <span class="keyword">if</span> ( DebugEvent_1-&gt;dwDebugEventCode != <span class="number">1</span> )  <span class="comment">// #define EXCEPTION_DEBUG_EVENT    1</span></span><br><span class="line">                                            <span class="comment">// #define CREATE_THREAD_DEBUG_EVENT 2</span></span><br><span class="line">                                            <span class="comment">// #define CREATE_PROCESS_DEBUG_EVENT 3</span></span><br><span class="line">                                            <span class="comment">// #define EXIT_THREAD_DEBUG_EVENT  4</span></span><br><span class="line">                                            <span class="comment">// #define EXIT_PROCESS_DEBUG_EVENT 5</span></span><br><span class="line">                                            <span class="comment">// #define LOAD_DLL_DEBUG_EVENT     6</span></span><br><span class="line">                                            <span class="comment">// #define UNLOAD_DLL_DEBUG_EVENT   7</span></span><br><span class="line">                                            <span class="comment">// #define OUTPUT_DEBUG_STRING_EVENT 8</span></span><br><span class="line">                                            <span class="comment">// #define RIP_EVENT               9</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( dwDebugEventCode == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        hThread = DebugEvent_1-&gt;u.CreateThread.hThread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( dwDebugEventCode != <span class="number">3</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( dwDebugEventCode == <span class="number">4</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                MarkThreadHandle(DebugEvent_1-&gt;dwThreadId);<span class="comment">//标志进程退出</span></span><br><span class="line">                                                         <span class="comment">// 这个结构如下</span></span><br><span class="line">                                                         <span class="comment">// 在TEB的16A0位置</span></span><br><span class="line">                                                         <span class="comment">// 0 LIST_ENTRY</span></span><br><span class="line">                                                         <span class="comment">// 0x8 线程句柄</span></span><br><span class="line">                                                         <span class="comment">// 0x10 进程句柄</span></span><br><span class="line">                                                         <span class="comment">// 0x18 线程ID</span></span><br><span class="line">                                                         <span class="comment">// 0x1C 进程ID</span></span><br><span class="line">                                                         <span class="comment">// 0x20 是否退出</span></span><br><span class="line">                                                         <span class="comment">// 这个就是用于方便调试器调试显示信息</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( dwDebugEventCode == <span class="number">5</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                MarkThreadHandle(DebugEvent_1-&gt;dwThreadId);</span><br><span class="line">                <span class="keyword">for</span> ( i = NtCurrentTeb()-&gt;DbgSsReserved[<span class="number">0</span>]; i; i = *(_QWORD *)i )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( *(_DWORD *)(i + <span class="number">24</span>) == DebugEvent_1-&gt;dwProcessId &amp;&amp; !*(_DWORD *)(i + <span class="number">28</span>) )</span><br><span class="line">                    &#123;</span><br><span class="line">                        *(_BYTE *)(i + <span class="number">0x20</span>) = <span class="number">1</span>;        <span class="comment">// 标志所有线程退出</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( dwDebugEventCode != <span class="number">6</span> &amp;&amp; dwDebugEventCode != <span class="number">7</span> &amp;&amp; (dwDebugEventCode &lt;= <span class="number">7</span> || dwDebugEventCode &gt; <span class="number">9</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">        &#125;        <span class="comment">// 能走到这都是2 3</span></span><br><span class="line">        SaveProcessHandle(DebugEvent_1-&gt;dwProcessId, DebugEvent_1-&gt;u.CreateProcessInfo.hProcess);<span class="comment">// 如果是进程创建啥的 需要在那个单链表进行保存</span></span><br><span class="line">        hThread = DebugEvent_1-&gt;u.CreateProcessInfo.hThread;</span><br><span class="line">    &#125;</span><br><span class="line">    SaveThreadHandle(DebugEvent_1-&gt;dwProcessId, DebugEvent_1-&gt;dwThreadId, hThread);<span class="comment">// 线程创建 也需要保存在单链表中</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即如果不是1,也就是EXCEPTION_DEBUG_EVENT,会判断进线程创建以及销毁。如果是,则会进行一些处理,具体是调用如下函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MarkThreadHandle(DebugEvent_1-&gt;dwThreadId);</span><br><span class="line">SaveProcessHandle(DebugEvent_1-&gt;dwProcessId, DebugEvent_1-&gt;u.CreateProcessInfo.hProcess);<span class="comment">// 如果是进程创建啥的 需要在那个单链表进行保存</span></span><br><span class="line">SaveThreadHandle(DebugEvent_1-&gt;dwProcessId, DebugEvent_1-&gt;dwThreadId, hThread);</span><br></pre></td></tr></table></figure>
<p>这些函数只有一个作用,就是把进程创建的线程 进程 保存在一个链表中。在TEB的16A0位置。<br>值得一提，这个链表的结构如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MarkThreadHandle(DebugEvent_1-&gt;dwThreadId);<span class="comment">//标志进程退出</span></span><br><span class="line">                                         <span class="comment">// 这个结构如下</span></span><br><span class="line">                                         <span class="comment">// 在TEB的16A0位置</span></span><br><span class="line">                                         <span class="comment">// 0 LIST_ENTRY</span></span><br><span class="line">                                         <span class="comment">// 0x8 线程句柄</span></span><br><span class="line">                                         <span class="comment">// 0x10 进程句柄</span></span><br><span class="line">                                         <span class="comment">// 0x18 线程ID</span></span><br><span class="line">                                         <span class="comment">// 0x1C 进程ID</span></span><br><span class="line">                                         <span class="comment">// 0x20 是否退出</span></span><br><span class="line">                                         <span class="comment">// 这个就是用于方便调试器调试显示信息</span></span><br></pre></td></tr></table></figure>
<p>他唯一的作用就是快速遍历当前调试进程的所有线程和进程。方便调试器调用一些API;</p>
<h4 id="dbguiwaitstatechange"><a href="#dbguiwaitstatechange" class="headerlink" title="dbguiwaitstatechange"></a>dbguiwaitstatechange</h4><p>这个函数是调试器等待机制的核心。<br>事实上，这个函数有三个参数，第一个参数就是hDebugObject了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">NtWaitForDebugEvent</span><span class="params">(</span></span><br><span class="line"><span class="params">    IN HANDLE DebugObjectHandle,</span></span><br><span class="line"><span class="params">    IN BOOLEAN Alertable,</span></span><br><span class="line"><span class="params">    IN PLARGE_INTEGER Timeout OPTIONAL,</span></span><br><span class="line"><span class="params">    OUT PDBGUI_WAIT_STATE_CHANGE WaitStateChange</span></span><br><span class="line"><span class="params">    )</span>;</span><br></pre></td></tr></table></figure>
<h5 id="ntwaitfordebugevent"><a href="#ntwaitfordebugevent" class="headerlink" title="ntwaitfordebugevent"></a>ntwaitfordebugevent</h5><p>调试器等待的内核实现。</p>
<p>其中核心代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    status = KeWaitForSingleObject(&amp;DebugObject_1-&gt;EventPresent.Header, <span class="number">0</span>,PreviousMode, v13, Timeout);<span class="comment">// 等待PresentEvent</span></span><br><span class="line">    <span class="keyword">if</span> ( status &lt; <span class="number">0</span> || status == <span class="number">0xC0</span> || (<span class="type">unsigned</span> <span class="type">int</span>)(status - <span class="number">0x101</span>) &lt;= <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    curEvent_1 = <span class="number">0</span>i64;</span><br><span class="line">    ExAcquireFastMutex(&amp;DebugObject_1-&gt;Mutex);<span class="comment">// 能走到这 说明不是等待超时 而是有调试时间</span></span><br><span class="line">    <span class="keyword">if</span> ( DebugObject_1-&gt;Flags &amp; <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        status = <span class="number">0xC0000354</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListHead = (_DEBUG_EVENT *)&amp;DebugObject_1-&gt;EventList;</span><br><span class="line">        <span class="keyword">for</span> ( curEvent = (_DEBUG_EVENT *)DebugObject_1-&gt;EventList.Flink;</span><br><span class="line">              curEvent != ListHead;</span><br><span class="line">              curEvent = (_DEBUG_EVENT *)curEvent-&gt;EventList.Flink )</span><br><span class="line">        &#123;</span><br><span class="line">            curEvent_1 = curEvent;</span><br><span class="line">            flags = curEvent-&gt;Flags;</span><br><span class="line">            <span class="keyword">if</span> (!(flags &amp; <span class="number">5</span>) )</span><br><span class="line">                <span class="comment">// #define DEBUG_EVENT_INACTIVE (0x04) // The message is in inactive. It may be activated or deleted later</span></span><br><span class="line">                <span class="comment">// #define DEBUG_EVENT_READ (0x01) // Event had been seen by win32 app</span></span><br><span class="line">            &#123;</span><br><span class="line">                bFind = <span class="number">1</span>;</span><br><span class="line">                FirstDebugEvent = (_DEBUG_EVENT *)ListHead-&gt;EventList.Flink;</span><br><span class="line">                <span class="keyword">if</span> ( (_DEBUG_EVENT *)ListHead-&gt;EventList.Flink != curEvent )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span> ( curEvent-&gt;ClientId.UniqueProcess != FirstDebugEvent-&gt;ClientId.UniqueProcess )</span><br><span class="line">                    &#123;</span><br><span class="line">                        FirstDebugEvent = (_DEBUG_EVENT *)FirstDebugEvent-&gt;EventList.Flink;</span><br><span class="line">                        <span class="keyword">if</span> ( FirstDebugEvent == curEvent )</span><br><span class="line">                            <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">                    &#125;</span><br><span class="line">                    curEvent-&gt;Flaes = flaes | <span class="number">4</span>: <span class="comment">// #define DEBUG_EVENT_INACTIVE</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 注：35行到50行代码笔记残缺</span></span><br><span class="line"></span><br><span class="line">                DbgkpConvertKernelToUserStateChange((__int64)&amp;WaitStateChange_2, (__int64)curEvent_1);<span class="comment">// 根据EVENT去处理一下WaitStateChange</span></span><br><span class="line">                curEvent_1-&gt;Flags |= <span class="number">1u</span>; <span class="comment">// 需要参考WRK // READ处理过</span></span><br><span class="line">                <span class="keyword">goto</span> LABEL_29;</span><br><span class="line">            &#125;</span><br><span class="line">            KeResetEvent(&amp;DebugObject_1-&gt;EventPresent);<span class="comment">// 设置等待</span></span><br><span class="line">        LABEL_29:</span><br><span class="line">            status = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        KeReleaseGuardedMutex((ULONG_PTR)&amp;DebugObject_1-&gt;Mutex);</span><br><span class="line">        <span class="keyword">if</span> ( status &lt; <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( bFind ) <span class="comment">// 解锁</span></span><br><span class="line">        &#123;</span><br><span class="line">            DbgkpOpenHandles(&amp;WaitStateChange_2, *(_QWORD *)&amp;SysTime.High2Time, Thread);</span><br><span class="line">            ObfDereferenceObjectWithTag(Thread);</span><br><span class="line">            ObfDereferenceObjectWithTag(*(ULONG_PTR *)&amp;SysTime.High2Time);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bFind = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v25 &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            v22 = MEMORY[<span class="number">0xFFFFF78000000014</span>] - *(_QWORD *)&amp;SysTime.LowPart + v25 &lt; <span class="number">0</span>;</span><br><span class="line">            v25 += MEMORY[<span class="number">0xFFFFF78000000014</span>] - *(_QWORD *)&amp;SysTime.LowPart;</span><br><span class="line">            *(_QWORD *)&amp;SysTime.LowPart = MEMORY[<span class="number">0xFFFFF78000000014</span>];</span><br><span class="line">            DebugObject_1 = DebugObject;</span><br><span class="line">            <span class="keyword">if</span> ( !v22 )</span><br><span class="line">            &#123;</span><br><span class="line">                status = <span class="number">258</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v13 = Alertable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本质就是调用 <code>KeWaitForSingleObject</code>，直到被调试进程 <code>SetEvent</code> 之后才能往下走。</p>
<p>再找到要处理的Event之后，<br><code>DbgkpConvertKernelToUserStateChange((__int64)&amp;WaitStateChange_2, (__int64)curEvent_1);</code>// 根据EVENT去处理一下WaitStateChange去复制Event的内容到WaitStateChange，然后返回。</p>
<p>值得一提的是<code>KeResetEvent</code>完成了事件的等待处理，直到下一个<code>KeSetEvent</code>。</p>
<p>自此，调试器等待就完毕了。剩下的就是R3的处理了，即把等待获取的WaitStateChange变量转换成R3可识别的DEBUG_EVENT即可，上面也已经提到了。</p>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>在调试器接受到事件之后,调用进行事件处理。这个函数本质是修改了位于DEBUG_OBJECT中的DEBUG_EVENT.ContinueEvent,让被调试进程中WaitSingleObject通信。所以进程调试是离不开这两个Event的。一个是DEBUG_EVENT的ContinueEvent，一个是DEBUG_OBJECT.PresentEvent。前者是被调试进程等待处理，后者是调试器等待消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ContinueDebugEvent(debugEvent.dwProcessId, debugEvent.dwThreadId, DBG_CONTINUE);</span><br></pre></td></tr></table></figure>
<p>值得一提的是，调试器很大程度是基于异常处理的，但是调试器处理异常时，却不是使用类似SEH、VEH等发送的CONTEXT，修改pContext值,然后返回R0修改的。调试器异常处理只需要返回1就代表此异常已经处理了。因为假如发生异常,这个时候事实上在DbgkpQueueMessage的时候已经把被调试进程等待了，处理需要通过SetThreadContext来改变线程的寄存器的值。然后调试器返回成功,代表处理。此时被调试进程惊醒，继续执行。这便是调试的核心.就是事件等待。<br>在ContinueDebugEvent中，核心就是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v5 = DbgUiContinue(&amp;dwProcessId_1, dwContinueStatus);</span><br></pre></td></tr></table></figure>
<p>直接调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">DbgUiContinue</span><span class="params">(__int64 pProcessId, <span class="type">unsigned</span> <span class="type">int</span> dwContinueStatus)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> NtDebugContinue(NtCurrentTeb()-&gt;DbgSsReserved[<span class="number">1</span>], pProcessId, dwContinueStatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ntdebugcontinue"><a href="#ntdebugcontinue" class="headerlink" title="ntdebugcontinue"></a>ntdebugcontinue</h4><p>函数声明:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">NtDebugContinue</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN HANDLE DebugObjectHandle,</span></span><br><span class="line"><span class="params">    IN PCLIENT_ID ClientId,</span></span><br><span class="line"><span class="params">    IN NTSTATUS ContinueStatus</span></span><br><span class="line"><span class="params">    )</span>;</span><br></pre></td></tr></table></figure>
<p>其中核心代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( DebugEvent-&gt;ClientId.UniqueProcess == ProcessId )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( GetEvent )        <span class="comment">// 先清空Event结点 在进行处理</span></span><br><span class="line">        &#123;</span><br><span class="line">            DebugEvent-&gt;Flags &amp;= <span class="number">0xFFFFFFFB</span>;        <span class="comment">// 去掉4 INACTIVE</span></span><br><span class="line">            KeSetEvent(&amp;DebouObject-&gt;EventPresent, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">// 这个不是对调试对象发!而是对调试器发 这样我们调试循环立刻就会接收到消息</span></span><br><span class="line">ListEmpty:</span><br><span class="line">            KeReleaseGuardedMutex((ULONG_PTR)&amp;DebouObject-&gt;Mutex);</span><br><span class="line">            HalPutDmaAdapter(DebouObject);</span><br><span class="line">            <span class="keyword">if</span> ( !GetEvent )</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0xC000000D</span>;</span><br><span class="line">            <span class="keyword">if</span> ( PerfGlobalGroupMask &amp; <span class="number">0x400000</span> )</span><br><span class="line">                EtwTraceDebuggerEvent((__int64)DebugEvent_1-&gt;Process, (__int64)DebugEvent_1-&gt;Thread, <span class="number">2</span>);<span class="comment">// 反调式?</span></span><br><span class="line">            DebugEvent_1-&gt;ApiMsg.ReturnedStatus = dwContinueStatus_1;</span><br><span class="line">            DebugEvent_1-&gt;Status = <span class="number">0</span>;</span><br><span class="line">            DbgkpWakeTarget(DebugEvent_1);        <span class="comment">// 他就是ResumeThread+设置Event.ContinueEvent</span></span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( DebugEvent-&gt;ClientId.UniqueThread == ThreadId &amp;&amp; DebugEvent-&gt;Flags &amp; <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            v15 = DebugEvent-&gt;EventList.Flink;</span><br><span class="line">            v16 = DebugEvent-&gt;EventList.Blink;</span><br><span class="line">            <span class="keyword">if</span> ( (_DEBUG_EVENT *)DebugEvent-&gt;EventList.Flink-&gt;Blink != DebugEvent</span><br><span class="line">                || (_DEBUG_EVENT *)v16-&gt;Flink != DebugEvent )</span><br><span class="line">            &#123;</span><br><span class="line">                __fastfail(<span class="number">3u</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            v16-&gt;Flink = v15;        <span class="comment">// 摘除结点</span></span><br><span class="line">            v15-&gt;Blink = v16;</span><br><span class="line">            DebugEvent_1 = DebugEvent;</span><br><span class="line">            GetEvent = <span class="number">1</span>;        <span class="comment">// 这个标志的意义是 while循环</span></span><br><span class="line">                                <span class="comment">// 他一次只能处理一个调试Event</span></span><br><span class="line">                                <span class="comment">// 但是while循环遍历整个Event链表</span></span><br><span class="line">                                <span class="comment">// GetVent可以保证只有一个处理了,然后KeSetEvent</span></span><br><span class="line">                                <span class="comment">// 让调试器赶紧去处理下一个</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DebugEvent = (_DEBUG_EVENT *)DebugEvent-&gt;EventList.Flink;</span><br><span class="line">    <span class="keyword">if</span> ( DebugEvent == (_DEBUG_EVENT *)&amp;DebouObject-&gt;EventList )</span><br><span class="line">        <span class="keyword">goto</span> ListEmpty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得一提是他循环EventList的判断机制，他的判断机制是如果有超过一个Event挂在链表上, 就去进行SetEvent,这个的作用是让R3的调试循环直接进行,可以节省时间。<br>他是先去除结点,在进行判断是否为空.如果为空的话直接ListEmpty就ret了。不会进行KeSetEvent了。</p>
<p>其中DbgkpWakeTarget(DebugEvent_1);的作用就是唤醒进程，同时设置一下Event.ContinueEvent，使得被调试进程能够继续运行下去。函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line"><span class="title function_">DbgkpWakeTarget</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN PDEBUG_EVENT DebugEvent</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line">&#123;</span><br><span class="line">    PETHREAD Thread;</span><br><span class="line"></span><br><span class="line">    Thread = DebugEvent-&gt;Thread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((DebugEvent-&gt;Flags&amp;DEBUG_EVENT_SUSPEND) != <span class="number">0</span>) &#123;</span><br><span class="line">        PsResumeThread (DebugEvent-&gt;Thread, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DebugEvent-&gt;Flags&amp;DEBUG_EVENT_RELEASE) &#123;</span><br><span class="line">        ExReleaseRundownProtection (&amp;Thread-&gt;RundownProtect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If we have an actual thread waiting then wake it up else free the memory.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> ((DebugEvent-&gt;Flags&amp;DEBUG_EVENT_NOWAIT) == <span class="number">0</span>) &#123;</span><br><span class="line">        KeSetEvent (&amp;DebugEvent-&gt;ContinueEvent, <span class="number">0</span>, FALSE); <span class="comment">// Wake up waiting process</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DbgkpFreeDebugEvent (DebugEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先进性判断,Event.Flags是否是进程需要暂停,不需要Resume线程，继续判断Event.Flags是否需要等待，如果需要等待,那么SetEvent ContinueEvent,让被卡住的进程继续下去,不等待则直接清理Event内存和零化链表。</p>
<h3 id="被调试进程消息采集"><a href="#被调试进程消息采集" class="headerlink" title="被调试进程消息采集"></a>被调试进程消息采集</h3><p>调试器等待和事件处理本质上是调试器做得事情，对于被调试进程,需要在各种情况下进行消息收集,放到DEBUG_OBJECT的链表中。<br>其核心函数在第一节有,即：<br>DbgkpSendApiMessage() 调用 DbgkpQueueMessage() 将 ApiMsg 变成 DEBUG_EVENT 挂入链表, 在DbgkpQueueMessage()中,包含了KeWaitForSingleObject进行等待Event.ContinueEvent。</p>
<h4 id="dbgkpqueuemessage-1"><a href="#dbgkpqueuemessage-1" class="headerlink" title="dbgkpqueuemessage"></a>dbgkpqueuemessage</h4><p>函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">DbgkpQueueMessage</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN PEPROCESS Process,</span></span><br><span class="line"><span class="params">    IN PETHREAD Thread,</span></span><br><span class="line"><span class="params">    IN OUT PDBGKM_APIMSG ApiMsg,</span></span><br><span class="line"><span class="params">    IN ULONG Flags,</span></span><br><span class="line"><span class="params">    IN PDEBUG_OBJECT TargetDebugObject</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>寻找DEBUG_PORT<ul>
<li>对于NoWait的Event消息，DEBUG_PORT使用TargetDebugObject（这是为了发送假消息做兼容）</li>
<li>对于需要等待的消息，DEBUG_PORT使用Process.DebugPort</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !(flags_1 &amp; <span class="number">2</span>) )</span><br><span class="line">&#123;</span><br><span class="line">    DebugObject_1 = (_DEBUG_PORT *)Process_1-&gt;DebugPort;</span><br></pre></td></tr></table></figure>
<p>flags定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_EVENT_READ          (0x01) <span class="comment">// Event had been seen by win32 app</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_EVENT_NOWAIT        (0x02) <span class="comment">// No waiter one this. Just free the pool</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_EVENT_INACTIVE      (0x04) <span class="comment">// The message is in inactive. It may be activated or deleted later</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_EVENT_RELEASE       (0x08) <span class="comment">// Release rundown protection on this thread</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_EVENT_PROTECT_FAILED (0x10) <span class="comment">// Rundown protection failed to be acquired on this thread</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_EVENT_SUSPEND       (0x20) <span class="comment">// Resume thread on continue</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>复制ApiMsg到DEBUG_EVENT</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ApiMsg_2 = ApiMsg_1;</span><br><span class="line">    v18 = <span class="number">2</span>i64;</span><br><span class="line">    <span class="keyword">do</span>                                      <span class="comment">// 把ApiMsg复制过去</span></span><br><span class="line">    &#123;</span><br><span class="line">        *DebugEvent_1_1 = *(_OWORD *)ApiMsg_2-&gt;h;</span><br><span class="line">        DebugEvent_1_1[<span class="number">1</span>] = *(_OWORD *)&amp;ApiMsg_2-&gt;h[<span class="number">16</span>];</span><br><span class="line">        DebugEvent_1_1[<span class="number">2</span>] = *(_OWORD *)&amp;ApiMsg_2-&gt;h[<span class="number">32</span>];</span><br><span class="line">        DebugEvent_1_1[<span class="number">3</span>] = *(_OWORD *)&amp;ApiMsg_2-&gt;u.Exception.ExceptionRecord.ExceptionCode;</span><br><span class="line">        DebugEvent_1_1[<span class="number">4</span>] = *((_OWORD *)&amp;ApiMsg_2-&gt;u.UnloadDll + <span class="number">1</span>);</span><br><span class="line">        DebugEvent_1_1[<span class="number">5</span>] = *((_OWORD *)&amp;ApiMsg_2-&gt;u.UnloadDll + <span class="number">2</span>);</span><br><span class="line">        DebugEvent_1_1[<span class="number">6</span>] = *((_OWORD *)&amp;ApiMsg_2-&gt;u.UnloadDll + <span class="number">3</span>);</span><br><span class="line">        DebugEvent_1_1 += <span class="number">8</span>;</span><br><span class="line">        v19 = *((_OWORD *)&amp;ApiMsg_2-&gt;u.UnloadDll + <span class="number">4</span>);</span><br><span class="line">        ApiMsg_2 = (_DBGKM_APIMSG *)((<span class="type">char</span> *)ApiMsg_2 + <span class="number">128</span>);</span><br><span class="line">        *(DebugEvent_1_1 - <span class="number">1</span>) = v19;</span><br><span class="line">        --v18;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">while</span> ( v18 );</span><br></pre></td></tr></table></figure>
<ul>
<li>对于需要等待的，进行KeWaitForSingleObject</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KeWaitForSingleObject((_DISPATCHER_HEADER *)(DebugEvent_1 + <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>i64);<span class="comment">// 进行等待</span></span><br><span class="line">    status = *((_DWORD *)DebugEvent_1 + <span class="number">18</span>); <span class="comment">// 注意,是被调试进程在这等!</span></span><br><span class="line">                                             <span class="comment">// 等待的是DebugEvent的Event</span></span><br><span class="line">                                             <span class="comment">// 而DebugObject的Event则标志着有事件要进行处理</span></span><br></pre></td></tr></table></figure>
<p>同时，KeSetEvent来进行调试器可以等待成功。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KeSetEvent(&amp;DebugObject_1-&gt;EventPresent, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">// 需要等待,设置一下DebugObject的位,当调试循环能改进行</span></span><br></pre></td></tr></table></figure>
<h4 id="收集api"><a href="#收集api" class="headerlink" title="收集api"></a>收集api</h4><p>收集API众多，最终会调用DbgkpSendApiMessage，收集API有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>API</th>
<th>操作</th>
<th>目标函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>DbgkPostModuleMessage+126</td>
<td>call</td>
<td>DbgkpSendApiMessage</td>
</tr>
<tr>
<td>2</td>
<td>DbgkCreateThread+1BCAB8</td>
<td>call</td>
<td>DbgkpSendApiMessage</td>
</tr>
<tr>
<td>3</td>
<td>DbgkCreateThread+1BCB42</td>
<td>call</td>
<td>DbgkpSendApiMessage</td>
</tr>
<tr>
<td>4</td>
<td>DbgkMapViewOfSection+1BBB5A</td>
<td>call</td>
<td>DbgkpSendApiMessage</td>
</tr>
<tr>
<td>5</td>
<td>DbgkUnMapViewOfSection+12C5FF</td>
<td>call</td>
<td>DbgkpSendApiMessage</td>
</tr>
<tr>
<td>6</td>
<td>DbgkForwardException+11174E</td>
<td>call</td>
<td>DbgkpSendApiMessage</td>
</tr>
<tr>
<td>7</td>
<td>DbgkCreateMinimalProcess+C6834</td>
<td>call</td>
<td>DbgkpSendApiMessage</td>
</tr>
<tr>
<td>8</td>
<td>DbgkSendSystemDllMessage+2A0</td>
<td>call</td>
<td>DbgkpSendApiMessage</td>
</tr>
<tr>
<td>9</td>
<td>bgkCreateMinimalThread+82</td>
<td>call</td>
<td>DbgkpSendApiMessage</td>
</tr>
<tr>
<td>10</td>
<td>DbgkExitProcess+96</td>
<td>call</td>
<td>DbgkpSendApiMessage</td>
</tr>
<tr>
<td>11</td>
<td>DbgkExitThread+88</td>
<td>call</td>
<td>DbgkpSendApiMessage</td>
</tr>
</tbody>
</table>
</div>
<p>这些收集API如创建线程收集API<code>DbgkCreateThread</code>这些API是在创建线程的必经之路上的。<br>这些函数会进行把信息变成<code>DBGKM_APIMSG</code>结构然后调用<code>DbgkpSendApiMessage</code>。</p>
<h5 id="线程逃逸"><a href="#线程逃逸" class="headerlink" title="线程逃逸"></a>线程逃逸</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the create worked then notify the debugger.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> ((Thread-&gt;CrossThreadFlags&amp;</span><br><span class="line">     (PS_CROSS_THREAD_FLAGS_DEADTHREAD|PS_CROSS_THREAD_FLAGS_HIDEFROMDBG)) == <span class="number">0</span>) &#123;</span><br><span class="line">    DbgkCreateThread (Thread, StartContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (DebugException) &#123;</span><br><span class="line">    <span class="keyword">if</span> (PsGetCurrentThread()-&gt;CrossThreadFlags&amp;PS_CROSS_THREAD_FLAGS_HIDEFROMDBG) &#123;</span><br><span class="line">        Port = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Port = Process-&gt;DebugPort;</span><br><span class="line">    &#125;</span><br><span class="line">    LpcPort = FALSE;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Port = Process-&gt;ExceptionPort;</span><br><span class="line">    m.h.u2.ZeroInit = LPC_EXCEPTION;</span><br><span class="line">    LpcPort = TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the destination LPC port address is NULL, then return FALSE.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (Port == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (LpcPort) &#123;</span><br><span class="line">    st = DbgkpSendApiMessageLpc(&amp;m,Port,DebugException);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    st = DbgkpSendApiMessage(&amp;m,DebugException);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进行收集时，如果线程的<code>HideFromDebugger</code>位被置位，那么就不会进行收集信息了，俗称<strong>线程逃逸</strong>。<br>调用<code>NtSetInformationThread</code>中有个<code>ThreadHideFromDebugger</code>(14号功能)，就会频闪调试器。</p>
<h3 id="调试原理"><a href="#调试原理" class="headerlink" title="调试原理"></a>调试原理</h3><h4 id="int3断点"><a href="#int3断点" class="headerlink" title="int3断点"></a>int3断点</h4><p>本质上，Int3断点就是往一个地址写入<code>CC</code>（即<code>int 3</code>）；在线程执行这个地方时，会进入3号中断。即与所有的陷阱门最后分发基本一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov     ecx, 80000003h</span><br><span class="line">mov     edx, 1</span><br><span class="line">mov     r8, [rbp+0E8h]  ; 80+E8==RIP</span><br><span class="line">dec     r8              ; RIP-1</span><br><span class="line">mov     r9d, 0</span><br><span class="line">call    KiExceptionDispatch</span><br><span class="line">nop</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>
<p>但是RIP是-1的。<br>在<code>KiDispatchException</code>进行异常派发时，调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DbgkForwardException(ExceptionRecord_1,<span class="number">1</span>,<span class="number">0</span>);<span class="comment">// 调用异常消息采集</span></span><br></pre></td></tr></table></figure>
<p>如果处理，则代表调试器处理。不用在进行异常分发。</p>
<h5 id="dbgkforwardexception"><a href="#dbgkforwardexception" class="headerlink" title="dbgkforwardexception"></a>dbgkforwardexception</h5><p>函数声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DECLSPEC_NOINLINE</span><br><span class="line">BOOLEAN</span><br><span class="line"><span class="title function_">DbgkForwardExcaption</span><span class="params">(</span></span><br><span class="line"><span class="params">    IN PEXCEPTION_RECORD ExceptionRecord,</span></span><br><span class="line"><span class="params">    IN BOOLEAN DebugException,</span></span><br><span class="line"><span class="params">    IN BOOLEAN SecondChance</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>函数首先：</p>
<ul>
<li>判断是否隐藏调试器的线程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( *(_DWORD *)((<span class="type">char</span> *)&amp;KeGetCurrentThread()[<span class="number">1</span>]._union_100.SwapListEntry + <span class="number">8</span>) &amp; <span class="number">4</span> )<span class="comment">//这个是HideFromDebugger</span></span><br><span class="line">    DebugPort = <span class="number">0</span>i64;                      <span class="comment">// 如果线程逃逸 那么就是0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    DebugPort = (_DEBUG_PORT *)Process-&gt;DebugPort;</span><br><span class="line">isLpc = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化ApiMsg变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KeCopyExceptionRecord(&amp;ApiMsg.u, ExRecord_1); <span class="comment">// 复制到ApiMsg</span></span><br></pre></td></tr></table></figure>
<ul>
<li>调用SendApiMessage</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status = DbgkpSendApiMessage(Process, DebugException_1 != <span class="number">0</span>, &amp;ApiMsg);</span><br></pre></td></tr></table></figure>
<ul>
<li>根据status判断是否调试器处理了</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( status &lt; <span class="number">0</span> )              <span class="comment">// 调试器没有处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h4 id="单步与硬件断点"><a href="#单步与硬件断点" class="headerlink" title="单步与硬件断点"></a>单步与硬件断点</h4><p>单步异常是TF位置位,会触发异常1号。从而一系列流程。<br>和int 1效果是一样的。</p>
<p>通过Dr寄存器可以区分硬断和单步断点。Dr6=0xf用于区分是否是硬件还是单步调试。</p>
<p>值得一提的是,对DR寄存器的操作都是Spuerviosr操作,设置Dr寄存器统统依靠API实现。<br>另外,DR7中G和L位,在Windows下通过API设置全局的硬件断点是无效的,即DR7中如果G位有值,API会忽略。</p>
<h4 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h4><p>就是页面异常。值得一提的是,一种可以用于无痕Hook的内存断点可以不依赖重定位。<br>但是效率极其低下。这些是OD等进程实现重复内存Hook的思路，<br>思路如下:<br>首先对某个页面进行Hook,调试或VEH/SEH接管之后,被中断,通过某些标志位进行判断是否是页面异常+在页面异常Hook范围内。<br>进行判断,如果就是Hook地址,进行Hook操作。<br>如果不是,恢复页面异常,设置TF单步异常位,判断是否是要Hook地址,如果不是,设置页面异常。如此迭代,直到暂停于要Hook的地方为止。</p>
<h2 id="lab7"><a href="#lab7" class="headerlink" title="lab7"></a>lab7</h2><h3 id="lab7：调试循环"><a href="#lab7：调试循环" class="headerlink" title="lab7：调试循环"></a>lab7：调试循环</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:6031)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 断点地址</span></span><br><span class="line">DWORD BP_VA = <span class="number">0x007A7358</span>;</span><br><span class="line"><span class="comment">// 007A7358 | . E8 C644FDEF call 0077B823</span></span><br><span class="line"></span><br><span class="line">DEBUG_EVENT DebugEv;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>** lpCstringSt;</span><br><span class="line"><span class="comment">// 007A73B2 E8 179FECFF call 007712CE</span></span><br><span class="line"></span><br><span class="line">BYTE dbOldByte;</span><br><span class="line">DWORD dwContinueStatus = DBG_CONTINUE; <span class="comment">// 这个代表如果出现调试出现异常，不用windows自带的SEH</span></span><br><span class="line">BYTE bInt3 = <span class="string">&#x27;\xcc&#x27;</span>; <span class="comment">// int3 断点指令</span></span><br><span class="line">BYTE bOldByte; <span class="comment">// 用于保存原始字节</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    STARTUPINFO si;</span><br><span class="line">    si = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    si.cb = <span class="built_in">sizeof</span>(STARTUPINFO);</span><br><span class="line">    PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">GetStartupInfo</span>(&amp;si);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* szFileName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, szFileName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建被调试进程</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CreateProcess</span>((WCHAR*)szFileName, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS, <span class="number">0</span>, <span class="number">0</span>, &amp;si, &amp;pi))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立调试循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">WaitForDebugEvent</span>(&amp;DebugEv, INFINITE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pi.dwProcessId == DebugEv.dwProcessId) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (DebugEv.dwDebugEventCode) &#123;</span><br><span class="line">            <span class="keyword">case</span> CREATE_PROCESS_DEBUG_EVENT: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Process Create Successsly!\r\n&quot;</span>);</span><br><span class="line">                <span class="comment">// 读取断点地址的原始字节</span></span><br><span class="line">                <span class="built_in">ReadProcessMemory</span>((HANDLE)pi.hProcess, (LPVOID)BP_VA, &amp;bOldByte, <span class="built_in">sizeof</span>(BYTE), <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;oldByte:%x\r\n&quot;</span>, bOldByte);</span><br><span class="line">                <span class="comment">// 写入int3断点</span></span><br><span class="line">                <span class="built_in">WriteProcessMemory</span>((HANDLE)pi.hProcess, (LPVOID)BP_VA, &amp;bInt3, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// printf(&quot;%d&quot;, bOldByte);</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;int3 break point lay up!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> EXCEPTION_DEBUG_EVENT: &#123;</span><br><span class="line">                <span class="comment">// 产生异常</span></span><br><span class="line">                <span class="keyword">switch</span> (DebugEv.u.Exception.ExceptionRecord.ExceptionCode) &#123;</span><br><span class="line">                <span class="keyword">case</span> EXCEPTION_BREAKPOINT: &#123;</span><br><span class="line">                    <span class="comment">// 断点异常</span></span><br><span class="line">                    CONTEXT context;</span><br><span class="line">                    context.ContextFlags = CONTEXT_ALL;</span><br><span class="line">                    <span class="built_in">GetThreadContext</span>(pi.hThread, &amp;context);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (BP_VA + <span class="number">1</span> == context.Eip) &#123;</span><br><span class="line">                        <span class="comment">// 注意这个地方是加1 因为int3这个指令占一个字节 此时已经执行了 Eip会往后挪一个字节</span></span><br><span class="line">                        <span class="type">char</span> szStr[<span class="number">256</span>];</span><br><span class="line">                        DWORD dwAddr;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 这个地址是跨进程的 因此要进行跨进程读取</span></span><br><span class="line">                        <span class="built_in">ReadProcessMemory</span>(pi.hProcess, (LPCVOID)context.Esp, &amp;dwAddr, <span class="built_in">sizeof</span>(DWORD), <span class="number">0</span>);</span><br><span class="line">                        <span class="built_in">ReadProcessMemory</span>(pi.hProcess, (LPCVOID)dwAddr, szStr, <span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;真正的用户名:%s&quot;</span>, szStr);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// lpCstringSt lpcsst = (lpCstringSt)context.Ecx;</span></span><br><span class="line">                        <span class="comment">// this call函数调用约定 ecx实际上指向的是Cstring的这个结构体</span></span><br><span class="line">                        <span class="built_in">ReadProcessMemory</span>(pi.hProcess, (LPCVOID)context.Ecx, &amp;dwAddr, <span class="built_in">sizeof</span>(DWORD), <span class="number">0</span>);</span><br><span class="line">                        <span class="built_in">ReadProcessMemory</span>(pi.hProcess, (LPCVOID)dwAddr, szStr, <span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;您输入的用户名:%s&quot;</span>, szStr);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 恢复EIP到断点前</span></span><br><span class="line">                        context.Eip--;</span><br><span class="line">                        <span class="comment">// 恢复原始字节</span></span><br><span class="line">                        <span class="built_in">WriteProcessMemory</span>(pi.hProcess, <span class="built_in">LPVOID</span>(BP_VA), &amp;bOldByte, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                        <span class="comment">// 设置线程上下文</span></span><br><span class="line">                        <span class="built_in">SetThreadContext</span>(pi.hThread, &amp;context);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                                         <span class="comment">// to do</span></span><br><span class="line">                                         <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">ContinueDebugEvent</span>(DebugEv.dwProcessId, DebugEv.dwThreadId, dwContinueStatus);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cap8：傀儡句柄无驱读写"><a href="#cap8：傀儡句柄无驱读写" class="headerlink" title="cap8：傀儡句柄无驱读写"></a>cap8：傀儡句柄无驱读写</h2><p>这里无驱动的意思并不是说从头到尾都不需要驱动,而是只是说在读写的时候,我不需要进行驱动通信,而且此时没有驱动;大部分读写,比如MDL,MmCopyMemory的物理读写,毫无疑问每次读写都需要和驱动进行通信一次;<br>无论你的通信手法如何高明,但是如果你不是kdMapper或者内存加载的驱动,被AC查到签名一样是拉闸;<br>而读写难度并不比注入难度小,通信、签名、方法缺一不可;<br>所以,目前的读写最好的手法一般如下</p>
<ul>
<li>map加载驱动+隐蔽通信+良好读写</li>
<li>正常加载驱动+whql+良好读写</li>
<li>黑科技读写,读写过程不需要驱动</li>
<li>DMA穿透读写</li>
</ul>
<p>此篇讲的是第三种,使用一些特殊取巧方法进行读写。</p>
<h3 id="读写原理"><a href="#读写原理" class="headerlink" title="读写原理"></a>读写原理</h3><p>首先可以看一下打豆豆大佬之前发过的也是可以叫做无驱动读写的,我这个灵感也是来源于他的傀儡进程读写：</p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-264318.htm">https://bbs.kanxue.com/thread-264318.htm</a></p>
<p>但是他这个有缺陷，首先,他是真的创建了进程,可以被AC遍历到,因此比较PML4E,发现傀儡进程;<br>另外,比较是创建了个线程,不可控程度是很大的,可以发现,他文章提到了进程退出蓝屏,下面的评论也有一堆蓝屏;<br>我们知道，动作越大,越不可控,越容易被检测。</p>
<p>所以这里我们考虑,复制一个假的EPROCESS,替换EPROCESS的cr3<br>然后使用ObOpenObjectByPointer来返回一个句柄。<br>这个时候,拿着这个句柄,直接返回R3,驱动加载失败,然后即可无驱动读写;</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="提高检测难度"><a href="#提高检测难度" class="headerlink" title="提高检测难度"></a>提高检测难度</h4><p>我们知道,游戏其实会查挂靠附加的,读写的时候肯定是会查,这个时候如果游戏比较的不是EPROCESS,而是CR3,那么这个读写方法是拉闸的。<br>而一个cr3其实就是一个页面,一个物理页,我们这里采用ExAllocate分配一个不分页内存,然后把游戏的cr3映射线性地址,把这块内存复制到假cr3那个页面。</p>
<h4 id="必须找到合适的TypeIndex"><a href="#必须找到合适的TypeIndex" class="headerlink" title="必须找到合适的TypeIndex"></a>必须找到合适的TypeIndex</h4><p>我们在正课的第三章句柄表那一块学过,TypeIndex是加密的,因此我们如果想要使用ObOpenObjectByPointer打开进程,就必须先把TypeIndex赋值合适。</p>
<h4 id="必须替换VAD"><a href="#必须替换VAD" class="headerlink" title="必须替换VAD"></a>必须替换VAD</h4><p>必须替换VAD,这样才能读写,这是因为WriteProcessMemory会先看VAD,如果VAD没有直接返回失败。</p>
<h4 id="如何获取模块"><a href="#如何获取模块" class="headerlink" title="如何获取模块"></a>如何获取模块</h4><p>替换PEB</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><blockquote>
<p>自己写。</p>
</blockquote>
<h2 id="lab8"><a href="#lab8" class="headerlink" title="lab8"></a>lab8</h2><h2 id="cap9：傀儡模块无痕hook"><a href="#cap9：傀儡模块无痕hook" class="headerlink" title="cap9：傀儡模块无痕hook"></a>cap9：傀儡模块无痕hook</h2><h3 id="HOOK-原理"><a href="#HOOK-原理" class="headerlink" title="HOOK 原理"></a>HOOK 原理</h3><p>首先要把HOOK的地方通过把要HOOK的地方设置成不可执行,每次执行到这个地方会出现不可执行异常。<br>然后把整个模块全部复制一份,此时触发异常,判断是否位于HOOK的页面,如果是,那么就跳转到对于的模块上面去;</p>
<h3 id="为什么不需要重定位"><a href="#为什么不需要重定位" class="headerlink" title="为什么不需要重定位"></a>为什么不需要重定位</h3><p>可能会疑惑,为什么不需要重定位<br>首先,我们需要明白,为什么需要重定位,重定位是编译器在编译的时候,全局变量地址在链接之前就已经确定好了,因此在引用全局变量的时候,一旦涉及到地址,无论是代码段,还是说data段,引用了这个全局变量的地址,必须重定位;<br>因此,引用全局变量的方式决定了如何进行重定位;<br>但除此之外,如果加载地址不变,那么肯定是不需要重定位的,这也就是为什么DLL需要重定位,而EXE只有开了ASLR才需要重定位;</p>
<h4 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h4><p>首先,就x86来说,我们知道,不仅是data可能引用全局变量,text段也是引用的全局变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">; C7 05 18 40 40 00 42 00 00 00 mov ?x@@3HA, 42h ; &#x27;B&#x27; ; int x</span><br><span class="line">; C7 05 1C 40 40 00 4D 00 00 00 mov ?y@@3HA, 4Dh ; &#x27;M&#x27; ; int y</span><br></pre></td></tr></table></figure>
<p>因此,在x86的软件上面,exe的重定位表是有<code>.text</code>节的;因为他这个变量引用是直接引用,也就是靠地址。<br>因此,我们需要重定位这个<code>.text</code>代码段,让他里面的这个四字节地址+真正Locat地址-原先的Locat地址。<br>除此之外,x86的其他地方也需要重定位,主要是全局变量引用全局变量。</p>
<p>那么问题来了,为什么说x86进行刚才的操作不需要进行重定位呢?<br>可以想象,一旦复制过去,我们其实只需要让代码段不可执行,然后跑到我们的傀儡模块里面去即可。<br>而我们知道,x86引用全局变量是靠绝对地址的,因此就算跑到我们的傀儡模块里面去,引用的全局变量还是原来真模块的,不会出现任何问题;比较我们知道,真模块的全局变量已经重定位过了,不需要在进行重定位了;</p>
<h4 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h4><p>那么x64为什么不需要重定位呢,其实道理很简单,x64的引用全局变量是靠间接引用的,也就是下面这种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ext:0000000140001135 8B 0D F4 3E 00 00    mov ecx, cs:?x@@3HA ; int</span><br><span class="line">ext:000000014000113A E8 5B FF FF FF       call ?haha@@YAHH@Z  ; haha(int)</span><br><span class="line">ext:0000000140001140 ...</span><br></pre></td></tr></table></figure>
<p>而且我们知道,既然是间接引用,而且data节和text节的偏移是不变的,也就是无论这个exe或者dll的ImageBase是多少,都不需要重定位。<br>那么难道说x64不需要重定位了吗? 但是不全对,x64只是.text节不需要重定位了。<br>但是其他的,涉及到全局变量引用全局变量,全局变量引用函数地址的,毫无疑问还是需要重定位的;<br>但是这个不是问题,因为我们知道,我们复制了整个模块,是连同本来的重定位一块给复制过去了;<br>所以这个时候是已经进行了重定位的,也是不需要重定位并且不会出现问题;<br>最终,我们得出结论,无论是x64还是x86,如果进行复制模块,都不需要。</p>
<h3 id="此方法的缺陷与展望"><a href="#此方法的缺陷与展望" class="headerlink" title="此方法的缺陷与展望"></a>此方法的缺陷与展望</h3><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><ul>
<li>虽然不用重定位,但是我们可以发现,其实data rdata这种全局变量节区,其实傀儡模块和真正模块共用的全局变量其实是复制之前的真模块的,rdata还好说,但是如果是data节,也就是可写的全局变量<br>如果在复制之后某个时间节点,真模块修改了data节区,那么就会造成全局变量不一致的情况,严重可能造成闪退。</li>
<li>其次因为涉及到了异常,设置不可执行,因此页面会有不可执行的痕迹,除此之外,一旦有异常处理那么毫无疑问,肯定会涉及VEH。</li>
</ul>
<h4 id="展望和解决"><a href="#展望和解决" class="headerlink" title="展望和解决"></a>展望和解决</h4><p>解决方法：</p>
<ul>
<li>使用驱动注入,并且使用驱动,让假模块的rdata,data这些全局变量节区的物理页(修改pte)和真模块相同,据此达到同步的目的。</li>
<li>使用超级VEH，规避veh(第六章知识)</li>
<li>隐藏内存,隐藏可执行(第四章知识)</li>
</ul>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><blockquote>
<p>自己写。</p>
</blockquote>
<h2 id="lab9"><a href="#lab9" class="headerlink" title="lab9"></a>lab9</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://njmxye.de5.net">楠寻njmxye</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://njmxye.de5.net/2025/12/13/%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%8E%86/">https://njmxye.de5.net/2025/12/13/%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%8E%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://njmxye.de5.net" target="_blank">楠 寻 の 小 窝</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/12/14/x64%E4%BD%93%E7%B3%BB%E6%8E%A2%E7%B4%A2%E5%8F%8A%E7%BC%96%E7%A8%8B/" title="x64体系探索及编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">x64体系探索及编程</div></div></a></div><div class="next-post pull-right"><a href="/2025/04/06/%E7%A4%BE%E4%BC%9A%E5%8C%96/" title="社会化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">社会化</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">楠寻njmxye</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/1289795105"><i class="fab fa-bilibili"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/njmxye" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://njmxye.de5.net/njmxye.github.io.apk" target="_blank" title="Apks"><i class="fas fa-download" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">带我走吧，我没法适应人类的生活，像个小孩一样，好痛苦，好想死。派一个人，收走我吧，我快撑不住了，我不再抱任何的希望了。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#cap0%EF%BC%9AVS2019%E7%8E%AF%E5%A2%83"><span class="toc-number">1.</span> <span class="toc-text">cap0：VS2019环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%8E%AF%E5%A2%83"><span class="toc-number">1.1.</span> <span class="toc-text">虚拟机环境</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cap0%EF%BC%9A%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95"><span class="toc-number">2.</span> <span class="toc-text">cap0：双机调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#windbg%E5%91%BD%E4%BB%A4"><span class="toc-number">2.1.</span> <span class="toc-text">windbg命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%BE%E7%A4%BA%E5%91%BD%E4%BB%A4%EF%BC%88%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">内存显示命令（虚拟内存）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BC%96%E8%BE%91%E5%91%BD%E4%BB%A4"><span class="toc-number">2.1.2.</span> <span class="toc-text">内存编辑命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%99%A8%E6%89%A9%E5%B1%95%E5%91%BD%E4%BB%A4%EF%BC%88%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%EF%BC%89"><span class="toc-number">2.1.3.</span> <span class="toc-text">调试器扩展命令（物理内存）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%90%9C%E7%B4%A2%E5%91%BD%E4%BB%A4"><span class="toc-number">2.1.4.</span> <span class="toc-text">内存搜索命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E6%B1%87%E7%BC%96%E5%91%BD%E4%BB%A4"><span class="toc-number">2.1.5.</span> <span class="toc-text">反汇编命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">2.1.6.</span> <span class="toc-text">寄存器命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%82%E9%A1%B9%E5%91%BD%E4%BB%A4"><span class="toc-number">2.1.7.</span> <span class="toc-text">杂项命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%AD%E7%82%B9%E5%91%BD%E4%BB%A4"><span class="toc-number">2.1.8.</span> <span class="toc-text">断点命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9"><span class="toc-number">2.1.9.</span> <span class="toc-text">条件断点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8"><span class="toc-number">2.2.</span> <span class="toc-text">第一个驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.2.1.</span> <span class="toc-text">前置条件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#code"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">code</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cap0%EF%BC%9A%E6%89%AB%E7%9B%B2%E7%AB%A0"><span class="toc-number">3.</span> <span class="toc-text">cap0：扫盲章</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B-Process"><span class="toc-number">3.0.1.</span> <span class="toc-text">进程(Process)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C"><span class="toc-number">3.0.1.1.</span> <span class="toc-text">进程运行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80"><span class="toc-number">3.0.1.2.</span> <span class="toc-text">虚拟地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.0.1.3.</span> <span class="toc-text">内核对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Windbg%E4%B8%AD%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.0.1.4.</span> <span class="toc-text">Windbg中查看进程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B-Thread"><span class="toc-number">3.0.2.</span> <span class="toc-text">线程(Thread)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8C%85%E5%90%AB%E4%BB%A5%E4%B8%8B%E7%BB%84%E4%BB%B6"><span class="toc-number">3.0.2.1.</span> <span class="toc-text">线程包含以下组件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Windbg%E4%B8%AD%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.0.2.2.</span> <span class="toc-text">Windbg中查看线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KPCR"><span class="toc-number">3.0.3.</span> <span class="toc-text">KPCR</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Windbg%E4%B8%AD%E6%9F%A5%E7%9C%8BKPCR"><span class="toc-number">3.0.3.1.</span> <span class="toc-text">Windbg中查看KPCR</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%A5%E6%9F%84"><span class="toc-number">3.0.4.</span> <span class="toc-text">句柄</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%A5%E6%9F%84%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">3.0.4.1.</span> <span class="toc-text">句柄的特性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E5%90%8D%E7%A7%B0"><span class="toc-number">3.0.5.</span> <span class="toc-text">内核对象名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Windows%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">3.0.6.</span> <span class="toc-text">Windows系统架构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cap1%EF%BC%9AIA32E%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">cap1：IA32E保护模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#x64%E4%B8%8Ex86%E6%8C%87%E4%BB%A4%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">x64与x86指令架构的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.1.</span> <span class="toc-text">寄存器区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%B7%AE%E5%88%AB"><span class="toc-number">4.1.2.</span> <span class="toc-text">地址差别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AE%E8%BD%AF%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">微软使用的地址</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x64%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AF%BB%E5%9D%80"><span class="toc-number">4.1.3.</span> <span class="toc-text">x64全局变量寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x64%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A-ABI"><span class="toc-number">4.1.4.</span> <span class="toc-text">x64调用约定(ABI)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x64InlineHook"><span class="toc-number">4.1.5.</span> <span class="toc-text">x64InlineHook</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vs%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96"><span class="toc-number">4.1.6.</span> <span class="toc-text">vs中使用内联汇编</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x64%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">x64保护模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">4.2.1.</span> <span class="toc-text">控制寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#cr8"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">cr8</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cr3"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">cr3</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cr0"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">cr0</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#PE%E4%BD%8D"><span class="toc-number">4.2.1.3.1.</span> <span class="toc-text">PE位</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#PG%E4%BD%8D"><span class="toc-number">4.2.1.3.2.</span> <span class="toc-text">PG位</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#WP%E4%BD%8D"><span class="toc-number">4.2.1.3.3.</span> <span class="toc-text">WP位</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cr4"><span class="toc-number">4.2.1.4.</span> <span class="toc-text">cr4</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#TSD%E4%BD%8D"><span class="toc-number">4.2.1.4.1.</span> <span class="toc-text">TSD位</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#SMEP%E4%BD%8D"><span class="toc-number">4.2.1.4.2.</span> <span class="toc-text">SMEP位</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#VMXE%E4%BD%8D"><span class="toc-number">4.2.1.4.3.</span> <span class="toc-text">VMXE位</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#PCIDE%E6%9C%BA%E5%88%B6"><span class="toc-number">4.2.1.4.4.</span> <span class="toc-text">PCIDE机制</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cr2"><span class="toc-number">4.2.1.5.</span> <span class="toc-text">cr2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#efer%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">4.2.1.6.</span> <span class="toc-text">efer扩展功能寄存器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#msr%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">msr寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#msr%E5%AF%B9%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">msr对特殊指令的支持</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#syscall-sysret"><span class="toc-number">4.2.2.1.1.</span> <span class="toc-text">syscall&#x2F;sysret</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#swapgs"><span class="toc-number">4.2.2.1.2.</span> <span class="toc-text">swapgs</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#msr%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">msr寄存器的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#rdmsr%E8%BF%9B%E8%A1%8C%E8%AF%BB"><span class="toc-number">4.2.2.2.1.</span> <span class="toc-text">rdmsr进行读</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#wrmsr%E8%BF%9B%E8%A1%8C%E5%86%99"><span class="toc-number">4.2.2.2.2.</span> <span class="toc-text">wrmsr进行写</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E9%AA%8C%E8%AF%81swapgs"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">实验验证swapgs</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#long-mode%E4%B8%8B%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.3.</span> <span class="toc-text">long mode下的保护模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AE%B5%E4%BF%9D%E6%8A%A4%EF%BC%88%E7%AE%A1%E7%90%86%EF%BC%89"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">段保护（管理）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AE%B5%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">4.2.3.1.1.</span> <span class="toc-text">段的内存管理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AE%B5%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%8E%AA%E6%96%BD"><span class="toc-number">4.2.3.1.2.</span> <span class="toc-text">段的保护措施</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90"><span class="toc-number">4.2.3.1.3.</span> <span class="toc-text">段选择子</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="toc-number">4.2.3.1.4.</span> <span class="toc-text">描述符表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">4.2.3.1.5.</span> <span class="toc-text">段选择子寄存器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">4.2.3.1.6.</span> <span class="toc-text">段描述符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ldt%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8Cldt"><span class="toc-number">4.2.3.1.7.</span> <span class="toc-text">ldt描述符和ldt</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#idtr%E4%B8%8Egdtr"><span class="toc-number">4.2.3.1.8.</span> <span class="toc-text">idtr与gdtr</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E4%BF%9D%E6%8A%A4%EF%BC%88%E7%AE%A1%E7%90%86%EF%BC%89"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">页保护（管理）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ia32e%E9%A1%B5%E8%BD%AC%E6%8D%A2%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.3.2.1.</span> <span class="toc-text">ia32e页转换模式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#cr3%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.3.2.2.</span> <span class="toc-text">cr3结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#pml4e%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.3.2.3.</span> <span class="toc-text">pml4e结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#pdpte%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.3.2.4.</span> <span class="toc-text">pdpte结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#pde%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.3.2.5.</span> <span class="toc-text">pde结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#pte%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.3.2.6.</span> <span class="toc-text">pte结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%9A%84%E5%85%B6%E4%BB%96%E4%BD%8D%E5%90%AB%E4%B9%89"><span class="toc-number">4.2.3.2.7.</span> <span class="toc-text">页表项的其他位含义</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tlb%E4%B8%8Ecache"><span class="toc-number">4.2.3.3.</span> <span class="toc-text">tlb与cache</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab1"><span class="toc-number">5.</span> <span class="toc-text">lab1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lab1%EF%BC%9Ainline-hook-framework"><span class="toc-number">5.1.</span> <span class="toc-text">lab1：inline_hook_framework</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lab1%EF%BC%9Asample-ptehook"><span class="toc-number">5.2.</span> <span class="toc-text">lab1：sample_ptehook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lab1%EF%BC%9Aperfect-pte-hook"><span class="toc-number">5.3.</span> <span class="toc-text">lab1：perfect_pte_hook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lab1%EF%BC%9Aother-pteHook"><span class="toc-number">5.4.</span> <span class="toc-text">lab1：other_pteHook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lab1-%E5%BC%80%E6%BA%90inlinehook%E7%BB%83%E4%B9%A0"><span class="toc-number">5.5.</span> <span class="toc-text">lab1-开源inlinehook练习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lab1-%E5%BC%80%E6%BA%90pte%E7%BB%83%E4%B9%A0"><span class="toc-number">5.6.</span> <span class="toc-text">lab1-开源pte练习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lab1-%E5%BC%80%E6%BA%90swapgs%E7%BB%83%E4%B9%A0"><span class="toc-number">5.7.</span> <span class="toc-text">lab1-开源swapgs练习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lab1-%E5%BC%80%E6%BA%90%E6%A8%A1%E5%9D%97%E5%9F%BA%E5%9D%80%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.8.</span> <span class="toc-text">lab1-开源模块基址查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lab1-%E5%BC%80%E6%BA%90r02r3%E9%80%9A%E4%BF%A1"><span class="toc-number">5.9.</span> <span class="toc-text">lab1-开源r02r3通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cap2%EF%BC%9Ax64-windows%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">cap2：x64_windows系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#r3-r0%E9%80%9A%E8%BF%87%E8%87%AA%E9%99%B7%E6%8C%87%E4%BB%A4%E8%BF%9B%E5%85%A5r0%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">6.1.</span> <span class="toc-text">r3-r0通过自陷指令进入r0的系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#windows-x64%E4%B8%8B%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">6.1.1.</span> <span class="toc-text">windows_x64下的系统调用指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#syscall%E6%8C%87%E4%BB%A4"><span class="toc-number">6.1.1.1.</span> <span class="toc-text">syscall指令</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KiSystemCall64"><span class="toc-number">6.1.2.</span> <span class="toc-text">KiSystemCall64</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#KiSystemServiceStart"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">KiSystemServiceStart</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#KiSystemServiceCopyEnd"><span class="toc-number">6.1.2.2.</span> <span class="toc-text">KiSystemServiceCopyEnd</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#etw%E5%88%A4%E6%96%AD"><span class="toc-number">6.1.2.3.</span> <span class="toc-text">etw判断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#InstrumentationCallback%E6%B4%BE%E9%81%A3"><span class="toc-number">6.1.2.4.</span> <span class="toc-text">InstrumentationCallback派遣</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%A8%E5%86%8CInstrumentationCallback"><span class="toc-number">6.1.2.4.1.</span> <span class="toc-text">注册InstrumentationCallback</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%9B%9E%E8%B0%83%E6%97%B6token%E6%9C%BA%E5%88%B6"><span class="toc-number">6.1.2.4.2.</span> <span class="toc-text">设置回调时token机制</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TOKEN%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90%EF%BC%88kd-dt%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">TOKEN结构解析（kd dt命令查看）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#sysret"><span class="toc-number">6.2.0.1.</span> <span class="toc-text">sysret</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#r0-r0%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">6.3.</span> <span class="toc-text">r0-r0的系统调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab2"><span class="toc-number">7.</span> <span class="toc-text">lab2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lab2-set-instcallback"><span class="toc-number">7.1.</span> <span class="toc-text">lab2-set_instcallback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lab2-OxygenDriver-%E7%A0%94%E8%AF%BB%E5%BC%80%E6%BA%90%E6%8B%89%E9%97%B8%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">7.2.</span> <span class="toc-text">lab2-OxygenDriver_研读开源拉闸的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lab2-instcallback%E4%BB%AA%E5%99%A8%E5%9B%9E%E8%B0%83%E6%B3%A8%E5%85%A5"><span class="toc-number">7.3.</span> <span class="toc-text">lab2-instcallback仪器回调注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Gemini%E6%9C%89%E8%AF%9D%E8%AF%B4"><span class="toc-number">7.3.1.</span> <span class="toc-text">Gemini有话说</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">7.3.1.1.</span> <span class="toc-text">1. 核心原理流程分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91%E6%A3%80%E6%9F%A5%E4%B8%8E%E9%A3%8E%E9%99%A9%E7%82%B9"><span class="toc-number">7.3.1.2.</span> <span class="toc-text">2. 代码逻辑检查与风险点</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#A-PageAttrHide-%E8%B0%83%E7%94%A8%E5%8F%82%E6%95%B0%E9%94%99%E8%AF%AF%EF%BC%88%E5%AF%BC%E8%87%B4%E9%9A%90%E8%97%8F%E5%A4%B1%E6%95%88%EF%BC%89"><span class="toc-number">7.3.1.2.1.</span> <span class="toc-text">A. PageAttrHide 调用参数错误（导致隐藏失效）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#B-%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E5%BF%85%E5%B4%A9%E7%82%B9%EF%BC%89"><span class="toc-number">7.3.1.2.2.</span> <span class="toc-text">B. 全局函数指针未初始化（必崩点）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#C-%E6%AD%BB%E9%94%81%E9%A3%8E%E9%99%A9%EF%BC%88%E6%97%A0%E9%99%90%E7%AD%89%E5%BE%85%EF%BC%89"><span class="toc-number">7.3.1.2.3.</span> <span class="toc-text">C. 死锁风险（无限等待）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E7%BB%86%E8%8A%82%E5%AE%A1%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number">7.3.1.3.</span> <span class="toc-text">3. 代码细节审计与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-ShellCode-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.3.1.3.1.</span> <span class="toc-text">关于 ShellCode 中的类型转换</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-IAT-%E4%BF%AE%E5%A4%8D%E9%80%BB%E8%BE%91"><span class="toc-number">7.3.1.3.2.</span> <span class="toc-text">关于 IAT 修复逻辑</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-VAD-%E9%9A%90%E8%97%8F-PageAttrHide"><span class="toc-number">7.3.1.3.3.</span> <span class="toc-text">关于 VAD 隐藏 (PageAttrHide)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lab2-%E5%85%B6%E4%BB%96%E5%BC%80%E6%BA%90%E6%B3%A8%E5%85%A5%E5%99%A8"><span class="toc-number">7.4.</span> <span class="toc-text">lab2-其他开源注入器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cap3%EF%BC%9Ax64%E5%8F%A5%E6%9F%84%E5%9B%9E%E8%B0%83%E5%92%8C%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.</span> <span class="toc-text">cap3：x64句柄回调和内核对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A5%E6%9F%84-1"><span class="toc-number">8.1.</span> <span class="toc-text">句柄</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#r0%E4%B8%8B%E7%9A%84%E5%8F%A5%E6%9F%84%E7%AE%A1%E7%90%86"><span class="toc-number">8.2.</span> <span class="toc-text">r0下的句柄管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E5%8F%A5%E6%9F%84%E8%A1%A8%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">8.2.1.</span> <span class="toc-text">私有句柄表的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87tablecode-%E5%8F%A5%E6%9F%84%E5%BD%93%E4%BD%9C%E7%B4%A2%E5%BC%95%E8%BF%9B%E8%A1%8C%E9%81%8D%E5%8E%86"><span class="toc-number">8.2.1.1.</span> <span class="toc-text">通过tablecode+句柄当作索引进行遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#grantedaccess%E4%BB%A5%E5%8F%8Awindows%E5%8F%A5%E6%9F%84%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81%E6%9C%BA%E5%88%B6"><span class="toc-number">8.2.2.</span> <span class="toc-text">grantedaccess以及windows句柄权限验证机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%A5%E6%9F%84%E8%A1%A8"><span class="toc-number">8.2.3.</span> <span class="toc-text">全局句柄表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A5%E6%9F%84%E5%9B%9E%E8%B0%83"><span class="toc-number">8.3.</span> <span class="toc-text">句柄回调</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ob-callback-registration"><span class="toc-number">8.3.1.</span> <span class="toc-text">ob_callback_registration</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E"><span class="toc-number">8.3.1.1.</span> <span class="toc-text">字段说明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E8%A2%AB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">8.3.2.</span> <span class="toc-text">回调被加载的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%A5%E6%9F%84%E5%88%9B%E5%BB%BA%E5%9C%A8psopenprocess%E4%B8%AD%E7%9A%84%E6%A3%80%E6%9F%A5"><span class="toc-number">8.3.2.1.</span> <span class="toc-text">句柄创建在psopenprocess中的检查</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#rundownprotect%E6%9C%BA%E5%88%B6"><span class="toc-number">8.3.2.1.1.</span> <span class="toc-text">rundownprotect机制</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%A5%E6%9F%84%E5%9B%9E%E8%B0%83%E6%94%AF%E6%8C%81%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-number">8.3.2.2.</span> <span class="toc-text">句柄回调支持的判断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.4.</span> <span class="toc-text">对象类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#typeinfo"><span class="toc-number">8.4.1.</span> <span class="toc-text">typeinfo</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab3"><span class="toc-number">9.</span> <span class="toc-text">lab3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lab3%EF%BC%9Aget-all-handles-%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%9E%9A%E4%B8%BE%E6%89%80%E6%9C%89%E5%8F%A5%E6%9F%84"><span class="toc-number">9.1.</span> <span class="toc-text">lab3：get_all_handles 用户模式下枚举所有句柄</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lab3-%E5%BC%80%E6%BA%90%E5%8F%A5%E6%9F%84%E5%9B%9E%E8%B0%83%E7%BB%83%E4%B9%A0"><span class="toc-number">9.2.</span> <span class="toc-text">lab3-开源句柄回调练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cap4%EF%BC%9Ax64windows%E5%86%85%E5%AD%98"><span class="toc-number">10.</span> <span class="toc-text">cap4：x64windows内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#windows%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E8%AE%BA"><span class="toc-number">10.1.</span> <span class="toc-text">windows内存管理概论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%9C%B0%E5%9D%80%E7%9A%84%E7%A9%BA%E9%97%B4%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">10.1.1.</span> <span class="toc-text">系统地址的空间内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%E6%83%85%E5%86%B5"><span class="toc-number">10.1.1.1.</span> <span class="toc-text">系统空间管理情况</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">10.1.2.</span> <span class="toc-text">用户空间的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#vad%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">10.1.2.1.</span> <span class="toc-text">vad的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#mmvad-short"><span class="toc-number">10.1.2.1.1.</span> <span class="toc-text">mmvad_short</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8C%BA%E5%AF%B9%E8%B1%A1-section-%E4%B8%8E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">10.1.2.1.2.</span> <span class="toc-text">内存区对象(_section)与共享内存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%A9%BA%E9%97%B4%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">10.1.3.</span> <span class="toc-text">物理空间的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mmpfndatabase"><span class="toc-number">10.1.3.1.</span> <span class="toc-text">mmpfndatabase</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#MmGetVirtualForPhysical"><span class="toc-number">10.1.3.1.1.</span> <span class="toc-text">MmGetVirtualForPhysical</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#originalpte"><span class="toc-number">10.1.4.</span> <span class="toc-text">originalpte</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8Bpte"><span class="toc-number">10.2.</span> <span class="toc-text">原型pte</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ptebase%E5%92%8C%E9%A1%B5%E8%A1%A8%E8%87%AA%E6%98%A0%E5%B0%84"><span class="toc-number">10.3.</span> <span class="toc-text">ptebase和页表自映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ptebase"><span class="toc-number">10.3.1.</span> <span class="toc-text">ptebase</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E8%87%AA%E6%98%A0%E5%B0%84"><span class="toc-number">10.3.2.</span> <span class="toc-text">页表自映射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%81%E7%A0%B4%E9%99%90%E5%88%B6%E6%98%A0%E5%B0%84pagetable%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">10.4.</span> <span class="toc-text">突破限制映射pagetable的两种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#physicalmemory-section%E5%AF%B9%E8%B1%A1%E6%98%A0%E5%B0%84"><span class="toc-number">10.4.1.</span> <span class="toc-text">physicalmemory section对象映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%AA%E9%80%A0pteaddress%E8%BF%87MmMapIoSpace"><span class="toc-number">10.4.2.</span> <span class="toc-text">伪造pteaddress过MmMapIoSpace</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab4"><span class="toc-number">11.</span> <span class="toc-text">lab4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cap5%EF%BC%9Ax64apc%E6%9C%BA%E5%88%B6%E5%92%8C%E6%8C%82%E9%9D%A0"><span class="toc-number">12.</span> <span class="toc-text">cap5：x64apc机制和挂靠</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#apc%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84"><span class="toc-number">12.1.</span> <span class="toc-text">apc定义及其相关结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#apc%E5%AE%9A%E4%B9%89"><span class="toc-number">12.1.1.</span> <span class="toc-text">apc定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#apc%E5%BA%94%E7%94%A8"><span class="toc-number">12.1.1.1.</span> <span class="toc-text">apc应用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#apc%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84"><span class="toc-number">12.1.2.</span> <span class="toc-text">apc相关结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#kapc-state"><span class="toc-number">12.1.2.1.</span> <span class="toc-text">kapc_state</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#alerted-2-%E5%92%8Calertable"><span class="toc-number">12.1.2.2.</span> <span class="toc-text">alerted[2]和alertable</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#apcqueueable-apcstatepointer%E4%B8%8Eapcstateindex"><span class="toc-number">12.1.2.3.</span> <span class="toc-text">apcqueueable,apcstatepointer与apcstateindex</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#savedapcstate"><span class="toc-number">12.1.2.4.</span> <span class="toc-text">savedapcstate</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#kapc"><span class="toc-number">12.1.2.5.</span> <span class="toc-text">kapc</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#apc%E6%8E%A7%E5%88%B6%E4%BD%8D"><span class="toc-number">12.1.2.6.</span> <span class="toc-text">apc控制位</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#apc%E4%BB%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%B0%E6%8F%92%E5%85%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">12.2.</span> <span class="toc-text">apc从初始化到插入过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#apc%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">12.2.1.</span> <span class="toc-text">apc的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#apc%E6%8F%92%E5%85%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">12.2.2.</span> <span class="toc-text">apc插入过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#keinsertqueueapc"><span class="toc-number">12.2.2.1.</span> <span class="toc-text">keinsertqueueapc</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#kiinsertqueueapc"><span class="toc-number">12.2.2.2.</span> <span class="toc-text">kiinsertqueueapc</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#apc%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">12.3.</span> <span class="toc-text">apc执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8apc%E6%89%A7%E8%A1%8C"><span class="toc-number">12.3.1.</span> <span class="toc-text">内核apc执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7apc%E6%89%A7%E8%A1%8C"><span class="toc-number">12.3.2.</span> <span class="toc-text">用户apc执行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%99%84%E5%8A%A0"><span class="toc-number">12.4.</span> <span class="toc-text">线程附加</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab5"><span class="toc-number">13.</span> <span class="toc-text">lab5</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cap6%EF%BC%9Ax64%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">14.</span> <span class="toc-text">cap6：x64异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E7%A1%AC%E4%BB%B6%E6%A6%82%E8%AE%BA"><span class="toc-number">14.1.</span> <span class="toc-text">中断与异常硬件概论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">14.1.1.</span> <span class="toc-text">异常中断的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#apic%E6%9E%B6%E6%9E%84%E7%9A%84%E4%B8%AD%E6%96%AD%E5%88%86%E7%B1%BB"><span class="toc-number">14.1.2.</span> <span class="toc-text">apic架构的中断分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E4%BA%A7%E7%94%9F"><span class="toc-number">14.1.2.1.</span> <span class="toc-text">硬件产生</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E4%BA%A7%E7%94%9F"><span class="toc-number">14.1.2.2.</span> <span class="toc-text">软件产生</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%BA%90%E4%B8%8E%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BF%AE%E5%A4%8D"><span class="toc-number">14.1.3.</span> <span class="toc-text">异常源与异常的修复</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%81%A2%E5%A4%8D"><span class="toc-number">14.1.3.1.</span> <span class="toc-text">异常恢复</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%ADvector"><span class="toc-number">14.1.4.</span> <span class="toc-text">中断vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%B1%8F%E8%94%BD"><span class="toc-number">14.1.5.</span> <span class="toc-text">中断的屏蔽</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#idtr%E5%92%8Cgate%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">14.1.6.</span> <span class="toc-text">idtr和gate描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#irql%E5%92%8Capic%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">14.1.7.</span> <span class="toc-text">irql和apic中断优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#irql"><span class="toc-number">14.1.7.1.</span> <span class="toc-text">irql</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#r0-r3%E5%BC%82%E5%B8%B8%E6%B4%BE%E9%81%A3%E5%88%86%E6%9E%90"><span class="toc-number">14.2.</span> <span class="toc-text">r0-r3异常派遣分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x64veh%E9%80%86%E5%90%91"><span class="toc-number">14.2.1.</span> <span class="toc-text">x64veh逆向</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#veh%E7%AE%80%E4%BB%8B"><span class="toc-number">14.2.1.1.</span> <span class="toc-text">veh简介</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x64%E5%8E%9F%E7%94%9Fseh%E9%80%86%E5%90%91"><span class="toc-number">14.2.2.</span> <span class="toc-text">x64原生seh逆向</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#seh%E7%9A%84%E4%BF%AE%E5%A4%8D"><span class="toc-number">14.3.</span> <span class="toc-text">seh的修复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E5%8A%A0%E8%BD%BDdll%E6%97%A0%E9%A1%BB%E5%8A%A0%E8%BD%BD%E4%BF%AE%E5%A4%8D"><span class="toc-number">14.3.1.</span> <span class="toc-text">正常加载dll无须加载修复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x86seh%E7%9A%84%E4%BF%AE%E5%A4%8D"><span class="toc-number">14.3.2.</span> <span class="toc-text">x86seh的修复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x64seh%E7%9A%84%E4%BF%AE%E5%A4%8D"><span class="toc-number">14.3.3.</span> <span class="toc-text">x64seh的修复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8callbacks"><span class="toc-number">14.3.4.</span> <span class="toc-text">异常callbacks</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RtlInstallFunctionTableCallback%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">14.3.4.1.</span> <span class="toc-text">RtlInstallFunctionTableCallback函数的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9Fveh"><span class="toc-number">14.4.</span> <span class="toc-text">传统veh</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E7%BA%A7VEH"><span class="toc-number">14.5.</span> <span class="toc-text">超级VEH</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab6"><span class="toc-number">15.</span> <span class="toc-text">lab6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cap7%EF%BC%9Ax64windows%E8%B0%83%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number">16.</span> <span class="toc-text">cap7：x64windows调试机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#windows%E8%B0%83%E8%AF%95%E4%BD%93%E7%B3%BB"><span class="toc-number">16.1.</span> <span class="toc-text">windows调试体系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-number">16.1.1.</span> <span class="toc-text">调试对象的建立</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#debugactiveprocess"><span class="toc-number">16.1.1.1.</span> <span class="toc-text">debugactiveprocess</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dbguiconnecttodbg"><span class="toc-number">16.1.1.2.</span> <span class="toc-text">dbguiconnecttodbg</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#nt-ntcreatedebugobject"><span class="toc-number">16.1.1.3.</span> <span class="toc-text">nt!ntcreatedebugobject</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%AF%B9%E8%B1%A1%E6%8C%82%E5%85%A5%E8%A2%AB%E8%B0%83%E8%AF%95%E8%BF%9B%E7%A8%8B"><span class="toc-number">16.1.2.</span> <span class="toc-text">调试对象挂入被调试进程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#nt-ntdebugactiveprocess"><span class="toc-number">16.1.2.1.</span> <span class="toc-text">nt!ntdebugactiveprocess</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E5%81%87%E6%B6%88%E6%81%AF"><span class="toc-number">16.1.3.</span> <span class="toc-text">发送假消息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#dbgkppostfakeprocesscreatemessages"><span class="toc-number">16.1.3.1.</span> <span class="toc-text">dbgkppostfakeprocesscreatemessages</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dbgkpqueuemessage"><span class="toc-number">16.1.3.2.</span> <span class="toc-text">dbgkpqueuemessage</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dbgkpsetprocessdebugobject"><span class="toc-number">16.1.3.3.</span> <span class="toc-text">dbgkpsetprocessdebugobject</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%99%A8%E7%AD%89%E5%BE%85"><span class="toc-number">16.2.</span> <span class="toc-text">调试器等待</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#waitfordebugevent"><span class="toc-number">16.2.1.</span> <span class="toc-text">waitfordebugevent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dbguiwaitstatechange"><span class="toc-number">16.2.2.</span> <span class="toc-text">dbguiwaitstatechange</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ntwaitfordebugevent"><span class="toc-number">16.2.2.1.</span> <span class="toc-text">ntwaitfordebugevent</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">16.3.</span> <span class="toc-text">事件处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ntdebugcontinue"><span class="toc-number">16.3.1.</span> <span class="toc-text">ntdebugcontinue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A2%AB%E8%B0%83%E8%AF%95%E8%BF%9B%E7%A8%8B%E6%B6%88%E6%81%AF%E9%87%87%E9%9B%86"><span class="toc-number">16.4.</span> <span class="toc-text">被调试进程消息采集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dbgkpqueuemessage-1"><span class="toc-number">16.4.1.</span> <span class="toc-text">dbgkpqueuemessage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E9%9B%86api"><span class="toc-number">16.4.2.</span> <span class="toc-text">收集api</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%83%E9%80%B8"><span class="toc-number">16.4.2.1.</span> <span class="toc-text">线程逃逸</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86"><span class="toc-number">16.5.</span> <span class="toc-text">调试原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#int3%E6%96%AD%E7%82%B9"><span class="toc-number">16.5.1.</span> <span class="toc-text">int3断点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#dbgkforwardexception"><span class="toc-number">16.5.1.1.</span> <span class="toc-text">dbgkforwardexception</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%AD%A5%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%96%AD%E7%82%B9"><span class="toc-number">16.5.2.</span> <span class="toc-text">单步与硬件断点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%96%AD%E7%82%B9"><span class="toc-number">16.5.3.</span> <span class="toc-text">内存断点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab7"><span class="toc-number">17.</span> <span class="toc-text">lab7</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lab7%EF%BC%9A%E8%B0%83%E8%AF%95%E5%BE%AA%E7%8E%AF"><span class="toc-number">17.1.</span> <span class="toc-text">lab7：调试循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cap8%EF%BC%9A%E5%82%80%E5%84%A1%E5%8F%A5%E6%9F%84%E6%97%A0%E9%A9%B1%E8%AF%BB%E5%86%99"><span class="toc-number">18.</span> <span class="toc-text">cap8：傀儡句柄无驱读写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%8E%9F%E7%90%86"><span class="toc-number">18.1.</span> <span class="toc-text">读写原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">18.2.</span> <span class="toc-text">注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E9%AB%98%E6%A3%80%E6%B5%8B%E9%9A%BE%E5%BA%A6"><span class="toc-number">18.2.1.</span> <span class="toc-text">提高检测难度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%85%E9%A1%BB%E6%89%BE%E5%88%B0%E5%90%88%E9%80%82%E7%9A%84TypeIndex"><span class="toc-number">18.2.2.</span> <span class="toc-text">必须找到合适的TypeIndex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%85%E9%A1%BB%E6%9B%BF%E6%8D%A2VAD"><span class="toc-number">18.2.3.</span> <span class="toc-text">必须替换VAD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%A8%A1%E5%9D%97"><span class="toc-number">18.2.4.</span> <span class="toc-text">如何获取模块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">18.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab8"><span class="toc-number">19.</span> <span class="toc-text">lab8</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cap9%EF%BC%9A%E5%82%80%E5%84%A1%E6%A8%A1%E5%9D%97%E6%97%A0%E7%97%95hook"><span class="toc-number">20.</span> <span class="toc-text">cap9：傀儡模块无痕hook</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HOOK-%E5%8E%9F%E7%90%86"><span class="toc-number">20.1.</span> <span class="toc-text">HOOK 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%9C%80%E8%A6%81%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">20.2.</span> <span class="toc-text">为什么不需要重定位</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x86"><span class="toc-number">20.2.1.</span> <span class="toc-text">x86</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x64"><span class="toc-number">20.2.2.</span> <span class="toc-text">x64</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A4%E6%96%B9%E6%B3%95%E7%9A%84%E7%BC%BA%E9%99%B7%E4%B8%8E%E5%B1%95%E6%9C%9B"><span class="toc-number">20.3.</span> <span class="toc-text">此方法的缺陷与展望</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7"><span class="toc-number">20.3.1.</span> <span class="toc-text">缺陷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%95%E6%9C%9B%E5%92%8C%E8%A7%A3%E5%86%B3"><span class="toc-number">20.3.2.</span> <span class="toc-text">展望和解决</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">20.4.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab9"><span class="toc-number">21.</span> <span class="toc-text">lab9</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/18/%E7%AE%97%E6%B3%95/" title="算法">算法</a><time datetime="2026-01-18T21:52:00.000Z" title="发表于 2026-01-18 21:52:00">2026-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/17/%E6%A5%A0%E5%AF%BB%E7%9C%BC%E4%B8%AD%E7%9A%84%E7%94%B7%E9%A2%91/" title="楠寻眼中的男频">楠寻眼中的男频</a><time datetime="2026-01-17T17:52:00.000Z" title="发表于 2026-01-17 17:52:00">2026-01-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/14/%E6%A5%A0%E5%AF%BB%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%A5%B3%E9%A2%91/" title="楠寻眼中的女频">楠寻眼中的女频</a><time datetime="2026-01-14T12:52:00.000Z" title="发表于 2026-01-14 12:52:00">2026-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/14/%E6%A5%A0%E5%AF%BB%E7%9C%BC%E4%B8%AD%E7%9A%84%E7%9F%AD%E5%89%A7/" title="楠寻眼中的短剧">楠寻眼中的短剧</a><time datetime="2026-01-14T12:52:00.000Z" title="发表于 2026-01-14 12:52:00">2026-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/05/ace/" title="ace">ace</a><time datetime="2026-01-05T04:00:00.000Z" title="发表于 2026-01-05 04:00:00">2026-01-05</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2026 By 楠寻njmxye</div><div class="footer_custom_text"><a href="https://icp.gov.moe/?keyword=20252779" target="_blank">萌ICP备20252779号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: '',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><div><div class="aplayer aplayer-tag-marker aplayer-withlrc aplayer-withlist aplayer-arrow" id="aplayer-VbASGHkA" style="margin-bottom:20px"><script>var options = {"narrow":false,"autoplay":true,"mode":"random","order":"random","mutex":true,"fixed":"true","theme":"#e6d0b2","preload":"metadata","listmaxheight":"200px","volume":0.06,"music":[{"title":"难断","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/难断.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"吹灭小山河","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/吹灭小山河.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"3 Strikes","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/3%20Strikes.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"ALL MY PEOPLE","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/ALL%20MY%20PEOPLE.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"After The Wind","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/After%20The%20Wind.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"All For Love","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/All%20For%20Love.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Baby love you","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Baby%20love%20you.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Constant Moderato","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Constant%20Moderato.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Dancing With Your Ghost","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Dancing%20With%20Your%20Ghost.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Daylight","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Daylight.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Different Lives (Explicit)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Different%20Lives%20(Explicit).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Dreamer","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Dreamer.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Drown (feat. Clinton Kane)(Alle Farben Remix)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Drown%20(feat.%20Clinton%20Kane)(Alle%20Farben%20Remix).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Fearless Pt. II","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Fearless%20Pt.%20II.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Fractures","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Fractures.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Home (Radio Edit)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Home%20(Radio%20Edit).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Lose Control","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Lose%20Control.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"MONTAGEM XONADA","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/MONTAGEM%20XONADA.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Meant To Be","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Meant%20To%20Be.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Minor Forever","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Minor%20Forever.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Montagem Nada Tropica","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Montagem%20Nada%20Tropica.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Power","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Power.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Sacred Play Secret Place","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Sacred%20Play%20Secret%20Place.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Save Me","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Save%20Me.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Secret Labs","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Secret%20Labs.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Taped Up Heart (feat. Clara Mae)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Taped%20Up%20Heart%20(feat.%20Clara%20Mae).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"The Hills (Slap House Mix)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/The%20Hills%20(Slap%20House%20Mix).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"WHOOPTY (Remix)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/WHOOPTY%20(Remix).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"aLIEz","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/aLIEz.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"おはなばたけ","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/おはなばたけ.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"三拜红尘凉","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/三拜红尘凉.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"不是相思是离别","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/不是相思是离别.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"东南西北中","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/东南西北中.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"乘风游","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/乘风游.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"人间惊鸿宴","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/人间惊鸿宴.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"人间烟火","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/人间烟火.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"今世债","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/今世债.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"他乡的月亮","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/他乡的月亮.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"伴你成长","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/伴你成长.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"你的答案","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/你的答案.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"使一颗心免于哀伤","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/使一颗心免于哀伤.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"关山酒 (DJ版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/关山酒%20(DJ版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"关山酒","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/关山酒.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"其实都没有","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/其实都没有.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"冬眠","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/冬眠.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"冬眠·2023","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/冬眠·2023.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"别回头","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/别回头.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"半入清风半入喉","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/半入清风半入喉.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"半生雪","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/半生雪.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"半生风雪","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/半生风雪.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"厚颜无耻","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/厚颜无耻.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"叹云兮","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/叹云兮.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"叹人间","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/叹人间.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"同进退","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/同进退.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"听花","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/听花.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"唯一","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/唯一.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"壁上观","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/壁上观.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"大笑人间","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/大笑人间.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"天亮以前说再见","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/天亮以前说再见.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"妈妈的话","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/妈妈的话.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"姑娘别哭泣","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/姑娘别哭泣.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"姑娘在远方","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/姑娘在远方.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"孤城","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/孤城.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"安和桥","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/安和桥.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"室内系的TrackMaker","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/室内系的TrackMaker.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"寄明月","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/寄明月.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"年轮","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/年轮.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"归途有风","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/归途有风.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"待我踏过彼岸花 (DJ版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/待我踏过彼岸花%20(DJ版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"御龙定乾坤","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/御龙定乾坤.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"循风","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/循风.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"忘川彼岸 (DJ名龙版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/忘川彼岸%20(DJ名龙版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"念","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/念.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"思念绕指尖 (DJ名龙版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/思念绕指尖%20(DJ名龙版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"恋愛サーキュレーション","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/恋愛サーキュレーション.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"想你时风起","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/想你时风起.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"愿与愁","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/愿与愁.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"折芙蓉","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/折芙蓉.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"折风渡夜 (DJ名龙版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/折风渡夜%20(DJ名龙版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"捂住耳朵 (DJ版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/捂住耳朵%20(DJ版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"提笔问飞花","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/提笔问飞花.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"旧梦一场","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/旧梦一场.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"时光背面的我","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/时光背面的我.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"明月不照离别人","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/明月不照离别人.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"明月天涯","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/明月天涯.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"星光就在前方","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/星光就在前方.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"星月落","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/星月落.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"春分","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/春分.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"月华落","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/月华落.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"月色倒映在西湖","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/月色倒映在西湖.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"本日は晴天なり","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/本日は晴天なり.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"梦中客","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/梦中客.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"江南烟雨色","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/江南烟雨色.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"江湖之间","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/江湖之间.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"江湖之间·2025","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/江湖之间·2025.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"沈园外","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/沈园外.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"没有意外","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/没有意外.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"沦陷 (DJ阿幻版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/沦陷%20(DJ阿幻版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"洛南·仓颉颂","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/洛南·仓颉颂.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"海市蜃楼","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/海市蜃楼.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"游京 (燃情版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/游京%20(燃情版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"潮汐","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/潮汐.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"燕无歇","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/燕无歇.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"爱是无畏的冒险","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/爱是无畏的冒险.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"牵丝戏 (DJ亚明版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/牵丝戏%20(DJ亚明版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"画离弦","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/画离弦.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"盐渍月亮 Salty Moon","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/盐渍月亮%20Salty%20Moon.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"盗墓笔记·十年人间","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/盗墓笔记·十年人间.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"知我","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/知我.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"破茧","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/破茧.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"破阵舞","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/破阵舞.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"离人殇","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/离人殇.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"离人赋 (治愈版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/离人赋%20(治愈版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"离别开出花","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/离别开出花.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"笔下江湖","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/笔下江湖.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"红尘回眸","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/红尘回眸.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"纵此生","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/纵此生.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"纸上风雅","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/纸上风雅.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"芒种","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/芒种.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"花开花谢花又飞","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/花开花谢花又飞.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"若月亮没来 (DJ铁柱版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/若月亮没来%20(DJ铁柱版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"若月亮没来","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/若月亮没来.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"荒","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/荒.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"莫问归期","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/莫问归期.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"落","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/落.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"诛神诀 (DJ R7版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/诛神诀%20(DJ%20R7版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"谁家","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/谁家.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"赐我","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/赐我.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"赤伶","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/赤伶.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"跳楼机","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/跳楼机.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"踏山河","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/踏山河.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"辞·九门回忆","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/辞·九门回忆.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"过此生","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/过此生.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"速度与坚果 Fast & Furynuts","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/速度与坚果%20Fast%20&%20Furynuts.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"遗失的心跳","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/遗失的心跳.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"邀","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/邀.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"酒家解相思","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/酒家解相思.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"醉春风 (DJ版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/醉春风%20(DJ版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"长安姑娘","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/长安姑娘.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"难却","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/难却.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"难得真兄弟","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/难得真兄弟.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"难断","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/难断.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"雾里","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/雾里.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"风催雨","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/风催雨.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"飘浮","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/飘浮.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"飞鸟和蝉","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/飞鸟和蝉.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"马步谣","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/马步谣.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"鸳鸯戏","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/鸳鸯戏.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"龙游万里","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/龙游万里.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"}]};options.element = document.getElementById("aplayer-VbASGHkA");var ap = new APlayer(options);window.aplayers || (window.aplayers = []);window.aplayers.push(ap)</script></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":false},"rect":"opacity:0.7","log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>