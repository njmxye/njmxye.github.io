<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>算法 | 楠 寻 の 小 窝</title><meta name="author" content="楠寻njmxye"><meta name="copyright" content="楠寻njmxye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="栈和队列设计一个有 getMin 功能的栈题目实现一个特殊的栈，在基本功能基础上实现返回栈中最小元素的操作。 要求  pop、push、getMin 操作的时间复杂度都是 O(1)。 设计的栈类型可以使用现成的栈结构。  解答我们在设计时，使用两个栈：  stackData：用来保存当前栈中的元素，功能和正常栈没区别。 stackMin：用于保存每一步的最小值。  方案一：压入时省空间，弹出时费时">
<meta property="og:type" content="article">
<meta property="og:title" content="算法">
<meta property="og:url" content="https://njmxye.de5.net/2026/01/18/%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="楠 寻 の 小 窝">
<meta property="og:description" content="栈和队列设计一个有 getMin 功能的栈题目实现一个特殊的栈，在基本功能基础上实现返回栈中最小元素的操作。 要求  pop、push、getMin 操作的时间复杂度都是 O(1)。 设计的栈类型可以使用现成的栈结构。  解答我们在设计时，使用两个栈：  stackData：用来保存当前栈中的元素，功能和正常栈没区别。 stackMin：用于保存每一步的最小值。  方案一：压入时省空间，弹出时费时">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg">
<meta property="article:published_time" content="2026-01-18T21:52:00.000Z">
<meta property="article:modified_time" content="2026-02-09T13:35:41.296Z">
<meta property="article:author" content="楠寻njmxye">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"><link rel="shortcut icon" href="https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/favicon.png"><link rel="canonical" href="https://njmxye.de5.net/2026/01/18/%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="cWyLZN3gSLDdjz3lqJl60UiBZnrX1fPVfGqm_rELJZA"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2026-02-09 13:35:41'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"><link rel="stylesheet" href="/assets/css/APlayer.min.css" class="aplayer-style-marker">
<script src="/assets/js/APlayer.min.js" class="aplayer-script-marker"></script>
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.helloimg.com/i/2024/12/20/6764f5f231582.png')"><nav id="nav"><span id="blog-info"><a href="/" title="楠 寻 の 小 窝"><span class="site-name">楠 寻 の 小 窝</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-01-18T21:52:00.000Z" title="发表于 2026-01-18 21:52:00">2026-01-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-02-09T13:35:41.296Z" title="更新于 2026-02-09 13:35:41">2026-02-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">101.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>401分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="设计一个有-getMin-功能的栈"><a href="#设计一个有-getMin-功能的栈" class="headerlink" title="设计一个有 getMin 功能的栈"></a>设计一个有 getMin 功能的栈</h2><p><strong>题目</strong><br>实现一个特殊的栈，在基本功能基础上实现返回栈中最小元素的操作。</p>
<p><strong>要求</strong></p>
<ol>
<li><code>pop</code>、<code>push</code>、<code>getMin</code> 操作的时间复杂度都是 O(1)。</li>
<li>设计的栈类型可以使用现成的栈结构。</li>
</ol>
<p><strong>解答</strong><br>我们在设计时，使用两个栈：</p>
<ul>
<li><code>stackData</code>：用来保存当前栈中的元素，功能和正常栈没区别。</li>
<li><code>stackMin</code>：用于保存每一步的最小值。</li>
</ul>
<p><strong>方案一：压入时省空间，弹出时费时间</strong></p>
<ul>
<li><strong>压入规则</strong>：<ol>
<li><code>stackData</code> 压入 <code>newNum</code>。</li>
<li>若 <code>stackMin</code> 为空，则 <code>newNum</code> 也压入 <code>stackMin</code>。</li>
<li>若 <code>stackMin</code> 不为空，比较 <code>newNum</code> 和 <code>stackMin</code> 栈顶：<ul>
<li>若 <code>newNum &lt;= stackMin</code> 栈顶，则 <code>newNum</code> 也压入 <code>stackMin</code>。</li>
<li>若 <code>newNum &gt; stackMin</code> 栈顶，<code>stackMin</code> 不压入任何内容。</li>
</ul>
</li>
</ol>
</li>
<li><strong>弹出规则</strong>：<ol>
<li><code>stackData</code> 弹出 <code>value</code>。</li>
<li>若 <code>value == stackMin</code> 栈顶，则 <code>stackMin</code> 弹出。</li>
</ol>
</li>
<li><strong>查询规则</strong>：<ul>
<li><code>stackMin</code> 始终记录着 <code>stackData</code> 中的最小值，直接返回 <code>stackMin</code> 栈顶。</li>
</ul>
</li>
</ul>
<p><strong>方案一代码 (Java)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackData;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackMin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stackData = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="built_in">this</span>.stackMin = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> newNum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.stackMin.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.stackMin.push(newNum);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNum &lt;= <span class="built_in">this</span>.getmin()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.stackMin.push(newNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.stackData.push(newNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.stackData.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Your stack is empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.stackData.pop();</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="built_in">this</span>.getmin()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.stackMin.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getmin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.stackMin.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Your stack is empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.stackMin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>方案二：压入时费空间，弹出时省时间</strong></p>
<ul>
<li><strong>压入规则</strong>：<ol>
<li><code>stackData</code> 压入 <code>newNum</code>。</li>
<li>若 <code>stackMin</code> 为空，则 <code>newNum</code> 也压入 <code>stackMin</code>。</li>
<li>若 <code>stackMin</code> 不为空，比较 <code>newNum</code> 和 <code>stackMin</code> 栈顶：<ul>
<li>若 <code>newNum &lt; stackMin</code> 栈顶，则 <code>newNum</code> 压入 <code>stackMin</code>。</li>
<li>若 <code>newNum &gt;= stackMin</code> 栈顶，则重复压入 <code>stackMin</code> 的栈顶元素。</li>
</ul>
</li>
</ol>
</li>
<li><strong>弹出规则</strong>：<ul>
<li><code>stackData</code> 和 <code>stackMin</code> 同步弹出，总是对应关系。</li>
</ul>
</li>
<li><strong>查询规则</strong>：<ul>
<li>同方案一，直接返回 <code>stackMin</code> 栈顶。</li>
</ul>
</li>
</ul>
<p><strong>方案二代码 (Java)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackData;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackMin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stackData = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="built_in">this</span>.stackMin = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> newNum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.stackMin.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.stackMin.push(newNum);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNum &lt; <span class="built_in">this</span>.getmin()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.stackMin.push(newNum);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newMin</span> <span class="operator">=</span> <span class="built_in">this</span>.stackMin.peek();</span><br><span class="line">            <span class="built_in">this</span>.stackMin.push(newMin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.stackData.push(newNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.stackData.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Your stack is empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.stackMin.pop();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.stackData.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getmin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.stackMin.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Your stack is empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.stackMin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>方案对比</strong></p>
<ul>
<li><strong>共同点</strong>：时间复杂度都是 O(1)，空间复杂度都是 O(n)。</li>
<li><strong>区别</strong>：<ul>
<li>方案一：<code>stackMin</code> 压入时稍省空间，弹出时稍费时间（需要判断）。</li>
<li>方案二：<code>stackMin</code> 压入时稍费空间（重复压入），弹出时稍省时间（直接弹出）。</li>
</ul>
</li>
</ul>
<h2 id="由两个栈组成的队列"><a href="#由两个栈组成的队列" class="headerlink" title="由两个栈组成的队列"></a>由两个栈组成的队列</h2><p><strong>题目</strong><br>编写一个类，用两个栈实现队列，支持队列的基本操作（<code>add</code>、<code>poll</code>、<code>peek</code>）。</p>
<p><strong>解答</strong><br>利用栈的“先进后出”特性，使用两个栈来实现队列的“先进先出”：</p>
<ul>
<li><code>stackPush</code>：负责压入数据。</li>
<li><code>stackPop</code>：负责弹出数据。</li>
</ul>
<p><strong>核心注意事项</strong><br>数据从 <code>stackPush</code> 压入 <code>stackPop</code> 时，必须严格遵守以下两点，否则顺序会乱：</p>
<ol>
<li><strong>必须一次性压入</strong>：<code>stackPush</code> 要倒数据，必须把所有数据一次性倒入 <code>stackPop</code>。</li>
<li><strong>stackPop 为空</strong>：只有当 <code>stackPop</code> 为空时，才能往里倒数据。</li>
</ol>
<p><strong>代码实现 (Java)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoStacksQueue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; stackPush;</span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; stackPop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TwoStacksQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stackPush = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">        stackPop = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 倒数据 helper 函数：仅当 stackPop 为空时，将 stackPush 所有数据倒入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushToPop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stackPop.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stackPush.empty()) &#123;</span><br><span class="line">                stackPop.push(stackPush.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> pushInt)</span> &#123;</span><br><span class="line">        stackPush.push(pushInt);</span><br><span class="line">        pushToPop(); <span class="comment">// 每次 add 尝试倒数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Queue is empty!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pushToPop(); <span class="comment">// 尝试倒数据，确保 stackPop 有数据可弹</span></span><br><span class="line">        <span class="keyword">return</span> stackPop.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Queue is empty!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pushToPop(); <span class="comment">// 尝试倒数据</span></span><br><span class="line">        <span class="keyword">return</span> stackPop.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="如何仅用递归函数和栈操作逆序一个栈"><a href="#如何仅用递归函数和栈操作逆序一个栈" class="headerlink" title="如何仅用递归函数和栈操作逆序一个栈"></a>如何仅用递归函数和栈操作逆序一个栈</h2><p><strong>题目</strong><br>实现一个栈的逆序，将栈顶到栈底元素 (e.g., 1, 2, 3) 反转为 (3, 2, 1)。</p>
<p><strong>要求</strong></p>
<ol>
<li>只能使用递归函数和栈操作。</li>
<li><strong>不能</strong>使用其他数据结构（如列表、数组等）。</li>
</ol>
<p><strong>解答</strong><br>设计两个递归函数来解决：</p>
<ol>
<li><code>getAndRemoveLastElement</code>：<strong>移除并返回</strong>当前栈底元素。<ul>
<li>利用递归一直向下直至栈底，取出元素后，再将上层元素重新压回。</li>
</ul>
</li>
<li><code>reverse</code>：逆序整个栈。<ul>
<li>利用 <code>getAndRemoveLastElement</code> 拿到栈底元素 <code>i</code>。</li>
<li>递归调用 <code>reverse</code> 处理剩余栈。</li>
<li>最后将 <code>i</code> 压入栈顶。</li>
</ul>
</li>
</ol>
<p><strong>代码实现 (Java)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackReverse</span> &#123;</span><br><span class="line">    <span class="comment">// 递归函数一：移除并返回栈底元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getAndRemoveLastElement</span><span class="params">(Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> getAndRemoveLastElement(stack);</span><br><span class="line">            stack.push(result);</span><br><span class="line">            <span class="keyword">return</span> last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归函数二：逆序栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> getAndRemoveLastElement(stack);</span><br><span class="line">        reverse(stack);</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="猫狗队列"><a href="#猫狗队列" class="headerlink" title="猫狗队列"></a>猫狗队列</h2><p><strong>题目</strong><br>实现一种猫狗队列结构，支持以下操作：</p>
<ul>
<li><code>add</code>：将 <code>Cat</code> 或 <code>Dog</code> 放入队列。</li>
<li><code>pollAll</code>：按进队列的先后顺序弹出所有实例。</li>
<li><code>pollDog</code> / <code>pollCat</code>：分别只弹出 <code>Dog</code> 或 <code>Cat</code> 实例（也要按顺序）。</li>
<li><code>isEmpty</code> / <code>isDogEmpty</code> / <code>isCatEmpty</code>：判空。</li>
</ul>
<p><strong>基础类 (给定)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> &#123; <span class="keyword">private</span> String type; <span class="keyword">public</span> <span class="title function_">Pet</span><span class="params">(String type)</span> &#123; <span class="built_in">this</span>.type = type; &#125; <span class="keyword">public</span> String <span class="title function_">getPetType</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.type; &#125; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123; <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123; <span class="built_in">super</span>(<span class="string">&quot;dog&quot;</span>); &#125; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123; <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span> &#123; <span class="built_in">super</span>(<span class="string">&quot;cat&quot;</span>); &#125; &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>解答</strong><br><strong>核心难点</strong>：<code>Dog</code> 和 <code>Cat</code> 是不同类，不能直接混放在一个队列里（否则难以单独 <code>pollDog</code>/<code>pollCat</code>），分开存又会丢失“谁先谁后”的时间顺序。</p>
<p><strong>设计方案</strong>：</p>
<ol>
<li><strong>Wrapper 类</strong>：定义一个新的类 <code>PetEnterQueue</code>，将 <code>Pet</code> 对象和“时间戳”（<code>count</code>）封装在一起。</li>
<li><strong>双队列</strong>：内部维护两个队列 <code>dogQ</code> 和 <code>catQ</code>。</li>
<li><strong>全局计数器</strong>：用一个全局 <code>count</code> 变量，每次 <code>add</code> 时自增，标记进队顺序。</li>
<li><strong>出队逻辑</strong>：<ul>
<li><code>pollDog</code>/<code>pollCat</code>：直接从对应的队列弹出。</li>
<li><code>pollAll</code>：比较 <code>dogQ</code> 和 <code>catQ</code> 队头的 <code>count</code>，谁小（更早进入）谁先出。</li>
</ul>
</li>
</ol>
<p><strong>代码实现 (Java)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包装类：给 Pet 加上时间戳</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PetEnterQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PetEnterQueue</span><span class="params">(Pet pet, <span class="type">long</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pet = pet;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Pet <span class="title function_">getPet</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.pet; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCount</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.count; &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEnterPetType</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.pet.getPetType(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogCatQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;PetEnterQueue&gt; dogQ;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;PetEnterQueue&gt; catQ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DogCatQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dogQ = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;PetEnterQueue&gt;();</span><br><span class="line">        <span class="built_in">this</span>.catQ = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;PetEnterQueue&gt;();</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Pet pet)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pet.getPetType().equals(<span class="string">&quot;dog&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.dogQ.add(<span class="keyword">new</span> <span class="title class_">PetEnterQueue</span>(pet, <span class="built_in">this</span>.count++));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pet.getPetType().equals(<span class="string">&quot;cat&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.catQ.add(<span class="keyword">new</span> <span class="title class_">PetEnterQueue</span>(pet, <span class="built_in">this</span>.count++));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;err, not dog or cat&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Pet <span class="title function_">pollAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.dogQ.isEmpty() &amp;&amp; !<span class="built_in">this</span>.catQ.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.dogQ.peek().getCount() &lt; <span class="built_in">this</span>.catQ.peek().getCount()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.dogQ.poll().getPet();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.catQ.poll().getPet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.dogQ.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.dogQ.poll().getPet();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.catQ.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.catQ.poll().getPet();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;err, queue is empty!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Dog <span class="title function_">pollDog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.isDogQueueEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Dog) <span class="built_in">this</span>.dogQ.poll().getPet();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Dog queue is empty!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Cat <span class="title function_">pollCat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.isCatQueueEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Cat) <span class="built_in">this</span>.catQ.poll().getPet();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Cat queue is empty!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.dogQ.isEmpty() &amp;&amp; <span class="built_in">this</span>.catQ.isEmpty(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDogQueueEmpty</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.dogQ.isEmpty(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCatQueueEmpty</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.catQ.isEmpty(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用一个栈实现另一个栈的排序"><a href="#用一个栈实现另一个栈的排序" class="headerlink" title="用一个栈实现另一个栈的排序"></a>用一个栈实现另一个栈的排序</h2><p><strong>题目</strong><br>将一个栈中的元素从顶到底按“从大到小”的顺序排序（即栈顶最大）。</p>
<p><strong>要求</strong></p>
<ol>
<li>只允许申请一个辅助栈。</li>
<li>可以申请新的变量，但不能使用其他数据结构（如数组）。</li>
</ol>
<p><strong>解答</strong><br>使用一个辅助栈 <code>help</code>。</p>
<ol>
<li>从原栈 <code>stack</code> 中弹出一个元素 <code>cur</code>。</li>
<li>如果 <code>cur</code> 小于或等于 <code>help</code> 的栈顶元素，直接压入 <code>help</code>。</li>
<li>如果 <code>cur</code> 大于 <code>help</code> 的栈顶元素，则将 <code>help</code> 的元素逐一弹出并压回 <code>stack</code>，直到 <code>cur</code> 小于或等于 <code>help</code> 栈顶（或 <code>help</code> 为空），再将 <code>cur</code> 压入 <code>help</code>。</li>
<li>重复上述过程直到 <code>stack</code> 为空。</li>
<li>最后将 <code>help</code> 中的所有元素压回 <code>stack</code>，此时 <code>stack</code> 即为从大到小排序。</li>
</ol>
<p><strong>代码实现 (Java)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sortStackByStack</span><span class="params">(Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; help = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="comment">// 如果 cur 比 help 栈顶大，说明 cur 应该在更下面</span></span><br><span class="line">        <span class="comment">// 把 help 中小的元素倒回 stack，为 cur 腾出位置</span></span><br><span class="line">        <span class="keyword">while</span> (!help.isEmpty() &amp;&amp; help.peek() &lt; cur) &#123;</span><br><span class="line">            stack.push(help.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        help.push(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// help 中现在是从小到大（栈顶最小），倒回 stack 变成从大到小</span></span><br><span class="line">    <span class="keyword">while</span> (!help.isEmpty()) &#123;</span><br><span class="line">        stack.push(help.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="用栈来求解汉诺塔问题"><a href="#用栈来求解汉诺塔问题" class="headerlink" title="用栈来求解汉诺塔问题"></a>用栈来求解汉诺塔问题</h2><p><strong>题目</strong><br>汉诺塔问题（修改版）：限制不能从最左侧(Left)直接移动到最右侧(Right)，也不能反之，必须经过中间(Mid)。求N层汉诺塔从Left移动到Right的最优移动过程和总步数。</p>
<p><strong>要求</strong></p>
<ol>
<li>方法一：递归。</li>
<li>方法二：非递归，用栈模拟。</li>
</ol>
<p><strong>方法一：递归</strong></p>
<ul>
<li><strong>核心逻辑</strong>：<ul>
<li>由于必须经过中间，移动动作减少为4种：<code>L-&gt;M</code>, <code>M-&gt;L</code>, <code>M-&gt;R</code>, <code>R-&gt;M</code>。</li>
<li><strong>相邻移动</strong>（如 <code>L-&gt;M</code>）：<ol>
<li>1~N-1 层 <code>L -&gt; R</code> (递归)</li>
<li>N 层 <code>L -&gt; M</code></li>
<li>1~N-1 层 <code>R -&gt; M</code> (递归)</li>
</ol>
</li>
<li><strong>跨越移动</strong>（如 <code>L -&gt; R</code>）：<ol>
<li>1~N-1 层 <code>L -&gt; R</code> (递归)</li>
<li>N 层 <code>L -&gt; M</code></li>
<li>1~N-1 层 <code>R -&gt; L</code> (递归)</li>
<li>N 层 <code>M -&gt; R</code></li>
<li>1~N-1 层 <code>L -&gt; R</code> (递归)</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>代码实现 (Recursive)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HanoiRecursive</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hanoiProblem1</span><span class="params">(<span class="type">int</span> num, String left, String mid, String right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> process(num, left, mid, right, left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> num, String left, String mid, String right, String from, String to)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (from.equals(mid) || to.equals(mid)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Move 1 from &quot;</span> + from + <span class="string">&quot; to &quot;</span> + to);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Move 1 from &quot;</span> + from + <span class="string">&quot; to &quot;</span> + mid);</span><br><span class="line">                System.out.println(<span class="string">&quot;Move 1 from &quot;</span> + mid + <span class="string">&quot; to &quot;</span> + to);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (from.equals(mid) || to.equals(mid)) &#123; <span class="comment">// 相邻移动</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">another</span> <span class="operator">=</span> (from.equals(left) || to.equals(left)) ? right : left;</span><br><span class="line">            <span class="type">int</span> <span class="variable">part1</span> <span class="operator">=</span> process(num - <span class="number">1</span>, left, mid, right, from, another);</span><br><span class="line">            <span class="type">int</span> <span class="variable">part2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;Move &quot;</span> + num + <span class="string">&quot; from &quot;</span> + from + <span class="string">&quot; to &quot;</span> + to);</span><br><span class="line">            <span class="type">int</span> <span class="variable">part3</span> <span class="operator">=</span> process(num - <span class="number">1</span>, left, mid, right, another, to);</span><br><span class="line">            <span class="keyword">return</span> part1 + part2 + part3;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 跨越移动</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">part1</span> <span class="operator">=</span> process(num - <span class="number">1</span>, left, mid, right, from, to);</span><br><span class="line">            <span class="type">int</span> <span class="variable">part2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;Move &quot;</span> + num + <span class="string">&quot; from &quot;</span> + from + <span class="string">&quot; to &quot;</span> + mid);</span><br><span class="line">            <span class="type">int</span> <span class="variable">part3</span> <span class="operator">=</span> process(num - <span class="number">1</span>, left, mid, right, to, from);</span><br><span class="line">            <span class="type">int</span> <span class="variable">part4</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;Move &quot;</span> + num + <span class="string">&quot; from &quot;</span> + mid + <span class="string">&quot; to &quot;</span> + to);</span><br><span class="line">            <span class="type">int</span> <span class="variable">part5</span> <span class="operator">=</span> process(num - <span class="number">1</span>, left, mid, right, from, to);</span><br><span class="line">            <span class="keyword">return</span> part1 + part2 + part3 + part4 + part5;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>方法二：非递归 (栈模拟)</strong></p>
<ul>
<li><strong>核心原则</strong>：<ol>
<li><strong>小压大</strong>：移动必须满足小盘压大盘。</li>
<li><strong>相邻不可逆</strong>：如果上一步是 <code>L-&gt;M</code>，这一步绝不能是 <code>M-&gt;L</code>（反之亦然）。</li>
</ol>
</li>
<li><strong>结论</strong>：根据这两个原则，每一步实际上只有唯一的合法移动（除了第一步，第一步显然是最小盘 <code>L-&gt;M</code>）。</li>
<li><strong>实现</strong>：使用三个栈 (<code>lS</code>, <code>mS</code>, <code>rS</code>) 模拟三个塔，记录上一步动作，循环执行直到完成。</li>
</ul>
<p><strong>代码实现 (Stack)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HanoiStack</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Action</span> &#123; No, LToM, MToL, MToR, RToM &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hanoiProblem2</span><span class="params">(<span class="type">int</span> num, String left, String mid, String right)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; lS = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; mS = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; rS = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        lS.push(Integer.MAX_VALUE);</span><br><span class="line">        mS.push(Integer.MAX_VALUE);</span><br><span class="line">        rS.push(Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num; i &gt; <span class="number">0</span>; i--) &#123; lS.push(i); &#125;</span><br><span class="line">        </span><br><span class="line">        Action[] record = &#123; Action.No &#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (rS.size() != num + <span class="number">1</span>) &#123;</span><br><span class="line">            step += fStackTotStack(record, Action.MToL, Action.LToM, lS, mS, left, mid);</span><br><span class="line">            step += fStackTotStack(record, Action.LToM, Action.MToL, mS, lS, mid, left);</span><br><span class="line">            step += fStackTotStack(record, Action.RToM, Action.MToR, mS, rS, mid, right);</span><br><span class="line">            step += fStackTotStack(record, Action.MToR, Action.RToM, rS, mS, right, mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fStackTotStack</span><span class="params">(Action[] record, Action preNoAct, Action nowAct, </span></span><br><span class="line"><span class="params">                                     Stack&lt;Integer&gt; fStack, Stack&lt;Integer&gt; tStack, </span></span><br><span class="line"><span class="params">                                     String from, String to)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (record[<span class="number">0</span>] != preNoAct &amp;&amp; fStack.peek() &lt; tStack.peek()) &#123;</span><br><span class="line">            tStack.push(fStack.pop());</span><br><span class="line">            System.out.println(<span class="string">&quot;Move &quot;</span> + tStack.peek() + <span class="string">&quot; from &quot;</span> + from + <span class="string">&quot; to &quot;</span> + to);</span><br><span class="line">            record[<span class="number">0</span>] = nowAct;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="生成窗口最大值数组"><a href="#生成窗口最大值数组" class="headerlink" title="生成窗口最大值数组"></a>生成窗口最大值数组</h2><p><strong>题目</strong><br>有一个整型数组 <code>arr</code> 和一个大小为 <code>w</code> 的窗口从数组的最左边滑到最右边，窗口每次向右边滑一个位置。<br>如果数组长度为 <code>n</code>，窗口大小为 <code>w</code>，则一共产生 <code>n-w+1</code> 个窗口的最大值。<br>请实现一个函数。</p>
<ul>
<li>输入：整型数组 <code>arr</code>，窗口大小为 <code>w</code>。</li>
<li>输出：一个长度为 <code>n-w+1</code> 的数组 <code>res</code>，<code>res[i]</code> 表示每一种窗口状态下的最大值。</li>
</ul>
<p><strong>举例</strong><br>数组为 <code>[4,3,5,4,3,3,6,7]</code>，窗口大小为 <code>3</code> 时：<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[4 3 5] 4 3 3 6 7        窗口中最大值为 5</span><br><span class="line">4 [3 5 4] 3 3 6 7        窗口中最大值为 5</span><br><span class="line">4 3 [5 4 3] 3 6 7        窗口中最大值为 5</span><br><span class="line">4 3 5 [4 3 3] 6 7        窗口中最大值为 4</span><br><span class="line">4 3 5 4 [3 3 6] 7        窗口中最大值为 6</span><br><span class="line">4 3 5 4 3 [3 6 7]        窗口中最大值为 7</span><br></pre></td></tr></table></figure><br>结果应返回 <code>&#123;5,5,5,4,6,7&#125;</code>。</p>
<p><strong>解答</strong><br>假设数组长度为 <code>N</code>，窗口大小为 <code>w</code>。</p>
<ul>
<li><strong>暴力解法</strong>：遍历每个窗口，遍历窗口内元素求最大值，时间复杂度 <code>O(N*w)</code>。</li>
<li><strong>最优解法</strong>：使用<strong>双端队列 (Deque)</strong>，时间复杂度 <code>O(N)</code>。</li>
</ul>
<p><strong>双端队列 (<code>qmax</code>) 更新规则</strong>：<br><code>qmax</code> 存放数组 <code>arr</code> 中的<strong>下标</strong>。</p>
<ol>
<li><strong>放入规则</strong>：<ul>
<li>当遍历到 <code>arr[i]</code> 时，如果 <code>qmax</code> 为空，直接将 <code>i</code> 放入队尾。</li>
<li>如果 <code>qmax</code> 不为空，取出队尾下标 <code>j</code>。<ul>
<li>如果 <code>arr[j] &gt; arr[i]</code>，直接将 <code>i</code> 放入队尾。</li>
<li>如果 <code>arr[j] &lt;= arr[i]</code>，将 <code>j</code> 从队尾弹出，重复此过程，直到 <code>qmax</code> 为空或队尾对应值大于 <code>arr[i]</code>，然后将 <code>i</code> 放入队尾。</li>
</ul>
</li>
<li>(保证队列中下标对应的数值是从大到小的)</li>
</ul>
</li>
<li><strong>弹出规则</strong>：<ul>
<li>如果 <code>qmax</code> 队头的下标等于 <code>i - w</code>，说明队头下标已过期（滑出窗口），将其弹出。</li>
</ul>
</li>
<li><strong>记录结果</strong>：<ul>
<li>当 <code>i &gt;= w - 1</code> 时，窗口形成，<code>arr[qmax.peekFirst()]</code> 即为当前窗口的最大值。</li>
</ul>
</li>
</ol>
<p><strong>代码实现 (Java)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlidingWindowMax</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getMaxWindow(<span class="type">int</span>[] arr, <span class="type">int</span> w) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || w &lt; <span class="number">1</span> || arr.length &lt; w) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 双端队列，存放下标</span></span><br><span class="line">        LinkedList&lt;Integer&gt; qmax = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length - w + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 保证队列单调递减：如果当前值 &gt;= 队尾值，弹出队尾</span></span><br><span class="line">            <span class="keyword">while</span> (!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[i]) &#123;</span><br><span class="line">                qmax.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            qmax.addLast(i);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查队头是否过期</span></span><br><span class="line">            <span class="keyword">if</span> (qmax.peekFirst() == i - w) &#123;</span><br><span class="line">                qmax.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 记录当前窗口最大值</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= w - <span class="number">1</span>) &#123;</span><br><span class="line">                res[index++] = arr[qmax.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="单调栈结构"><a href="#单调栈结构" class="headerlink" title="单调栈结构"></a>单调栈结构</h2><p><strong>题目</strong><br>给定一个不含有重复值的数组 <code>arr</code>，找到每一个 <code>i</code> 位置左边和右边离 <code>i</code> 位置最近且值比 <code>arr[i]</code> 小的位置。返回所有位置相应的信息。</p>
<p><strong>进阶问题</strong><br>给定一个可能含有重复值的数组 <code>arr</code>，找到每一个 <code>i</code> 位置左边和右边离 <code>i</code> 位置最近且值比 <code>arr[i]</code> 小的位置。</p>
<p><strong>举例</strong><br><code>arr = &#123;3, 4, 1, 5, 6, 2, 7&#125;</code><br>返回结果如下（<code>res[i][0]</code> 为左边最近较小值下标，<code>res[i][1]</code> 为右边最近较小值下标，<code>-1</code> 表示不存在）：<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index: 0(3) -&gt; left: -1, right: 2(1)</span><br><span class="line">index: 1(4) -&gt; left: 0(3), right: 2(1)</span><br><span class="line">index: 2(1) -&gt; left: -1, right: -1</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p><strong>解答</strong></p>
<ul>
<li><strong>核心思想</strong>：使用<strong>单调栈</strong>，栈中存放数组下标，代表的值从栈底到栈顶<strong>严格递增</strong>。</li>
<li><strong>逻辑</strong>：<ol>
<li>遍历数组，当 <code>arr[i]</code> &gt; 栈顶代表的值时，直接入栈（保持递增）。</li>
<li>当 <code>arr[i]</code> &lt; 栈顶代表的值时，说明栈顶元素的<strong>右边最近较小值</strong>出现了（即 <code>i</code>）。<ul>
<li>弹出栈顶 <code>popIndex</code>。</li>
<li><strong>右边最近较小值</strong>：当前遍历到的 <code>i</code>。</li>
<li><strong>左边最近较小值</strong>：弹出后的新栈顶（如果栈为空则为 <code>-1</code>）。</li>
<li>重复直到栈顶 &lt;= <code>arr[i]</code> 或栈为空，将 <code>i</code> 入栈。</li>
</ul>
</li>
<li>遍历完成后，清算栈中剩余元素：<ul>
<li><strong>右边最近较小值</strong>：<code>-1</code>（不存在）。</li>
<li><strong>左边最近较小值</strong>：弹出后的新栈顶（如果栈为空则为 <code>-1</code>）。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>进阶（有重复值）</strong></p>
<ul>
<li>当 <code>arr[i] ==</code> 栈顶代表的值时，将下标合并在一起（栈存储 <code>List&lt;Integer&gt;</code> 或处理相等情况不弹出，等后面更小值出现时一起结算）。</li>
<li>通常做法是：栈中存储链表/列表 <code>List&lt;Integer&gt;</code>，代表值相同的一组下标。<ul>
<li>弹出时，列表中所有下标的<strong>右边最近较小值</strong>都是 <code>i</code>。</li>
<li>列表中所有下标的<strong>左边最近较小值</strong>都是栈中下一个列表的<strong>最后一个</strong>下标（即最晚加入的那个）。</li>
</ul>
</li>
</ul>
<p><strong>代码实现 (Java)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonotonousStack</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无重复值的情况</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] getNearLessNoRepeat(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length][<span class="number">2</span>];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 当当前值 &lt; 栈顶值，破坏了单调递增，开始结算栈顶</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek()] &gt; arr[i]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">popIndex</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">leftLessIndex</span> <span class="operator">=</span> stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">                res[popIndex][<span class="number">0</span>] = leftLessIndex;</span><br><span class="line">                res[popIndex][<span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清算剩余元素</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">popIndex</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftLessIndex</span> <span class="operator">=</span> stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            res[popIndex][<span class="number">0</span>] = leftLessIndex;</span><br><span class="line">            res[popIndex][<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有重复值的情况 (通用解法)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] getNearLess(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 栈中存放的是下标列表，同一列表中的下标代表的值相同</span></span><br><span class="line">        Stack&lt;List&lt;Integer&gt;&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek().get(<span class="number">0</span>)] &gt; arr[i]) &#123;</span><br><span class="line">                List&lt;Integer&gt; popIs = stack.pop();</span><br><span class="line">                <span class="comment">// 取位于下面位置的列表中，最晚加入的那个 -&gt; leftLessIndex</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">leftLessIndex</span> <span class="operator">=</span> stack.isEmpty() ? -<span class="number">1</span> : stack.peek().get(stack.peek().size() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span> (Integer popi : popIs) &#123;</span><br><span class="line">                    res[popi][<span class="number">0</span>] = leftLessIndex;</span><br><span class="line">                    res[popi][<span class="number">1</span>] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek().get(<span class="number">0</span>)] == arr[i]) &#123;</span><br><span class="line">                stack.peek().add(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                list.add(i);</span><br><span class="line">                stack.push(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; popIs = stack.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftLessIndex</span> <span class="operator">=</span> stack.isEmpty() ? -<span class="number">1</span> : stack.peek().get(stack.peek().size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (Integer popi : popIs) &#123;</span><br><span class="line">                res[popi][<span class="number">0</span>] = leftLessIndex;</span><br><span class="line">                res[popi][<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求最大子矩阵的大小"><a href="#求最大子矩阵的大小" class="headerlink" title="求最大子矩阵的大小"></a>求最大子矩阵的大小</h2><p><strong>题目</strong><br>给定一个整型矩阵 <code>map</code>，其中的值只有 0 和 1 两种，求其中全是 1 的所有矩形区域中，最大的矩形区域为 1 的数量。</p>
<p><strong>举例</strong><br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 1 0</span><br></pre></td></tr></table></figure><br>结果返回 3。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 0 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 0</span><br></pre></td></tr></table></figure>
<p>结果返回 6。</p>
<p><strong>解答</strong></p>
<ul>
<li><strong>时间复杂度</strong>：<code>O(N * M)</code>，其中 <code>N</code> 为行数，<code>M</code> 为列数。</li>
<li><strong>核心思路</strong>：将问题转化为<strong>求直方图中的最大矩形面积</strong>。<ol>
<li><strong>逐行切割</strong>：以每一行作为底，统计每个位置往上连续 1 的数量，形成一个高度数组 <code>height</code>。<ul>
<li>如果 <code>map[i][j] == 0</code>，则 <code>height[j] = 0</code>。</li>
<li>如果 <code>map[i][j] == 1</code>，则 <code>height[j] = 上一行height[j] + 1</code>。</li>
</ul>
</li>
<li><strong>计算最大面积</strong>：对于每一行的 <code>height</code> 数组（看作直方图），利用<strong>单调栈</strong>求解其中的最大矩形面积。<ul>
<li>对于直方图中的每一根柱子 <code>x</code>，找到其左边最近比它小的位置 <code>k</code>，和右边最近比它小的位置 <code>j</code>。</li>
<li>该柱子能扩展的最大面积 = <code>(j - k - 1) * height[x]</code>。</li>
</ul>
</li>
<li><strong>全局最大</strong>：每一行计算出的最大值中取最大。</li>
</ol>
</li>
</ul>
<p><strong>代码实现 (Java)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaximalRectangle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxRecSize</span><span class="params">(<span class="type">int</span>[][] map)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map == <span class="literal">null</span> || map.length == <span class="number">0</span> || map[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] height = <span class="keyword">new</span> <span class="title class_">int</span>[map[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; map.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; map[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                height[j] = map[i][j] == <span class="number">0</span> ? <span class="number">0</span> : height[j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxArea = Math.max(maxRecFromBottom(height), maxArea);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求直方图中的最大矩形面积</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxRecFromBottom</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (height == <span class="literal">null</span> || height.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 单调栈：栈底到栈顶从小到大</span></span><br><span class="line">            <span class="comment">// 当当前值 &lt;= 栈顶值时，结算栈顶</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &lt;= height[stack.peek()]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">                <span class="comment">// 右边界是 i，左边界是 k</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">curArea</span> <span class="operator">=</span> (i - k - <span class="number">1</span>) * height[j];</span><br><span class="line">                maxArea = Math.max(maxArea, curArea);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清算栈中剩余元素</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            <span class="comment">// 右边界是 height.length，左边界是 k</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">curArea</span> <span class="operator">=</span> (height.length - k - <span class="number">1</span>) * height[j];</span><br><span class="line">            maxArea = Math.max(maxArea, curArea);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最大值减去最小值小于或等于-num-的子数组数量"><a href="#最大值减去最小值小于或等于-num-的子数组数量" class="headerlink" title="最大值减去最小值小于或等于 num 的子数组数量"></a>最大值减去最小值小于或等于 num 的子数组数量</h2><p><strong>题目</strong><br>给定数组 <code>arr</code> 和整数 <code>num</code>，共返回有多少个子数组满足如下情况：<br><code>max(arr[i..j]) - min(arr[i..j]) &lt;= num</code><br><code>max(arr[i..j])</code> 表示子数组 <code>arr[i..j]</code> 中的最大值，<code>min(arr[i..j])</code> 表示子数组 <code>arr[i..j]</code> 中的最小值。</p>
<p><strong>要求</strong><br>如果数组长度为 <code>N</code>，请实现时间复杂度为 <code>O(N)</code> 的解法。</p>
<p><strong>解答</strong></p>
<ul>
<li><strong>核心结论</strong>：<ol>
<li>如果子数组 <code>arr[i..j]</code> 满足条件，则 <code>arr[i..j]</code> 中的每一个子数组也都满足条件（因为范围缩小，最大值不会变大，最小值不会变小，差值只会变小或不变）。</li>
<li>如果子数组 <code>arr[i..j]</code> 不满足条件，则所有包含 <code>arr[i..j]</code> 的子数组也都不满足条件（因为范围扩大，最大值可能变大，最小值可能变小，差值只会变大或不变）。</li>
</ol>
</li>
<li><strong>算法流程 (双端队列 + 滑动窗口)</strong>：<ol>
<li>使用两个双端队列 <code>qmax</code> 和 <code>qmin</code> 分别维护窗口内的最大值和最小值的更新（存储下标）。</li>
<li>使用两个变量 <code>i</code> (左边界) 和 <code>j</code> (右边界)，初始均为 0。</li>
<li>固定 <code>i</code>，让 <code>j</code> 不断向右扩，更新 <code>qmax</code> 和 <code>qmin</code>。</li>
<li>当 <code>arr[i..j]</code> 刚好不满足条件（即 <code>max - min &gt; num</code>）或者 <code>j</code> 越界时，停止扩大。此时，以 <code>i</code> 开头的满足条件的子数组数量为 <code>j - i</code> 个（即 <code>arr[i..i], arr[i..i+1] ... arr[i..j-1]</code>）。</li>
<li>累加数量 <code>res += j - i</code>。</li>
<li><code>i</code> 向右移动一位 (<code>i++</code>)，并检查 <code>qmax</code> 和 <code>qmin</code> 的队头是否过期（等于 <code>i-1</code> 则弹出），然后继续尝试向右扩展 <code>j</code>。</li>
<li>直到 <code>i</code> 遍历完整个数组。</li>
</ol>
</li>
<li><strong>时间复杂度</strong>：<code>i</code> 和 <code>j</code> 都只增加不减少，每个元素最多进出队列一次，复杂度为 <code>O(N)</code>。</li>
</ul>
<p><strong>代码实现 (Java)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubArrayNum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;Integer&gt; qmin = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; qmax = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; arr.length) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; arr.length) &#123;</span><br><span class="line">                <span class="comment">// 更新 qmin</span></span><br><span class="line">                <span class="keyword">while</span> (!qmin.isEmpty() &amp;&amp; arr[qmin.peekLast()] &gt;= arr[j]) &#123;</span><br><span class="line">                    qmin.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                qmin.addLast(j);</span><br><span class="line">                <span class="comment">// 更新 qmax</span></span><br><span class="line">                <span class="keyword">while</span> (!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[j]) &#123;</span><br><span class="line">                    qmax.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                qmax.addLast(j);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 检查是否满足条件</span></span><br><span class="line">                <span class="keyword">if</span> (arr[qmax.getFirst()] - arr[qmin.getFirst()] &gt; num) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 此时以 i 开头，j-1 结尾的子数组是满足条件的，长度为 j-i</span></span><br><span class="line">            <span class="comment">// 包含的子数组个数就是 j-i 个</span></span><br><span class="line">            res += j - i;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// i 向右移，如果队头过期则弹出</span></span><br><span class="line">            <span class="keyword">if</span> (qmin.peekFirst() == i) &#123;</span><br><span class="line">                qmin.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (qmax.peekFirst() == i) &#123;</span><br><span class="line">                qmax.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="可见的山峰对数量"><a href="#可见的山峰对数量" class="headerlink" title="可见的山峰对数量"></a>可见的山峰对数量</h2><p><strong>题目</strong><br>一个不含有负数的数组可以代表一圈环形山，每个位置的值代表山的高度。比如 <code>&#123;3,1,2,4,5&#125;</code> 代表一个环形结构。<br>山峰 A 和 山峰 B 能够相互看见的条件为：</p>
<ol>
<li>如果 A 和 B 是同一座山，认为不能相互看见。</li>
<li>如果 A 和 B 是不同的山，并且在环中相邻，认为可以相互看见。</li>
<li>如果 A 和 B 是不同的山，并且在环中不相邻，假设两座山高度的最小值为 <code>min</code>。如果 A 通过 <code>next</code> 方向到 B 的途中没有高度比 <code>min</code> 大的山峰，或者 A 通过 <code>last</code> 方向到 B 的途中没有高度比 <code>min</code> 大的山峰，认为 A 和 B 可以相互看见。</li>
</ol>
<p><strong>问题</strong></p>
<ol>
<li><strong>原问题</strong>：如果 <code>arr</code> 中没有重复值，返回有多少对山峰能够相互看见。</li>
<li><strong>进阶问题</strong>：如果 <code>arr</code> 中含有重复值，返回有多少对山峰能够相互看见。</li>
</ol>
<p><strong>要求</strong><br>如果 <code>arr</code> 长度为 <code>N</code>，没有重复值的情况下时间复杂度达到 <code>O(1)</code>，可能有重复值的情况下时间复杂度请达到 <code>O(N)</code>。</p>
<p><strong>解答</strong></p>
<p><strong>1. 原问题 (无重复值)</strong></p>
<ul>
<li><strong>结论</strong>：<code>2 * N - 3</code> 对。</li>
<li><strong>推导</strong>：<ul>
<li>环形结构中最高的山峰（记为 Max）和次高的山峰（记为 SecondMax）一定能互相看见（1对）。</li>
<li>除了 Max 和 SecondMax 之外，剩下的 <code>N - 2</code> 座山峰，每一座山峰 <code>X</code> 在顺时针和逆时针方向上，一定会遇到<strong>第一座</strong>比它高的山峰。因为没有重复值，所以这两个方向找到的比它高的山峰必然不同。</li>
<li>所以这 <code>N - 2</code> 座山峰，每座都能贡献 2 对可见山峰对。</li>
<li>总数 = <code>1 + (N - 2) * 2 = 2 * N - 3</code>。</li>
<li>(前提 <code>N &gt;= 2</code>，如果 <code>N &lt; 2</code> 答案为 0)。</li>
</ul>
</li>
</ul>
<p><strong>2. 进阶问题 (有重复值)</strong></p>
<ul>
<li><strong>核心思路</strong>：使用<strong>单调栈</strong>。<ol>
<li><strong>准备工作</strong>：找到数组中<strong>最大值</strong>的位置，将其作为遍历的起始点，保证栈底永远是最大值，防止逻辑断裂。</li>
<li><strong>单调栈策略</strong>：栈中存放 <code>Record</code> 对象（包含高度 <code>value</code> 和出现次数 <code>times</code>），保持栈底到栈顶高度<strong>严格递减</strong>。</li>
<li><strong>遍历流程</strong>：<ul>
<li>当前高度 <code>cur</code> &gt; 栈顶高度 <code>top</code>：<ul>
<li>弹出栈顶 <code>Record(k, times)</code>。</li>
<li><strong>结算</strong>：该记录产生的可见对数为 <code>C(2, times) + times * 2</code>。<ul>
<li><code>C(2, times)</code>：相同高度内部互看（如果 <code>times=1</code> 则为0）。</li>
<li><code>times * 2</code>：对外看，顺时针遇到 <code>cur</code>，逆时针遇到栈中下一个元素（因为是从最大值开始遍历，栈底总是最大值，所以一定存在下一个元素）。</li>
</ul>
</li>
</ul>
</li>
<li>当前高度 <code>cur</code> == 栈顶高度 <code>top</code>：栈顶 <code>times++</code>。</li>
<li>当前高度 <code>cur</code> &lt; 栈顶高度 <code>top</code>：压入新记录。</li>
</ul>
</li>
<li><strong>清算阶段</strong>（遍历结束后栈不为空）：<ul>
<li><strong>第 1 阶段</strong>：弹出记录不是倒数第 1 条，也不是倒数第 2 条。<ul>
<li>产生对数：<code>C(2, times) + times * 2</code>。</li>
</ul>
</li>
<li><strong>第 2 阶段</strong>：弹出记录是倒数第 2 条。<ul>
<li>如果倒数第 1 条（最大值）的 <code>times == 1</code>，产生对数 <code>C(2, times) + times * 1</code>（因为顺时针和逆时针看到的是同一个最大值）。</li>
<li>如果倒数第 1 条（最大值）的 <code>times &gt; 1</code>，产生对数 <code>C(2, times) + times * 2</code>。</li>
</ul>
</li>
<li><strong>第 3 阶段</strong>：弹出记录是倒数第 1 条（最大值）。<ul>
<li>产生对数：<code>C(2, times)</code>（内部互看，对外不再产生对数）。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>代码实现 (Java)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisibleNum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> times;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Record</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.times = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getVisibleNum</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 先找到其中一个最大值的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            maxIndex = arr[maxIndex] &lt; arr[i] ? i : maxIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Stack&lt;Record&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Record&gt;();</span><br><span class="line">        <span class="comment">// 先把最大值放入栈中</span></span><br><span class="line">        stack.push(<span class="keyword">new</span> <span class="title class_">Record</span>(arr[maxIndex]));</span><br><span class="line">        <span class="comment">// 从最大值位置的下一个位置开始沿 next 方向遍历</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> nextIndex(maxIndex, size);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (index != maxIndex) &#123;</span><br><span class="line">            <span class="comment">// 当前值 &gt; 栈顶值，结算栈顶</span></span><br><span class="line">            <span class="keyword">while</span> (stack.peek().value &lt; arr[index]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> stack.pop().times;</span><br><span class="line">                res += getInternalSum(k) + <span class="number">2</span> * k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前值 == 栈顶值，累加次数</span></span><br><span class="line">            <span class="keyword">if</span> (stack.peek().value == arr[index]) &#123;</span><br><span class="line">                stack.peek().times++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前值 &lt; 栈顶值，压入</span></span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">Record</span>(arr[index]));</span><br><span class="line">            &#125;</span><br><span class="line">            index = nextIndex(index, size);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 清算阶段</span></span><br><span class="line">        <span class="keyword">while</span> (stack.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> stack.pop().times;</span><br><span class="line">            res += getInternalSum(times) + <span class="number">2</span> * times;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (stack.size() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> stack.pop().times;</span><br><span class="line">            <span class="comment">// 如果栈底（最大值）只有1个，那么对外只能贡献1对；如果有多个，贡献2对</span></span><br><span class="line">            res += getInternalSum(times) + (stack.peek().times == <span class="number">1</span> ? times : <span class="number">2</span> * times);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最后剩下的最大值，只计算内部对数</span></span><br><span class="line">        res += getInternalSum(stack.pop().times);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 C(2, k)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getInternalSum</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> k == <span class="number">1</span> ? <span class="number">0</span> : (k * (k - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环形数组下一个索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i &lt; (size - <span class="number">1</span>) ? (i + <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="链表问题"><a href="#链表问题" class="headerlink" title="链表问题"></a>链表问题</h1><h2 id="打印两个有序链表的公共部分"><a href="#打印两个有序链表的公共部分" class="headerlink" title="打印两个有序链表的公共部分"></a>打印两个有序链表的公共部分</h2><p><strong>题目</strong><br>给定两个有序链表的头指针 head1 和 head2，打印两个链表的公共部分。</p>
<p><strong>解答</strong><br>本题难度很低，因为是有序链表，所以从两个链表的头开始进行如下判断：</p>
<ul>
<li>如果 head1 的值小于 head2，则 head1 往下移动。</li>
<li>如果 head2 的值小于 head1，则 head2 往下移动。</li>
<li>如果 head1 的值与 head2 的值相等，则打印这个值，然后 head1 与 head2 都往下移动。</li>
<li>head1 或 head2 有任何一个移动到 null，则整个过程停止。</li>
</ul>
<p>具体过程参看如下代码中的 printCommonPart 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printCommonPart</span><span class="params">(Node head1, Node head2)</span> &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;Common Part: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="literal">null</span> &amp;&amp; head2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head1.value &lt; head2.value) &#123;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head1.value &gt; head2.value) &#123;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(head1.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在单链表和双链表中删除倒数第-K-个节点"><a href="#在单链表和双链表中删除倒数第-K-个节点" class="headerlink" title="在单链表和双链表中删除倒数第 K 个节点"></a>在单链表和双链表中删除倒数第 K 个节点</h2><p><strong>题目</strong><br>分别实现两个函数，一个可以删除单链表中倒数第 K 个节点，另一个可以删除双链表中倒数第 K 个节点。</p>
<p><strong>要求</strong><br>如果链表长度为 N，时间复杂度达到 O(N)，额外空间复杂度达到 O(1)。</p>
<p><strong>解答</strong><br>本题较为简单，实现方式也是多种多样的，本书提供一种方法供读者参考。</p>
<p>先来看看单链表如何调整。如果链表为空或者 K 值小于 1，这种情况下，参数是无效的，直接返回即可。除此之外，让链表从头开始走到尾，每移动一步，就让 K 的值减 1。</p>
<ul>
<li>链表：1-&gt;2-&gt;3, K=4, 链表根本不存在倒数第 4 个节点。<ul>
<li>走到节点：1 -&gt; 2 -&gt; 3</li>
<li>K变化为：3 2 1</li>
</ul>
</li>
<li>链表：1-&gt;2-&gt;3, K=3, 链表倒数第 3 个节点是 1 节点。<ul>
<li>走到节点：1 -&gt; 2 -&gt; 3</li>
<li>K变化为：2 1 0</li>
</ul>
</li>
<li>链表：1-&gt;2-&gt;3, K=2, 链表倒数第 2 个节点是 2 节点。<ul>
<li>走到节点：1 -&gt; 2 -&gt; 3</li>
<li>K变化为：1 0 -1</li>
</ul>
</li>
</ul>
<p>由以上三种情况可知，让链表从头开始走到尾，每移动一步，就让 K 值减 1，当链表走到结尾时：</p>
<ul>
<li>如果 K 值大于 0，说明不用调整链表，因为链表根本没有倒数第 K 个节点，此时将原链表直接返回即可。</li>
<li>如果 K 值等于 0，说明链表倒数第 K 个节点就是头节点，此时直接返回 head.next，也就是原链表的第二个节点，让第二个节点作为链表的头返回即可，相当于删除头节点。</li>
<li>如果 K 值小于 0，说明要删除链表的头节点之后的某个节点。实际需要找到要删除节点的前一个节点。方法如下：<ol>
<li>重新从头节点开始走，每移动一步，就让 K 的值加 1。</li>
<li>当 K 等于 0 时，移动停止，移动到的节点就是要删除节点的前一个节点。<br>这样做是非常好理解的，因为如果链表长度为 N，要删除倒数第 K 个节点，很明显，倒数第 K 个节点的前一个节点就是第 N-K 个节点。在第一次遍历后，K 的值变为 K-N。第二次遍历时，K 的值不断加 1，加到 0 就停止遍历，第二次遍历当然会停到第 N-K 个节点的位置。</li>
</ol>
</li>
</ul>
<p>具体过程参看如下代码中的 removeLastKthNode 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">removeLastKthNode</span><span class="params">(Node head, <span class="type">int</span> lastKth)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || lastKth &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        lastKth--;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lastKth == <span class="number">0</span>) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lastKth &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (++lastKth != <span class="number">0</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于双链表的调整，几乎与单链表的处理方式一样，注意 last 指针的重连即可。具体过程请参看如下代码中的 removeLastKthNode 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> DoubleNode last;</span><br><span class="line">    <span class="keyword">public</span> DoubleNode next;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoubleNode</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> DoubleNode <span class="title function_">removeLastKthNode</span><span class="params">(DoubleNode head, <span class="type">int</span> lastKth)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || lastKth &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">DoubleNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        lastKth--;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lastKth == <span class="number">0</span>) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        head.last = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lastKth &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (++lastKth != <span class="number">0</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">DoubleNode</span> <span class="variable">newNext</span> <span class="operator">=</span> cur.next.next;</span><br><span class="line">        cur.next = newNext;</span><br><span class="line">        <span class="keyword">if</span> (newNext != <span class="literal">null</span>) &#123;</span><br><span class="line">            newNext.last = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除链表的中间节点和-a-b-处的节点"><a href="#删除链表的中间节点和-a-b-处的节点" class="headerlink" title="删除链表的中间节点和 a/b 处的节点"></a>删除链表的中间节点和 a/b 处的节点</h2><p><strong>题目</strong><br>给定链表的头节点 head，实现删除链表的中间节点的函数。<br>例如：</p>
<ul>
<li>不删除任何节点；</li>
<li>1-&gt;2，删除节点 1；</li>
<li>1-&gt;2-&gt;3，删除节点 2；</li>
<li>1-&gt;2-&gt;3-&gt;4，删除节点 2；</li>
<li>1-&gt;2-&gt;3-&gt;4-&gt;5，删除节点 3；</li>
</ul>
<p><strong>进阶</strong><br>给定链表的头节点 head、整数 a 和 b，实现删除位于 a/b 处节点的函数。<br>例如：<br>链表：1-&gt;2-&gt;3-&gt;4-&gt;5，假设 a/b 的值为 r。</p>
<ul>
<li>如果 r 等于 0，不删除任何节点；</li>
<li>如果 r 在区间 (0, 1/5] 上，删除节点 1；</li>
<li>如果 r 在区间 (1/5, 2/5] 上，删除节点 2；</li>
<li>如果 r 在区间 (2/5, 3/5] 上，删除节点 3；</li>
<li>如果 r 在区间 (3/5, 4/5] 上，删除节点 4；</li>
<li>如果 r 在区间 (4/5, 1] 上，删除节点 5；</li>
<li>如果 r 大于 1，不删除任何节点。</li>
</ul>
<p><strong>解答</strong><br>先来分析原问题，如果链表为空或者长度为 1，不需要调整，则直接返回；如果链表的长度为 2，将头节点删除即可；当链表长度到达 3，应该删除第 2 个节点；当链表长度为 4，应该删除第 2 个节点；当链表长度为 5，应该删除第 3 个节点……也就是链表长度每增加 2 (3, 5, 7…)，要删除的节点就后移一个节点。删除节点的问题在之前的题目中我们已经讨论过，如果要删除一个节点，则需要找到待删除节点的前一个节点。<br>具体过程请参看如下代码中的 removeMidNode 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">removeMidNode</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head.next.next;</span><br><span class="line">    <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        cur = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = pre.next.next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来讨论进阶问题，首先需要解决的问题是，如何根据链表的长度 n，以及 a 与 b 的值决定该删除的节点是哪一个节点呢？根据如下方法：先计算 <code>double r = ((double) (a * n)) / ((double) b)</code> 的值，然后 r 向上取整之后的整数值代表该删除的节点是第几个节点。</p>
<p>下面举几个例子来验证一下。</p>
<ul>
<li>如果链表长度为 7, a=5, b=7。<br>r = (7*5)/7 = 5.0，向上取整后为 5，所以应该删除第 5 个节点。</li>
<li>如果链表长度为 7, a=5, b=6。<br>r = (7*5)/6 = 5.8333…，向上取整后为 6，所以应该删除第 6 个节点。</li>
<li>如果链表长度为 7, a=1, b=6。<br>r = (7*1)/6 = 1.1666…，向上取整后为 2，所以应该删除第 2 个节点。</li>
</ul>
<p>知道该删除第几个节点之后，接下来找到需要删除节点的前一个节点即可。具体过程请参看如下代码中的 removeByRatio 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">removeByRatio</span><span class="params">(Node head, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">1</span> || a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        n++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    n = (<span class="type">int</span>) Math.ceil(((<span class="type">double</span>) (a * n)) / ((<span class="type">double</span>) b));</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (--n != <span class="number">1</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反转单向和双向链表"><a href="#反转单向和双向链表" class="headerlink" title="反转单向和双向链表"></a>反转单向和双向链表</h2><p><strong>题目</strong><br>分别实现反转单向链表和反转双向链表的函数。</p>
<p><strong>要求</strong><br>如果链表长度为 N，时间复杂度要求为 O(N)，额外空间复杂度要求为 O(1)。</p>
<p><strong>解答</strong><br>本题比较简单，读者做到代码一次完成，运行不出错即可。</p>
<p>反转单向链表的函数如下（该函数返回反转之后链表新的头节点）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">reverseList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反转双向链表的函数如下（函数返回反转之后链表新的头节点）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> DoubleNode last;</span><br><span class="line">    <span class="keyword">public</span> DoubleNode next;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoubleNode</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> DoubleNode <span class="title function_">reverseList</span><span class="params">(DoubleNode head)</span> &#123;</span><br><span class="line">    <span class="type">DoubleNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">DoubleNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        head.last = next;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反转部分单向链表"><a href="#反转部分单向链表" class="headerlink" title="反转部分单向链表"></a>反转部分单向链表</h2><p><strong>题目</strong><br>给定一个单向链表的头节点 head，以及两个整数 from 和 to，在单向链表上把第 from 个节点到第 to 个节点这一部分进行反转。<br>例如：<br>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null, from=2, to=4<br>调整结果为：1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;null<br>再如：<br>1-&gt;2-&gt;3-&gt;null, from=1, to=3<br>调整结果为：3-&gt;2-&gt;1-&gt;null</p>
<p><strong>要求</strong></p>
<ol>
<li>如果链表长度为 N，时间复杂度要求为 O(N)，额外空间复杂度要求为 O(1)。</li>
<li>如果不满足 1&lt;=from&lt;=to&lt;=N，则不用调整。</li>
</ol>
<p><strong>解答</strong><br>本题有可能存在换头的问题，比如题目的第二个例子，所以函数应该返回调整后的新头节点。整个处理过程如下：</p>
<ol>
<li>先判断是否满足 1&lt;=from&lt;=to&lt;=N，如果不满足，则直接返回原来的头节点。</li>
<li>找到第 from-1 个节点 fPre 和第 to+1 个节点 tPos。fPre 就是要反转部分的前一个节点，tPos 是反转部分的后一个节点。把反转的部分先反转，然后正确地连接 fPre 和 tPos。<br>例如：1-&gt;2-&gt;3-&gt;4-&gt;null，假设 fPre 为节点 1，tPos 为节点 4，要反转部分为 2-&gt;3。先反转成 3-&gt;2，然后 fPre 连向节点 3，节点 2 连向 tPos，就变成了 1-&gt;3-&gt;2-&gt;4-&gt;null。</li>
<li>如果 fPre 为 null，说明反转部分是包含头节点的，则返回新的头节点，也就是没反转之前反转部分的最后一个节点，也是反转之后反转部分的第一个节点；如果 fPre 不为 null，则返回旧的头节点。<br>全部过程请参看如下代码中的 reversePart 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">reversePart</span><span class="params">(Node head, <span class="type">int</span> from, <span class="type">int</span> to)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node1</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">fPre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">tPos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (node1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        fPre = len == from - <span class="number">1</span> ? node1 : fPre;</span><br><span class="line">        tPos = len == to + <span class="number">1</span> ? node1 : tPos;</span><br><span class="line">        node1 = node1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (from &gt; to || from &lt; <span class="number">1</span> || to &gt; len) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    node1 = fPre == <span class="literal">null</span> ? head : fPre.next;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node2</span> <span class="operator">=</span> node1.next;</span><br><span class="line">    node1.next = tPos;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (node2 != tPos) &#123;</span><br><span class="line">        next = node2.next;</span><br><span class="line">        node2.next = node1;</span><br><span class="line">        node1 = node2;</span><br><span class="line">        node2 = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fPre != <span class="literal">null</span>) &#123;</span><br><span class="line">        fPre.next = node1;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="环形单链表的约瑟夫问题"><a href="#环形单链表的约瑟夫问题" class="headerlink" title="环形单链表的约瑟夫问题"></a>环形单链表的约瑟夫问题</h2><p><strong>题目</strong><br>据说著名犹太历史学家 Josephus 有过以下故事：在罗马人占领乔塔帕特后，39 个犹太人与 Josephus 及他的朋友躲到一个洞中，39 个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41 个人排成一个圆圈，由第 1 个人开始报数，报数到 3 的人就自杀，然后再由下一个人重新报 1，报数到 3 的人再自杀，这样依次下去，直到剩下最后一个人时，那个人可以自由选择自己的命运。这就是著名的约瑟夫问题。现在请用单向环形链表描述该结构并呈现整个自杀过程。<br>输入：一个环形单向链表的头节点 head 和报数的值 m。<br>返回：最后生存下来的节点，且这个节点自己组成环形单向链表，其他节点都删掉。</p>
<p><strong>进阶</strong><br>如果链表节点数为 N，想在时间复杂度为 O(N) 时完成原问题的要求，该怎么实现？</p>
<p><strong>解答</strong><br><strong>普通解法</strong><br>先来看看普通解法是如何实现的，其实非常简单，方法如下：</p>
<ol>
<li>如果链表为空或者链表节点数为 1，或者 m 的值小于 1，则不用调整就直接返回。</li>
<li>在环形链表中遍历每个节点，不断转圈，不断让每个节点报数。</li>
<li>当报数到达 m 时，就删除当前报数的节点。</li>
<li>删除节点后，别忘了还要把剩下的节点继续连成环状，继续转圈报数，继续删除。</li>
<li>不停地删除，直到环形链表中只剩一个节点，过程结束。<br>普通的解法时间复杂度为 O(N*M)。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">josephusKill1</span><span class="params">(Node head, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == head || m &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (last.next != head) &#123;</span><br><span class="line">        last = last.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != last) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++count == m) &#123;</span><br><span class="line">            last.next = head.next;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last = last.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = last.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>进阶解法</strong><br>原问题之所以花费的时间多，是因为我们一开始不知道到底哪一个节点最后会活下来。所以依靠不断地删除来淘汰节点，当只剩下一个节点的时候，才知道是这个节点。如果不通过一直删除方式，有没有办法直接确定最后活下来的节点是哪一个呢？这就是进阶解法的实质。</p>
<p>如果环形链表节点数为 n，我们做如下定义：从这个环形链表的头节点开始编号，头节点编号为 1，头节点的下一个节点编号为 2，……，最后一个节点编号为 n。<br>我们用 <code>Num(i)</code> 表示在由 i 个节点组成的环中，最后幸存节点的编号。<br>通过数学推导（编号与报数的关系、删除节点前后的编号映射），可以得到如下递推公式：</p>
<ul>
<li><code>Num(1) = 1</code></li>
<li><code>Num(i) = (Num(i-1) + m - 1) % i + 1</code></li>
</ul>
<p>算法过程总结为：</p>
<ol>
<li>遍历链表，求链表的节点个数记为 n。时间复杂度为 O(N)。</li>
<li>根据 n 和 m 的值，利用递推公式求出 <code>Num(n)</code>，即最后幸存节点的编号。这可以通过递归函数实现，时间复杂度为 O(N)。</li>
<li>最后根据幸存节点的编号，遍历链表找到该节点。时间复杂度为 O(N)。</li>
<li>整个过程结束，总的时间复杂度为 O(N)。</li>
</ol>
<p>具体实现请参看如下代码中的 josephusKill2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">josephusKill2</span><span class="params">(Node head, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == head || m &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// list size</span></span><br><span class="line">    <span class="keyword">while</span> (cur != head) &#123;</span><br><span class="line">        tmp++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = getLive(tmp, m); <span class="comment">// tmp -&gt; service node position</span></span><br><span class="line">    <span class="keyword">while</span> (--tmp != <span class="number">0</span>) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLive</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (getLive(i - <span class="number">1</span>, m) + m - <span class="number">1</span>) % i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断一个链表是否为回文结构"><a href="#判断一个链表是否为回文结构" class="headerlink" title="判断一个链表是否为回文结构"></a>判断一个链表是否为回文结构</h2><p><strong>题目</strong><br>给定一个链表的头节点 head，请判断该链表是否为回文结构。<br>例如：<br>1-&gt;2-&gt;1，返回 true。<br>1-&gt;2-&gt;2-&gt;1，返回 true。<br>15-&gt;6-&gt;15，返回 true。<br>1-&gt;2-&gt;3，返回 false。</p>
<p><strong>进阶</strong><br>如果链表长度为 N，时间复杂度达到 O(N)，额外空间复杂度达到 O(1)。</p>
<p><strong>解答</strong><br><strong>方法一</strong><br>方法一是最容易实现的方法，利用栈结构即可。从左到右遍历链表，遍历的过程中把每个节点依次压入栈中。因为栈是先进后出的，所以在遍历完成后，从栈顶到栈底的节点值出现顺序会与原链表从左到右的值出现顺序反过来。那么，如果一个链表是回文结构，逆序之后，值出现的次序还是一样的，如果不是回文结构，顺序就肯定对不上。<br>例如：<br>链表 1-&gt;2-&gt;3-&gt;4，从左到右依次压栈之后，从栈顶到栈底的节点值顺序为 4，3，2，1。两者顺序对不上，所以这个链表不是回文结构。<br>链表 1-&gt;2-&gt;2-&gt;1，从左到右依次压栈之后，从栈顶到栈底的节点值顺序为 1，2，2，1。两者顺序一样，所以这个链表是回文结构。<br>方法一需要一个额外的栈结构，并且需要把所有的节点都压入栈中，所以这个额外的栈结构需要 O(N) 的空间。具体过程请参看如下代码中的 isPalindrome1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome1</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Node&gt;();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack.push(cur);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.value != stack.pop().value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法二</strong><br>方法二对方法一进行了优化，虽然也是利用栈结构，但其实并不需要将所有的节点都压入栈中，只用压入一半的节点即可。首先假设链表的长度为 N，如果 N 是偶数，前 N/2 的节点叫作左半区，后 N/2 的节点叫作右半区。如果 N 是奇数，忽略处于最中间的节点，还是前 N/2 的节点叫作左半区，后 N/2 的节点叫作右半区。<br>例如：<br>链表 1-&gt;2-&gt;2-&gt;1，左半区为：1，2；右半区为：2，1。<br>链表 1-&gt;2-&gt;3-&gt;2-&gt;1，左半区为：1，2；右半区为：2，1。<br>方法二就是把整个链表的右半部分压入栈中，压入完成后，再检查栈顶到栈底出现的顺序是否和链表左半部分的值相对应。<br>例如：<br>链表 1-&gt;2-&gt;2-&gt;1，链表的右半部分压入栈中后，从栈顶到栈底为 1，2。链表的左半部分也是 1，2。所以这个链表是回文结构。<br>链表 1-&gt;2-&gt;3-&gt;2-&gt;1，链表的右半部分压入栈中后，从栈顶到栈底为 1，2。链表的左半部分也是 1，2。所以这个链表是回文结构。<br>链表 1-&gt;2-&gt;3-&gt;3-&gt;1，链表的右半部分压入栈中后，从栈顶到栈底为 1，3。链表的左半部分也是 1，2。所以这个链表不是回文结构。<br>方法二也可以直观地理解为将链表的右半部分“折过去”，然后让它和左半部分比较。<br>方法二的具体过程请参看如下代码中的 isPalindrome2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome2</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">right</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        right = right.next;</span><br><span class="line">        cur = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">while</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack.push(right);</span><br><span class="line">        right = right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.value != stack.pop().value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法三</strong><br>方法三不需要栈和其他数据结构，只用有限几个变量，其额外空间复杂度为 O(1)，就可以在时间复杂度为 O(N) 内完成所有的过程，也就是满足进阶的要求。具体过程如下：</p>
<ol>
<li>改变链表右半区的结构，使整个右半区反转，最后指向中间节点。<br>例如：<br>链表 1-&gt;2-&gt;3-&gt;2-&gt;1，通过这一步将其调整之后的结构如图 2-6 所示。<br>链表 1-&gt;2-&gt;3-&gt;3-&gt;2-&gt;1，将其调整之后的结构如图 2-7 所示。</li>
</ol>
<p>我们将左半区的第一个节点（也就是原链表的头节点）记为 leftStart，右半区反转之后最右边的节点（也就是原链表的最后一个节点）记为 rightStart。</p>
<ol>
<li>leftStart 和 rightStart 同时向中间点移动，移动每一步时都比较 leftStart 和 rightStart 节点的值，看是否一样。如果都一样，说明链表为回文结构，否则不是回文结构。</li>
<li>不管最后返回的是 true 还是 false，在返回前都应该把链表恢复成原来的样子。</li>
<li>链表恢复成原来的结构之后，返回检查结果。<br>粗看起来，虽然方法三的整个过程也没有多少难度，但要想用有限几个变量完成以上所有的操作，在实现上还是比较考查代码实现能力的。方法三的全部过程请参看如下代码中的 isPalindrome3 方法，该方法只申请了三个 Node 类型的变量。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome3</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">n1</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">n2</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (n2.next != <span class="literal">null</span> &amp;&amp; n2.next.next != <span class="literal">null</span>) &#123; <span class="comment">// 查找中间节点</span></span><br><span class="line">        n1 = n1.next; <span class="comment">// n1 -&gt; 中部</span></span><br><span class="line">        n2 = n2.next.next; <span class="comment">// n2 -&gt; 结尾</span></span><br><span class="line">    &#125;</span><br><span class="line">    n2 = n1.next; <span class="comment">// n2 -&gt; 右部分第一个节点</span></span><br><span class="line">    n1.next = <span class="literal">null</span>; <span class="comment">// mid.next -&gt; null</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (n2 != <span class="literal">null</span>) &#123; <span class="comment">// 右半区反转</span></span><br><span class="line">        n3 = n2.next; <span class="comment">// n3 -&gt; 保存下一个节点</span></span><br><span class="line">        n2.next = n1; <span class="comment">// 下一个反转节点</span></span><br><span class="line">        n1 = n2; <span class="comment">// n1 移动</span></span><br><span class="line">        n2 = n3; <span class="comment">// n2 移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    n3 = n1; <span class="comment">// n3 -&gt; 保存最后一个节点</span></span><br><span class="line">    n2 = head;<span class="comment">// n2 -&gt; 左边第一个节点</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="literal">null</span> &amp;&amp; n2 != <span class="literal">null</span>) &#123; <span class="comment">// 检查回文</span></span><br><span class="line">        <span class="keyword">if</span> (n1.value != n2.value) &#123;</span><br><span class="line">            res = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n1 = n1.next; <span class="comment">// 从左到中部</span></span><br><span class="line">        n2 = n2.next; <span class="comment">// 从右到中部</span></span><br><span class="line">    &#125;</span><br><span class="line">    n1 = n3.next;</span><br><span class="line">    n3.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="literal">null</span>) &#123; <span class="comment">// 恢复列表</span></span><br><span class="line">        n2 = n1.next;</span><br><span class="line">        n1.next = n3;</span><br><span class="line">        n3 = n1;</span><br><span class="line">        n1 = n2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将单向链表按某值划分成左边小、中间相等、右边大的形式"><a href="#将单向链表按某值划分成左边小、中间相等、右边大的形式" class="headerlink" title="将单向链表按某值划分成左边小、中间相等、右边大的形式"></a>将单向链表按某值划分成左边小、中间相等、右边大的形式</h2><p><strong>题目</strong><br>给定一个单向链表的头节点 head，节点的值类型是整型，再给定一个整数 pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于 pivot 的节点，中间部分都是值等于 pivot 的节点，右部分都是值大于 pivot 的节点。除这个要求外，对调整后的节点顺序没有更多的要求。<br>例如：链表 9-&gt;0-&gt;4-&gt;5-&gt;1，pivot=3。<br>调整后链表可以是 1-&gt;0-&gt;4-&gt;9-&gt;5，也可以是 0-&gt;1-&gt;9-&gt;5-&gt;4。总之，满足左部分都是小于 3 的节点，中间部分都是等于 3 的节点（本例中这个部分为空），右部分都是大于 3 的节点即可。对某部分内部的节点顺序不做要求。</p>
<p><strong>进阶</strong><br>在原问题的要求之上再增加如下两个要求。</p>
<ul>
<li>在左、中、右三个部分的内部也做顺序要求，要求每部分里的节点从左到右的顺序与原链表中节点的先后次序一致。<br>例如：链表 9-&gt;0-&gt;4-&gt;5-&gt;1，pivot=3。调整后的链表是 0-&gt;1-&gt;9-&gt;4-&gt;5。在满足原问题要求的同时，左部分节点从左到右为 0、1。在原链表中也是先出现 0，后出现 1；中间部分在本例中为空，不再讨论；右部分节点从左到右为 9、4、5。在原链表中也是先出现 9，然后出现 4，最后出现 5。</li>
<li>如果链表长度为 N，时间复杂度请达到 O(N)，额外空间复杂度请达到 O(1)。</li>
</ul>
<p><strong>解答</strong><br>普通解法的时间复杂度为 O(N)，额外空间复杂度为 O(N)，就是把链表中的所有节点放进一个额外的数组中，然后统一调整位置的办法。具体过程如下：</p>
<ol>
<li>先遍历一遍链表，为了得到链表的长度，假设长度为 N。</li>
<li>生成长度为 N 的 Node 类型的数组 nodeArr，然后遍历一次链表，将节点依次放进 nodeArr 中。本书在这里不用 LinkedList 或 ArrayList 等 Java 提供的结构，因为一个纯粹的数组结构比较利于步骤 3 的调整。</li>
<li>在 nodeArr 中把小于 pivot 的节点放在左边，把相等的放中间，把大于的放在右边。也就是改进了快速排序中 partition 的调整过程，即如下代码中的 arrPartition 方法。实现的具体解释请查看本书“数组类似 partition 的调整”问题，这里不再详述。</li>
<li>经过步骤 3 的调整后，nodeArr 是满足题目要求的节点顺序，只要把 nodeArr 中的节点依次重连起来即可，整个过程结束。<br>全部过程请参看如下代码中的 listPartition1 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">listPartition1</span><span class="params">(Node head, <span class="type">int</span> pivot)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node[] nodeArr = <span class="keyword">new</span> <span class="title class_">Node</span>[i];</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i != nodeArr.length; i++) &#123;</span><br><span class="line">        nodeArr[i] = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    arrPartition(nodeArr, pivot);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i != nodeArr.length; i++) &#123;</span><br><span class="line">        nodeArr[i - <span class="number">1</span>].next = nodeArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nodeArr[i - <span class="number">1</span>].next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> nodeArr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">arrPartition</span><span class="params">(Node[] nodeArr, <span class="type">int</span> pivot)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">big</span> <span class="operator">=</span> nodeArr.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index != big) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodeArr[index].value &lt; pivot) &#123;</span><br><span class="line">            swap(nodeArr, ++small, index++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeArr[index].value == pivot) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(nodeArr, --big, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Node[] nodeArr, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> nodeArr[a];</span><br><span class="line">    nodeArr[a] = nodeArr[b];</span><br><span class="line">    nodeArr[b] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来看看增加要求之后的进阶解法。对每部分都增加了节点顺序要求，同时时间复杂度仍然为 O(N)，额外空间复杂度为 O(1)。既然额外空间复杂度为 O(1)，说明实现时只能使用有限的几个变量来完成所有的调整。<br>进阶解法的具体过程如下：</p>
<ol>
<li>将原链表中的所有节点依次划分进三个链表，三个链表分别为 small 代表左部分，equal 代表中间部分，big 代表右部分。<br>例如，链表 7-&gt;9-&gt;1-&gt;8-&gt;5-&gt;2-&gt;5，pivot=5。在划分之后，small、equal、big 分别为：<br>small: 1-&gt;2-&gt;null<br>equal: 5-&gt;5-&gt;null<br>big: 7-&gt;9-&gt;8-&gt;null</li>
<li>将 small、equal 和 big 三个链表重新串起来即可。</li>
<li>整个过程需要特别注意对 null 节点的判断和处理。<br>进阶解法主要还是考查面试者利用有限几个变量调整链表的代码实现能力，全部进阶解法请参看如下代码中的 listPartition2 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">listPartition2</span><span class="params">(Node head, <span class="type">int</span> pivot)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">sH</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 小的头</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">sT</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 小的尾</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">eH</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 相等的头</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">eT</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 相等的尾</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">bH</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 大的头</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">bT</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 大的尾</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 保存下一个节点</span></span><br><span class="line">    <span class="comment">// 所有的节点分进三个链表中</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head.value &lt; pivot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sH == <span class="literal">null</span>) &#123;</span><br><span class="line">                sH = head;</span><br><span class="line">                sT = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sT.next = head;</span><br><span class="line">                sT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.value == pivot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eH == <span class="literal">null</span>) &#123;</span><br><span class="line">                eH = head;</span><br><span class="line">                eT = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                eT.next = head;</span><br><span class="line">                eT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bH == <span class="literal">null</span>) &#123;</span><br><span class="line">                bH = head;</span><br><span class="line">                bT = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bT.next = head;</span><br><span class="line">                bT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 小的和相等的重新连接</span></span><br><span class="line">    <span class="keyword">if</span> (sT != <span class="literal">null</span>) &#123;</span><br><span class="line">        sT.next = eH;</span><br><span class="line">        eT = eT == <span class="literal">null</span> ? sT : eT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所有的重新连接</span></span><br><span class="line">    <span class="keyword">if</span> (eT != <span class="literal">null</span>) &#123;</span><br><span class="line">        eT.next = bH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sH != <span class="literal">null</span> ? sH : eH != <span class="literal">null</span> ? eH : bH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复制含有随机指针节点的链表"><a href="#复制含有随机指针节点的链表" class="headerlink" title="复制含有随机指针节点的链表"></a>复制含有随机指针节点的链表</h2><p><strong>题目</strong></p>
<p>一种特殊的链表节点类描述如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="keyword">public</span> Node rand;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Node 类中的 value 是节点值，next 指针和正常单链表中 next 指针的意义一样，都指向下一个节点，rand 指针是 Node 类中新增的指针，这个指针可能指向链表中的任意一个节点，也可能指向 null。</p>
<p>给定一个由 Node 节点类型组成的无环单链表的头节点 head，请实现一个函数完成这个链表中所有结构的复制，并返回复制的新链表的头节点。例如：链表 1-&gt;2-&gt;3-&gt;null，假设 1 的 rand 指针指向 3，2 的 rand 指针指向 null，3 的 rand 指针指向 1。复制后的链表应该也是这种结构，比如，1’-&gt;2’-&gt;3’-&gt;null，1’ 的 rand 指针指向 3’，2’ 的 rand 指针指向 null，3’ 的 rand 指针指向 1’，最后返回 1’。</p>
<p><strong>解答</strong></p>
<p>首先介绍普通解法，普通解法可以做到时间复杂度为 O(N)，额外空间复杂度为 O(N)，需要使用到哈希表 (HashMap) 结构。具体过程如下：</p>
<ol>
<li>从左到右遍历链表，对每个节点都复制生成相应的副本节点，然后将对应关系放入哈希表 map 中。例如，链表 1-&gt;2-&gt;3-&gt;null，遍历 1、2、3 时依次生成 1’、2’、3’，最后将对应关系放入 map 中。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">key</th>
<th style="text-align:left">value</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1’</td>
<td style="text-align:left">表示节点 1 复制了节点 1’</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">2’</td>
<td style="text-align:left">表示节点 2 复制了节点 2’</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">3’</td>
<td style="text-align:left">表示节点 3 复制了节点 3’</td>
</tr>
</tbody>
</table>
</div>
<p>步骤 1 完成后，原链表没有任何变化，每一个副本节点的 next 和 rand 指针都指向 null。</p>
<ol>
<li><p>再从左到右遍历链表，此时就可以设置每一个副本节点的 next 和 rand 指针。<br>例如：原链表 1-&gt;2-&gt;3-&gt;null，假设 1 的 rand 指针指向 3，2 的 rand 指针指向 null，3 的 rand 指针指向 1。遍历到节点 1 时，可以从 map 中得到节点 1 的副本节点 1’，节点 1 的 next 指向节点 2，所以从 map 中得到节点 2 的副本节点 2’，然后令 1’.next=2’，副本节点 1’ 的 next 指针就设置好了。同时节点 1 的 rand 指向节点 3，所以从 map 中得到节点 3 的副本节点 3’，然后令 1’.rand=3’，副本节点 1’ 的 rand 指针也设置好了。以这种方式可以设置每一个副本节点的 next 和 rand 指针。</p>
</li>
<li><p>将 1’ 节点作为结果返回即可。</p>
</li>
</ol>
<p>哈希表增删改查的操作时间复杂度都是 O(1)，普通方法一共只遍历链表两遍，所以普通解法的时间复杂度为 O(N)。因为使用了哈希表来保存原节点与副本节点的对应关系，所以额外空间复杂度为 O(N)。</p>
<p>具体过程请参看如下代码中的 copyListWithRand1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyListWithRand1</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    HashMap&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node, Node&gt;();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.put(cur, <span class="keyword">new</span> <span class="title class_">Node</span>(cur.value));</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.get(cur).next = map.get(cur.next);</span><br><span class="line">        map.get(cur).rand = map.get(cur.rand);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来介绍进阶解法，进阶解法不使用哈希表来保存对应关系，而只用有限的几个变量完成所有的功能。具体过程如下：</p>
<ol>
<li><p>从左到右遍历链表，对每个节点 cur 都复制生成相应的副本节点 copy，然后把 copy 放在 cur 和下一个遍历节点的中问。<br>例如：原链表 1-&gt;2-&gt;3-&gt;null，在步骤 1 完成后，原链表变成 1-&gt;1’-&gt;2-&gt;2’-&gt;3-&gt;3’-&gt;null。</p>
</li>
<li><p>再从左到右遍历链表，在遍历时设置每一个副本节点的 rand 指针。还是举例来说明调整过程。<br>例如：此时链表为 1-&gt;1’-&gt;2-&gt;2’-&gt;3-&gt;3’-&gt;null，假设 1 的 rand 指针指向 3，2 的 rand 指针指向 null，3 的 rand 指针指向 1。遍历到节点 1 时，节点 1 的下一个节点 1.next 就是其副本节点 1’。1 的 rand 指针指向 3，所以 1’ 的 rand 指针应该指向 3’。如何找到 3’ 呢？因为每个节点的副本节点都在自己的后一个，所以此时通过 3.next 就可以找到 3’，令 1’.rand=3’ 即可。以这种方式可以设置每一个副本节点的 rand 指针。</p>
</li>
<li><p>步骤 2 完成后，节点 1, 2, 3, ……之间的 rand 关系没有任何变化，节点 1’, 2’, 3’……之间的 rand 关系也被正确设置了，此时所有的节点与副本节点串在一起，将其分离出来即可。<br>例如：此时链表为 1-&gt;1’-&gt;2-&gt;2’-&gt;3-&gt;3’-&gt;null，分离成 1-&gt;2-&gt;3-&gt;null 和 1’-&gt;2’-&gt;3’-&gt;null 即可，并且在这一步中，每个节点的 rand 指针不用做任何调整，在步骤 2 中都已经设置好。</p>
</li>
<li><p>将 1’ 节点作为结果返回即可。</p>
</li>
</ol>
<p>进阶解法考查的依然是利用有限几个变量完成链表调整的代码实现能力。具体过程请参看如下代码中的 copyListWithRand2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyListWithRand2</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 复制并链接每一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        next = cur.next;</span><br><span class="line">        cur.next = <span class="keyword">new</span> <span class="title class_">Node</span>(cur.value);</span><br><span class="line">        cur.next.next = next;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">curCopy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 设置复制节点的 rand 指针</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        next = cur.next.next;</span><br><span class="line">        curCopy = cur.next;</span><br><span class="line">        curCopy.rand = cur.rand != <span class="literal">null</span> ? cur.rand.next : <span class="literal">null</span>;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">res</span> <span class="operator">=</span> head.next;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="comment">// 拆分</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        next = cur.next.next;</span><br><span class="line">        curCopy = cur.next;</span><br><span class="line">        cur.next = next;</span><br><span class="line">        curCopy.next = next != <span class="literal">null</span> ? next.next : <span class="literal">null</span>;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两个单链表生成相加链表"><a href="#两个单链表生成相加链表" class="headerlink" title="两个单链表生成相加链表"></a>两个单链表生成相加链表</h2><p><strong>题目</strong></p>
<p>假设链表中每一个节点的值都在 0~9 之间，那么链表整体就可以代表一个整数。<br>例如：9-&gt;3-&gt;7，可以代表整数 937。<br>给定两个这种链表的头节点 head1 和 head2，请生成代表两个整数相加值的结果链表。<br>例如：链表 1 为 9-&gt;3-&gt;7，链表 2 为 6-&gt;3，最后生成新的结果链表为 1-&gt;0-&gt;0-&gt;0。</p>
<p><strong>解答</strong></p>
<p>这道题难度较低，考查面试者基本的代码实现能力。一种实现方式是将两个链表先算出各自所代表的整数，然后求出两个整数的和，最后将这个和转换成链表的形式，但是这种方法有一个很大的问题，链表的长度可以很长，可以表达一个很大的整数。因此，转成系统中的 int 类型时可能会溢出，所以不推荐这种方法。</p>
<p>方法一：利用栈结构求解。</p>
<ol>
<li>将两个链表分别从左到右遍历，遍历过程中将值压栈，这样就生成了两个链表节点值的逆序栈，分别表示为 s1 和 s2。<br>例如：链表 9-&gt;3-&gt;7，s1 从栈顶到栈底为 7，3，9；链表 6-&gt;3，s2 从栈顶到栈底为 3，6。</li>
<li>将 s1 和 s2 同步弹出，这样就相当于两个链表从低位到高位依次弹出，在这个过程中生成相加链表即可，同时需要关注每一步是否有进位，用 ca 表示。<br>例如：s1 先弹出 7，s2 先弹出 3，这一步相加结果为 10，产生了进位，令 ca=1，然后生成一个节点值为 0 的新节点，记为 new1；s1 再弹出 3，s2 再弹出 6，这时进位为 ca=1，所以这一步相加结果为 10，继续产生进位，仍令 ca=1，然后生成一个节点值为 0 的新节点，记为 new2，令 new2.next=new1；s1 再弹出 9，s2 为空，这时 ca=1，这一步相加结果为 10，仍令 ca=1，然后生成一个节点值为 0 的新节点，记为 new3，令 new3.next=new2。这一步也是模拟简单的从低位到高位进位相加的过程。</li>
<li>当 s1 和 s2 都为空时，还要关注一下进位信息是否为 1，如果为 1，比如步骤 2 中的例子，表示还要生成一个节点值为 1 的新节点，记为 new4，令 new4.next=new3。</li>
<li>返回新生成的结果链表即可。<br>具体过程请参看如下代码中的 addLists1 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">addLists1</span><span class="params">(Node head1, Node head2)</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        s1.push(head1.value);</span><br><span class="line">        head1 = head1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        s2.push(head2.value);</span><br><span class="line">        head2 = head2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ca</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!s1.isEmpty() || !s2.isEmpty()) &#123;</span><br><span class="line">        n1 = s1.isEmpty() ? <span class="number">0</span> : s1.pop();</span><br><span class="line">        n2 = s2.isEmpty() ? <span class="number">0</span> : s2.pop();</span><br><span class="line">        n = n1 + n2 + ca;</span><br><span class="line">        pre = node;</span><br><span class="line">        node = <span class="keyword">new</span> <span class="title class_">Node</span>(n % <span class="number">10</span>);</span><br><span class="line">        node.next = pre;</span><br><span class="line">        ca = n / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ca == <span class="number">1</span>) &#123;</span><br><span class="line">        pre = node;</span><br><span class="line">        node = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">        node.next = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：利用链表的逆序求解，可以节省用栈的空间。</p>
<ol>
<li>将两个链表逆序，这样就可以依次得到从低位到高位的数字。<br>例如：链表 9-&gt;3-&gt;7，逆序后变为 7-&gt;3-&gt;9；链表 6-&gt;3，逆序后变为 3-&gt;6。</li>
<li>同步遍历两个逆序后的链表，这样就依次得到两个链表从低位到高位的数字，在这个过程中生成相加链表即可，同时需要关注每一步是否有进位，用 ca 表示。具体过程与方法一的步骤 2 相同。</li>
<li>当两个链表都遍历完成后，还要关注进位信息是否为 1，如果为 1，还要生成一个节点值为 1 的新节点。</li>
<li>将两个逆序的链表再逆序一次，即调整成原来的样子。</li>
<li>返回新生成的结果链表。<br>具体过程请参看如下代码中的 addLists2 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">addLists2</span><span class="params">(Node head1, Node head2)</span> &#123;</span><br><span class="line">    head1 = reverseList(head1);</span><br><span class="line">    head2 = reverseList(head2);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ca</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">c1</span> <span class="operator">=</span> head1;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">c2</span> <span class="operator">=</span> head2;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (c1 != <span class="literal">null</span> || c2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        n1 = c1 != <span class="literal">null</span> ? c1.value : <span class="number">0</span>;</span><br><span class="line">        n2 = c2 != <span class="literal">null</span> ? c2.value : <span class="number">0</span>;</span><br><span class="line">        n = n1 + n2 + ca;</span><br><span class="line">        pre = node;</span><br><span class="line">        node = <span class="keyword">new</span> <span class="title class_">Node</span>(n % <span class="number">10</span>);</span><br><span class="line">        node.next = pre;</span><br><span class="line">        ca = n / <span class="number">10</span>;</span><br><span class="line">        c1 = c1 != <span class="literal">null</span> ? c1.next : <span class="literal">null</span>;</span><br><span class="line">        c2 = c2 != <span class="literal">null</span> ? c2.next : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ca == <span class="number">1</span>) &#123;</span><br><span class="line">        pre = node;</span><br><span class="line">        node = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">        node.next = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    reverseList(head1);</span><br><span class="line">    reverseList(head2);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">reverseList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两个单链表相交的一系列问题"><a href="#两个单链表相交的一系列问题" class="headerlink" title="两个单链表相交的一系列问题"></a>两个单链表相交的一系列问题</h2><p><strong>题目</strong></p>
<p>在本题中，单链表可能有环，也可能无环。给定两个单链表的头节点 head1 和 head2，这两个链表可能相交，也可能不相交。请实现一个函数，如果两个链表相交，请返回相交的第一个节点；如果不相交，返回 null 即可。</p>
<p>要求：如果链表 1 的长度为 N，链表 2 的长度为 M，时间复杂度请达到 O(N+M)，额外空间复杂度请达到 O(1)。</p>
<p><strong>解答</strong></p>
<p>这道题需要分析的情况非常多，同时因为有额外空间复杂度为 O(1) 的限制，所以实现起来也比较困难。</p>
<p>本题可以拆分成三个子问题，每个问题都可以作为一道独立的算法题，具体如下。<br>问题一：如何判断一个链表是否有环，如果有，则返回第一个进入环的节点，没有则返回 null。<br>问题二：如何判断两个无环链表是否相交，相交则返回第一个相交节点，不相交则返回 null。<br>问题三：如何判断两个有环链表是否相交，相交则返回第一个相交节点，不相交则返回 null。<br>注意：如果一个链表有环，另外一个链表无环，它们是不可能相交的，直接返回 null。</p>
<p>下面逐一分析每个问题。</p>
<p><strong>问题一：如何判断一个链表是否有环，如果有，则返回第一个进入环的节点，没有则返回 null。</strong></p>
<p>如果一个链表没有环，那么遍历链表一定可以遇到链表的终点；如果链表有环，那么遍历链表就永远在环里转下去了。如何找到第一个入环节点，具体过程如下：</p>
<ol>
<li>设置一个慢指针 slow 和一个快指针 fast。在开始时，slow 和 fast 都指向链表的头节点 head。然后 slow 每次移动一步，fast 每次移动两步，在链表中遍历起来。</li>
<li>如果链表无环，那么 fast 指针在移动过程中一定先遇到终点，一旦 fast 到达终点，说明链表是没有环的，直接返回 null，表示该链表无环，当然也没有第一个入环的节点。</li>
<li>如果链表有环，那么 fast 指针和 slow 指针一定会在环中的某个位置相遇，当 fast 和 slow 相遇时，fast 指针重新回到 head 的位置，slow 指针不动。接下来，fast 指针从每次移动两步改为每次移动一步，slow 指针依然每次移动一步，然后继续遍历。</li>
<li>fast 指针和 slow 指针一定会再次相遇，并且在第一个入环的节点处相遇。证明略。<br>注意：你也可以用哈希表完成问题一的判断，但是不符合题目关于空间复杂度的要求。</li>
</ol>
<p>问题一的具体实现请参看如下代码中的 getLoopNode 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">getLoopNode</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">n1</span> <span class="operator">=</span> head.next; <span class="comment">// n1 -&gt; slow</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">n2</span> <span class="operator">=</span> head.next.next; <span class="comment">// n2 -&gt; fast</span></span><br><span class="line">    <span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n2.next == <span class="literal">null</span> || n2.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n2 = n2.next.next;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    n2 = head; <span class="comment">// n2 -&gt; walk again from head</span></span><br><span class="line">    <span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">        n2 = n2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果解决了问题一，我们就知道了两个链表有环或者无环的情况。如果一个链表有环，另一个链表无环，那么这两个链表是无论如何也不可能相交的。能相交的情况就分为两种，一种是两个链表都无环，即问题二；另一种是两个链表都有环，即问题三。</p>
<p><strong>问题二：如何判断两个无环链表是否相交，相交则返回第一个相交节点，不相交则返回 null。</strong></p>
<p>如果两个无环链表相交，那么从相交节点开始，一直到两个链表终止的这一段，是两个链表共享的。解决问题二的具体过程如下：</p>
<ol>
<li>链表 1 从头节点开始，走到最后一个节点（不是结束），统计链表 1 的长度记为 len1，同时记录链表 1 的最后一个节点记为 end1。</li>
<li>链表 2 从头节点开始，走到最后一个节点（不是结束），统计链表 2 的长度记为 len2，同时记录链表 2 的最后一个节点记为 end2。</li>
<li>如果 end1 != end2，说明两个链表不相交，返回 null 即可；如果 end1 == end2，说明两个链表相交，进入步骤 4 来寻找第一个相交节点。</li>
<li>如果链表 1 比较长，链表 1 就先走 len1-len2 步；如果链表 2 比较长，链表 2 就先走 len2-len1 步。然后两个链表一起走，一起走的过程中，两个链表第一次走到一起的那个节点就是第一个相交的节点。<br>例如：链表 1 长度为 100，链表 2 长度为 30，如果已经由步骤 3 确定了链表 1 和链表 2 一定相交，那么接下来，链表 1 先走 70 步，然后链表 1 和链表 2 一起走，它们一定会共同进入第一个相交的节点。</li>
</ol>
<p>问题二的具体实现请参看如下代码中的 noLoop 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">noLoop</span><span class="params">(Node head1, Node head2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="literal">null</span> || head2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur1</span> <span class="operator">=</span> head1;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur2</span> <span class="operator">=</span> head2;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur1.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        n++;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cur2.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        n--;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur1 != cur2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">    cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">    n = Math.abs(n);</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        n--;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题三：如何判断两个有环链表是否相交，相交则返回第一个相交节点，不相交则返回 null。</strong></p>
<p>考虑问题三的时候，我们已经得到了两个链表各自的第一个入环节点，假设链表 1 的第一个入环节点记为 loop1，链表 2 的第一个入环节点记为 loop2。以下是解决问题三的过程。</p>
<ol>
<li>如果 loop1 == loop2，那么两个链表的拓扑结构如图 2-8 所示。<br>这种情况，我们只要考虑链表 1 从头开始到 loop1 这一段与链表 2 从头开始到 loop2 这一段，在哪里第一次相交即可，而不用考虑进环该怎么处理，这就与问题二类似，只不过问题二是把 null 作为一个链表的终点，而这里是把 loop1(loop2) 作为链表的终点。但是判断的主要过程是相同的。</li>
<li>如果 loop1 != loop2，两个链表不相交的拓扑结构如图 2-9 所示。两个链表相交的拓扑结构如图 2-10 所示。</li>
</ol>
<p>如何分辨是这两中拓扑结构的哪一种呢？进入步骤 3。</p>
<ol>
<li>让链表 1 从 loop1 出发，因为 loop1 和之后的所有节点都在环上，所以将来一定能回到 loop1。如果回到 loop1 之前并没有遇到 loop2，说明两个链表的拓扑结构如图 2-9 所示，也就是不相交，直接返回 null；如果回到 loop1 之前遇到了 loop2，说明两个链表的拓扑结构如图 2-10 所示，也就是相交。因为 loop1 和 loop2 都在两条链表上，只不过 loop1 是离链表 1 较近的节点，loop2 是离链表 2 较近的节点。所以，此时返回 loop1 或 loop2 都可以。</li>
</ol>
<p>问题三的具体实现参看如下代码中的 bothLoop 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">bothLoop</span><span class="params">(Node head1, Node loop1, Node head2, Node loop2)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (loop1 == loop2) &#123;</span><br><span class="line">        cur1 = head1;</span><br><span class="line">        cur2 = head2;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur2 != loop2) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur1 = loop1.next;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur1 == loop2) &#123;</span><br><span class="line">                <span class="keyword">return</span> loop1;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全部过程参看如下代码中的 getIntersectNode 方法，这也是整个题目的主方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">getIntersectNode</span><span class="params">(Node head1, Node head2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="literal">null</span> || head2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">loop1</span> <span class="operator">=</span> getLoopNode(head1);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">loop2</span> <span class="operator">=</span> getLoopNode(head2);</span><br><span class="line">    <span class="keyword">if</span> (loop1 == <span class="literal">null</span> &amp;&amp; loop2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> noLoop(head1, head2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (loop1 != <span class="literal">null</span> &amp;&amp; loop2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> bothLoop(head1, loop1, head2, loop2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将单链表的每-K-个节点之间逆序"><a href="#将单链表的每-K-个节点之间逆序" class="headerlink" title="将单链表的每 K 个节点之间逆序"></a>将单链表的每 K 个节点之间逆序</h2><p><strong>题目</strong></p>
<p>给定一个单链表的头节点 head，实现一个调整单链表的函数，使得每 K 个节点之间逆序，如果最后不够 K 个节点一组，则不调整最后几个节点。</p>
<p>例如：<br>链表：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;null, K=3。<br>调整后为：3-&gt;2-&gt;1-&gt;6-&gt;5-&gt;4-&gt;7-&gt;8-&gt;null。其中 7、8 不调整，因为不够一组。</p>
<p><strong>解答</strong></p>
<p>首先，如果 K 的值小于 2，不用进行任何调整。因为 K&lt;1 没有意义，K==1 时，代表每 1 个节点为 1 组进行逆序，原链表也没有任何变化。接下来介绍两种方法，如果链表长度为 N，方法一的时间复杂度为 O(N)，额外空间复杂度为 O(K)。方法二的时间复杂度为 O(N)，额外空间复杂度为 O(1)。本题考查面试者代码实现不出错的能力。</p>
<p>方法一：利用栈结构的解法。</p>
<ol>
<li>从左到右遍历链表，如果栈的大小不等于 K，就将节点不断压入栈中。</li>
<li>当栈的大小第一次到达 K 时，说明第一次凑齐了 K 个节点进行逆序，从栈中依次弹出这些节点，并根据弹出的顺序重新连接，这一组逆序完成后，需要记录一下新的头部，同时第一组的最后一个节点（原来是头节点）应该连接下一个节点。</li>
<li>步骤 2 之后，当栈的大小每次到达 K 时，说明又凑齐了一组应该进行逆序的节点，从栈中依次弹出这些节点，并根据弹出的顺序重新连接。这一组逆序完成后，该组的第一个节点（原来是该组最后一个节点）应该被上一组的最后一个节点连接上，这一组的最后一个节点（原来是该组第一个节点）应该连接下一个节点。然后继续去凑下一组，直到链表都被遍历完。</li>
<li>最后应该返回 newHead，作为链表新的头节点。</li>
</ol>
<p>方法一的具体实现请参看如下代码中的 reverseKNodes1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">reverseKNodes1</span><span class="params">(Node head, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (K &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Node&gt;();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">newHead</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        next = cur.next;</span><br><span class="line">        stack.push(cur);</span><br><span class="line">        <span class="keyword">if</span> (stack.size() == K) &#123;</span><br><span class="line">            pre = resign1(stack, pre, next);</span><br><span class="line">            newHead = newHead == head ? cur : newHead;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">resign1</span><span class="params">(Stack&lt;Node&gt; stack, Node left, Node right)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">        left.next = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        next = stack.pop();</span><br><span class="line">        cur.next = next;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.next = right;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：不需要栈结构，在原链表中直接调整。<br>用变量记录每一组开始的第一个节点和最后一个节点，然后直接逆序调整，把这一组的节点都逆序。和方法一一样，同样需要注意第一组节点的特殊处理，以及之后的每个组在逆序重连之后，需要让该组的第一个节点（原来是最后一个节点）被之前组的最后一个节点连接上，将该组的最后一个节点（原来是第一个节点）连接下一个节点。</p>
<p>方法二的具体实现请参看如下代码中的 reverseKNodes2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">reverseKNodes2</span><span class="params">(Node head, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (K &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        next = cur.next;</span><br><span class="line">        <span class="keyword">if</span> (count == K) &#123;</span><br><span class="line">            start = pre == <span class="literal">null</span> ? head : pre.next;</span><br><span class="line">            head = pre == <span class="literal">null</span> ? cur : head;</span><br><span class="line">            resign2(pre, start, cur, next);</span><br><span class="line">            pre = start;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resign2</span><span class="params">(Node left, Node start, Node end, Node right)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> start;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> start.next;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != right) &#123;</span><br><span class="line">        next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">        left.next = end;</span><br><span class="line">    &#125;</span><br><span class="line">    start.next = right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除无序单链表中值重复出现的节点"><a href="#删除无序单链表中值重复出现的节点" class="headerlink" title="删除无序单链表中值重复出现的节点"></a>删除无序单链表中值重复出现的节点</h2><p><strong>题目</strong></p>
<p>给定一个无序单链表的头节点 head，删除其中值重复出现的节点。</p>
<p>例如：1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;2-&gt;1-&gt;1-&gt;null，删除值重复的节点之后为 1-&gt;2-&gt;3-&gt;4-&gt;null。</p>
<p>请按以下要求实现两种方法。<br>方法 1：如果链表长度为 N，时间复杂度达到 O(N)。<br>方法 2：额外空间复杂度为 O(1)。</p>
<p><strong>解答</strong></p>
<p>方法一：利用哈希表。时间复杂度为 O(N)，额外空间复杂度为 O(N)。<br>具体过程如下：</p>
<ol>
<li>生成一个哈希表，因为头节点是不用删除的节点，所以首先将头节点的值放入哈希表。</li>
<li>从头节点的下一个节点开始往后遍历节点，假设当前遍历到 cur 节点，先检查 cur 的值是否在哈希表中，如果在，则说明 cur 节点的值是之前出现过的，就将 cur 节点删除，删除的方式是将最近一个没有被删除的节点 pre 连接到 cur 的下一个节点，即 pre.next=cur.next。如果不在，将 cur 节点的值加入哈希表，同时令 pre=cur，即更新最近一个没有被删除的节点。</li>
</ol>
<p>方法一的具体实现请参看如下代码中的 removeRep1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeRep1</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">    set.add(head.value);</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(cur.value)) &#123;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set.add(cur.value);</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：类似选择排序的过程，时间复杂度为 O(N^2)，额外空间复杂度为 O(1)。<br>例如，链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;2-&gt;1-&gt;1-&gt;null。<br>首先是头节点，节点值为 1，往后检查所有值为 1 的节点，全部删除。链表变为：<br>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;2-&gt;null。<br>然后是第二个节点，节点值为 2，往后检查所有值为 2 的节点，全部删除。链表变为：<br>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;null。<br>接着是第三个节点，节点值为 3，往后检查所有值为 3 的节点，全部删除。链表变为：<br>1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;null。<br>最后是第四个节点，节点值为 4，往后检查所有值为 4 的节点，全部删除。链表变为：<br>1-&gt;2-&gt;3-&gt;4-&gt;null。<br>删除过程结束。</p>
<p>方法二的具体实现请参看如下代码中的 removeRep2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeRep2</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        pre = cur;</span><br><span class="line">        next = cur.next;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.value == next.value) &#123;</span><br><span class="line">                pre.next = next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = next;</span><br><span class="line">            &#125;</span><br><span class="line">            next = next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在单链表中删除指定值的节点"><a href="#在单链表中删除指定值的节点" class="headerlink" title="在单链表中删除指定值的节点"></a>在单链表中删除指定值的节点</h2><p><strong>题目</strong></p>
<p>给定一个链表的头节点 head 和一个整数 num，请实现函数将值为 num 的节点全部删除。<br>例如，链表为 1-&gt;2-&gt;3-&gt;4-&gt;null, num=3，链表调整后为：1-&gt;2-&gt;4-&gt;null。</p>
<p><strong>解答</strong></p>
<p>方法一：利用栈或者其他容器收集节点的方法。时间复杂度为 O(N)，额外空间复杂度为 O(N)。<br>将值不等于 num 的节点用栈收集起来，收集完成后重新连接即可。最后将栈底的节点作为新的头节点返回，具体过程请参看如下代码中的 removeValue1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">removeValue1</span><span class="params">(Node head, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.value != num) &#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        stack.peek().next = head;</span><br><span class="line">        head = stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：不用任何容器而直接调整的方法。时间复杂度为 O(N)，额外空间复杂度为 O(1)。<br>首先从链表头开始，找到第一个值不等于 num 的节点，作为新的头节点，这个节点是肯定不用删除的，记为 newHead。继续往后遍历，假设当前节点为 cur，如果 cur 节点值等于 num，就将 cur 节点删除，删除的方式是将之前最近一个值不等于 num 的节点 pre 连接到 cur 的下一个节点，即 pre.next=cur.next；如果 cur 节点值不等于 num，就令 pre=cur，即更新最近一个值不等于 num 的节点。<br>具体实现过程请参看如下代码中的 removeValue2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">removeValue2</span><span class="params">(Node head, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.value != num) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.value == num) &#123;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将搜索二叉树转换成双向链表"><a href="#将搜索二叉树转换成双向链表" class="headerlink" title="将搜索二叉树转换成双向链表"></a>将搜索二叉树转换成双向链表</h2><p><strong>题目</strong></p>
<p>对二叉树的节点来说，有本身的值域，有指向左孩子节点和右孩子节点的两个指针；对双向链表的节点来说，有本身的值域，有指向下一个节点和上一个节点的指针。在结构上，两种结构有相似性，现在有一棵搜索二叉树，请将其转换为一个有序的双向链表。</p>
<p>例如，节点定义为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一棵搜索二叉树如图 2-11 所示。<br>这棵搜索二叉树转换后的双向链表从头到尾依次是 1~9。对每一个节点来说，原来的 right 指针等价于转换后的 next 指针，原来的 left 指针等价于转换后的 last 指针，最后返回转换后的双向链表头节点。</p>
<p><strong>解答</strong></p>
<p>方法一：用队列等容器收集二叉树中序遍历结果的方法。时间复杂度为 O(N)，额外空间复杂度为 O(N)。<br>具体过程如下：</p>
<ol>
<li>生成一个队列，记为 queue，按照二叉树中序遍历的顺序，将每个节点放入 queue 中。</li>
<li>从 queue 中依次弹出节点，并按照弹出的顺序重连所有的节点即可。</li>
</ol>
<p>方法一的具体实现请参看如下代码中的 convert1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">convert1</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Node&gt;();</span><br><span class="line">    inOrderToQueue(head, queue);</span><br><span class="line">    <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    head = queue.poll();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    pre.left = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        cur = queue.poll();</span><br><span class="line">        pre.right = cur;</span><br><span class="line">        cur.left = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.right = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrderToQueue</span><span class="params">(Node head, Queue&lt;Node&gt; queue)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrderToQueue(head.left, queue);</span><br><span class="line">    queue.offer(head);</span><br><span class="line">    inOrderToQueue(head.right, queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：利用递归函数，除此之外，不使用任何容器的方法。时间复杂度为 O(N)，额外空间复杂度为 O(h)，h 为二叉树的高度。<br>实现递归函数 process。process 的输入参数是一棵二叉树的头节点 x，功能是将以 x 为头的搜索二叉树转换为一个有序双向链表。返回值是这个有序双向链表的头节点和尾节点，所以返回值的类型是一个复杂结构，就是如下的 ReturnType 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReturnType</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node start;</span><br><span class="line">    <span class="keyword">public</span> Node end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReturnType</span><span class="params">(Node start, Node end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体过程为先把以 x 为头的搜索二叉树的左子树转换为有序双向链表，并且返回左子树有序双向链表的头和尾，然后把以 x 为头的搜索二叉树的右子树转换为有序双向链表，并且返回右子树有序双向链表的头和尾，接着通过 x 把两部分分接起来即可。最后不要忘记，递归函数对任何节点的要求是一样的，所以要返回此时大的有序双向链表的头和尾。具体实现请参看如下代码中的 convert2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">convert2</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(head).start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ReturnType <span class="title function_">process</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnType</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ReturnType</span> <span class="variable">leftList</span> <span class="operator">=</span> process(head.left);</span><br><span class="line">    <span class="type">ReturnType</span> <span class="variable">rightList</span> <span class="operator">=</span> process(head.right);</span><br><span class="line">    <span class="keyword">if</span> (leftList.end != <span class="literal">null</span>) &#123;</span><br><span class="line">        leftList.end.right = head;</span><br><span class="line">    &#125;</span><br><span class="line">    head.left = leftList.end;</span><br><span class="line">    head.right = rightList.start;</span><br><span class="line">    <span class="keyword">if</span> (rightList.start != <span class="literal">null</span>) &#123;</span><br><span class="line">        rightList.start.left = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnType</span>(leftList.start != <span class="literal">null</span> ? leftList.start : head,</span><br><span class="line">            rightList.end != <span class="literal">null</span> ? rightList.end : head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于方法二中时间复杂度与空间复杂度的解释，可以用 process 递归函数发生的次数来估算时间复杂度，process 会处理所有的子树，子树的数量就是二叉树节点的个数。所以时间复杂度为 O(N)，process 递归函数最多占用二叉树高度为 h 的栈空间，所以额外空间复杂度为 O(h)。</p>
<p><strong>扩展</strong></p>
<p>本题在复杂度方面能够达到的程度完全取决于二叉树遍历的实现，如果一颗二叉树遍历的实现时间复杂度为 O(N)、额外空间复杂度为 O(1) 的遍历实现呢？也就是既不用栈，也不用递归函数，只用有限几个变量的实现？有。有兴趣的读者可阅读本书“遍历二叉树的神级方法”问题，然后结合神级的遍历方法重新实现这道题。有关方法二中递归函数的设计方法，我们在本书的二叉树章节还能进一步学习并形成固定的套路。</p>
<h2 id="单链表的选择排序"><a href="#单链表的选择排序" class="headerlink" title="单链表的选择排序"></a>单链表的选择排序</h2><p><strong>题目</strong></p>
<p>给定一个无序单链表的头节点 head，实现单链表的选择排序。</p>
<p>要求：额外空间复杂度为 O(1)。</p>
<p><strong>解答</strong></p>
<p>既然要求额外空间复杂度为 O(1)，就不能把链表装进数组等容器中进行排序，排好序之后再重新连接，而是要求面试者在原链表上利用有限几个变量完成选择排序的过程。选择排序是从未排序的部分中找到最小值，然后放在排好序部分的尾部，逐渐将未排序的部分缩小，最后全部变成排好序的部分。本书实现的方法模拟了这个过程。</p>
<ol>
<li>开始时默认整个链表都是未排序的部分，对于找到的第一个最小值节点，肯定是整个链表的最小值节点，将其设置为新的头节点，记为 newHead。</li>
<li>每次在未排序的部分中找到最小值的节点，然后把这个节点从未排序的链表中删除，删除的过程当然要保证未排序部分的链表在结构上不至于断开。例如，2-&gt;1-&gt;3，删除节点 1 之后，链表应该变成 2-&gt;3，这就要求我们应该找到要删除节点的前一个节点。</li>
<li>把删除的节点 (也就是每次的最小值节点) 连接到排好序部分的链表尾部。</li>
<li>全部过程处理完后，整个链表都已经有序，返回 newHead。</li>
</ol>
<p>和选择排序一样，如果链表的长度为 N，时间复杂度为 O(N^2)，额外空间复杂度为 O(1)。<br>本题依然是考查调整链表的代码技巧，具体过程请参看如下代码中的 selectionSort 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">selectionSort</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 排序部分尾部</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head; <span class="comment">// 未排序部分头部</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">smallPre</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 最小节点的前一个节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">small</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 最小的节点</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        small = cur;</span><br><span class="line">        smallPre = getSmallestPreNode(cur);</span><br><span class="line">        <span class="keyword">if</span> (smallPre != <span class="literal">null</span>) &#123;</span><br><span class="line">            small = smallPre.next;</span><br><span class="line">            smallPre.next = small.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur == small ? cur.next : cur;</span><br><span class="line">        <span class="keyword">if</span> (tail == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = small;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.next = small;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = small;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">getSmallestPreNode</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">smallPre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">small</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.value &lt; small.value) &#123;</span><br><span class="line">            smallPre = pre;</span><br><span class="line">            small = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> smallPre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一种怪异的节点删除方式"><a href="#一种怪异的节点删除方式" class="headerlink" title="一种怪异的节点删除方式"></a>一种怪异的节点删除方式</h2><p><strong>题目</strong></p>
<p>链表节点值类型为 int 型，给定一个链表中的节点 node，但不给定整个链表的头节点。如何在链表中删除 node？请实现这个函数，并分析这样会有出现哪些问题。</p>
<p>要求：时间复杂度为 O(1)。</p>
<p><strong>解答</strong></p>
<p>本题的思路很简单，举例就能说明具体的做法。<br>例如，链表 1-&gt;2-&gt;3-&gt;null，只知道要删除节点 2，而不知道头节点。那么只需把节点 2 的值变成节点 3 的值，然后在链表中删除节点 3 即可。</p>
<p>这道题目出现的次数很多，这么做看起来非常方便，但其实是有很大问题的。</p>
<p>问题一：这样的删除方式无法删除最后一个节点。还是以原示例来说明，如果知道要删除节点 3，而不知道头节点。但它是最后的节点，根本没有下一个节点来代替节点 3 被删除，那么只有让节点 2 的 next 指向 null 这一种办法，而我们又根本找不到节点 2，所以根本没法正确删除节点 3。读者可能会问，我们能不能把节点 3 在内存上的区域变成 null 呢？这样不就相当于让节点 2 的 next 指针指向了 null，起到节点 3 被删除的效果了吗？不可以。null 在系统中是一个特定的区域，如果想让节点 2 的 next 指针指向 null，必须找到节点 2。</p>
<p>问题二：这种删除方式在本质上根本就不是删除了 node 节点，而是把 node 节点的值改变，然后删除 node 的下一个节点，在实际的工程中可能会带来很大问题。比如，工程上的一个节点可能代表很复杂的结构，节点值的复制会相当复杂，或者可能改变节点值这个操作都是被禁止的；再如，工程上的一个节点代表提供服务的一个服务器，外界对每个节点都有很多依赖，比如，示例中删除节点 2 时，其实影响了节点 3 对外提供的服务。</p>
<p>这种删除方式的具体过程请参看如下代码中的 removeNodeWired 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeNodeWired</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;can not remove last node.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    node.value = next.value;</span><br><span class="line">    node.next = next.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="向有序的环形单链表中插入新节点"><a href="#向有序的环形单链表中插入新节点" class="headerlink" title="向有序的环形单链表中插入新节点"></a>向有序的环形单链表中插入新节点</h2><p><strong>题目</strong></p>
<p>一个环形单链表从头节点 head 开始不降序，同时由最后的节点指回头节点。给定这样一个环形单链表的头节点 head 和一个整数 num，请生成节点值为 num 的新节点，并插入到这个环形链表中，保证调整后的链表依然有序。</p>
<p><strong>解答</strong></p>
<p>直接给出时间复杂度为 O(N)、额外空间复杂度为 O(1) 的方法。具体过程如下：</p>
<ol>
<li>生成节点值为 num 的新节点，记为 node。</li>
<li>如果链表为空，让 node 自己组成环形链表，然后直接返回 node。</li>
<li>如果链表不为空，令变量 pre=head，cur=head.next，然后令 pre 和 cur 同步移动下去，如果遇到 pre 的节点值小于或等于 num，并且 cur 的节点值大于或等于 num，说明 node 应该在 pre 节点和 cur 节点之间插入，插入 node，然后返回 head 即可。例如，链表 1-&gt;3-&gt;4-&gt;1-&gt;…，num=2。应该把节点值为 2 的节点插入到 1 和 3 之间，然后返回头节点。</li>
<li>如果 pre 和 cur 转了一圈，这期间都没有发现步骤 3 所说的情况，说明 node 应该插入到头节点的前面，这种情况之所以会发生，要么是因为 node 节点的值比链表中每个节点的值都大，要么是因为 node 的值比链表中每个节点的值都小。<br>分别举两个例子：示例 1，链表 1-&gt;3-&gt;4-&gt;1-&gt;…，num=5，应该把节点值为 5 的节点插入到节点 1 的前面；示例 2，链表 1-&gt;3-&gt;4-&gt;1-&gt;…，num=0，也应该把节点值为 0 的节点插入到节点 1 的前面。</li>
<li>如果 node 节点的值比链表中每个节点的值都大，返回原来的头节点即可；如果 node 节点的值比链表中每个节点的值都小，应该把 node 作为链表新的头节点返回。</li>
</ol>
<p>具体过程请参看如下代码中的 insertNum 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">insertNum</span><span class="params">(Node head, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(num);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        node.next = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span> (cur != head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre.value &lt;= num &amp;&amp; cur.value &gt;= num) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = node;</span><br><span class="line">    node.next = cur;</span><br><span class="line">    <span class="keyword">return</span> head.value &lt; num ? head : node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合并两个有序的单链表"><a href="#合并两个有序的单链表" class="headerlink" title="合并两个有序的单链表"></a>合并两个有序的单链表</h2><p><strong>题目</strong></p>
<p>给定两个有序单链表的头节点 head1 和 head2，请合并两个有序链表，合并后的链表依然有序，并返回合并后链表的头节点。</p>
<p>例如：<br>0-&gt;2-&gt;3-&gt;7-&gt;null<br>1-&gt;3-&gt;5-&gt;7-&gt;9-&gt;null<br>合并后的链表为：0-&gt;1-&gt;2-&gt;3-&gt;3-&gt;5-&gt;7-&gt;7-&gt;9-&gt;null</p>
<p><strong>解答</strong></p>
<p>本题比较简单，假设两个链表的长度分别为 M 和 N，直接给出时间复杂度为 O(M+N)、额外空间复杂度为 O(1) 的方法。具体过程如下：</p>
<ol>
<li>如果两个链表中有一个为空，说明无须合并过程，返回另一个链表的头节点即可。</li>
<li>比较 head1 和 head2 的值，小的节点也是合并后链表的最小节点，这个节点无疑应该是合并链表的头节点，记为 head；在之后的步骤里，哪个链表的头节点的值更小，另一个链表的所有节点都会依次插入到这个链表中。</li>
<li>不妨设 head 节点所在的链表为链表 1，另一个链表为链表 2。链表 1 和链表 2 都从头部开始一起遍历，比较每次遍历到的两个节点的值，记为 cur1 和 cur2，然后根据大小关系做出不同的调整，同时用一个变量 pre 表示上次比较时值较小的节点。<br>例如，链表 1 为 1-&gt;5-&gt;6-&gt;null，链表 2 为 2-&gt;3-&gt;7-&gt;null。<br>cur1=1, cur2=2, pre=null。cur1 小于 cur2，不做调整，因为此时 cur1 较小，所以令 pre=cur1=1，然后继续遍历链表 1 的下一个节点，也就是节点 5。<br>cur1=5, cur2=2, pre=1。cur2 小于 cur1，让 pre 的 next 指针指向 cur2，cur2 的 next 指针指向 cur1，这样，cur2 便插入到链表 1 中。因为此时 cur2 较小，所以令 pre=cur2=2，然后继续遍历链表 2 的下一个节点，也就是节点 3。这一步完成后，链表 1 变为 1-&gt;2-&gt;5-&gt;6-&gt;null，链表 2 变为 3-&gt;7-&gt;null，cur1=5，cur2=3，pre=2。<br>cur1=5, cur2=3, pre=2。此时又是 cur2 较小，与上一步调整类似，这一步完成后，链表 1 变为 1-&gt;2-&gt;3-&gt;5-&gt;6-&gt;null，链表 2 为 7-&gt;null，cur1=5，cur2=7，pre=3。<br>cur1=5, cur2=7, pre=3。cur1 小于 cur2，不做调整，因为此时 cur1 较小，所以令 pre=cur1=5，然后继续遍历链表 1 的下一个节点，也就是节点 6。<br>cur1=6, cur2=7, pre=5。cur1 小于 cur2，不做调整，因为此时 cur1 较小，所以令 pre=cur1=6，此时已经走到链表 1 的最后一个节点，再往下就结束，如果链表 1 或链表 2 有任何一个走到了结束，就进入步骤 4。</li>
<li>如果链表 1 先走完，此时 cur1=null，pre 为链表 1 的最后一个节点，那么就把 pre 的 next 指针指向链表 2 当前的节点 (即 cur2)，表示把链表 2 没遍历到的有序部分直接拼接到最后，调整结束。如果链表 2 先走完，说明链表 2 的所有节点都已经插入到链表 1 中，调整结束。</li>
<li>返回合并后链表的头节点 head。</li>
</ol>
<p>全部过程请参看如下代码中的 merge 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">merge</span><span class="params">(Node head1, Node head2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="literal">null</span> || head2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head1 != <span class="literal">null</span> ? head1 : head2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> head1.value &lt; head2.value ? head1 : head2;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur1</span> <span class="operator">=</span> head == head1 ? head1 : head2;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur2</span> <span class="operator">=</span> head == head1 ? head2 : head1;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur1 != <span class="literal">null</span> &amp;&amp; cur2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur1.value &lt;= cur2.value) &#123;</span><br><span class="line">            pre = cur1;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next = cur2.next;</span><br><span class="line">            pre.next = cur2;</span><br><span class="line">            cur2.next = cur1;</span><br><span class="line">            pre = cur2;</span><br><span class="line">            cur2 = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = cur1 == <span class="literal">null</span> ? cur2 : cur1;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="按照左右半区的方式重新组合单链表"><a href="#按照左右半区的方式重新组合单链表" class="headerlink" title="按照左右半区的方式重新组合单链表"></a>按照左右半区的方式重新组合单链表</h2><p><strong>题目</strong></p>
<p>给定一个单链表的头部节点 head，链表长度为 N，如果 N 为偶数，那么前 N/2 个节点算作左半区，后 N/2 个节点算作右半区；如果 N 为奇数，那么前 N/2 个节点算作左半区，后 N/2+1 个节点算作右半区。左半区从左到右依次记为 L1-&gt;L2-&gt;…，右半区从左到右依次记为 R1-&gt;R2-&gt;…，请将单链表调整成 L1-&gt;R1-&gt;L2-&gt;R2-&gt;… 的形式。</p>
<p>例如：<br>1-&gt;null，调整为 1-&gt;null。<br>1-&gt;2-&gt;null，调整为 1-&gt;2-&gt;null。<br>1-&gt;2-&gt;3-&gt;null，调整为 1-&gt;2-&gt;3-&gt;null。<br>1-&gt;2-&gt;3-&gt;4-&gt;null，调整为 1-&gt;3-&gt;2-&gt;4-&gt;null。<br>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null，调整为 1-&gt;3-&gt;2-&gt;4-&gt;5-&gt;null。<br>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null，调整为 1-&gt;4-&gt;2-&gt;5-&gt;3-&gt;6-&gt;null。</p>
<p><strong>解答</strong></p>
<p>假设链表的长度为 N，直接给出时间复杂度为 O(N)、额外空间复杂度为 O(1) 的方法。具体过程如下：</p>
<ol>
<li>如果链表为空或长度为 1，不用调整，过程直接结束。</li>
<li>链表长度大于 1 时，遍历一遍找到左半区的最后一个节点，记为 mid。<br>例如：1-&gt;2，mid 为 1；1-&gt;2-&gt;3，mid 为 1；1-&gt;2-&gt;3-&gt;4，mid 为 2；1-&gt;2-&gt;3-&gt;4-&gt;5，mid 为 2；1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6，mid 为 3。也就是说，从长度为 2 开始，长度每增加 2，mid 就往后移动一个节点。</li>
<li>遍历一遍找到 mid 之后，将左半区与右半区分离成两个链表 (mid.next=null)，分别记为 left (head) 和 right (原来的 mid.next)。</li>
<li>将两个链表按照题目要求合并起来。</li>
</ol>
<p>具体过程请参看如下代码中的 relocate 方法，其中的 mergeLR 方法为步骤 4 的合并过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">relocate</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">mid</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">right</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span> (right.next != <span class="literal">null</span> &amp;&amp; right.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        mid = mid.next;</span><br><span class="line">        right = right.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    right = mid.next;</span><br><span class="line">    mid.next = <span class="literal">null</span>;</span><br><span class="line">    mergeLR(head, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeLR</span><span class="params">(Node left, Node right)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (left.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        next = right.next;</span><br><span class="line">        right.next = left.next;</span><br><span class="line">        left.next = right;</span><br><span class="line">        left = right.next;</span><br><span class="line">        right = next;</span><br><span class="line">    &#125;</span><br><span class="line">    left.next = right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树问题"><a href="#二叉树问题" class="headerlink" title="二叉树问题"></a>二叉树问题</h1><h2 id="分别用递归和非递归方式实现二叉树先序、中序和后序遍历"><a href="#分别用递归和非递归方式实现二叉树先序、中序和后序遍历" class="headerlink" title="分别用递归和非递归方式实现二叉树先序、中序和后序遍历"></a>分别用递归和非递归方式实现二叉树先序、中序和后序遍历</h2><p><strong>题目</strong><br>用递归和非递归方式，分别按照二叉树先序、中序和后序打印所有的节点。我们约定：先序遍历顺序为根、左、右；中序遍历顺序为左、根、右；后序遍历顺序为左、右、根。</p>
<p><strong>解答</strong><br>用递归方式实现三种遍历是教材上的基础内容，本书不再详述，直接给出代码实现。<br>先序遍历的递归实现请参看如下代码中的 <code>preOrderRecur</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrderRecur</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    preOrderRecur(head.left);</span><br><span class="line">    preOrderRecur(head.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中序遍历的递归实现请参看如下代码中的 <code>inOrderRecur</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrderRecur</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrderRecur(head.left);</span><br><span class="line">    System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    inOrderRecur(head.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后序遍历的递归实现请参看如下代码中的 <code>posOrderRecur</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">posOrderRecur</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    posOrderRecur(head.left);</span><br><span class="line">    posOrderRecur(head.right);</span><br><span class="line">    System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用递归方法解决的问题都能用非递归的方法实现。这是因为递归方法无非就是利用函数栈来保存信息，如果用自己申请的数据结构来代替函数栈，也可以实现相同的功能。<br>用非递归的方式实现二叉树的先序遍历，具体过程如下：</p>
<ol>
<li>申请一个新的栈，记为 <code>stack</code>。然后将头节点 <code>head</code> 压入 <code>stack</code> 中。</li>
<li>从 <code>stack</code> 中弹出栈顶节点，记为 <code>cur</code>，然后打印 <code>cur</code> 节点的值，再将节点 <code>cur</code> 的右孩子节点（不为空的话）先压入 <code>stack</code> 中，最后将 <code>cur</code> 的左孩子节点（不为空的话）压入 <code>stack</code> 中。</li>
<li>不断重复步骤 2，直到 <code>stack</code> 为空，全部过程结束。</li>
</ol>
<p>整个过程请参看如下代码中的 <code>preOrderUnRecur</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrderUnRecur</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;pre-order: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Node&gt;();</span><br><span class="line">        stack.add(head);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            head = stack.pop();</span><br><span class="line">            System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用非递归的方式实现二叉树的中序遍历，具体过程如下：</p>
<ol>
<li>申请一个新的栈，记为 <code>stack</code>。初始时，令变量 <code>cur = head</code>。</li>
<li>先把 <code>cur</code> 节点压入栈中，对以 <code>cur</code> 节点为头节点的整棵子树来说，依次把左边界压入栈中，即不停地令 <code>cur = cur.left</code>，然后重复步骤 2。</li>
<li>不断重复步骤 2，直到发现 <code>cur</code> 为空，此时从 <code>stack</code> 中弹出一个节点，记为 <code>node</code>。打印 <code>node</code> 的值，并且让 <code>cur = node.right</code>，然后继续重复步骤 2。</li>
<li>当 <code>stack</code> 为空且 <code>cur</code> 为空时，整个过程停止。</li>
</ol>
<p>全部过程请参看如下代码中的 <code>inOrderUnRecur</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrderUnRecur</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;in-order: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Node&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(head);</span><br><span class="line">                head = head.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head = stack.pop();</span><br><span class="line">                System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                head = head.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用非递归的方式实现二叉树的后序遍历有点麻烦，本书介绍以下两种方法供读者参考。<br>先介绍用两个栈实现后序遍历的过程，具体过程如下：</p>
<ol>
<li>申请一个栈，记为 <code>s1</code>，然后将头节点 <code>head</code> 压入 <code>s1</code> 中。</li>
<li>从 <code>s1</code> 中弹出的节点记为 <code>cur</code>，然后依次将 <code>cur</code> 的左孩子节点和右孩子节点压入 <code>s1</code> 中。</li>
<li>在整个过程中，每一个从 <code>s1</code> 中弹出的节点都放进 <code>s2</code> 中。</li>
<li>不断重复步骤 2 和步骤 3，直到 <code>s1</code> 为空，过程停止。</li>
<li>从 <code>s2</code> 中依次弹出节点并打印，打印的顺序就是后序遍历的顺序。</li>
</ol>
<p>使用两个栈实现后序遍历的全部过程请参看如下代码中的 <code>posOrderUnRecur1</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">posOrderUnRecur1</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;pos-order: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        Stack&lt;Node&gt; s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Node&gt;();</span><br><span class="line">        Stack&lt;Node&gt; s2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Node&gt;();</span><br><span class="line">        s1.push(head);</span><br><span class="line">        <span class="keyword">while</span> (!s1.isEmpty()) &#123;</span><br><span class="line">            head = s1.pop();</span><br><span class="line">            s2.push(head);</span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                s1.push(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                s1.push(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!s2.isEmpty()) &#123;</span><br><span class="line">            System.out.print(s2.pop().value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后介绍只用一个栈实现后序遍历的过程，具体过程如下。</p>
<ol>
<li>申请一个栈，记为 <code>stack</code>，将头节点压入 <code>stack</code>，同时设置两个变量 <code>h</code> 和 <code>c</code>。在整个流程中，<code>h</code> 代表最近一次弹出并打印的节点，<code>c</code> 代表 <code>stack</code> 的栈顶节点，初始时 <code>h</code> 为头节点，<code>c</code> 为 <code>null</code>。</li>
<li>每次令 <code>c</code> 等于当前 <code>stack</code> 的栈顶节点，但是不从 <code>stack</code> 中弹出，此时分以下三种情况。<br> ① 如果 <code>c</code> 的左孩子节点不为 <code>null</code>，并且 <code>h</code> 不等于 <code>c</code> 的左孩子节点，也不等于 <code>c</code> 的右孩子节点，则把 <code>c</code> 的左孩子节点压入 <code>stack</code> 中。<br> ② 如果条件①不成立，并且 <code>c</code> 的右孩子节点不为 <code>null</code>，<code>h</code> 不等于 <code>c</code> 的右孩子节点，则把 <code>c</code> 的右孩子节点压入 <code>stack</code> 中。<br> ③ 如果条件①和条件②都不成立，说明 <code>c</code> 的左子树和右子树都已经打印完毕，那么从 <code>stack</code> 中弹出 <code>c</code> 并打印，然后令 <code>h = c</code>。</li>
<li>一直重复步骤 2，直到 <code>stack</code> 为空，过程停止。</li>
</ol>
<p>只用一个栈实现后序遍历的全部过程请参看如下代码中的 <code>posOrderUnRecur2</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">posOrderUnRecur2</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;pos-order: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Node&gt;();</span><br><span class="line">        stack.push(head);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            c = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (c.left != <span class="literal">null</span> &amp;&amp; h != c.left &amp;&amp; h != c.right) &#123;</span><br><span class="line">                stack.push(c.left);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c.right != <span class="literal">null</span> &amp;&amp; h != c.right) &#123;</span><br><span class="line">                stack.push(c.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(stack.pop().value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                h = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="打印二叉树的边界节点"><a href="#打印二叉树的边界节点" class="headerlink" title="打印二叉树的边界节点"></a>打印二叉树的边界节点</h2><p><strong>题目</strong><br>给定一棵二叉树的头节点 <code>head</code>，按照如下两种标准分别实现二叉树边界节点的逆时针打印。</p>
<p>标准一：</p>
<ol>
<li>头节点为边界节点。</li>
<li>叶节点为边界节点。</li>
<li>如果节点在其所在的层中是最左的或最右的，那么该节点也是边界节点。</li>
</ol>
<p>标准二：</p>
<ol>
<li>头节点为边界节点。</li>
<li>叶节点为边界节点。</li>
<li>树左边界延伸下去的路径为边界节点。</li>
<li>树右边界延伸下去的路径为边界节点。</li>
</ol>
<p>例如，如图 3-2 所示的树。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   1</span><br><span class="line"> /   \</span><br><span class="line">2     3</span><br><span class="line"> \   / \</span><br><span class="line">  4 5   6</span><br><span class="line"> / \ \</span><br><span class="line">7   8 9 10</span><br><span class="line">   / \ \</span><br><span class="line">  11 12 16</span><br><span class="line"> / \ /</span><br><span class="line">13 14 15</span><br></pre></td></tr></table></figure>
<p>图 3-2</p>
<p>按标准一的打印结果为：1, 2, 4, 7, 11, 13, 14, 15, 16, 12, 10, 6, 3<br>按标准二的打印结果为：1, 2, 4, 7, 13, 14, 15, 16, 10, 6, 3</p>
<p><strong>要求</strong></p>
<ol>
<li>如果节点数为 N，两种标准实现的时间复杂度要求都为 O(N)，额外空间复杂度要求都为 O(h)，h 为二叉树的高度。</li>
<li>两种标准都要求逆时针顺序且不重复打印所有的边界节点。</li>
</ol>
<p><strong>解答</strong><br>按照标准一的要求实现打印的具体过程如下：</p>
<ol>
<li>得到二叉树每一层上最左和最右的节点。以题目的例子来说，这个记录如下：<br>第一层：最左 1，最右 1<br>第二层：最左 2，最右 3<br>第三层：最左 4，最右 6<br>第四层：最左 7，最右 10<br>第五层：最左 11，最右 12<br>第六层：最左 13，最右 16</li>
<li>从上到下打印所有层中的最左节点。对题目的例子来说，即打印：1, 2, 4, 7, 11, 13。</li>
<li>先序遍历二叉树，打印那些不属于某一层最左或最右的节点，但同时又是叶节点的节点。对题目的例子来说，即打印：14, 15。</li>
<li>从下到上打印所有层中的最右节点，但节点不能既是最左节点，又是最右节点。对题目的例子来说，即打印：16, 12, 10, 6, 3。</li>
</ol>
<p>按标准一打印的全部过程请参看如下代码中的 <code>printEdge1</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEdge1</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> getHeight(head, <span class="number">0</span>);</span><br><span class="line">    Node[][] edgeMap = <span class="keyword">new</span> <span class="title class_">Node</span>[height][<span class="number">2</span>];</span><br><span class="line">    setEdgeMap(head, <span class="number">0</span>, edgeMap);</span><br><span class="line">    <span class="comment">// 打印左边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != edgeMap.length; i++) &#123;</span><br><span class="line">        System.out.print(edgeMap[i][<span class="number">0</span>].value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印既不是左边界，也不是右边界的叶子节点</span></span><br><span class="line">    printLeafNotInMap(head, <span class="number">0</span>, edgeMap);</span><br><span class="line">    <span class="comment">// 打印右边界，但不是左边界的节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> edgeMap.length - <span class="number">1</span>; i != -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edgeMap[i][<span class="number">0</span>] != edgeMap[i][<span class="number">1</span>]) &#123;</span><br><span class="line">            System.out.print(edgeMap[i][<span class="number">1</span>].value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(Node h, <span class="type">int</span> l)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(getHeight(h.left, l + <span class="number">1</span>), getHeight(h.right, l + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEdgeMap</span><span class="params">(Node h, <span class="type">int</span> l, Node[][] edgeMap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    edgeMap[l][<span class="number">0</span>] = edgeMap[l][<span class="number">0</span>] == <span class="literal">null</span> ? h : edgeMap[l][<span class="number">0</span>];</span><br><span class="line">    edgeMap[l][<span class="number">1</span>] = h;</span><br><span class="line">    setEdgeMap(h.left, l + <span class="number">1</span>, edgeMap);</span><br><span class="line">    setEdgeMap(h.right, l + <span class="number">1</span>, edgeMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLeafNotInMap</span><span class="params">(Node h, <span class="type">int</span> l, Node[][] m)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h.left == <span class="literal">null</span> &amp;&amp; h.right == <span class="literal">null</span> &amp;&amp; h != m[l][<span class="number">0</span>] &amp;&amp; h != m[l][<span class="number">1</span>]) &#123;</span><br><span class="line">        System.out.print(h.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printLeafNotInMap(h.left, l + <span class="number">1</span>, m);</span><br><span class="line">    printLeafNotInMap(h.right, l + <span class="number">1</span>, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照标准二的要求实现打印的具体过程如下：</p>
<ol>
<li>从头节点开始往下寻找，只要找到第一个既有左孩子节点，又有右孩子节点的节点，记为 <code>h</code>，则进入步骤 2。在这个过程中，找过的节点都打印。对题目的例子来说，即打印：1，因为头节点直接符合要求，所以打印后没有后续的寻找过程，直接进入步骤 2。但如果二叉树如图 3-3 所示，此时则打印：1, 2, 3。节点 3 是从头节点开始往下第一个符合要求的。如果二叉树从上到下一直找到叶节点也不存在符合要求的节点，则说明二叉树是棒状结构，那么打印找过的节点后直接返回即可。</li>
<li><code>h</code> 的左子树先进入步骤 3 的打印过程；<code>h</code> 的右子树再进入步骤 4 的打印过程；最后返回。</li>
<li>打印左边界的延伸路径，以及 <code>h</code> 左子树上所有的叶节点，具体请参看如下代码中的 <code>printLeftEdge</code> 方法。</li>
<li>打印右边界的延伸路径以及 <code>h</code> 右子树上所有的叶节点，具体请参看如下代码中的 <code>printRightEdge</code> 方法。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">    /</span><br><span class="line">  null</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 4   5</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>
<p>图 3-3</p>
<p>按标准二打印的全部过程请参看如下代码中的 <code>printEdge2</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEdge2</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (head.left != <span class="literal">null</span> &amp;&amp; head.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        printLeftEdge(head.left, <span class="literal">true</span>);</span><br><span class="line">        printRightEdge(head.right, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        printEdge2(head.left != <span class="literal">null</span> ? head.left : head.right);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLeftEdge</span><span class="params">(Node h, <span class="type">boolean</span> print)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (print || (h.left == <span class="literal">null</span> &amp;&amp; h.right == <span class="literal">null</span>)) &#123;</span><br><span class="line">        System.out.print(h.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printLeftEdge(h.left, print);</span><br><span class="line">    printLeftEdge(h.right, print &amp;&amp; h.left == <span class="literal">null</span> ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printRightEdge</span><span class="params">(Node h, <span class="type">boolean</span> print)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printRightEdge(h.left, print &amp;&amp; h.right == <span class="literal">null</span> ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">    printRightEdge(h.right, print);</span><br><span class="line">    <span class="keyword">if</span> (print || (h.left == <span class="literal">null</span> &amp;&amp; h.right == <span class="literal">null</span>)) &#123;</span><br><span class="line">        System.out.print(h.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何较为直观地打印二叉树"><a href="#如何较为直观地打印二叉树" class="headerlink" title="如何较为直观地打印二叉树"></a>如何较为直观地打印二叉树</h2><p><strong>题目</strong><br>二叉树可以用常规的三种遍历结果来描述其结构，但是不够直观，尤其是二叉树中有重复值的时候，仅通过三种遍历的结果来构造二叉树的真实结构更是难上加难，有时则根本不可能。给定一棵二叉树的头节点 <code>head</code>，已知二叉树节点值的类型为 32 位整型，请实现一个打印二叉树的函数，可以直观地展示树的形状，也便于画出真实的结构。</p>
<p><strong>解答</strong><br>这是一道较开放的题目，实现者不仅要设计出符合要求且不会产生歧义的打印方式，还要考虑实现难度，在面试时仅仅写出思路必然是不满足代码面试要求的。本书给出一种符合要求且代码量不大的实现，希望读者也能实现并优化自己的设计。具体过程如下：</p>
<ol>
<li>设计打印的样式。实现者首先应该解决的问题是用什么样的方式来无歧义地打印二叉树。比如，二叉树如图 3-4 所示。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> /   / \</span><br><span class="line">4   5   6</span><br><span class="line"> \</span><br><span class="line">  7</span><br></pre></td></tr></table></figure>
<p>图 3-4</p>
<p>对如图 3-4 所示的二叉树，本书设计的打印样式如图 3-5 所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        v6v</span><br><span class="line">    v3v</span><br><span class="line">        ^5^</span><br><span class="line">H1H</span><br><span class="line">        ^2^</span><br><span class="line">    ^4^</span><br><span class="line">        v7v</span><br></pre></td></tr></table></figure>
<p>图 3-5</p>
<p>下面解释一下如何看打印的结果。首先，二叉树大概的样子是把打印结果顺时针旋转 90°，读者可以把图 3-4 的打印结果（也就是图 3-5 顺时针旋转 90°之后）做对比，两幅图是存在明显对应关系的；接下来，怎么清晰地确定任何一个节点的父节点呢？如果一个节点打印结果的前缀与后缀都有“H”（如图 3-5 中的“H1H”），则说明这个节点是头节点，当然就不存在父节点。如果一个节点打印结果的前缀与后缀都有“v”，则表示父节点在该节点所在列的前一列，在该节点所在行的下方，并且是离该节点最近的节点。比如，图 3-5 中的“v3v”“v6v”和“v7v”，父节点分别为“H1H”“v3v”和“^4^”。如果一个节点打印结果的前缀与后缀都有“^”，则表示父节点在该节点所在列的前一列，在该节点所在行的上方，并且是离该节点最近的节点。比如，图 3-5 中的“^5^”“^2^”和“^4^”，父节点分别为“v3v”“H1H”和“^2^”。</p>
<ol>
<li><p>一个需要重点考虑的问题——规定节点打印时占用的统一长度。我们必须规定一个节点在打印时到底占多长。试想一下，如果有些节点的值本身的长度很短，如“1”“2”等，而有些节点的值本身的长度很长，如“43323232”“78787237”等，那么如果不规定一个统一的长度，则在打印一个长短值交替的二叉树时必然会出现格式对不齐的问题，进而产生歧义。在 Java 中，整型值占用长度最长的值是 <code>Integer.MIN_VALUE</code>（-2147483648），占用的长度为 11，加上前缀和后缀（“H”“v”或“^”）之后占用长度为 13。为了在打印之后更好地进行区分，再把前面加上两个空格，后面加上两个空格，总共占用长度为 17。也就是说，长度为 17 的空间必然可以放下任何一个 32 位整数，同时样式还不错。至此，我们约定，打印每一个节点时，必须让每一个节点在打印时占用长度都为 17，如果不足，则前后都用空格补齐。比如，节点值为 8，假设这个节点加上“v”作为前后缀，那么实质内容为“v8v”，长度才为 3，在打印时在“v8v”的前面补 7 个空格，后面也补 7 个空格，让总长度为 17。再如，节点值为 66，假设这个节点加上“v”作为前后缀，那么实质内容为“v66v”，长度才为 4，在打印时在“v66v”的前面补 6 个空格，后面补 7 个空格，让总长度为 17。总之，如果长度不足，则前后贴上几乎数量相等的空格来补齐。</p>
</li>
<li><p>确定了打印的样式，规定了占用长度的标准，最后来解释具体的实现。打印的整体过程结合了二叉树先右子树、再根节点、最后左子树的递归遍历过程。如果递归到一个节点，则首先遍历它的右子树。右子树遍历结束后，回到这个节点。如果这个节点所在层为 l，那么先打印 l×17 个空格（不换行），然后开始制作该节点的打印内容，这个内容当然包括节点的值，以及确定的前后缀字符。如果该节点是其父节点的右孩子节点，则前后缀为“v”，如果该节点是其父节点的左孩子节点，则前后缀为“^”，如果是头节点，则前后缀为“H”。最后在前后分别贴上数量几乎一致的空格，占用长度为 17 的打印内容就制作完成，打印这个内容后换行。最后进行左子树的遍历过程。</p>
</li>
</ol>
<p>直观地打印二叉树的所有过程请参看如下代码中的 <code>printTree</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printTree</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Binary Tree:&quot;</span>);</span><br><span class="line">    printInOrder(head, <span class="number">0</span>, <span class="string">&quot;H&quot;</span>, <span class="number">17</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printInOrder</span><span class="params">(Node head, <span class="type">int</span> height, String to, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printInOrder(head.right, height + <span class="number">1</span>, <span class="string">&quot;v&quot;</span>, len);</span><br><span class="line">    <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> to + head.value + to;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lenM</span> <span class="operator">=</span> val.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">lenL</span> <span class="operator">=</span> (len - lenM) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lenR</span> <span class="operator">=</span> len - lenM - lenL;</span><br><span class="line">    val = getSpace(lenL) + val + getSpace(lenR);</span><br><span class="line">    System.out.println(getSpace(height * len) + val);</span><br><span class="line">    printInOrder(head.left, height + <span class="number">1</span>, <span class="string">&quot;^&quot;</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getSpace</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">space</span> <span class="operator">=</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        buf.append(space);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a>二叉树的序列化和反序列化</h2><p><strong>题目</strong></p>
<p>二叉树被记录成文件的过程叫做二叉树的序列化，通过文件内容重建原来二叉树的过程叫做二叉树的反序列化。给定一棵二叉树的头节点 <code>head</code>，已知二叉树节点值的类型为 32 位整型。<br>请设计一种二叉树序列化和反序列化的方案，并用代码实现。</p>
<p><strong>解答</strong></p>
<p>提供两套序列化和反序列化的实现，供参考。</p>
<p><strong>方法一：通过先序遍历实现序列化和反序列化</strong></p>
<p>先介绍先序遍历下的序列化过程。首先假设序列化的结果字符串为 <code>str</code>，初始时 <code>str=&quot;&quot;</code>。先序遍历二叉树，如果遇到 <code>null</code> 节点，就在 <code>str</code> 的末尾加上 <code>&quot;#!&quot;</code>，<code>&quot;#&quot;</code> 表示这个节点为空，节点值不存在，<code>&quot;!&quot;</code> 表示一个值的结束；如果遇到不为空的节点，假设节点值为 3，就在 <code>str</code> 的末尾加上 <code>&quot;3!&quot;</code>。</p>
<p><strong>序列化代码 (Java)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">serialByPre</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> head.value + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">    res += serialByPre(head.left);</span><br><span class="line">    res += serialByPre(head.right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先序遍历的反序列化其实就是重做先序遍历，遇到 <code>&quot;#&quot;</code> 就生成 <code>null</code> 节点，结束生成后续子树的过程。</p>
<p><strong>反序列化代码 (Java)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">reconByPreString</span><span class="params">(String preStr)</span> &#123;</span><br><span class="line">    String[] values = preStr.split(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != values.length; i++) &#123;</span><br><span class="line">        queue.offer(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reconPreOrder(queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">reconPreOrder</span><span class="params">(Queue&lt;String&gt; queue)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">    <span class="keyword">if</span> (value.equals(<span class="string">&quot;#&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Integer.valueOf(value));</span><br><span class="line">    head.left = reconPreOrder(queue);</span><br><span class="line">    head.right = reconPreOrder(queue);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法二：通过层遍历实现序列化和反序列化</strong></p>
<p>先介绍层遍历下的序列化过程。首先假设序列化的结果字符串为 <code>str</code>，初始时 <code>str=&quot;&quot;</code>。然后实现二叉树的按层遍历，具体方式是利用队列结构，这也是宽度遍历图的常见方式。</p>
<p><strong>序列化代码 (Java)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">serialByLevel</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> head.value + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Node&gt;();</span><br><span class="line">    queue.offer(head);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        head = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (head.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            res += head.left.value + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">            queue.offer(head.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += <span class="string">&quot;#!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            res += head.right.value + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">            queue.offer(head.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += <span class="string">&quot;#!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与根据先序遍历的反序列化过程一样，根据层遍历的反序列化是重做层遍历，遇到 <code>&quot;#&quot;</code> 就生成 <code>null</code> 节点，同时不把 <code>null</code> 节点放到队列里即可。</p>
<p><strong>反序列化代码 (Java)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">reconByLevelString</span><span class="params">(String levelStr)</span> &#123;</span><br><span class="line">    String[] values = levelStr.split(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> generateNodeByString(values[index++]);</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        node = queue.poll();</span><br><span class="line">        node.left = generateNodeByString(values[index++]);</span><br><span class="line">        node.right = generateNodeByString(values[index++]);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">generateNodeByString</span><span class="params">(String val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (val.equals(<span class="string">&quot;#&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Integer.valueOf(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历二叉树的神级方法"><a href="#遍历二叉树的神级方法" class="headerlink" title="遍历二叉树的神级方法"></a>遍历二叉树的神级方法</h2><p><strong>题目</strong></p>
<p>给定一棵二叉树的头节点 <code>head</code>，完成二叉树的先序、中序和后序遍历。如果二叉树的节点数为 N，则要求时间复杂度为 O(N)，额外空间复杂度为 O(1)。</p>
<p><strong>解答</strong></p>
<p>本题真正的难点在于对复杂度的要求，尤其是额外空间复杂度为 O(1) 的限制。<br>通常的递归和非递归方法都会使用栈结构，空间复杂度为 O(h)，h 为二叉树的高度。<br>Morris 遍历使用二叉树节点中大量指向 null 的指针，由 Joseph Morris 于 1979 年发明。</p>
<p><strong>Morris 遍历的实质</strong></p>
<p>Morris 遍历的实质就是避免用栈结构，而是让下层到上层有指针，具体是通过让底层节点指向 null 的空闲指针指向上层的某个节点，从而完成下层到上层的移动。</p>
<p><strong>Morris 遍历的过程</strong></p>
<p>假设当前节点为 <code>cur</code>，初始时 <code>cur</code> 就是整棵树的头节点，根据以下标准让 <code>cur</code> 移动：</p>
<ol>
<li>如果 <code>cur</code> 为 <code>null</code>，过程停止，否则继续下面的过程。</li>
<li>如果 <code>cur</code> 没有左子树，则让 <code>cur</code> 向右移动，即 <code>cur = cur.right</code>。</li>
<li>如果 <code>cur</code> 有左子树，则找到 <code>cur</code> 左子树上最右的节点，记为 <code>mostRight</code>。<br>1) 如果 <code>mostRight</code> 的 <code>right</code> 指针指向 <code>null</code>，则令 <code>mostRight.right = cur</code>，也就是让 <code>mostRight</code> 的 <code>right</code> 指针指向当前节点，然后让 <code>cur</code> 向左移动，即 <code>cur = cur.left</code>。<br>2) 如果 <code>mostRight</code> 的 <code>right</code> 指针指向 <code>cur</code>，则令 <code>mostRight.right = null</code>，也就是让 <code>mostRight</code> 的 <code>right</code> 指针指向 <code>null</code>，然后让 <code>cur</code> 向右移动，即 <code>cur = cur.right</code>。</li>
</ol>
<p><strong>Morris 序</strong></p>
<p>根据 Morris 遍历，对于有左子树的节点都可以到达两次，对于没有左子树的节点都只会到达一次。<br>对于任何一个能够到达两次的节点 X，接下来 <code>cur</code> 要么跑到 X 的左子树上，要么就返回上级。<br>第一次到达 X 时，<code>mostRight</code> 指针指向 null；第二次到达 X 时，<code>mostRight</code> 指针指向 X。</p>
<p><strong>先序遍历</strong></p>
<ol>
<li>对于 <code>cur</code> 只能到达一次的节点（无左子树），<code>cur</code> 到达时直接打印。</li>
<li>对于 <code>cur</code> 可以到达两次的节点（有左子树），<code>cur</code> 第一次到达时打印，第二次到达时不打印。</li>
</ol>
<p><strong>中序遍历</strong></p>
<ol>
<li>对于 <code>cur</code> 只能到达一次的节点（无左子树），<code>cur</code> 到达时直接打印。</li>
<li>对于 <code>cur</code> 可以到达两次的节点（有左子树），<code>cur</code> 第一次到达时不打印，第二次到达时打印。</li>
</ol>
<p><strong>后序遍历</strong></p>
<ol>
<li>对于 <code>cur</code> 只能到达一次的节点（无左子树），直接跳过，没有打印行为。</li>
<li>对于 <code>cur</code> 可以到达两次的任何一个节点 X，<code>cur</code> 第一次到达时没有打印行为；当第二次到达时，逆序打印 X 左子树的右边界。</li>
<li><code>cur</code> 遍历完成后，逆序打印整棵树的右边界。</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MorrisTraversal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Morris 遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">morris</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            <span class="keyword">if</span> (mostRight != <span class="literal">null</span>) &#123; <span class="comment">// 如果当前 cur 有左子树</span></span><br><span class="line">                <span class="comment">// 找到 cur 左子树上最右的节点</span></span><br><span class="line">                <span class="keyword">while</span> (mostRight.right != <span class="literal">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 从上面的 while 里出来后，mostRight 就是 cur 左子树上最右的节点</span></span><br><span class="line">                <span class="keyword">if</span> (mostRight.right == <span class="literal">null</span>) &#123; <span class="comment">// 如果 mostRight.right 指向 null</span></span><br><span class="line">                    mostRight.right = cur; <span class="comment">// 让其指向 cur</span></span><br><span class="line">                    cur = cur.left; <span class="comment">// cur 向左移动</span></span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// 回到最外层的 while，继续判断 cur 的情况</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果 mostRight.right 是指向 cur 的</span></span><br><span class="line">                    mostRight.right = <span class="literal">null</span>; <span class="comment">// 让其指向 null</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cur 如果没有左子树，cur 向右移动</span></span><br><span class="line">            <span class="comment">// 或者 cur 左子树上最右节点的右指针是指向 cur 的，cur 向右移动</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Morris 先序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">morrisPre</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            <span class="keyword">if</span> (mostRight != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (mostRight.right != <span class="literal">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mostRight.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    System.out.print(cur.value + <span class="string">&quot; &quot;</span>); <span class="comment">// 第一次到达时打印</span></span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mostRight.right = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(cur.value + <span class="string">&quot; &quot;</span>); <span class="comment">// 无左子树，直接打印</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Morris 中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">morrisIn</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            <span class="keyword">if</span> (mostRight != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (mostRight.right != <span class="literal">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mostRight.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mostRight.right = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(cur.value + <span class="string">&quot; &quot;</span>); <span class="comment">// 第二次到达，或者无左子树到达时打印</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Morris 后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">morrisPos</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            <span class="keyword">if</span> (mostRight != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (mostRight.right != <span class="literal">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mostRight.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mostRight.right = <span class="literal">null</span>;</span><br><span class="line">                    printEdge(cur.left); <span class="comment">// 第二次到达时，逆序打印左子树的右边界</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        printEdge(head); <span class="comment">// 遍历完成后，逆序打印整棵树的右边界</span></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printEdge</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">tail</span> <span class="operator">=</span> reverseEdge(head);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(cur.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        reverseEdge(tail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">reverseEdge</span><span class="params">(Node from)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (from != <span class="literal">null</span>) &#123;</span><br><span class="line">            next = from.right;</span><br><span class="line">            from.right = pre;</span><br><span class="line">            pre = from;</span><br><span class="line">            from = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在二叉树中找到累加和为指定值的最长路径长度"><a href="#在二叉树中找到累加和为指定值的最长路径长度" class="headerlink" title="在二叉树中找到累加和为指定值的最长路径长度"></a>在二叉树中找到累加和为指定值的最长路径长度</h2><p><strong>题目</strong><br>给定一棵二叉树的头节点 head 和一个 32 位整数 sum，二叉节点值类型为整型，求累加和为 sum 的最长路径长度。路径是指从某个节点往下，每次最多选择一个孩子节点或者不选所形成的节点链。</p>
<p>例如，如果 sum=6，那么累加和为 6 的最长路径为：-3, 3, 0, 6，所以返回 4。<br>如果 sum=-9，那么累加和为 -9 的最长路径为：-9，所以返回 1。</p>
<p>注：本题不用考虑节点值相加可能溢出的情况。</p>
<p><strong>解答</strong><br>在阅读本题的解答之前，请读者先阅读本书“求未排序数组中累加和为规定值的最长子数组长度”问题。针对二叉树，本文的解法改写了这个问题的实现。如果二叉树的节点数为 N，本文的解法可以做到时间复杂度为 O(N)，额外空间复杂度为 O(h)，其中，h 为二叉树的高度。</p>
<p>具体过程如下：</p>
<ol>
<li>二叉树头节点 head 和规定值 sum 已知；生成变量 maxLen，负责记录累加和等于 sum 的最长路径长度。</li>
<li>生成哈希表 sumMap。sumMap 负责记录从 head 开始的一条路径上的累加和出现的情况。sumMap 的 key 值代表某个累加和，value 值代表这个累加和在路径中最早出现的层数。</li>
<li>首先在 sumMap 中加入一个记录(0,0)，它表示累加和 0 不用包括任何节点就可以得到。然后按照二叉树先序遍历的方式遍历节点，遍历到的当前节点记为 cur，从 head 到 cur 父节点的累加和记为 preSum，cur 所在的层数记为 level。将 cur.value + preSum 的值记为 curSum，就是从 head 到 cur 的累加和。<ul>
<li>如果 sumMap 中已经包含了 curSum 的记录，说明 curSum 在上层中已经出现过，那么就不更新 sumMap。</li>
<li>如果 sumMap 不包含 curSum 的记录，说明 curSum 是第一次出现，就把 (curSum, level) 这个记录放入 sumMap。</li>
<li>求解在必须以 cur 结尾的情况下，累加和为规定值的最长路径长度。如果 sumMap 包含 curSum - sum，则 maxLen = Math.max(maxLen, level - sumMap.get(curSum - sum))。</li>
<li>然后遍历 cur 左子树和右子树。</li>
<li>处理完以 cur 为头节点的子树，返回 cur 父节点之前，在 sumMap 中查询 curSum 这个累加和出现的层数。如果 value 等于 level，说明 curSum 这个累加和的记录是在遍历到 cur 时加进去的，那就把这条记录删除；如果 value 不等于 level，则不做任何调整。</li>
</ul>
</li>
<li>步骤 3 会遍历二叉树所有的节点，也会求解以每个节点结尾的情况下，累加和为规定值的最长路径长度。用 maxLen 记录其中的最大值即可。</li>
</ol>
<p><strong>代码 (Java)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaxLength</span><span class="params">(Node head, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; sumMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    sumMap.put(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 重要</span></span><br><span class="line">    <span class="keyword">return</span> preOrder(head, sum, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, sumMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">preOrder</span><span class="params">(Node head, <span class="type">int</span> sum, <span class="type">int</span> preSum, <span class="type">int</span> level,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span> maxLen, HashMap&lt;Integer, Integer&gt; sumMap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> preSum + head.value;</span><br><span class="line">    <span class="keyword">if</span> (!sumMap.containsKey(curSum)) &#123;</span><br><span class="line">        sumMap.put(curSum, level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sumMap.containsKey(curSum - sum)) &#123;</span><br><span class="line">        maxLen = Math.max(level - sumMap.get(curSum - sum), maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    maxLen = preOrder(head.left, sum, curSum, level + <span class="number">1</span>, maxLen, sumMap);</span><br><span class="line">    maxLen = preOrder(head.right, sum, curSum, level + <span class="number">1</span>, maxLen, sumMap);</span><br><span class="line">    <span class="keyword">if</span> (level == sumMap.get(curSum)) &#123;</span><br><span class="line">        sumMap.remove(curSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="找到二叉树中的最大搜索二叉子树"><a href="#找到二叉树中的最大搜索二叉子树" class="headerlink" title="找到二叉树中的最大搜索二叉子树"></a>找到二叉树中的最大搜索二叉子树</h2><p><strong>题目</strong><br>给定一棵二叉树的头节点 head，已知其中所有节点的值都不一样，找到含有节点最多的搜索二叉子树，并返回这棵子树的头节点。</p>
<p><strong>解答</strong><br>本题可以使用二叉树递归套路（树形DP）来解决。<br>如果二叉树的节点数为 N，要求时间复杂度为 O(N)，额外空间复杂度为 O(h)，h 为二叉树的高度。</p>
<p>以节点 X 为头的子树中，最大的搜索二叉子树只可能是以下三种情况中可能性最大的那种：</p>
<ol>
<li>第一种：X 为头节点的子树中，最大的搜索二叉子树就是 X 的左子树中的最大搜索二叉子树。</li>
<li>第二种：X 为头节点的子树中，最大的搜索二叉子树就是 X 的右子树中的最大搜索二叉子树。</li>
<li>第三种：如果 X 左子树上的最大搜索二叉子树是 X 左子树的全体，X 右子树上的最大搜索二叉子树是 X 右子树的全体，并且 X 的值大于 X 左子树所有节点的最大值，但小于 X 右子树所有节点的最小值，那么 X 为头节点的子树中，最大的搜索二叉子树就是以 X 为头节点的全体。</li>
</ol>
<p>为了分析这三种可能性，我们需要收集左子树和右子树的信息。<br>对于任意子树，我们需要：</p>
<ol>
<li><code>maxBSTHead</code>：最大搜索二叉子树的头节点。</li>
<li><code>maxBSTSize</code>：最大搜索二叉子树的大小。</li>
<li><code>min</code>：这棵子树上的最小值。</li>
<li><code>max</code>：这棵子树上的最大值。</li>
</ol>
<p>合并信息逻辑：</p>
<ol>
<li>获取左右子树的信息 <code>lData</code> 和 <code>rData</code>。</li>
<li>计算当前子树的最小值 <code>min</code> 和最大值 <code>max</code>。</li>
<li>初步确定 <code>maxBSTSize</code> 为 <code>lData.maxBSTSize</code> 和 <code>rData.maxBSTSize</code> 中的较大值，<code>maxBSTHead</code> 随之确定。</li>
<li>判断是否存在第三种可能性：<ul>
<li><code>lData.maxBSTHead == X.left</code> (左子树最大BST是左子树全体)</li>
<li><code>rData.maxBSTHead == X.right</code> (右子树最大BST是右子树全体)</li>
<li><code>X.value &gt; lData.max</code> 且 <code>X.value &lt; rData.min</code></li>
<li>如果满足，说明以 X 为头的整棵树是搜索二叉树，更新 <code>maxBSTSize</code> 为 <code>lData.maxBSTSize + rData.maxBSTSize + 1</code>，<code>maxBSTHead</code> 为 <code>X</code>。</li>
</ul>
</li>
<li>返回合并后的信息。</li>
</ol>
<p><strong>代码 (Java)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindMaxBSTSubtree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReturnType</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> Node maxBSTHead;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> maxBSTSize;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> min;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> max;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ReturnType</span><span class="params">(Node maxBSTHead, <span class="type">int</span> maxBSTSize, <span class="type">int</span> min, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.maxBSTHead = maxBSTHead;</span><br><span class="line">            <span class="built_in">this</span>.maxBSTSize = maxBSTSize;</span><br><span class="line">            <span class="built_in">this</span>.min = min;</span><br><span class="line">            <span class="built_in">this</span>.max = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">getMaxBST</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> process(head).maxBSTHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReturnType <span class="title function_">process</span><span class="params">(Node X)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (X == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnType</span>(<span class="literal">null</span>, <span class="number">0</span>, Integer.MAX_VALUE, Integer.MIN_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ReturnType</span> <span class="variable">lData</span> <span class="operator">=</span> process(X.left);</span><br><span class="line">        <span class="type">ReturnType</span> <span class="variable">rData</span> <span class="operator">=</span> process(X.right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(X.value, Math.min(lData.min, rData.min));</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(X.value, Math.max(lData.max, rData.max));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认情况1和2，取左右子树中较大的那个BST</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxBSTSize</span> <span class="operator">=</span> Math.max(lData.maxBSTSize, rData.maxBSTSize);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">maxBSTHead</span> <span class="operator">=</span> lData.maxBSTSize &gt;= rData.maxBSTSize ? lData.maxBSTHead : rData.maxBSTHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断情况3：以X为头的整棵树是否是BST</span></span><br><span class="line">        <span class="comment">// 条件：左树最大BST是左树全体 &amp;&amp; 右树最大BST是右树全体 &amp;&amp; X的值大于左树最大值 &amp;&amp; X的值小于右树最小值</span></span><br><span class="line">        <span class="keyword">if</span> (lData.maxBSTHead == X.left &amp;&amp; rData.maxBSTHead == X.right &amp;&amp;</span><br><span class="line">            X.value &gt; lData.max &amp;&amp; X.value &lt; rData.min) &#123;</span><br><span class="line">            maxBSTSize = lData.maxBSTSize + rData.maxBSTSize + <span class="number">1</span>;</span><br><span class="line">            maxBSTHead = X;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnType</span>(maxBSTHead, maxBSTSize, min, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="找到二叉树中符合搜索二叉树条件的最大拓扑结构"><a href="#找到二叉树中符合搜索二叉树条件的最大拓扑结构" class="headerlink" title="找到二叉树中符合搜索二叉树条件的最大拓扑结构"></a>找到二叉树中符合搜索二叉树条件的最大拓扑结构</h2><p><strong>题目</strong></p>
<p>给定一棵二叉树的头节点 <code>head</code>，已知所有节点的值都不一样，返回其中最大的且符合搜索二叉树条件的最大拓扑结构的大小。</p>
<p><strong>解答</strong></p>
<p><strong>方法一</strong></p>
<p>二叉树的节点数为 $N$，时间复杂度为 $O(N^2)$ 的方法。</p>
<p>以节点 <code>h</code> 为头节点的树中，在拓扑结构中也必须以 <code>h</code> 为头节点的情况下，怎么找到符合搜索二叉树条件的最大结构？可以考查 <code>h</code> 的孩子节点，根据孩子节点的值从 <code>h</code> 开始按照二叉搜索的方式移动，如果最后能移动到同一个孩子节点上，说明这个孩子节点可以作为这个拓扑的一部分，并继续考查这个孩子节点的孩子节点，一直延伸下去。</p>
<p>也就是说，我们根据一个节点的值，从 <code>h</code> 开始，每次向左或者向右移动，如果最后能移动到原来的节点上，说明该节点可以作为以 <code>h</code> 为头节点的拓扑的一部分。</p>
<p>接下来只要遍历所有的二叉树节点，并在以每个节点为头节点的子树中都求一遍其中的最大拓扑结构，其中最大的那个就是我们想找的结构，它的大小就是返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bstTopoSize1</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> maxTopo(head, head);</span><br><span class="line">    max = Math.max(bstTopoSize1(head.left), max);</span><br><span class="line">    max = Math.max(bstTopoSize1(head.right), max);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxTopo</span><span class="params">(Node h, Node n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; n != <span class="literal">null</span> &amp;&amp; isBSTNode(h, n, n.value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> maxTopo(h, n.left) + maxTopo(h, n.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBSTNode</span><span class="params">(Node h, Node n, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isBSTNode(h.value &gt; value ? h.left : h.right, n, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法二</strong></p>
<p>二叉树的节点数为 $N$，时间复杂度为 $O(N)$ 的方法。</p>
<p>核心是利用<strong>拓扑贡献记录</strong>。如果分别得到了 <code>h</code> 左右两个孩子节点为头节点的拓扑贡献记录，可以快速得到以 <code>h</code> 为头节点的拓扑贡献记录。</p>
<p>利用二叉树的后序遍历，对每个节点来说，首先生成其左孩子节点的记录，然后是右孩子节点的记录，接着把两组记录修改成以这个节点为头的拓扑贡献记录，并找出所有节点的最大拓扑结构中最大的那个。</p>
<p>建立记录的过程：</p>
<ol>
<li>对于节点 <code>h</code>，先得到其左子树的拓扑贡献记录。</li>
<li>考查左子树的右边界。如果节点值小于 <code>h.value</code>，则保留记录；如果大于 <code>h.value</code>，则删除该节点及其子树的记录（因为它不能作为以 <code>h</code> 为根的 BST 拓扑的一部分），并更新父节点的右子树贡献值。</li>
<li>同理，考查右子树的左边界，处理大于 <code>h.value</code> 的节点，删除小于 <code>h.value</code> 的节点记录。</li>
<li>整合左右子树的记录，得到 <code>h</code> 的拓扑贡献记录。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> l;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Record</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.l = left;</span><br><span class="line">        <span class="built_in">this</span>.r = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bstTopoSize2</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    Map&lt;Node, Record&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node, Record&gt;();</span><br><span class="line">    <span class="keyword">return</span> posOrder(head, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">posOrder</span><span class="params">(Node h, Map&lt;Node, Record&gt; map)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ls</span> <span class="operator">=</span> posOrder(h.left, map);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> posOrder(h.right, map);</span><br><span class="line">    modifyMap(h.left, h.value, map, <span class="literal">true</span>);</span><br><span class="line">    modifyMap(h.right, h.value, map, <span class="literal">false</span>);</span><br><span class="line">    <span class="type">Record</span> <span class="variable">lr</span> <span class="operator">=</span> map.get(h.left);</span><br><span class="line">    <span class="type">Record</span> <span class="variable">rr</span> <span class="operator">=</span> map.get(h.right);</span><br><span class="line">    <span class="type">int</span> <span class="variable">lbst</span> <span class="operator">=</span> lr == <span class="literal">null</span> ? <span class="number">0</span> : lr.l + lr.r + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rbst</span> <span class="operator">=</span> rr == <span class="literal">null</span> ? <span class="number">0</span> : rr.l + rr.r + <span class="number">1</span>;</span><br><span class="line">    map.put(h, <span class="keyword">new</span> <span class="title class_">Record</span>(lbst, rbst));</span><br><span class="line">    <span class="keyword">return</span> Math.max(lbst + rbst + <span class="number">1</span>, Math.max(ls, rs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">modifyMap</span><span class="params">(Node n, <span class="type">int</span> v, Map&lt;Node, Record&gt; m, <span class="type">boolean</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="literal">null</span> || (!m.containsKey(n))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Record</span> <span class="variable">r</span> <span class="operator">=</span> m.get(n);</span><br><span class="line">    <span class="keyword">if</span> ((s &amp;&amp; n.value &gt; v) || ((!s) &amp;&amp; n.value &lt; v)) &#123;</span><br><span class="line">        m.remove(n);</span><br><span class="line">        <span class="keyword">return</span> r.l + r.r + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minus</span> <span class="operator">=</span> modifyMap(s ? n.right : n.left, v, m, s);</span><br><span class="line">        <span class="keyword">if</span> (s) &#123;</span><br><span class="line">            r.r = r.r - minus;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.l = r.l - minus;</span><br><span class="line">        &#125;</span><br><span class="line">        m.put(n, r);</span><br><span class="line">        <span class="keyword">return</span> minus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的按层打印与-ZigZag-打印"><a href="#二叉树的按层打印与-ZigZag-打印" class="headerlink" title="二叉树的按层打印与 ZigZag 打印"></a>二叉树的按层打印与 ZigZag 打印</h2><p><strong>题目</strong></p>
<p>给定一棵二叉树的头节点 head，分别实现按层和 ZigZag 打印二叉树的函数。<br>例如，二叉树如图 3-29 所示。</p>
<p>按层打印时，输出格式必须如下：</p>
<p>Level 1 : 1<br>Level 2 : 2 3<br>Level 3 : 4 5 6<br>Level 4 : 7 8</p>
<p>ZigZag 打印时，输出格式必须如下：</p>
<p>Level 1 from left to right: 1<br>Level 2 from right to left: 3 2<br>Level 3 from left to right: 4 5 6<br>Level 4 from right to left: 8 7</p>
<p><strong>解答</strong></p>
<p>按层打印的实现</p>
<p>按层打印原本是十分基础的内容，对二叉树做简单的宽度优先遍历即可，但本题有额外的要求，那就是同一层的节点必须打印在一行上，并且要求输出行号。这就需要在原来宽度优先遍历的基础上做一些改进，所以关键问题是如何知道该换行。只需要用两个 node 类型的变量 last 和 nLast 就可以解决这个问题，last 变量表示正在打印的当前行的最右节点，nLast 表示下一行的最右节点。假设我们每一层都做从左到右的宽度优先遍历，如果发现遍历到的节点等于 last，则说明应该换行。换行之后，只要令 last=nLast，就可以继续下一行的打印过程，重复此过程，直到所有的节点都打印完。那么问题就变成了如何更新 nLast？只需要让 nLast 一直跟踪记录宽度优先队列中的最新加入的节点即可。这是因为最新加入队列的节点一定是目前已经发现的下一行的最右节点。所以在当前行打印完时，nLast 一定是下一行所有节点中的最右节点。<br>接下来结合题目的例子来说明整个过程。<br>开始时，last=节点 1，nLast=null，把节点 1 放入队列 queue，遍历开始，queue={1}。<br>从 queue 中弹出节点 1 并打印，然后把节点 1 的孩子节点依次放入 queue，放入节点 2 时，nLast=节点 2，放入节点 3 时，nLast=节点 3，此时发现弹出的节点 1==last，所以换行，并令 last=nLast=节点 3，queue={2,3}。<br>从 queue 中弹出节点 2 并打印，然后把节点 2 的孩子节点放入 queue，放入节点 4 时，nLast=节点 4，queue={3,4}。<br>从 queue 中弹出节点 3 并打印，然后把节点 3 的孩子节点放入 queue，放入节点 5 时，nLast=节点 5，放入节点 6 时，nLast=节点 6，此时发现弹出的节点 3==last，所以换行，并令 last=nLast=节点 6，queue={4,5,6}。<br>从 queue 中弹出节点 4 并打印，节点 4 没有孩子节点，所以不放入任何节点，nLast 也不更新。<br>从 queue 中弹出节点 5 并打印，然后把节点 5 的孩子节点依次放入 queue，放入节点 7 时，nLast=节点 7，放入节点 8 时，nLast=节点 8，queue={6,7,8}。<br>从 queue 中弹出节点 6 并打印，节点 6 没有孩子节点，所以不放入任何节点，nLast 也不更新，此时发现弹出的节点 6==last。所以换行，并令 last=nLast=节点 8，queue={7,8}。<br>用同样的判断过程打印节点 7 和节点 8，整个过程结束。<br>按层打印的详细过程请参看如下代码中的 printByLevel 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printByLevel</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Node&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">nLast</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    queue.offer(head);</span><br><span class="line">    System.out.print(<span class="string">&quot;Level &quot;</span> + (level++) + <span class="string">&quot; : &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        head = queue.poll();</span><br><span class="line">        System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (head.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(head.left);</span><br><span class="line">            nLast = head.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(head.right);</span><br><span class="line">            nLast = head.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head == last &amp;&amp; !queue.isEmpty()) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;\nLevel &quot;</span> + (level++) + <span class="string">&quot; : &quot;</span>);</span><br><span class="line">            last = nLast;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ZigZag 打印的实现</p>
<p>先简单介绍一种不推荐的方法，即使用 ArrayList 结构的方法。两个 ArrayList 结构记为 list1 和 list2，用 list1 收集当前层的节点，然后从左到右打印当前层，接着把当前层的孩子节点放进 list2，并从右到左打印，接下来再把 list2 的所有节点的孩子节点放入 list1，如此反复。不推荐的原因是 ArrayList 结构为动态数组，在这个结构中，当元素数量到一定规模时将发生扩容操作，扩容操作的时间复杂度为 O(N)，是比较高的，这个结构增加和删除元素的时间复杂度也较高。总之，对本题来讲，用这个结构时数据结构不够“纯粹”和“干净”，而且还需要两个 ArrayList 结构，如果读者不充分理解这个结构的底层实现，最好不要使用。<br>本书提供的方法只使用了一个双端队列，具体为 Java 中的 LinkedList 结构，这个结构的底层实现就是非常纯粹的双端队列结构，本书的方法也仅使用双端队列结构的基本操作。<br>先举题目的例子来展示大体过程，首先生成双端队列结构 dq，将节点 1 从 dq 的头部放入 dq。<br>原则 1：如果是从左到右的过程。那么一律从 dq 的头部弹出节点，如果弹出的节点没有孩子节点，当然不用放入任何节点到 dq 中；如果当前节点有孩子节点，先让左孩子节点从尾部进入 dq，再让右孩子节点从尾部进入 dq。<br>根据原则 1，先从 dq 头部弹出节点 1 并打印，然后让节点 2 从 dq 尾部进入，再让节点 3 从 dq 尾部进入。<br>原则 2：如果是从右到左的过程。那么一律从 dq 的尾部弹出节点，如果弹出的节点没有孩子节点，当然不用放入任何节点到 dq 中；如果当前节点有孩子节点，先让右孩子节点从头部进入 dq，再让左孩子节点从头部进入 dq。<br>根据原则 2，先从 dq 尾部弹出节点 3 并打印，然后让节点 6 从 dq 头部进入，再让节点 5 从 dq 头部进入。<br>根据原则 2，先从 dq 尾部弹出节点 2 并打印，然后让节点 4 从 dq 头部进入。<br>根据原则 1，依次从 dq 头部弹出节点 4、5、6 并打印，这期间先让节点 7 从 dq 尾部进入，再让节点 8 从 dq 尾部进入。<br>最后根据原则 2，依次从 dq 尾部弹出节点 8 和 7 并打印即可。<br>用原则 1 和原则 2 的过程切换，我们可以完成 ZigZag 的打印过程，所以现在只剩一个问题：如何确定切换原则 1 和原则 2 的时机？这其实还是如何确定每一层最后一个节点的问题。<br>在 ZigZag 的打印过程中，下一层最后打印的节点是当前层有孩子节点的节点中先进入 dq 的节点。比如，处理第 1 层的第 1 个有孩子节点的节点，也就是节点 1 时，节点 1 的左孩子节点 2 最先进入的 dq，那么节点 2 就是下一层打印时的最后一个节点。处理第 2 层的第一个有孩子的节点，也就是节点 3 时，节点 3 的右孩子节点 6 最先进入的 dq，那么节点 6 就是下一层打印时的最后一个节点。处理第 3 层的第一个有孩子节点的节点，也就是节点 5 时，节点 5 的左孩子节点 7 最先进的 dq，那么节点 7 就是下一层打印时的最后一个节点。<br>ZigZag 打印的全部过程请参看如下代码中的 printByZigZag 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printByZigZag</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;Node&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Node&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">lr</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">nLast</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    dq.offerFirst(head);</span><br><span class="line">    printLevelAndOrientation(level++, lr);</span><br><span class="line">    <span class="keyword">while</span> (!dq.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lr) &#123;</span><br><span class="line">            head = dq.pollFirst();</span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                nLast = nLast == <span class="literal">null</span> ? head.left : nLast;</span><br><span class="line">                dq.offerLast(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                nLast = nLast == <span class="literal">null</span> ? head.right : nLast;</span><br><span class="line">                dq.offerLast(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = dq.pollLast();</span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                nLast = nLast == <span class="literal">null</span> ? head.right : nLast;</span><br><span class="line">                dq.offerFirst(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                nLast = nLast == <span class="literal">null</span> ? head.left : nLast;</span><br><span class="line">                dq.offerFirst(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (head == last &amp;&amp; !dq.isEmpty()) &#123;</span><br><span class="line">            lr = !lr;</span><br><span class="line">            last = nLast;</span><br><span class="line">            nLast = <span class="literal">null</span>;</span><br><span class="line">            System.out.println();</span><br><span class="line">            printLevelAndOrientation(level++, lr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLevelAndOrientation</span><span class="params">(<span class="type">int</span> level, <span class="type">boolean</span> lr)</span> &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;Level &quot;</span> + level + <span class="string">&quot; from &quot;</span>);</span><br><span class="line">    System.out.print(lr ? <span class="string">&quot;left to right: &quot;</span> : <span class="string">&quot;right to left: &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调整搜索二叉树中两个错误的节点"><a href="#调整搜索二叉树中两个错误的节点" class="headerlink" title="调整搜索二叉树中两个错误的节点"></a>调整搜索二叉树中两个错误的节点</h2><p><strong>题目</strong></p>
<p>一棵二叉树原本是搜索二叉树，但是其中有两个节点调换了位置，使得这棵二叉树不再是搜索二叉树，请找到这两个错误节点并返回。已知二叉树中所有节点的值都不一样，给定二叉树的头节点 head，返回一个长度为 2 的二叉树节点类型的数组 errs，errs[0]表示一个错误节点，errs[1]表示另一个错误节点。</p>
<p>进阶问题：如果在原问题中得到了这两个错误节点，我们当然可以通过交换两个节点的节点值的方式让整棵二叉树重新成为搜索二叉树。但现在要求你不能这么做，而是在结构上完全交换两个节点的位置，请实现调整的函数。</p>
<p><strong>解答</strong></p>
<p>原问题——找到这两个错误节点。如果对所有的节点值都不一样的搜索二叉树进行中序遍历，那么出现的节点值会一直升序。因此，如果有两个节点位置错了，就一定会出现降序。</p>
<p>如果在中序遍历时节点值出现了两次降序，第一个错误的节点为第一次降序时较大的节点，第二个错误的节点为第二次降序时较小的节点。</p>
<p>比如，原来的搜索二叉树在中序遍历时的节点值依次出现{1,2,3,4,5}，如果因为两个节点位置错了而出现{1,5,3,4,2}，第一次降序为 5-&gt;3，所以第一个错误节点为 5，第二次降序为 4-&gt;2，所以第二个错误节点为 2。把 5 和 2 换过来就可以恢复。</p>
<p>如果在中序遍历时节点值只出现了一次降序，第一个错误的节点为这次降序时较大的节点，第二个错误的节点为这次降序时较小的节点。</p>
<p>比如，原来的搜索二叉树在中序遍历时的节点值依次出现{1,2,3,4,5}，如果因为两个节点位置错了而出现{1,2,4,3,5}，只有一次降序为 4-&gt;3，所以第一个错误节点为 4，第二个错误节点为 3。把 4 和 3 换过来就可以恢复。</p>
<p>寻找两个错误节点的过程可以总结为：第一个错误节点为第一次降序时较大的节点，第二个错误节点为最后一次降序时较小的节点。</p>
<p>因此，只要改写一个基本的中序遍历，就可以完成原问题的要求，改写递归、非递归或者 Morris 遍历都可以。</p>
<p>找到两个错误节点的过程请参看如下代码中的 getTwoErrNodes 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node[] getTwoErrNodes(Node head) &#123;</span><br><span class="line">    Node[] errs = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> errs;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Node&gt;();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head = head.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (pre != <span class="literal">null</span> &amp;&amp; pre.value &gt; head.value) &#123;</span><br><span class="line">                errs[<span class="number">0</span>] = errs[<span class="number">0</span>] == <span class="literal">null</span> ? pre : errs[<span class="number">0</span>];</span><br><span class="line">                errs[<span class="number">1</span>] = head;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = head.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> errs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进阶问题——在结构上交换这两个错误节点。若要在结构上交换两个错误节点，首先应该找到两个错误节点各自的父节点，再随便改写一个二叉树的遍历即可。</p>
<p>找到两个错误节点各自父节点的过程请参看如下代码中的 getTwoErrParents 方法，该方法返回长度为 2 的 Node 类型的数组 parents，parents[0]表示第一个错误节点的父节点，parents[1]表示第二个错误节点的父节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node[] getTwoErrParents(Node head, Node e1, Node e2) &#123;</span><br><span class="line">    Node[] parents = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> parents;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head = head.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (head.left == e1 || head.right == e1) &#123;</span><br><span class="line">                parents[<span class="number">0</span>] = head;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.left == e2 || head.right == e2) &#123;</span><br><span class="line">                parents[<span class="number">1</span>] = head;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找到两个错误节点的父节点之后，第一个错误节点记为 e1，e1 的父节点记为 e1P，e1 的左孩子节点记为 e1L，e1 的右孩子节点记为 e1R。第二个错误节点记为 e2，e2 的父节点记为 e2P，e2 的左孩子节点记为 e2L，e2 的右孩子节点记为 e2R。</p>
<p>在结构上交换两个节点，实际上就是把两个节点互换环境。简单地讲，就是让 e2 成为 e1P 的孩子节点，让 e1L 和 e1R 成为 e2 的孩子节点；让 e1 成为 e2P 的孩子节点，让 e2L 和 e2R 成为 e1 的孩子节点。但这只是简单地理解，在实际交换的过程中有很多情况需要我们做特殊处理。<br>比如，如果 e1 是头节点，则意味着 e1P 为 null，那么让 e2 成为 e1P 的孩子节点时，关于 e1P 的任何 left 指针或 right 指针操作都会发生错误，因为 e1P 为 null 则根本没有 Node 类型节点的结构。再如，如果 e1 本身就是 e2 的左孩子节点，即 e1==e2L，那么让 e2L 成为 e1 的左孩子节点时，e1 的 left 指针将指向 e2L，将会指向自己，这会让整棵二叉树发生严重的结构错误。</p>
<p>换句话说，我们必须理清楚 e1 及其上下环境之间的关系，e2 及其上下环境之间的关系，以及两个环境之间是否有联系。有以下三个问题和一个特别注意是必须关注的。<br>问题一：e1 和 e2 是否有一个是头节点？如果有，谁是头节点？<br>问题二：e1 和 e2 是否相邻？如果相邻，谁是谁的父节点？<br>问题三：e1 和 e2 分别是各自父节点的左孩子节点还是右孩子节点？<br>特别注意：因为是在中序遍历时先找到 e1，后找到 e2，所以 e1 一定不是 e2 的右孩子节点，e2 也一定不是 e1 的左孩子节点。</p>
<p>以上三个问题与特别注意之间相互影响，情况非常复杂。经过仔细整理，共有 14 种情况，每一种情况在调整 e1 和 e2 各自的拓扑关系时都有特殊处理。</p>
<ol>
<li>e1 是头节点，e1 是 e2 的父节点，此时 e2 只能是 e1 的右孩子节点。</li>
<li>e1 是头节点，e1 不是 e2 的父节点，e2 是 e2P 的左孩子节点。</li>
<li>e1 是头节点，e1 不是 e2 的父节点，e2 是 e2P 的右孩子节点。</li>
<li>e2 是头节点，e2 是 e1 的父节点，此时 e1 只能是 e2 的左孩子节点。</li>
<li>e2 是头节点，e2 不是 e1 的父节点，e1 是 e1P 的左孩子节点。</li>
<li>e2 是头节点，e2 不是 e1 的父节点，e1 是 e1P 的右孩子节点。</li>
<li>e1 和 e2 都不是头节点，e1 是 e2 的父节点，此时 e2 只能是 e1 的右孩子节点，e1 是 e1P 的左孩子节点。</li>
<li>e1 和 e2 都不是头节点，e1 是 e2 的父节点，此时 e2 只能是 e1 的右孩子节点，e1 是 e1P 的右孩子节点。</li>
<li>e1 和 e2 都不是头节点，e2 是 e1 的父节点，此时 e1 只能是 e2 的左孩子节点，e2 是 e2P 的左孩子节点。</li>
<li>e1 和 e2 都不是头节点，e2 是 e1 的父节点，此时 e1 只能是 e2 的左孩子节点，e2 是 e2P 的右孩子节点。</li>
<li>e1 和 e2 都不是头节点，谁也不是谁的父节点，e1 是 e1P 的左孩子节点，e2 是 e2P 的左孩子节点。</li>
<li>e1 和 e2 都不是头节点，谁也不是谁的父节点，e1 是 e1P 的左孩子节点，e2 是 e2P 的右孩子节点。</li>
<li>e1 和 e2 都不是头节点，谁也不是谁的父节点，e1 是 e1P 的右孩子节点，e2 是 e2P 的左孩子节点。</li>
<li>e1 和 e2 都不是头节点，谁也不是谁的父节点，e1 是 e1P 的右孩子节点，e2 是 e2P 的右孩子节点。</li>
</ol>
<p>当情况 1 至情况 3 发生时，二叉树新的头节点应该为 e2，当情况 4 至情况 6 发生时，二叉树新的头节点应该为 e1，其他情况发生时，二叉树的头节点不用发生变化。<br>从结构上调整两个错误节点的全部过程请参看如下代码中的 recoverTree 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">recoverTree</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    Node[] errs = getTwoErrNodes(head);</span><br><span class="line">    Node[] parents = getTwoErrParents(head, errs[<span class="number">0</span>], errs[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">e1</span> <span class="operator">=</span> errs[<span class="number">0</span>];</span><br><span class="line">    <span class="type">Node</span> <span class="variable">e1P</span> <span class="operator">=</span> parents[<span class="number">0</span>];</span><br><span class="line">    <span class="type">Node</span> <span class="variable">e1L</span> <span class="operator">=</span> e1.left;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">e1R</span> <span class="operator">=</span> e1.right;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">e2</span> <span class="operator">=</span> errs[<span class="number">1</span>];</span><br><span class="line">    <span class="type">Node</span> <span class="variable">e2P</span> <span class="operator">=</span> parents[<span class="number">1</span>];</span><br><span class="line">    <span class="type">Node</span> <span class="variable">e2L</span> <span class="operator">=</span> e2.left;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">e2R</span> <span class="operator">=</span> e2.right;</span><br><span class="line">    <span class="keyword">if</span> (e1 == head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e1 == e2P) &#123; <span class="comment">// 情况 1</span></span><br><span class="line">            e1.left = e2L;</span><br><span class="line">            e1.right = e2R;</span><br><span class="line">            e2.right = e1;</span><br><span class="line">            e2.left = e1L;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e2P.left == e2) &#123; <span class="comment">// 情况 2</span></span><br><span class="line">            e2P.left = e1;</span><br><span class="line">            e2.left = e1L;</span><br><span class="line">            e2.right = e1R;</span><br><span class="line">            e1.left = e2L;</span><br><span class="line">            e1.right = e2R;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 情况 3</span></span><br><span class="line">            e2P.right = e1;</span><br><span class="line">            e2.left = e1L;</span><br><span class="line">            e2.right = e1R;</span><br><span class="line">            e1.left = e2L;</span><br><span class="line">            e1.right = e2R;</span><br><span class="line">        &#125;</span><br><span class="line">        head = e2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e2 == head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e2 == e1P) &#123; <span class="comment">// 情况 4</span></span><br><span class="line">            e2.left = e1L;</span><br><span class="line">            e2.right = e1R;</span><br><span class="line">            e1.left = e2;</span><br><span class="line">            e1.right = e2R;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e1P.left == e1) &#123; <span class="comment">// 情况 5</span></span><br><span class="line">            e1P.left = e2;</span><br><span class="line">            e1.left = e2L;</span><br><span class="line">            e1.right = e2R;</span><br><span class="line">            e2.left = e1L;</span><br><span class="line">            e2.right = e1R;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 情况 6</span></span><br><span class="line">            e1P.right = e2;</span><br><span class="line">            e1.left = e2L;</span><br><span class="line">            e1.right = e2R;</span><br><span class="line">            e2.left = e1L;</span><br><span class="line">            e2.right = e1R;</span><br><span class="line">        &#125;</span><br><span class="line">        head = e1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e1 == e2P) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e1P.left == e1) &#123; <span class="comment">// 情况 7</span></span><br><span class="line">                e1P.left = e2;</span><br><span class="line">                e1.left = e2L;</span><br><span class="line">                e1.right = e2R;</span><br><span class="line">                e2.left = e1L;</span><br><span class="line">                e2.right = e1;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 情况 8</span></span><br><span class="line">                e1P.right = e2;</span><br><span class="line">                e1.left = e2L;</span><br><span class="line">                e1.right = e2R;</span><br><span class="line">                e2.left = e1L;</span><br><span class="line">                e2.right = e1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e2 == e1P) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e2P.left == e2) &#123; <span class="comment">// 情况 9</span></span><br><span class="line">                e2P.left = e1;</span><br><span class="line">                e2.left = e1L;</span><br><span class="line">                e2.right = e1R;</span><br><span class="line">                e1.left = e2;</span><br><span class="line">                e1.right = e2R;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 情况 10</span></span><br><span class="line">                e2P.right = e1;</span><br><span class="line">                e2.left = e1L;</span><br><span class="line">                e2.right = e1R;</span><br><span class="line">                e1.left = e2;</span><br><span class="line">                e1.right = e2R;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (e1P.left == e1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e2P.left == e2) &#123; <span class="comment">// 情况 11</span></span><br><span class="line">                    e1.left = e2L;</span><br><span class="line">                    e1.right = e2R;</span><br><span class="line">                    e2.left = e1L;</span><br><span class="line">                    e2.right = e1R;</span><br><span class="line">                    e1P.left = e2;</span><br><span class="line">                    e2P.left = e1;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 情况 12</span></span><br><span class="line">                    e1.left = e2L;</span><br><span class="line">                    e1.right = e2R;</span><br><span class="line">                    e2.left = e1L;</span><br><span class="line">                    e2.right = e1R;</span><br><span class="line">                    e1P.left = e2;</span><br><span class="line">                    e2P.right = e1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e2P.left == e2) &#123; <span class="comment">// 情况 13</span></span><br><span class="line">                    e1.left = e2L;</span><br><span class="line">                    e1.right = e2R;</span><br><span class="line">                    e2.left = e1L;</span><br><span class="line">                    e2.right = e1R;</span><br><span class="line">                    e1P.right = e2;</span><br><span class="line">                    e2P.left = e1;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 情况 14</span></span><br><span class="line">                    e1.left = e2L;</span><br><span class="line">                    e1.right = e2R;</span><br><span class="line">                    e2.left = e1L;</span><br><span class="line">                    e2.right = e1R;</span><br><span class="line">                    e1P.right = e2;</span><br><span class="line">                    e2P.right = e1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断-t1-树是否包含-t2-树全部的拓扑结构"><a href="#判断-t1-树是否包含-t2-树全部的拓扑结构" class="headerlink" title="判断 t1 树是否包含 t2 树全部的拓扑结构"></a>判断 t1 树是否包含 t2 树全部的拓扑结构</h2><p><strong>题目</strong><br>给定彼此独立的两棵树头节点分别为 t1 和 t2，判断 t1 树是否包含 t2 树全部的拓扑结构。</p>
<p><strong>解答</strong><br>如果 t1 中某棵子树头节点的值与 t2 头节点的值一样，则从这两个头节点开始匹配。匹配的每一步都让 t1 上的节点跟着 t2 上的节点的先序遍历移动，每移动一步，都检查 t1 的当前节点是否与 t2 当前节点的值一样。<br>如果匹配的过程中发现有不匹配的情况，则直接返回 false，说明 t1 的当前子树从头节点开始，无法与 t2 匹配，那么再去寻找 t1 的下一棵子树。<br>t1 的每棵子树上都有可能匹配出 t2，所以都要检查一遍。<br>如果 t1 的节点数为 N，t2 的节点数为 M，则该方法的时间复杂度为 O(N×M)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Node t1, Node t2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (t2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(t1, t2) || contains(t1.left, t2) || contains(t1.right, t2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(Node h, Node t2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (t2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">null</span> || h.value != t2.value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(h.left, t2.left) &amp;&amp; check(h.right, t2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断-t1-树中是否有与-t2-树拓扑结构完全相同的子树"><a href="#判断-t1-树中是否有与-t2-树拓扑结构完全相同的子树" class="headerlink" title="判断 t1 树中是否有与 t2 树拓扑结构完全相同的子树"></a>判断 t1 树中是否有与 t2 树拓扑结构完全相同的子树</h2><p><strong>题目</strong><br>给定彼此独立的两棵树头节点分别为 t1 和 t2，判断 t1 中是否有与 t2 树拓扑结构完全相同的子树。</p>
<p><strong>解答</strong><br>如果 t1 的节点数为 N，t2 的节点数为 M，则本题最优解是时间复杂度为 O(N+M) 的方法。<br>首先简单介绍一个时间复杂度为 O(N×M) 的方法，对于 t1 的每棵子树，都判断是否与 t2 树的拓扑结构完全一样，这个过程的时间复杂度为 O(M)，t1 的子树一共有 N 棵，所以时间复杂度为 O(N×M)。</p>
<p>下面重点介绍一下时间复杂度为 O(N+M) 的方法。首先把 t1 树和 t2 树按照先序遍历的方式序列化。<br>t1 树序列化后的结果记为 t1Str，t2 树序列化后的结果记为 t2Str。接下来，只要验证 t2Str 是否是 t1Str 的子串即可，这个用 KMP 算法可以在线性时间内解决。<br>因此，t1 序列化的过程为 O(N)，t2 序列化的过程为 O(M)，KMP 解决 t1Str 和 t2Str 的匹配问题 O(M+N)，所以时间复杂度为 O(M+N)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(Node t1, Node t2)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">t1Str</span> <span class="operator">=</span> serialByPre(t1);</span><br><span class="line">    <span class="type">String</span> <span class="variable">t2Str</span> <span class="operator">=</span> serialByPre(t2);</span><br><span class="line">    <span class="keyword">return</span> getIndexOf(t1Str, t2Str) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">serialByPre</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> head.value + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">    res += serialByPre(head.left);</span><br><span class="line">    res += serialByPre(head.right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndexOf</span><span class="params">(String s, String m)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || m == <span class="literal">null</span> || m.length() &lt; <span class="number">1</span> || s.length() &lt; m.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] ss = s.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] ms = m.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">si</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] next = getNextArray(ms);</span><br><span class="line">    <span class="keyword">while</span> (si &lt; ss.length &amp;&amp; mi &lt; ms.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ss[si] == ms[mi]) &#123;</span><br><span class="line">            si++;</span><br><span class="line">            mi++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next[mi] == -<span class="number">1</span>) &#123;</span><br><span class="line">            si++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mi = next[mi];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mi == ms.length ? si - mi : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getNextArray(<span class="type">char</span>[] ms) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ms.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; -<span class="number">1</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[ms.length];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cn</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos &lt; next.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ms[pos - <span class="number">1</span>] == ms[cn]) &#123;</span><br><span class="line">            next[pos++] = ++cn;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cn = next[cn];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next[pos++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断二叉树是否为平衡二叉树"><a href="#判断二叉树是否为平衡二叉树" class="headerlink" title="判断二叉树是否为平衡二叉树"></a>判断二叉树是否为平衡二叉树</h2><p><strong>题目</strong><br>平衡二叉树的性质为：要么是一棵空树，要么任何一个节点的左右子树高度差的绝对值不超过 1。给定一棵二叉树的头节点 head，判断这棵二叉树是否为平衡二叉树。</p>
<p><strong>解答</strong><br>平衡二叉树的标准是：对任何子树来说，左子树和右子树的高度差都不超过 1。本题解法的整体过程为树形 dp 套路。<br>树形 dp 套路第一步：以某个节点 X 为头节点的子树中，分析答案有哪些可能性，并且这种分析是以 X 的左子树、X 的右子树和 X 整棵树的角度来考虑可能性的。<br>可能性一：如果 X 的左子树不是平衡的，则以 X 为头节点的树就是不平衡的。<br>可能性二：如果 X 的右子树不是平衡的，则以 X 为头节点的树就是不平衡的。<br>可能性三：如果 X 的左子树和右子树高度差超过 1，则以 X 为头节点的树就是不平衡的。<br>可能性四：如果上面可能性都没中，那么以 X 为头节点的树是平衡的。</p>
<p>树形 dp 套路第二步：根据第一步的可能性分析，列出所有需要的信息。左子树和右子树都需要知道各自是否平衡，以及高度这两个信息。<br>树形 dp 套路第三步：根据第二步信息汇总。定义信息如 ReturnType 类所示。</p>
<p>如果二叉树的节点数为 N，则要求时间复杂度为 O(N)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReturnType</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> isBalanced;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReturnType</span><span class="params">(<span class="type">boolean</span> isBalanced, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.isBalanced = isBalanced;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ReturnType <span class="title function_">process</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnType</span>(<span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ReturnType</span> <span class="variable">leftData</span> <span class="operator">=</span> process(head.left);</span><br><span class="line">    <span class="type">ReturnType</span> <span class="variable">rightData</span> <span class="operator">=</span> process(head.right);</span><br><span class="line">    <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> Math.max(leftData.height, rightData.height) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isBalanced</span> <span class="operator">=</span> leftData.isBalanced &amp;&amp; rightData.isBalanced</span><br><span class="line">            &amp;&amp; Math.abs(leftData.height - rightData.height) &lt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnType</span>(isBalanced, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> process(head).isBalanced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="根据后序数组重建搜索二叉树"><a href="#根据后序数组重建搜索二叉树" class="headerlink" title="根据后序数组重建搜索二叉树"></a>根据后序数组重建搜索二叉树</h2><p><strong>题目</strong><br>给定一个整型数组 arr，已知其中没有重复值，判断 arr 是否可能是节点值类型为整型的搜索二叉树后序遍历的结果。<br>进阶问题：如果整型数组 arr 中没有重复值，且已知是一棵搜索二叉树的后序遍历结果，通过数组 arr 重构二叉树。</p>
<p><strong>解答</strong><br>原问题的解法。二叉树的后序遍历为先左、再右、最后根的顺序，所以，如果一个数组是二叉树后序遍历的结果，那么头节点的值一定会是数组的最后一个元素。根据搜索二叉树的性质，比后序数组最后一个元素值小的数组会在数组的左边，比数组最后一个元素值大的数组会在数组的右边。比如，arr=[2,1,3,6,5,7,4]，比 4 小的部分为[2,1,3]，比 4 大的部分为[6,5,7]。如果不满足这种情况，则说明这个数组一定不可能是搜索二叉树后序遍历的结果。接下来，数组划分成左边数组和右边数组，相当于二叉树分出了左子树和右子树，只要递归地进行如上判断即可。</p>
<p>具体过程请查看如下代码中的 isPostArray 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPostArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isPost(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPost</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">less</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> end;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[end] &gt; arr[i]) &#123;</span><br><span class="line">            less = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            more = more == end ? i : more;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (less == -<span class="number">1</span> || more == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> isPost(arr, start, end - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (less != more - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isPost(arr, start, less) &amp;&amp; isPost(arr, more, end - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进阶问题的分析与原问题同理，一棵树的后序数组中最后一个值为二叉树头节点的值，数组左部分都比头节点的值小，用来生成头节点的左子树，剩下的部分用来生成右子树。<br>具体过程请查看如下代码中的 posArrayToBST 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">posArrayToBST</span><span class="params">(<span class="type">int</span>[] posArr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (posArr == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> posToBST(posArr, <span class="number">0</span>, posArr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">posToBST</span><span class="params">(<span class="type">int</span>[] posArr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(posArr[end]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">less</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> end;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (posArr[end] &gt; posArr[i]) &#123;</span><br><span class="line">            less = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            more = more == end ? i : more;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    head.left = posToBST(posArr, start, less);</span><br><span class="line">    head.right = posToBST(posArr, more, end - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断一棵二叉树是否为搜索二叉树和完全二叉树"><a href="#判断一棵二叉树是否为搜索二叉树和完全二叉树" class="headerlink" title="判断一棵二叉树是否为搜索二叉树和完全二叉树"></a>判断一棵二叉树是否为搜索二叉树和完全二叉树</h2><p><strong>题目</strong><br>给定二叉树的一个头节点 head，已知其中没有重复值的节点，实现两个函数分别判断这棵二叉树是否为搜索二叉树和完全二叉树。</p>
<p><strong>解答</strong><br>判断一棵二叉树是否为搜索二叉树，只要改写一个二叉树中序遍历，在遍历的过程中看节点值是否都是递增的即可。本书改写的是 Morris 中序遍历，所以时间复杂度为 O(N)，额外空间复杂度为 O(1)。有关 Morris 中序遍历的介绍，请读者阅读本书“遍历二叉树的神级方法”问题。<br>需要注意的是，Morris 遍历分调整二叉树结构和恢复二叉树结构两个阶段。因此，当发现节点值是降序时，不能直接返回 false，这么做可能会跳过恢复阶段，从而破坏二叉树的结构。<br>通过改写 Morris 中序遍历来判断搜索二叉树的过程请查看如下代码中的 isBST 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBST</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur1</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        cur2 = cur1.left;</span><br><span class="line">        <span class="keyword">if</span> (cur2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur2.right != <span class="literal">null</span> &amp;&amp; cur2.right != cur1) &#123;</span><br><span class="line">                cur2 = cur2.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur2.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                cur2.right = cur1;</span><br><span class="line">                cur1 = cur1.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur2.right = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">null</span> &amp;&amp; pre.value &gt; cur1.value) &#123;</span><br><span class="line">            res = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur1;</span><br><span class="line">        cur1 = cur1.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断一棵二叉树是否为完全二叉树，依据以下标准会使判断过程变得简单且易实现。</p>
<ol>
<li>按层遍历二叉树，从每层的左边向右边依次遍历所有的节点。</li>
<li>如果当前节点有右孩子节点，但没有左孩子节点，则直接返回 false。</li>
<li>如果当前节点并不是左右孩子节点全有，那么之后的节点必须都为叶节点，否则返回 false。</li>
<li>遍历过程中如果不返回 false，则遍历结束后返回 true。<br>判断是否是完全二叉树的全部过程请查看如下代码中的 isCBT 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCBT</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Node&gt;();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">leaf</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">l</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    queue.offer(head);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        head = queue.poll();</span><br><span class="line">        l = head.left;</span><br><span class="line">        r = head.right;</span><br><span class="line">        <span class="keyword">if</span> ((leaf &amp;&amp; (l != <span class="literal">null</span> || r != <span class="literal">null</span>)) || (l == <span class="literal">null</span> &amp;&amp; r != <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(r);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leaf = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过有序数组生成平衡搜索二叉树"><a href="#通过有序数组生成平衡搜索二叉树" class="headerlink" title="通过有序数组生成平衡搜索二叉树"></a>通过有序数组生成平衡搜索二叉树</h2><p><strong>题目</strong><br>给定一个有序数组 sortArr，已知其中没有重复值，用这个有序数组生成一棵平衡搜索二叉树，并且该搜索二叉树中序遍历的结果与 sortArr 一致。</p>
<p><strong>解答</strong><br>本题的递归过程比较简单，用有序数组中最中间的数生成搜索二叉树的头节点，然后用这个数左边的数生成左子树，用右边的数生成右子树即可。<br>全部过程请查看如下代码中的 generateTree 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">generateTree</span><span class="params">(<span class="type">int</span>[] sortArr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sortArr == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> generate(sortArr, <span class="number">0</span>, sortArr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">generate</span><span class="params">(<span class="type">int</span>[] sortArr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(sortArr[mid]);</span><br><span class="line">    head.left = generate(sortArr, start, mid - <span class="number">1</span>);</span><br><span class="line">    head.right = generate(sortArr, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在二叉树中找到一个节点的后继节点"><a href="#在二叉树中找到一个节点的后继节点" class="headerlink" title="在二叉树中找到一个节点的后继节点"></a>在二叉树中找到一个节点的后继节点</h2><p><strong>题目</strong><br>现在有一种新的二叉树节点类型如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="keyword">public</span> Node parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该结构比普通二叉树节点结构多了一个指向父节点的 parent 指针。假设有一棵 Node 类型的节点组成的二叉树，树中每个节点的 parent 指针都正确地指向自己的父节点，头节点的 parent 指向 null。只给出一个在二叉树中的某个节点 node，请实现返回 node 的后继节点的函数。在二叉树的中序遍历的序列中，node 的下一个节点叫做 node 的后继节点。</p>
<p><strong>解答</strong><br>最优解法不必遍历所有的节点，如果 node 节点和 node 后继节点之间的实际距离为 L，最优解法只用走过 L 个节点，时间复杂度为 O(L)，额外空间复杂度为 O(1)。<br>接下来详细说明最优解法是如何找到 node 的后继节点的。<br>情况 1：如果 node 有右子树，那么后继节点就是右子树上最左边的节点。<br>情况 2：如果 node 没有右子树，那么先看 node 是不是 node 父节点的左孩子节点，如果是左孩子节点，那么此时 node 的父节点就是 node 的后继节点；如果是右孩子节点，就向上寻找 node 的后继节点，假设向上移动到的节点记为 s，s 的父节点记为 p，如果发现 s 是 p 的左孩子节点，那么节点 p 就是 node 节点的后继节点，否则就一直向上移动。<br>情况 3：如果在情况 2 中一直向上寻找，都移动到空节点时还是没有发现 node 的后继节点，说明 node 根本不存在后继节点。</p>
<p>最优解的具体过程请查看如下代码中的 getNextNode 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">getNextNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getLeftMost(node.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> node.parent;</span><br><span class="line">        <span class="keyword">while</span> (parent != <span class="literal">null</span> &amp;&amp; parent.left != node) &#123;</span><br><span class="line">            node = parent;</span><br><span class="line">            parent = node.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">getLeftMost</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在二叉树中找到两个节点的最近公共祖先"><a href="#在二叉树中找到两个节点的最近公共祖先" class="headerlink" title="在二叉树中找到两个节点的最近公共祖先"></a>在二叉树中找到两个节点的最近公共祖先</h2><p><strong>题目</strong><br>给定一棵二叉树的头节点 head，以及这棵树中的两个节点 o1 和 o2，请返回 o1 和 o2 的最近公共祖先节点。<br>例如，图 3-41 所示的二叉树。<br>节点 4 和节点 5 的最近公共祖先节点为节点 2。节点 5 和节点 2 的最近公共祖先节点为节点 2。节点 6 和节点 8 的最近公共祖先节点为节点 3。节点 5 和节点 8 的最近公共祖先节点为节点 1。<br>进阶问题：如果查询两个节点的最近公共祖先的操作十分频繁，想让单条查询的查询时间减少。<br>再进阶问题：给定二叉树的头节点 head，同时给定所有想要进行的查询。二叉树的节点数量为 N，查询条数为 M，请在时间复杂度为 O(N+M) 内返回所有查询的结果。</p>
<p><strong>解答</strong><br>先来解决原问题。后序遍历二叉树，假设遍历到的当前节点为 cur。因为是后序遍历，所以先处理 cur 的两棵子树。假设处理 cur 左子树时返回节点为 left，处理右子树时返回节点为 right。</p>
<ol>
<li>如果发现 cur 等于 null，或者 o1、o2，则返回 cur。</li>
<li>如果 left 和 right 都为空，说明 cur 整棵子树上没有发现过 o1 或 o2，返回 null。</li>
<li>如果 left 和 right 都不为空，说明左子树上发现过 o1 或 o2，右子树上也发现过 o2 或 o1，说明 o1 向上与 o2 向上的过程中，首次在 cur 相遇，返回 cur。</li>
<li>如果 left 和 right 有一个为空，另一个不为空，假设不为空的那个记为 node，此时 node 到底是什么？有两种可能，要么 node 是 o1 或 o2 中的一个，要么 node 已经是 o1 和 o2 的最近公共祖先。不管是哪种情况，直接返回 node 即可。</li>
</ol>
<p>找到两个节点最近公共祖先的详细过程请参看如下代码中的 lowestAncestor 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">lowestAncestor</span><span class="params">(Node head, Node o1, Node o2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head == o1 || head == o2) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">left</span> <span class="operator">=</span> lowestAncestor(head.left, o1, o2);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">right</span> <span class="operator">=</span> lowestAncestor(head.right, o1, o2);</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进阶问题其实是先花较大的力气建立一种记录，以后执行每次查询时就可以完全根据记录进行查询。记录的方式可以有很多种，本书提供两种记录结构供读者参考，两种记录各有优缺点。</p>
<p>结构一：建立二叉树中每个节点对应的父节点信息，是一张哈希表。<br>如果对题目中的二叉树建立这种哈希表，哈希表中的信息如下：<br>key 代表二叉树中的一个节点，value 代表其对应的父节点。只用遍历一次二叉树，这张表就可以建好，以后每次查询都可以根据这张哈希表进行。<br>假设想查节点 4 和节点 8 的最近公共祖先，方法是使用如上的哈希表，把包括节点 4 在内的所有节点 4 的祖先节点放进另一个哈希表 A 中，A 表示节点 4 到头节点这条路径上所有节点的集合。然后使用如上的哈希表，从节点 8 开始往上逐渐移动到头节点。首先是节点 8，发现不在 A 中，然后是节点 7，发现也不在 A 中，接下是节点 3，依然不在 A 中，最后是节点 1，发现在 A 中，那么节点 1 就是节点 4 和节点 8 的最近公共祖先。只要在移动过程中发现某个节点在 A 中，这个节点就是要求的公共祖先节点。<br>结构一的具体实现请参看如下代码中 Record1 类的实现，构造函数是创建记录过程，方法 query 是查询操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Record1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Node, Node&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Record1</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node, Node&gt;();</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.put(head, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setMap(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setMap</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.put(head.left, head);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.put(head.right, head);</span><br><span class="line">        &#125;</span><br><span class="line">        setMap(head.left);</span><br><span class="line">        setMap(head.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">query</span><span class="params">(Node o1, Node o2)</span> &#123;</span><br><span class="line">        HashSet&lt;Node&gt; path = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Node&gt;();</span><br><span class="line">        <span class="keyword">while</span> (map.containsKey(o1)) &#123;</span><br><span class="line">            path.add(o1);</span><br><span class="line">            o1 = map.get(o1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!path.contains(o2)) &#123;</span><br><span class="line">            o2 = map.get(o2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，结构一建立记录的过程时间复杂度为 O(N)、额外空间复杂度为 O(N)。进行查询操作时，时间复杂度为 O(h)，其中，h 为二叉树的高度。<br>结构二：直接建立任意两个节点之间的最近公共祖先记录，便于以后查询。<br>建立记录的具体过程如下：</p>
<ol>
<li>对二叉树中的每棵子树（一共 N 棵）都进行步骤 2。</li>
<li>假设子树的头节点为 h，h 所有的后代节点和 h 节点的最近公共祖先都是 h，记录下来。h 左子树的每个节点和 h 右子树的每个节点的最近公共祖先都是 h，记录下来。<br>为了保证记录不重复，设计一种好的实现方式是这种结构实现的重点。<br>结构二的具体实现请参看如下代码中 Record2 类的实现。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Record2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Node, HashMap&lt;Node, Node&gt;&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Record2</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node, HashMap&lt;Node, Node&gt;&gt;();</span><br><span class="line">        initMap(head);</span><br><span class="line">        setMap(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initMap</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(head, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node, Node&gt;());</span><br><span class="line">        initMap(head.left);</span><br><span class="line">        initMap(head.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setMap</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        headRecord(head.left, head);</span><br><span class="line">        headRecord(head.right, head);</span><br><span class="line">        subRecord(head);</span><br><span class="line">        setMap(head.left);</span><br><span class="line">        setMap(head.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">headRecord</span><span class="params">(Node n, Node h)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.get(n).put(h, h);</span><br><span class="line">        headRecord(n.left, h);</span><br><span class="line">        headRecord(n.right, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">subRecord</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preLeft(head.left, head.right, head);</span><br><span class="line">        subRecord(head.left);</span><br><span class="line">        subRecord(head.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preLeft</span><span class="params">(Node l, Node r, Node h)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preRight(l, r, h);</span><br><span class="line">        preLeft(l.left, r, h);</span><br><span class="line">        preLeft(l.right, r, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preRight</span><span class="params">(Node l, Node r, Node h)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.get(l).put(r, h);</span><br><span class="line">        preRight(l, r.left, h);</span><br><span class="line">        preRight(l, r.right, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">query</span><span class="params">(Node o1, Node o2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o1 == o2) &#123;</span><br><span class="line">            <span class="keyword">return</span> o1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(o1)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(o1).get(o2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(o2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(o2).get(o1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果二叉树的节点数为 N，想要记录每两个节点之间的信息，信息的条数为 ((N-1)×N)/2。所以建立结构二的过程的额外空间复杂度为 O(N²)，时间复杂度为 O(N²)，单次查询的时间复杂度为 O(1)。</p>
<h2 id="Tarjan-算法与并查集解决二叉树节点间最近公共祖先的批量查询问题"><a href="#Tarjan-算法与并查集解决二叉树节点间最近公共祖先的批量查询问题" class="headerlink" title="Tarjan 算法与并查集解决二叉树节点间最近公共祖先的批量查询问题"></a>Tarjan 算法与并查集解决二叉树节点间最近公共祖先的批量查询问题</h2><p><strong>题目</strong><br>如下的 Node 类是标准的二叉树节点结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>再定义 Query 类如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Query</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node o1;</span><br><span class="line">    <span class="keyword">public</span> Node o2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Query</span><span class="params">(Node o1, Node o2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.o1 = o1;</span><br><span class="line">        <span class="built_in">this</span>.o2 = o2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一个 Query 类的实例表示一条查询语句，表示想要查询 o1 节点和 o2 节点的最近公共祖先节点。<br>给定一棵二叉树的头节点 head，并给定所有的查询语句，即一个 Query 类型的数组 Query[] ques，请返回 Node 类型的数组 Node[] ans，ans[i]代表 ques[i]这条查询的答案，即 ques[i].o1 和 ques[i].o2 的最近公共祖先。</p>
<p><strong>要求</strong><br>如果二叉树的节点数为 N，查询语句的条数为 M，整个处理过程的时间复杂度要求达到 O(N+M)。</p>
<p><strong>解答</strong><br>本题的解法利用了 Tarjan 算法与并查集结构的结合。<br>二叉树的后序遍历（或者说深度优先遍历）配合并查集可以实现批量查询。<br>具体流程如下：</p>
<ol>
<li>生成两张哈希表 queryMap 和 indexMap。queryMap 类似于邻接表，key 表示查询涉及的某个节点，value 是一个链表类型，表示 key 与哪些节点之间有查询任务。indexMap 的 key 也表示查询涉及的某个节点，value 也是链表类型，表示如果依次解决有关 key 节点的每个问题，该把答案放在 ans 的什么位置。</li>
<li>遍历二叉树（后序遍历）：<ul>
<li>递归遍历左子树。</li>
<li>集合合并：左子树遍历完后，将左孩子所在集合与当前节点所在集合合并。</li>
<li>设置祖先：设置合并后集合的祖先为当前节点。</li>
<li>递归遍历右子树。</li>
<li>集合合并：右子树遍历完后，将右孩子所在集合与当前节点所在集合合并。</li>
<li>设置祖先：设置合并后集合的祖先为当前节点。</li>
<li>处理查询：遍历 queryMap 中当前节点涉及的所有查询。如果查询的另一个节点 o2 已经访问过（即在已遍历的集合中），则 o2 所在集合的祖先即为当前节点和 o2 的最近公共祖先。</li>
</ul>
</li>
</ol>
<p>为了达到 O(N+M) 的复杂度，并查集的 find 和 union 操作需要近似 O(1)，这需要路径压缩和按秩合并的优化。</p>
<p>全部的处理流程请参看如下代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Element</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Element</span><span class="params">(V value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFindSet</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;V, Element&lt;V&gt;&gt; elementMap;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Element&lt;V&gt;, Element&lt;V&gt;&gt; fatherMap;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Element&lt;V&gt;, Integer&gt; rankMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFindSet</span><span class="params">(List&lt;V&gt; list)</span> &#123;</span><br><span class="line">        elementMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;V, Element&lt;V&gt;&gt;();</span><br><span class="line">        fatherMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Element&lt;V&gt;, Element&lt;V&gt;&gt;();</span><br><span class="line">        rankMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Element&lt;V&gt;, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (V value : list) &#123;</span><br><span class="line">            Element&lt;V&gt; element = <span class="keyword">new</span> <span class="title class_">Element</span>&lt;V&gt;(value);</span><br><span class="line">            elementMap.put(value, element);</span><br><span class="line">            fatherMap.put(element, element);</span><br><span class="line">            rankMap.put(element, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Element&lt;V&gt; <span class="title function_">findHead</span><span class="params">(Element&lt;V&gt; element)</span> &#123;</span><br><span class="line">        Stack&lt;Element&lt;V&gt;&gt; path = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Element&lt;V&gt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (element != fatherMap.get(element)) &#123;</span><br><span class="line">            path.push(element);</span><br><span class="line">            element = fatherMap.get(element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!path.isEmpty()) &#123;</span><br><span class="line">            fatherMap.put(path.pop(), element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">findHead</span><span class="params">(V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> elementMap.containsKey(value) ? findHead(elementMap.get(value)).value : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameSet</span><span class="params">(V a, V b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementMap.containsKey(a) &amp;&amp; elementMap.containsKey(b)) &#123;</span><br><span class="line">            <span class="keyword">return</span> findHead(elementMap.get(a)) == findHead(elementMap.get(b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(V a, V b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementMap.containsKey(a) &amp;&amp; elementMap.containsKey(b)) &#123;</span><br><span class="line">            Element&lt;V&gt; aF = findHead(elementMap.get(a));</span><br><span class="line">            Element&lt;V&gt; bF = findHead(elementMap.get(b));</span><br><span class="line">            <span class="keyword">if</span> (aF != bF) &#123;</span><br><span class="line">                Element&lt;V&gt; big = rankMap.get(aF) &gt;= rankMap.get(bF) ? aF : bF;</span><br><span class="line">                Element&lt;V&gt; small = big == aF ? bF : aF;</span><br><span class="line">                fatherMap.put(small, big);</span><br><span class="line">                rankMap.put(big, rankMap.get(aF) + rankMap.get(bF));</span><br><span class="line">                rankMap.remove(small);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TarjanLCA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Query</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> Node o1;</span><br><span class="line">        <span class="keyword">public</span> Node o2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Query</span><span class="params">(Node o1, Node o2)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.o1 = o1;</span><br><span class="line">            <span class="built_in">this</span>.o2 = o2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node[] tarJanQuery(Node head, Query[] quries) &#123;</span><br><span class="line">        HashMap&lt;Node, LinkedList&lt;Node&gt;&gt; queryMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node, LinkedList&lt;Node&gt;&gt;();</span><br><span class="line">        HashMap&lt;Node, LinkedList&lt;Integer&gt;&gt; indexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node, LinkedList&lt;Integer&gt;&gt;();</span><br><span class="line">        HashMap&lt;Node, Node&gt; ancestorMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node, Node&gt;();</span><br><span class="line">        UnionFindSet&lt;Node&gt; sets = <span class="keyword">new</span> <span class="title class_">UnionFindSet</span>&lt;Node&gt;(getAllNodes(head));</span><br><span class="line">        Node[] ans = <span class="keyword">new</span> <span class="title class_">Node</span>[quries.length];</span><br><span class="line">        setQueriesAndSetEasyAnswers(quries, ans, queryMap, indexMap);</span><br><span class="line">        setAnswers(head, ans, queryMap, indexMap, ancestorMap, sets);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">getAllNodes</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        List&lt;Node&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Node&gt;();</span><br><span class="line">        process(head, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Node head, List&lt;Node&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(head);</span><br><span class="line">        process(head.left, res);</span><br><span class="line">        process(head.right, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setQueriesAndSetEasyAnswers</span><span class="params">(Query[] ques, Node[] ans,</span></span><br><span class="line"><span class="params">            HashMap&lt;Node, LinkedList&lt;Node&gt;&gt; queryMap, HashMap&lt;Node, LinkedList&lt;Integer&gt;&gt; indexMap)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != ans.length; i++) &#123;</span><br><span class="line">            o1 = ques[i].o1;</span><br><span class="line">            o2 = ques[i].o2;</span><br><span class="line">            <span class="keyword">if</span> (o1 == o2 || o1 == <span class="literal">null</span> || o2 == <span class="literal">null</span>) &#123;</span><br><span class="line">                ans[i] = o1 != <span class="literal">null</span> ? o1 : o2;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!queryMap.containsKey(o1)) &#123;</span><br><span class="line">                    queryMap.put(o1, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Node&gt;());</span><br><span class="line">                    indexMap.put(o1, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!queryMap.containsKey(o2)) &#123;</span><br><span class="line">                    queryMap.put(o2, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Node&gt;());</span><br><span class="line">                    indexMap.put(o2, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                queryMap.get(o1).add(o2);</span><br><span class="line">                indexMap.get(o1).add(i);</span><br><span class="line">                queryMap.get(o2).add(o1);</span><br><span class="line">                indexMap.get(o2).add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setAnswers</span><span class="params">(Node head, Node[] ans, HashMap&lt;Node, LinkedList&lt;Node&gt;&gt; queryMap,</span></span><br><span class="line"><span class="params">            HashMap&lt;Node, LinkedList&lt;Integer&gt;&gt; indexMap, HashMap&lt;Node, Node&gt; ancestorMap,</span></span><br><span class="line"><span class="params">            UnionFindSet&lt;Node&gt; sets)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        setAnswers(head.left, ans, queryMap, indexMap, ancestorMap, sets);</span><br><span class="line">        sets.union(head.left, head);</span><br><span class="line">        ancestorMap.put(sets.findHead(head), head);</span><br><span class="line">        setAnswers(head.right, ans, queryMap, indexMap, ancestorMap, sets);</span><br><span class="line">        sets.union(head.right, head);</span><br><span class="line">        ancestorMap.put(sets.findHead(head), head);</span><br><span class="line">        LinkedList&lt;Node&gt; nList = queryMap.get(head);</span><br><span class="line">        LinkedList&lt;Integer&gt; iList = indexMap.get(head);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">nodeFather</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (nList != <span class="literal">null</span> &amp;&amp; !nList.isEmpty()) &#123;</span><br><span class="line">            node = nList.poll();</span><br><span class="line">            index = iList.poll();</span><br><span class="line">            nodeFather = sets.findHead(node);</span><br><span class="line">            <span class="keyword">if</span> (ancestorMap.containsKey(nodeFather)) &#123;</span><br><span class="line">                ans[index] = ancestorMap.get(nodeFather);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树节点间的最大距离问题"><a href="#二叉树节点间的最大距离问题" class="headerlink" title="二叉树节点间的最大距离问题"></a>二叉树节点间的最大距离问题</h2><p><strong>题目</strong><br>从二叉树的节点 A 出发，可以向上或者向下走，但沿途的节点只能经过一次，当到达节点 B 时，路径上的节点数叫做 A 到 B 的距离。<br>比如，图 3-43 所示的二叉树，节点 4 和节点 2 的距离为 2，节点 5 和节点 6 的距离为 5。<br>给定一棵二叉树的头节点 head，求整棵树上节点间的最大距离。</p>
<p><strong>要求</strong><br>如果二叉树的节点数为 N，时间复杂度要求为 O(N)。</p>
<p><strong>解答</strong><br>本题解法的整体过程为树形 dp 套路。首先本题对于树形 dp 套路前提是满足的：依次求出每一个节点为头节点的子树上的最大距离，那么最终答案一定在其中。<br>树形 dp 套路第一步：以某个节点 X 为头节点的子树中，分析答案来自哪些可能性，并且这种分析是以 X 的左子树、X 的右子树和整棵树的角度来考虑可能性的。<br>可能性一：以 X 为头节点的子树，最大距离可能是左子树上的最大距离。<br>可能性二：以 X 为头节点的子树，最大距离可能是右子树上的最大距离。<br>可能性三：以 X 为头节点的子树，最大距离可能是从 X 的左子树离 X 最远的节点，先到达 X，然后走到 X 的右子树离 X 最远的节点。也就是左子树高度 + 右子树高度 + 1。</p>
<p>树形 dp 套路第二步：根据第一步的可能性分析，列出所有需要的信息。左子树和右子树都需要知道自己这棵子树上的最大距离，以及高度这两个信息。<br>树形 dp 套路第三步：根据第二步信息汇总。定义信息如 ReturnType 类所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReturnType</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> maxDistance;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReturnType</span><span class="params">(<span class="type">int</span> maxDistance, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxDistance = maxDistance;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>树形 dp 套路第四步：设计递归函数。递归函数是处理以 X 为头节点的情况下的答案，包括设计递归的 base case、默认直接得到左树和右树的所有信息，以及把可能性做整合，并且也要返回第三步的信息结构这四个小步骤。本题的递归实现请看以下的 process 方法，主函数是以下的 getMaxDistance 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ReturnType <span class="title function_">process</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnType</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ReturnType</span> <span class="variable">leftData</span> <span class="operator">=</span> process(head.left);</span><br><span class="line">    <span class="type">ReturnType</span> <span class="variable">rightData</span> <span class="operator">=</span> process(head.right);</span><br><span class="line">    <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> Math.max(leftData.height, rightData.height) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDistance</span> <span class="operator">=</span> Math.max(leftData.height + rightData.height + <span class="number">1</span>,</span><br><span class="line">            Math.max(leftData.maxDistance, rightData.maxDistance));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnType</span>(maxDistance, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaxDistance</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> process(head).maxDistance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="派对的最大快乐值"><a href="#派对的最大快乐值" class="headerlink" title="派对的最大快乐值"></a>派对的最大快乐值</h2><p><strong>题目</strong><br>员工信息的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> happy; <span class="comment">// 这名员工可以带来的快乐值</span></span><br><span class="line">    List&lt;Employee&gt; subordinates; <span class="comment">// 这名员工有哪些直接下级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、没有环的多叉树。树的头节点是公司唯一的老板，除老板外，每个员工都有唯一的直接上级。叶节点是没有任何下属的基层员工（subordinates 列表为空），除基层员工外，每个员工都有一个或多个直接下级。<br>这个公司现在要办 party，你可以决定哪些员工来，哪些员工不来。但是要遵循如下规则。</p>
<ol>
<li>如果某个员工来了，那么这个员工的所有直接下级都不能来。</li>
<li>派对的整体快乐值是所有到场员工快乐值的累加。</li>
<li>你的目标是让派对的整体快乐值尽量大。<br>给定一个头节点 boss，请返回派对的最大快乐值。</li>
</ol>
<p><strong>要求</strong><br>如果以 boss 为头节点的整棵树有 N 个节点，请做到时间复杂度为 O(N)。</p>
<p><strong>解答</strong><br>假设以 X 为头节点的整棵树如图 3-44 所示。<br>X 有 a、b、c 三个直接下级，a、b、c 再往下一级的关系在图中已经省略。现在分析以 X 为头节点的整棵树，最大快乐值如何得到。情况只有两种，一种为 X 来情况下，整棵树的最大快乐值，记为 yes_X_max；另一种为 X 不来情况下，整棵树的最大快乐值，记为 no_X_max。下面分别进行分析。<br>yes_X_max。在 X 来的情况下，派对一定会累加 X 的快乐值，记为 X_happy，同时在这种情况下，a、b、c 都不能来。假设以 a 为头节点的整棵树，在 a 不来情况下的最大快乐值记为 no_a_max；以 b 为头节点的整棵树，在 b 不来情况下的最大快乐值记为 no_b_max；以 c 为头节点的整棵树，在 c 不来情况下的最大快乐值记为 no_c_max。那么 yes_X_max 的值如下：<br>yes_X_max = X_happy + no_a_max + no_b_max + no_c_max<br>no_X_max。在 X 不来的情况下，派对无法累加 X 的快乐值，同时在这种情况下，a、b、c 谁来不来都可以。假设以 a 为头节点的整棵树，在 a 不来情况下的最大快乐值记为 no_a_max，在 a 来情况下的最大快乐值记为 yes_a_max；以 b 为头节点的整棵树，在 b 不来情况下的最大快乐值记为 no_b_max，在 b 来情况下的最大快乐值记为 yes_b_max；以 c 为头节点的整棵树，在 c 不来情况下的最大快乐值记为 no_c_max，在 c 来情况下的最大快乐值记为 yes_c_max。那么 no_X_max 的值如下：<br>no_X_max = Max { no_a_max, yes_a_max } + Max { no_b_max, yes_b_max } + Max{ no_c_max, yes_c_max}</p>
<p>也就是说，某一个下级节点来还是不来，要看这个下级节点来还是不来的两种情况下，哪一种获得的收益最多。<br>yes_X_max 和 no_X_max 哪个大，哪个就是 X 为头节点的整棵树的最大快乐值。<br>上面的分析说明中，以 X 为头节点的整棵树，需要以直接下级为头节点的每一棵子树，都给出子树的头节点（a、b、c）来还是不来两种情况下的最大收益。整个过程明显是一个递归过程。递归过程的返回值结构如 ReturnData 类所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每棵树处理完之后的返回值类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReturnData</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> yesHeadMax; <span class="comment">// 树的头节点来的情况下，整棵树的最大收益</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> noHeadMax; <span class="comment">// 树的头节点不来的情况下，整棵树的最大收益</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReturnData</span><span class="params">(<span class="type">int</span> yesHeadMax, <span class="type">int</span> noHeadMax)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.yesHeadMax = yesHeadMax;</span><br><span class="line">        <span class="built_in">this</span>.noHeadMax = noHeadMax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个递归过程如 process 方法所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数处理以 x 为头节点的树，并且返回 x 来和不来两种情况下的最大快乐值</span></span><br><span class="line"><span class="comment">// 所以返回值的类型为 ReturnData 类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ReturnData <span class="title function_">process</span><span class="params">(Employee X)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">yesX</span> <span class="operator">=</span> X.happy; <span class="comment">// X 来的情况下，一定要累加上 X 自己的快乐值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">noX</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// X 不来的情况下，不累加上 X 自己的快乐值</span></span><br><span class="line">    <span class="keyword">if</span> (X.subordinates.isEmpty()) &#123; <span class="comment">// 如果 X 没有直接下属，说明是基层员工，直接返回即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnData</span>(yesX, noX);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果 x 有直接下属，就按照题目的分析来</span></span><br><span class="line">        <span class="comment">// 枚举 x 的每一个直接下级员工 next</span></span><br><span class="line">        <span class="keyword">for</span> (Employee next : X.subordinates) &#123;</span><br><span class="line">            <span class="comment">// 递归调用 process，得到以 next 为头节点的子树，</span></span><br><span class="line">            <span class="comment">// 在 next 来和不来两种情况下分别获得的最大收益</span></span><br><span class="line">            <span class="type">ReturnData</span> <span class="variable">subTreeInfo</span> <span class="operator">=</span> process(next);</span><br><span class="line">            yesX += subTreeInfo.noHeadMax; <span class="comment">// 见书中 yes_X_max 的分析</span></span><br><span class="line">            noX += Math.max(subTreeInfo.yesHeadMax, subTreeInfo.noHeadMax); <span class="comment">// 见书中 no_X_max 的分析</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnData</span>(yesX, noX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理解了上面的分析之后，我们看以 boss 为头节点的整棵树的答案怎么得到。毫无疑问，以 boss 为头节点的整棵树分两种情况，boss 来的情况下整棵树的最大快乐值和 boss 不来的情况下整棵树的最大快乐值，最大的那个就是我们想要的答案。整个解法的主方法请看如下的 getMaxHappy 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaxHappy</span><span class="params">(Employee boss)</span> &#123;</span><br><span class="line">    <span class="type">ReturnData</span> <span class="variable">allTreeInfo</span> <span class="operator">=</span> process(boss);</span><br><span class="line">    <span class="keyword">return</span> Math.max(allTreeInfo.noHeadMax, allTreeInfo.yesHeadMax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过先序和中序数组生成后序数组"><a href="#通过先序和中序数组生成后序数组" class="headerlink" title="通过先序和中序数组生成后序数组"></a>通过先序和中序数组生成后序数组</h2><p><strong>题目</strong></p>
<p>已知一棵二叉树所有的节点值都不同，给定这棵树正确的先序和中序数组，不要重建整棵树，而是通过这两个数组直接生成正确的后序数组。</p>
<p><strong>解答</strong></p>
<p>举例说明生成后序数组的过程，假设 <code>pre = [1, 2, 4, 5, 3, 6, 7]</code>, <code>in = [4, 2, 5, 1, 6, 3, 7]</code>。</p>
<ol>
<li>根据 <code>pre</code> 和 <code>in</code> 的长度，生成长度为 7 的后序数组 <code>pos</code>，按以下规则从右到左填满 <code>pos</code>。</li>
<li>根据 <code>[1, 2, 4, 5, 3, 6, 7]</code> 和 <code>[4, 2, 5, 1, 6, 3, 7]</code>，设置 <code>pos[6] = 1</code>，即先序数组最左边的值。根据 1，把 <code>in</code> 划分成 <code>[4, 2, 5]</code> 和 <code>[6, 3, 7]</code>，<code>pre</code> 中 1 的右边部分根据这两部分等长划分出 <code>[2, 4, 5]</code> 和 <code>[3, 6, 7]</code>。<code>[2, 4, 5]</code> 和 <code>[4, 2, 5]</code> 一组，<code>[3, 6, 7]</code> 和 <code>[6, 3, 7]</code> 一组。</li>
<li>根据 <code>[3, 6, 7]</code> 和 <code>[6, 3, 7]</code>，设置 <code>pos[5] = 3</code>，再次划分出 <code>[6]</code>（来自 <code>[3, 6, 7]</code>）和 <code>[6]</code>（来自 <code>[6, 3, 7]</code>）一组，<code>[7]</code>（来自 <code>[3, 6, 7]</code>）和 <code>[7]</code>（来自 <code>[6, 3, 7]</code>）一组。</li>
<li>根据 <code>[7]</code> 和 <code>[7]</code>，设置 <code>pos[4] = 7</code>。</li>
<li>根据 <code>[6]</code> 和 <code>[6]</code>，设置 <code>pos[3] = 6</code>。</li>
<li>根据 <code>[2, 4, 5]</code> 和 <code>[4, 2, 5]</code>，设置 <code>pos[2] = 2</code>，再次划分出 <code>[4]</code>（来自 <code>[2, 4, 5]</code>）和 <code>[4]</code>（来自 <code>[4, 2, 5]</code>）一组，<code>[5]</code>（来自 <code>[2, 4, 5]</code>）和 <code>[5]</code>（来自 <code>[4, 2, 5]</code>）一组。</li>
<li>根据 <code>[5]</code> 和 <code>[5]</code>，设置 <code>pos[1] = 5</code>。</li>
<li>根据 <code>[4]</code> 和 <code>[4]</code>，设置 <code>pos[0] = 4</code>。</li>
</ol>
<p>如上过程简单总结为：根据当前的先序和中序数组，设置后序数组最右边的值，然后划分出左子树的先序、中序数组，以及右子树的先序、中序数组，先根据右子树的划分设置好后序数组，再根据左子树的划分，从右边到左边依次设置好后序数组的全部位置。</p>
<p>具体过程请参看如下代码中的 <code>getPosArray</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getPosArray(<span class="type">int</span>[] pre, <span class="type">int</span>[] in) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="literal">null</span> || in == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> pre.length;</span><br><span class="line">    <span class="type">int</span>[] pos = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        map.put(in[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    setPos(pre, <span class="number">0</span>, len - <span class="number">1</span>, in, <span class="number">0</span>, len - <span class="number">1</span>, pos, len - <span class="number">1</span>, map);</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从右往左依次填好后序数组s</span></span><br><span class="line"><span class="comment">// si为后序数组s该填的位置</span></span><br><span class="line"><span class="comment">// 返回值为s该填的下一个位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">setPos</span><span class="params">(<span class="type">int</span>[] p, <span class="type">int</span> pi, <span class="type">int</span> pj, <span class="type">int</span>[] n, <span class="type">int</span> ni, <span class="type">int</span> nj,</span></span><br><span class="line"><span class="params">        <span class="type">int</span>[] s, <span class="type">int</span> si, HashMap&lt;Integer, Integer&gt; map)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pi &gt; pj) &#123;</span><br><span class="line">        <span class="keyword">return</span> si;</span><br><span class="line">    &#125;</span><br><span class="line">    s[si--] = p[pi];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> map.get(p[pi]);</span><br><span class="line">    si = setPos(p, pj - nj + i + <span class="number">1</span>, pj, n, i + <span class="number">1</span>, nj, s, si, map);</span><br><span class="line">    <span class="keyword">return</span> setPos(p, pi + <span class="number">1</span>, pi + i - ni, n, ni, i - <span class="number">1</span>, s, si, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="统计和生成所有不同的二叉树"><a href="#统计和生成所有不同的二叉树" class="headerlink" title="统计和生成所有不同的二叉树"></a>统计和生成所有不同的二叉树</h2><p><strong>题目</strong></p>
<p>给定一个整数 $N$，如果 $N &lt; 1$，代表空树结构，否则代表中序遍历的结果为 ${1, 2, 3, \dots, N}$。请返回可能的二叉树结构有多少。</p>
<p>例如，$N=-1$ 时，代表空树结构，返回 1；$N=2$ 时，满足中序遍历为 ${1, 2}$ 的二叉树结构只有 2 种，所以返回结果为 2。</p>
<p><strong>进阶</strong>：$N$ 的含义不变，假设可能的二叉树结构有 $M$ 种，请返回 $M$ 个二叉树的头节点，每一棵二叉树代表一种可能的结构。</p>
<p><strong>解答</strong></p>
<p>如果中序遍历有序且无重复值，则二叉树必为搜索二叉树。假设 <code>num(a)</code> 代表 $a$ 个节点的搜索二叉树有多少种可能，再假设序列为 ${1, \dots, i, \dots, N}$，如果以 1 作为头节点，1 不可能有左子树，故以 1 作为头节点有多少种可能的结构，完全取决于 1 的右子树有多少种可能结构，1 的右子树有 $N-1$ 个节点，所以有 <code>num(N-1)</code> 种可能。</p>
<p>如果以 $i$ 作为头节点，$i$ 的左子树有 $i-1$ 个节点，所以可能的结构有 <code>num(i-1)</code> 种，右子树有 $N-i$ 个节点，所以有 <code>num(N-i)</code> 种可能。故以 $i$ 为头节点的可能结构有 <code>num(i-1) * num(N-i)</code> 种。</p>
<p>如果以 $N$ 作为头节点，$N$ 不可能有右子树，故以 $N$ 作为头节点有多少种可能，完全取决于 $N$ 的左子树有多少种可能，$N$ 的左子树有 $N-1$ 个节点，所以有 <code>num(N-1)</code> 种。</p>
<p>把从 1 到 $N$ 分别作为头节点时，所有可能的结构加起来就是答案，可以利用动态规划来加速计算的过程，从而做到 $O(N^2)$ 的时间复杂度。</p>
<p>具体请参看如下代码中的 <code>numTrees</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            num[i] += num[j - <span class="number">1</span>] * num[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进阶问题与原问题的过程其实很类似。如果要生成中序遍历是 ${a \dots b}$ 的所有结构，就从 $a$ 开始一直到 $b$，枚举每一个值作为头节点，把每次生成的二叉树结构的头节点都保存下来即可。<br>假设其中一次是以 $i$ 值为头节点的 ($a \le i \le b$)，以 $i$ 为头节点的所有结构按如下步骤生成：</p>
<ol>
<li>用 ${a \dots i-1}$ 递归生成左子树的所有结构，假设所有结构的头节点保存在 <code>listLeft</code> 链表中。</li>
<li>用 ${i+1 \dots b}$ 递归生成右子树的所有结构，假设所有结构的头节点保存在 <code>listRight</code> 链表中。</li>
<li>在以 $i$ 为头节点的前提下，<code>listLeft</code> 中的每一种结构都可以与 <code>listRight</code> 中的每一种结构构成单独的结构，且和其他任何结构都不同。为了保证所有的结构之间不互相交叉，所以对每一种结构都复制出新的树，并记录在总的链表 <code>res</code> 中。</li>
</ol>
<p>具体过程请参看如下代码中的 <code>generateTrees</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Node&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> generate(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Node&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    List&lt;Node&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        res.add(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(i);</span><br><span class="line">        List&lt;Node&gt; lSubs = generate(start, i - <span class="number">1</span>);</span><br><span class="line">        List&lt;Node&gt; rSubs = generate(i + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">for</span> (Node l : lSubs) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node r : rSubs) &#123;</span><br><span class="line">                head.left = l;</span><br><span class="line">                head.right = r;</span><br><span class="line">                res.add(cloneTree(head));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">cloneTree</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(head.value);</span><br><span class="line">    res.left = cloneTree(head.left);</span><br><span class="line">    res.right = cloneTree(head.right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="统计完全二叉树的节点数"><a href="#统计完全二叉树的节点数" class="headerlink" title="统计完全二叉树的节点数"></a>统计完全二叉树的节点数</h2><p><strong>题目</strong></p>
<p>给定一棵完全二叉树的头节点 <code>head</code>，返回这棵树的节点个数。</p>
<p><strong>要求</strong></p>
<p>如果完全二叉树的节点数为 $N$，请实现时间复杂度低于 $O(N)$ 的解法。</p>
<p><strong>解答</strong></p>
<p>遍历整棵树当然可以求出节点数，但这肯定不是最优解法。<br>如果完全二叉树的层数为 $h$，本书的解法可以做到时间复杂度为 $O(h^2)$，具体过程如下：</p>
<ol>
<li>如果 <code>head == null</code>，说是空树，直接返回 0。</li>
<li>如果不是空树，就求树的高度，求法是找到树的最左节点看能到哪一层，层数记为 $h$。</li>
<li>这一步是求解的主要逻辑，也是一个递归过程，记为 <code>bs(node, l, h)</code>，<code>node</code> 表示当前节点，<code>l</code> 表示 <code>node</code> 所在的层数，<code>h</code> 表示整棵树的层数是始终不变的。<code>bs(node, l, h)</code> 的返回值表示以 <code>node</code> 为头节点的完全二叉树的节点数是多少。初始时，<code>node</code> 为头节点 <code>head</code>，<code>l</code> 为 1，因为 <code>head</code> 在第 1 层，一共有 $h$ 层始终不变。</li>
</ol>
<p>找到 <code>node</code> 右子树的最左节点，发现它能到达最后一层，即 $h$ 层。此时说明 <code>node</code> 的整棵左子树都是满二叉树，并且层数为 $h-l$ 层，一棵层数为 $h-l$ 的满二叉树，其节点数为 $2^{h-l}-1$ 个。如果加上 <code>node</code> 节点自己，那么节点数为 $2^{h-l}-1+1 = 2^{h-l}$ 个。此时如果再知道 <code>node</code> 右子树的节点数，那么以 <code>node</code> 为头节点的完全二叉树上到底有多少个节点就求出来了。那么 <code>node</code> 右子树的节点数到底是多少呢？就是 <code>bs(node.right, l+1, h)</code> 的结果，递归去求即可。最后整体返回 $2^{h-l} + bs(node.right, l+1, h)$。</p>
<p>找到 <code>node</code> 右子树的最左节点，发现没有到达最后一层，说明 <code>node</code> 的整棵右子树都是满二叉树，并且层数为 $h-l-1$ 层，一棵层数为 $h-l-1$ 的满二叉树，其节点数为 $2^{h-l-1}-1$ 个。如果加上 <code>node</code> 节点自己，那么节点数为 $2^{h-l-1}-1+1 = 2^{h-l-1}$ 个。此时如果再知道 <code>node</code> 左子树的节点数，那么以 <code>node</code> 为头节点的完全二叉树上到底有多少个节点就求出来了。<code>node</code> 左子树的节点数到底是多少呢？就是 <code>bs(node.left, l+1, h)</code> 的结果，递归去求即可，最后整体返回 $2^{h-l-1} + bs(node.left, l+1, h)$。</p>
<p>全部过程请参看如下代码中的 <code>nodeNum</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nodeNum</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bs(head, <span class="number">1</span>, mostLeftLevel(head, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bs</span><span class="params">(Node node, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == h) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mostLeftLevel(node.right, l + <span class="number">1</span>) == h) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; (h - l)) + bs(node.right, l + <span class="number">1</span>, h);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; (h - l - <span class="number">1</span>)) + bs(node.left, l + <span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mostLeftLevel</span><span class="params">(Node node, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        level++;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一层只会选择一个节点 <code>node</code> 进行 <code>bs</code> 的递归过程，所以调用 <code>bs</code> 函数的次数为 $O(h)$。每次调用 <code>bs</code> 函数时，都会查看 <code>node</code> 右子树的最左节点，所以会遍历 $O(h)$ 个节点，整个过程的时间复杂度为 $O(h^2)$。</p>
<h1 id="递归和动态规划"><a href="#递归和动态规划" class="headerlink" title="递归和动态规划"></a>递归和动态规划</h1><h2 id="斐波那契数列问题的递归和动态规划"><a href="#斐波那契数列问题的递归和动态规划" class="headerlink" title="斐波那契数列问题的递归和动态规划"></a>斐波那契数列问题的递归和动态规划</h2><p><strong>题目</strong><br>给定整数 N，返回斐波那契数列的第 N 项。</p>
<p>补充问题 1：给定整数 N，代表台阶数，一次可以跨 2 个或者 1 个台阶，返回有多少种走法。</p>
<p>补充问题 2：假设农场中成熟的母牛每年只会生 1 头小母牛，并且永远不会死。第一年农场有 1 只成熟的母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求出 N 年后牛的数量。</p>
<p><strong>要求</strong><br>对以上所有的问题，请实现时间复杂度为 O(logN) 的解法。</p>
<p><strong>解答</strong></p>
<p><strong>原问题</strong><br>O(2^N) 的方法。斐波那契数列为 1, 1, 2, 3, 5, 8, …，也就是除第 1 项和第 2 项为 1 以外，对于第 N 项，有 F(N)=F(N-1)+F(N-2)。于是很轻松地写出暴力递归的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f1(n - <span class="number">1</span>) + f1(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>O(N) 的方法。斐波那契数列可以从左到右依次求出每一项的值，那么通过顺序计算求到第 N 项即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        tmp = res;</span><br><span class="line">        res = res + pre;</span><br><span class="line">        pre = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>O(logN) 的方法。如果递归式严格遵循 F(N)=F(N-1)+F(N-2)，对于求第 N 项的值，有矩阵乘法的方式可以将时间复杂度降至 O(logN)。F(n)=F(n-1)+F(n-2)，是一个二阶递推数列，一定可以用矩阵乘法的形式表示，且状态矩阵为 2x2 的矩阵：</p>
<script type="math/tex; mode=display">(F(n), F(n-1)) = (F(n-1), F(n-2)) \times \begin{bmatrix} a & b \\ c & d \end{bmatrix}</script><p>把斐波那契数列的前 4 项 F(1)==1, F(2)==1, F(3)==2, F(4)==3 代入，可以求出状态矩阵：</p>
<script type="math/tex; mode=display">\begin{bmatrix} a & b \\ c & d \end{bmatrix} = \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}</script><p>求矩阵之后，当 n&gt;2 时，原来的公式可化简为：</p>
<script type="math/tex; mode=display">(F(n), F(n-1)) = (F(n-1), F(n-2)) \times \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix} = (1, 1) \times \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}^{n-2}</script><p>所以，要求斐波那契数列第 N 项的问题就变成了如何用最快的方法求一个矩阵 N 次方的问题。<br>求矩阵 N 次方的问题明显是一个能够在 O(logN) 时间内解决的问题。<br>假设一个整数是 10，如何最快地求解 10 的 75 次方。</p>
<ol>
<li>75 的二进制数形式为 1001011。</li>
<li>10^75 = 10^64 <em> 10^8 </em> 10^2 * 10^1。<br>在这个过程中，我们先求出 10^1，然后根据 10^1 求出 10^2，再根据 10^2 求出 10^4，……，最后根据 10^32 求出 10^64。即 75 的二进制数总共有多少位，我们就使用了几次乘法。</li>
<li>在步骤 2 进行的过程中，把应该累乘的值相乘即可。</li>
</ol>
<p>对矩阵来说同理，求矩阵 m 的 p 次方请参看如下代码中的 matrixPower 方法。其中 muliMatrix 方法是两个矩阵相乘的具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] matrixPower(<span class="type">int</span>[][] m, <span class="type">int</span> p) &#123;</span><br><span class="line">    <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[m.length][m[<span class="number">0</span>].length];</span><br><span class="line">    <span class="comment">// 先把 res 设为单位矩阵，相当于整数中的 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">        res[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] tmp = m;</span><br><span class="line">    <span class="keyword">for</span> (; p != <span class="number">0</span>; p &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            res = muliMatrix(res, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = muliMatrix(tmp, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] muliMatrix(<span class="type">int</span>[][] m1, <span class="type">int</span>[][] m2) &#123;</span><br><span class="line">    <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[m1.length][m2[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m2[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; m2.length; k++) &#123;</span><br><span class="line">                res[i][j] += m1[i][k] * m2[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用矩阵乘法求解斐波那契数列第 N 项的全部过程请参看如下代码中的 f3 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f3</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] base = &#123; &#123; <span class="number">1</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span> &#125; &#125;;</span><br><span class="line">    <span class="type">int</span>[][] res = matrixPower(base, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>] + res[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>补充问题 1</strong><br>如果台阶只有 1 级，方法只有 1 种。如果台阶有 2 级，方法有 2 种。如果台阶有 N 级，最后跳上第 N 级的情况，要么是从 N-2 级台阶直接跨 2 级台阶，要么是从 N-1 级台阶跨 1 级台阶，所以台阶有 N 级的方法数为跨到 N-2 级台阶的方法数加上跨到 N-1 级台阶的方法数，即 S(N)=S(N-1)+S(N-2)，初始项 S(1)==1, S(2)==2。所以，类似斐波那契数列，唯一的不同就是初始项不同。可以很轻易地写出 O(2^N) 与 O(N) 的方法，请参看如下代码中的 s1 和 s2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">s1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s1(n - <span class="number">1</span>) + s1(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">s2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        tmp = res;</span><br><span class="line">        res = res + pre;</span><br><span class="line">        pre = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>O(logN) 的方法。表达式 S(n)=S(n-1)+S(n-2) 是一个二阶递推数列，同样，用上文矩阵乘法的方法，根据前 4 项 S(1)==1, S(2)==2, S(3)==3, S(4)==5，求出状态矩阵：</p>
<script type="math/tex; mode=display">\begin{bmatrix} a & b \\ c & d \end{bmatrix} = \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}</script><p>同样根据上文的过程得到：</p>
<script type="math/tex; mode=display">(S(n), S(n-1)) = (S(2), S(1)) \times \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}^{n-2} = (2, 1) \times \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}^{n-2}</script><p>全部的实现请参看如下代码中的 s3 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">s3</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] base = &#123; &#123; <span class="number">1</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span> &#125; &#125;;</span><br><span class="line">    <span class="type">int</span>[][] res = matrixPower(base, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * res[<span class="number">0</span>][<span class="number">0</span>] + res[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>补充问题 2</strong><br>所有的牛都不会死，所以第 N-1 年的牛会毫发无损地活到第 N 年。同时所有成熟的牛都会生 1 头新的牛，那么成熟牛的数量如何估计？就是第 N-3 年的所有牛，到第 N 年肯定是成熟的牛，期间出生的牛肯定都没有成熟。所以 C(n)=C(n-1)+C(n-3)，初始项为 C(1)==1, C(2)==2, C(3)==3。这个和斐波那契数列十分类似，只不过 C(n) 依赖 C(n-1) 和 C(n-3) 的值，而斐波那契数列 F(n) 依赖 F(n-1) 和 F(n-2) 的值。同样可以轻易地写出 O(2^N) 与 O(N) 的方法，请参看如下代码中的 c1 和 c2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">c1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span> || n == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c1(n - <span class="number">1</span>) + c1(n - <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">c2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span> || n == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">prepre</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        tmp1 = res;</span><br><span class="line">        tmp2 = pre;</span><br><span class="line">        res = res + prepre;</span><br><span class="line">        pre = tmp1;</span><br><span class="line">        prepre = tmp2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>O(logN) 的方法。C(n)=C(n-1)+C(n-3) 是一个三阶递推数列，一定可以用矩阵乘法的形式表示，且状态矩阵为 3x3 的矩阵。</p>
<script type="math/tex; mode=display">(C_n, C_{n-1}, C_{n-2}) = (C_{n-1}, C_{n-2}, C_{n-3}) \times \begin{bmatrix} a & b & c \\ d & e & f \\ g & h & i \end{bmatrix}</script><p>把前 5 项 C(1)==1, C(2)==2, C(3)==3, C(4)==4, C(5)==6 代入，求出状态矩阵：</p>
<script type="math/tex; mode=display">\begin{bmatrix} a & b & c \\ d & e & f \\ g & h & i \end{bmatrix} = \begin{bmatrix} 1 & 1 & 0 \\ 0 & 0 & 1 \\ 1 & 0 & 0 \end{bmatrix}</script><p>求矩阵之后，当 n&gt;3 时，原来的公式可化简为：</p>
<script type="math/tex; mode=display">(C_n, C_{n-1}, C_{n-2}) = (C_3, C_2, C_1) \times \begin{bmatrix} 1 & 1 & 0 \\ 0 & 0 & 1 \\ 1 & 0 & 0 \end{bmatrix}^{n-3} = (3, 2, 1) \times \begin{bmatrix} 1 & 1 & 0 \\ 0 & 0 & 1 \\ 1 & 0 & 0 \end{bmatrix}^{n-3}</script><p>接下来的过程又是利用加速矩阵乘法的方式进行实现，具体请参看如下代码中的 c3 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">c3</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span> || n == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] base = &#123; &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125; &#125;;</span><br><span class="line">    <span class="type">int</span>[][] res = matrixPower(base, n - <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> * res[<span class="number">0</span>][<span class="number">0</span>] + <span class="number">2</span> * res[<span class="number">1</span>][<span class="number">0</span>] + res[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果递推式严格符合 F(n)=a<em>F(n-1)+b</em>F(n-2)+…+k*F(n-i)，那么它就是一个 i 阶的递推式，必然有与 ixi 的状态矩阵有关的矩阵乘法的表达。一律可以用加速矩阵乘法的动态规划将时间复杂度降为 O(logN)。</p>
<h2 id="矩阵的最小路径和"><a href="#矩阵的最小路径和" class="headerlink" title="矩阵的最小路径和"></a>矩阵的最小路径和</h2><p><strong>题目</strong><br>给定一个矩阵 m，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，返回所有的路径中最小的路径和。</p>
<p><strong>举例</strong><br>如果给定的 m 如下：<br>1 3 5 9<br>8 1 3 4<br>5 0 6 1<br>8 8 4 0<br>路径 1, 3, 1, 0, 6, 1, 0 是所有路径中路径和最小的，所以返回 12。</p>
<p><strong>解答</strong><br>经典动态规划方法。假设矩阵 m 的大小为 MxN，行数为 M，列数为 N。先生成大小和 m 一样的矩阵 dp，dp[i][j] 的值表示从左上角 (即(0,0)) 位置走到(i,j)位置的最小路径和。对 m 的第一行的所有位置来说，即 (0,j) (0&lt;=j&lt;N)，从(0,0)位置走到(0,j)位置只能向右走，所以(0,0)位置到(0,j)位置的路径和就是 m[0][0..j]这些值的累加结果。同理，对 m 的第一列的所有位置来说，即 (i,0) (0&lt;=i&lt;M)，从(0,0)位置走到(i,0)位置只能向下走，所以(0,0)位置到(i,0)位置的路径和就是 m[0..i][0]这些值的累加结果。以题目中的例子来说，dp 第一行和第一列的值如下：<br>1 4 9 18<br>9<br>14<br>22<br>除第一行和第一列的其他位置 (i,j) 外，都有左边位置 (i-1,j) 和上边位置 (i,j-1)。从 (0,0) 到 (i,j) 的路径必然经过位置 (i-1,j) 或位置 (i,j-1)，所以，dp[i][j]=min{dp[i-1][j],dp[i][j-1]}+m[i][j]，含义是比较从 (0,0) 位置开始，经过 (i-1,j) 位置最终到达 (i,j) 的最小路径和经过 (i,j-1) 位置最终到达 (i,j) 的最小路径和之间，哪条路径的路径和更小。那么更小的路径和就是 dp[i][j] 的值。以题目中的例子来说，最终生成的 dp 矩阵如下：<br>1 4 9 18<br>9 5 8 12<br>14 5 11 12<br>22 13 15 12<br>除第一行和第一列外，每一个位置都考虑从左边到达自己的路径和更小还是从上边到达自己的路径和更小。最右下角的值就是整个问题的答案。具体过程请参看如下代码中的 minPathSum1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum1</span><span class="params">(<span class="type">int</span>[][] m)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">null</span> || m.length == <span class="number">0</span> || m[<span class="number">0</span>] == <span class="literal">null</span> || m[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> m.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> m[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[row][col];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + m[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + m[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + m[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>矩阵中一共有 MxN 个位置，每个位置都计算一次从 (0,0) 位置达到自己的最小路径和，计算的时候只是比较上边位置的最小路径和与左边位置的最小路径和哪个更小，所以时间复杂度为 O(MxN)，dp 矩阵的大小为 MxN，所以额外空间复杂度为 O(MxN)。</p>
<p>动态规划经过空间压缩后的方法。这道题的经典动态规划方法在经过空间压缩之后，时间复杂度依然是 O(MxN)，但是额外空间复杂度可以从 O(MxN)减小至 O(min{M,N})，也就是不使用大小为 MxN 的 dp 矩阵，而仅仅使用大小为 min{M,N} 的 arr 数组。具体过程如下（以题目的例子来举例说明）。</p>
<ol>
<li>生成长度为 4 的数组 arr，初始时 arr=[0,0,0,0]，我们知道从 (0,0) 位置到达 m 中第一行的每个位置，最小路径和就是从 (0,0) 位置的值开始依次累加的结果，所以依次把 arr 设置为 arr=[1,4,9,18]，此时 arr[j] 的值代表从 (0,0) 位置达到(0,j)位置的最小路径和。</li>
<li>步骤 1 中 arr[j]的值代表从 (0,0) 位置达到 (0,j) 位置的最小路径和，在这步中想把 arr[j]的值更新成从 (0,0) 位置达到 (1,j) 位置的最小路径和。首先来看 arr[0]，更新之前 arr[0]的值代表 (0,0) 位置到达 (0,0) 位置的最小路径和 (dp[0][0])，如果想把 arr[0]更新成从 (0,0) 位置达到 (1,0) 位置的最小路径和 (dp[1][0])，令 arr[0]=arr[0]+m[1][0]=9 即可。然后来看 arr[1]，更新之前 arr[1]的值代表 (0,0) 位置到达 (0,1) 位置的最小路径和 (dp[0][1])，更新之后想让 arr[1]代表 (0,0) 位置到达 (1,1) 位置的最小路径和 (dp[1][1])。根据动态规划的求解过程，到达 (1,1) 位置有两种选择，一种是从 (1,0) 位置到达 (1,1) 位置 (dp[1][0]+m[1][1])，另一种是从 (0,1) 位置到达 (1,1) 位置 (dp[0][1]+m[1][1])，应该选择路径和最小的那个。此时 arr[0]的值已经更新成 dp[1][0]，arr[1]目前还没有更新，所以，arr[1]还是 dp[0][1]，arr[1]=min{arr[0],arr[1]}+m[1][1]=5。更新之后，arr[1]的值变为 dp[1][1]的值。同理，arr[2]=min{arr[1],arr[2]}+m[1][2]，……最终 arr 可以更新成[9,5,8,12]。</li>
<li>重复步骤 2 的更新过程，一直到 arr 彻底变成 dp 矩阵的最后一行。整个过程其实就是不断滚动更新 arr 数组，让 arr 依次变成 dp 矩阵每一行的值，最终变成 dp 矩阵最后一行的值。</li>
</ol>
<p>本题的例子是矩阵 m 的行数等于列数，如果给定的矩阵列数小于行数 (N&lt;M)，依然可以用上面的方法令 arr 更新成 dp 矩阵每一行的值。但如果给定的矩阵行数小于列数 (M&lt;N)，那么就生成长度为 M 的 arr，然后令 arr 更新成 dp 矩阵每一列的值，从左向右滚动过去。以本例来说，如果按列来更新，arr 首先更新成[1,9,14,22]，然后向右滚动更新成[4,5,5,13]，继续向右滚动更新成[9,8,11,15]，最后是[18,12,12,12]。总之，是根据给定矩阵行和列的大小关系决定滚动的方式，始终生成最小长度(min{M,N})的 arr 数组。具体过程请参看如下代码中的 minPathSum2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum2</span><span class="params">(<span class="type">int</span>[][] m)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">null</span> || m.length == <span class="number">0</span> || m[<span class="number">0</span>] == <span class="literal">null</span> || m[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> Math.max(m.length, m[<span class="number">0</span>].length); <span class="comment">// 行数与列数较大的那个为 more</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">less</span> <span class="operator">=</span> Math.min(m.length, m[<span class="number">0</span>].length); <span class="comment">// 行数与列数较小的那个为 less</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">rowmore</span> <span class="operator">=</span> more == m.length; <span class="comment">// 行数是不是大于或等于列数</span></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[less]; <span class="comment">// 辅助数组的长度仅为行数与列数中的最小值</span></span><br><span class="line">    arr[<span class="number">0</span>] = m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; less; i++) &#123;</span><br><span class="line">        arr[i] = arr[i - <span class="number">1</span>] + (rowmore ? m[<span class="number">0</span>][i] : m[i][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; more; i++) &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = arr[<span class="number">0</span>] + (rowmore ? m[i][<span class="number">0</span>] : m[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; less; j++) &#123;</span><br><span class="line">            arr[j] = Math.min(arr[j - <span class="number">1</span>], arr[j]) + (rowmore ? m[i][j] : m[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[less - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>扩展</strong><br>本题压缩空间的方法几乎可以应用到所有需要二维动态规划表的面试题目中，通过一个数组滚动更新的方式无疑节省了大量的空间。没有优化之前，取得某个位置动态规划值的过程是在矩阵中进行两次寻址，优化后，这一过程只需要一次寻址，程序的常数时间也得到了一定程度的加速。但是空间压缩的方法是有局限性的，本题如果改成“打印具有最小路径和的路径”，那么就不能使用空间压缩的方法。如果类似本题这种需要二维表的动态规划题目，最终目的是想求最优解的具体路径，往往需要完整的动态规划表，但如果只是想求最优解的值，则可以使用空间压缩的方法。因为空间压缩的方法是滚动更新的，会覆盖之前求解的值，让求解轨迹变得不可回溯。希望读者好好研究这种空间压缩的实现技巧，本书还有许多动态规划题目会涉及空间压缩方法的实现。</p>
<h2 id="换钱的最少货币数"><a href="#换钱的最少货币数" class="headerlink" title="换钱的最少货币数"></a>换钱的最少货币数</h2><p><strong>题目</strong><br>给定数组 arr，arr 中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数 aim，代表要找的钱数，求组成 aim 的最少货币数。</p>
<p><strong>举例</strong><br>arr=[5,2,3], aim=20。<br>4 张 5 元可以组成 20 元，其他的找钱方案都要使用更多张的货币，所以返回 4。</p>
<p>arr=[5,2,3], aim=0。<br>不用任何货币就可以组成 0 元，返回 0。</p>
<p>arr=[3,5], aim=2。<br>根本无法组成 2 元，钱不能找开的情况下默认返回 -1。</p>
<p><strong>解答</strong><br>这道题我们使用暴力递归优化成动态规划的套路，不熟悉套路的读者请先阅读本书“机器人达到指定位置方法数”问题的解答。先想暴力尝试的方法，然后优化成动态规划。首先是原问题的暴力尝试方法。只有想出尝试方法是最难、最重要的。<br>原问题的暴力尝试过程请看如下的 process 方法。就是每一种面值都会尝试不同的张数，尝试是从哪里开始的？是从 arr[0]开始依次往右考虑所有面值的，主方法见 minCoins1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCoins1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(arr, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前考虑的面值是 arr[i]，还剩 rest 的钱需要找零</span></span><br><span class="line"><span class="comment">// 如果返回 -1，说明自由使用 arr[i..N-1]面值的情况下，无论如何也无法找零 rest</span></span><br><span class="line"><span class="comment">// 如果返回不是 -1，代表自由使用 arr[i..N-1]面值的情况下，找零 rest 需要的最少张数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line">    <span class="comment">// base case:</span></span><br><span class="line">    <span class="comment">// 已经没有面值能够考虑了</span></span><br><span class="line">    <span class="comment">// 如果此时剩余的钱为 0，返回 0 张</span></span><br><span class="line">    <span class="comment">// 如果此时剩余的钱不是 0，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (i == arr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最少张数，初始时为 -1，因为还没找到有效解</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 依次尝试使用当前面值(arr[i])0张、1张、k张，但不能超过 rest</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k * arr[i] &lt;= rest; k++) &#123;</span><br><span class="line">        <span class="comment">// 使用了 k 张 arr[i]，剩下的钱为 rest - k * arr[i]</span></span><br><span class="line">        <span class="comment">// 交给剩下的面值去搞定(arr[i+1..N-1])</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> process(arr, i + <span class="number">1</span>, rest - k * arr[i]);</span><br><span class="line">        <span class="keyword">if</span> (next != -<span class="number">1</span>) &#123; <span class="comment">// 说明这个后续过程有效</span></span><br><span class="line">            res = res == -<span class="number">1</span> ? next + k : Math.min(res, next + k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原问题暴力递归改动态规划，利用优化套路过程如下。<br>前提：尝试过程是无后效性的。上面的尝试其实明显是无后效性的，但是为了方便理解，我们还是举个例子，arr = {5,2,3,1}，aim=100，那么 process(arr,0,100)的返回值就是最终答案。如果使用 2 张 5 元，0 张 2 元，那么后续的过程是 process(arr,2,90)；但如果使用 0 张 5 元，5 张 2 元，那么后续的过程还是 process(arr,2,90)。这个状态的返回值肯定是一样的，说明一个状态最终的返回值与怎么达到这个状态的过程无关。<br>1) 可变参数 i 和 rest 一旦确定，返回值就确定了。<br>2) 如果可变参数 i 和 rest 组合的所有情况组成一张二维表，这张表一定可以装下所有的返回值。i 的含义是 arr 中的位置，又因为 process 中允许 i 来到 arr 的终止位置，所以 i 的范围是[0,N]。rest 代表剩余的钱数，剩余的钱不可能大于 aim，所以 rest 的范围是[0,aim]。所以这张二维表是一个 N 行 aim 列的表，记为 dp[][]。<br>3) 最终状态是 process(arr,0,aim)，也就是 dp[0][aim]的值，位于 dp 表 0 行最后一列。<br>4) 填写初始的位置，根据 process(arr,i,rest)函数的 base case:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == arr.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>i=arr.length，就是 dp 表中最后一行 dp[N][…]，这最后一行只有 dp[N][0]是 0，其他位置都是 -1。<br>5) base case 之外的情况都是普遍位置，在 process(arr,i,rest)函数中如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最少张数，初始时为 -1，因为还没找到有效解</span></span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 依次尝试使用当前面值(arr[i])0张、1张、k张，但不能超过 rest</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k * arr[i] &lt;= rest; k++) &#123;</span><br><span class="line">    <span class="comment">// 使用了 k 张 arr[i]，剩下的钱为 rest - k * arr[i]</span></span><br><span class="line">    <span class="comment">// 交给剩下的面值去搞定(arr[i+1..N-1])</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> process(arr, i + <span class="number">1</span>, rest - k * arr[i]);</span><br><span class="line">    <span class="keyword">if</span> (next != -<span class="number">1</span>) &#123; <span class="comment">// 说明这个后续过程有效</span></span><br><span class="line">        res = res == -<span class="number">1</span> ? next + k : Math.min(res, next + k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><br>process(arr,i,rest)的返回值就是 dp[i][rest]，这个位置依赖哪些位置呢？请看下表。<br>| i 行 | … | … | … | <em>dp[i][rest-arr[i]] | … | dp[i][rest] |<br>| :—- | :—- | :—- | :—- | :—- | :—- | :—- |<br>| i+1 行 | … | dp[i+1][rest-2</em>arr[i]] | … | dp[i+1][rest-1<em>arr[i]] | … | dp[i+1][rest-0</em>arr[i]] |</p>
<p>表中右上角的位置就是 dp[i][rest]，根据 process(arr,i,rest)函数可知，dp[i][rest]的值就是以下这些值中最小的一个：dp[i+1][rest-0<em>arr[i]] + 0、dp[i+1][rest-1</em>arr[i]] + 1、dp[i+1][rest-2<em>arr[i]] + 2、… dp[i+1][rest-k</em>arr[i]] + k、……直到越界。在表中已经标出了这些位置。也就是说，要想得到 dp[i][rest]的值，必须枚举 i+1 行的这些值。<br>但其实这个枚举过程是可以优化的。请看表中用星号标出的位置，即 dp[i][rest-arr[i]]这个位置。如果在求 dp[i][rest]之前，dp[i][rest-arr[i]]已经求过了。那么我们看看 dp[i][rest-arr[i]]是怎么求出来的，同样，根据 process(arr,i,rest)函数可知，dp[i][rest-arr[i]]的值就是以下这些值中最小的一个：dp[i+1][rest-arr[i]] + 0、dp[i+1][rest-2<em>arr[i]] + 1、… dp[i+1][rest-k</em>arr[i]] + k-1、……直到越界。读者请对比一下 dp[i][rest]和 dp[i][rest-arr[i]]各自依赖的位置就可以得到，dp[i][rest] = min{ dp[i][rest-arr[i]] + 1, dp[i+1][rest] }。也就是说，求 dp[i][rest]只依赖下面的一个位置 (dp[i+1][rest]) 和左边的一个位置 (dp[i][rest-arr[i]] + 1) 即可。<br>现在 dp 表中最后一排的值已经有了，既然剩下的位置都只依赖下面和左边的位置，那么只要从左往右求出倒数第二排、从左往右求出倒数第三排……从左往右求出第一排即可。<br>6) 最后返回 dp[0][aim]位置的值就是答案。<br>具体过程请看如下的 minCoins2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCoins2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 设置最后一排的值，除 dp[N][0]为 0 外，其他都是 -1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">1</span>; col &lt;= aim; col++) &#123;</span><br><span class="line">        dp[N][col] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 从底往上计算每一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123; <span class="comment">// 每一行都从左往右</span></span><br><span class="line">            dp[i][rest] = -<span class="number">1</span>; <span class="comment">// 初始时先设置 dp[i][rest]的值无效</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i + <span class="number">1</span>][rest] != -<span class="number">1</span>) &#123; <span class="comment">// 下面的值如果有效</span></span><br><span class="line">                dp[i][rest] = dp[i + <span class="number">1</span>][rest]; <span class="comment">// 先设置成下面的值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果左边的位置不越界且有效</span></span><br><span class="line">            <span class="keyword">if</span> (rest - arr[i] &gt;= <span class="number">0</span> &amp;&amp; dp[i][rest - arr[i]] != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][rest] == -<span class="number">1</span>) &#123; <span class="comment">// 如果之前下面的值无效</span></span><br><span class="line">                    dp[i][rest] = dp[i][rest - arr[i]] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 说明下面和左边的值都有效，取最小的</span></span><br><span class="line">                    dp[i][rest] = Math.min(dp[i][rest],</span><br><span class="line">                                           dp[i][rest - arr[i]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>minCoins2 方法就是填一张 Nxaim 的表，而且因为省掉了枚举过程，所以每个位置的值都在 O(1)的时间内得到，该方法时间复杂度为 O(Nxaim)。原问题还可以在动态规划基础上做空间压缩。空间压缩的原理请读者参考本书“矩阵的最小路径和”问题，本书这里就不做重复描述。</p>
<h2 id="机器人达到指定位置方法数"><a href="#机器人达到指定位置方法数" class="headerlink" title="机器人达到指定位置方法数"></a>机器人达到指定位置方法数</h2><p><strong>题目</strong></p>
<p>假设有排成一行的 N 个位置，记为 1~N，N 一定大于或等于 2。开始时机器人在其中的 M 位置上（M 一定是 1~N 中的一个），机器人可以往左走或者往右走，如果机器人来到 1 位置，那么下一步只能往右来到 2 位置；如果机器人来到 N 位置，那么下一步只能往左来到 N-1 位置。规定机器人必须走 K 步，最终能来到 P 位置（P 也一定是 1~N 中的一个）的方法有多少种。给定四个参数 N、M、K、P，返回方法数。</p>
<p><strong>举例</strong></p>
<p>N=5, M=2, K=3, P=3<br>上面的参数代表所有位置为 1 2 3 4 5。机器人最开始在 2 位置上，必须经过 3 步，最后到达 3 位置。走的方法只有如下 3 种：<br>1) 从 2 到 1，从 1 到 2，从 2 到 3<br>2) 从 2 到 3，从 3 到 2，从 2 到 3<br>3) 从 2 到 3，从 3 到 4，从 4 到 3<br>所以返回方法数 3。</p>
<p>N=3, M=1, K=3, P=3<br>上面的参数代表所有位置为 1 2 3。机器人最开始在 1 位置上，必须经过 3 步，最后到达 3 位置。怎么走也不可能，所以返回方法数 0。</p>
<p><strong>解答</strong></p>
<p>这道题不算难，但是在全书的地位极高，因为通过这道题总结了用暴力递归解决的方法如何优化成动态规划的套路。这个套路可以解决大量的类似问题。首先介绍本题暴力递归方法，想想怎么去尝试走所有的路。如果当前来到 cur 位置，还剩 rest 步要走，那么下一步该怎么走呢？如果当前 cur==1，下一步只能走到 2，后续还剩 rest-1 步；如果当前 cur==N，下一步只能走到 N-1，后续还剩 rest-1 步；如果 cur 是 1~N 中间的位置，下一步可以走到 cur-1 或者 cur+1，后续还剩 rest-1 步。每一种走的可能都尝试一遍，每一次尝试怎么结束？所有步数都走完了，尝试就结束了。如果走完了所有的步数，最后的位置停在 P，说明这次尝试有效，即找到了一种；如果最后的位置没有停在 P，说明这次尝试无效，即找到了 0 种。<br>尝试的递归过程请看如下 walk 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N : 位置为 1 ~ N，固定参数</span></span><br><span class="line"><span class="comment">// cur : 当前在 cur 位置，可变参数</span></span><br><span class="line"><span class="comment">// rest : 还剩 rest 步没有走，可变参数</span></span><br><span class="line"><span class="comment">// P : 最终目标位置是 P，固定参数</span></span><br><span class="line"><span class="comment">// 只能在 1~N 这些位置上移动，当前在 cur 位置，走完 rest 步之后，停在 P 位置的方法数作为返回值返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">walk</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> cur, <span class="type">int</span> rest, <span class="type">int</span> P)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果没有剩余步数了，当前的 cur 位置就是最后的位置</span></span><br><span class="line">    <span class="comment">// 如果最后的位置停在 P 上，那么之前的移动是有效的</span></span><br><span class="line">    <span class="comment">// 如果最后的位置没在 P 上，那么之前的移动是无效的</span></span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cur == P ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果还有 rest 步要走，而当前的 cur 位置在 1 位置上，那么当前这步只能从 1 走向 2</span></span><br><span class="line">    <span class="comment">// 后续的过程就是来到 2 位置上，还剩 rest-1 步要走</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> walk(N, <span class="number">2</span>, rest - <span class="number">1</span>, P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果还有 rest 步要走，而当前的 cur 位置在 N 位置上，那么当前这步只能从 N 走向 N-1</span></span><br><span class="line">    <span class="comment">// 后续的过程就是来到 N-1 位置上，还剩 rest-1 步要走</span></span><br><span class="line">    <span class="keyword">if</span> (cur == N) &#123;</span><br><span class="line">        <span class="keyword">return</span> walk(N, N - <span class="number">1</span>, rest - <span class="number">1</span>, P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果还有 rest 步要走，而当前的 cur 位置在中间位置上，那么可以走向左，也可以走向右</span></span><br><span class="line">    <span class="comment">// 走向左之后，后续的过程就是，来到 cur-1 位置上，还剩 rest-1 步要走</span></span><br><span class="line">    <span class="comment">// 走向右之后，后续的过程就是，来到 cur+1 位置上，还剩 rest-1 步要走</span></span><br><span class="line">    <span class="comment">// 走向左、走向右是截然不同的方法，所以总方法数要都算上</span></span><br><span class="line">    <span class="keyword">return</span> walk(N, cur - <span class="number">1</span>, rest - <span class="number">1</span>, P) + walk(N, cur + <span class="number">1</span>, rest - <span class="number">1</span>, P);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试是从哪里开始的？是从题目给定的 N、M、K、P 开始的，主方法见如下 ways1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ways1</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> M, <span class="type">int</span> K, <span class="type">int</span> P)</span> &#123;</span><br><span class="line">    <span class="comment">// 参数无效直接返回 0</span></span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">2</span> || K &lt; <span class="number">1</span> || M &lt; <span class="number">1</span> || M &gt; N || P &lt; <span class="number">1</span> || P &gt; N) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 总共 N 个位置，从 M 点出发，还剩 K 步，返回最终能达到 P 的方法数</span></span><br><span class="line">    <span class="keyword">return</span> walk(N, M, K, P);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决一个问题，如果没有想到显而易见的求解策略（比如数学公式、贪心策略等，都是显而易见的求解策略），那么就想如何通过尝试的方式找到答案，一旦写出了好的尝试函数，后面的优化过程全都是固定套路。下面介绍本题如何从暴力递归优化成动态规划的解法。暴力递归优化成动态规划时，首先根据 walk 函数的含义结合题意，分析整个递归过程是不是无后效性的。代码面试中出现的需要利用尝试解决的问题，绝大多数都是无后效性的，有后效性的递归过程在面试中出现的概率极其罕见，这是一个真实情况，本书不再详述。但是分析一个递归过程是不是无后效性的，依然非常重要，可以帮我们确定这个暴力递归能不能改成动态规划。<br>比如本题，walk 函数有两个固定参数 N 和 P，任何时候都不变，说明 N 和 P 与具体的递归状态无关，忽略它们。只需要关注可变参数 cur 和 rest。walk(cur,rest)表示的含义是，当前来到 cur 位置，还剩 rest 步，有效方法有多少种。所谓无后效性，是指一个递归状态的返回值与怎么到达这个状态的路径无关。<br>比如本题，walk(5,7)代表当前来到 5 位置，还剩 7 步，有效方法有多少种。那么最终的返回值与怎么到达这个状态的路径有关系吗？没有。不管是通过 walk(4,6)来到 walk(5,5)，还是从 walk(6,6)来到 walk(5,5)，只要是“当前来到 5 位置，还剩 5 步”这个问题，返回值都是不变的。所以这是一个无后效性问题。接下来的分析与原始题意已经没有关系了，某个无后效性的递归过程（尝试过程）一旦确定，怎么优化成动态规划是有固定套路的。请读者好好阅读下面的文字，理解这个套路。这个套路可以解决面试中绝大多数尝试性算法的优化。<br>套路大体步骤如下。<br>前提：你的尝试过程是无后效性的。<br>1) 找到什么可变参数可以代表一个递归状态，也就是哪些参数一旦确定，返回值就确定了。<br>2) 把可变参数的所有组合映射成一张表，有 1 个可变参数就是一维表，2 个可变参数就是二维表……<br>3) 最终答案要是表中的哪个位置，在表中标出。<br>4) 根据递归过程的 base case，把这张表最简单、不需要依赖其他位置的那些位置填好值。<br>5) 根据递归过程非 base case 的部分，也就是分析表中的普通位置需要怎么计算得到，那么这张表的填写顺序也就确定了。<br>6) 填好表，返回最终答案在表中位置的值。</p>
<p>下面以本题为例来使用这个套路。假设想求，N=7, M=4, K=9, P=5 的答案。<br>前提：walk 方法是无后效性的，满足前提。<br>1) walk 函数中，可变参数 cur 和 rest 一旦确定，返回值就确定了。<br>2) 如果可变参数 cur 和 rest 组合的所有情况组成一张表，这张表一定可以装下所有的返回值。cur 变量的含义是当前来到的位置，例子给的 N 代表一共有 1~7 这些位置，所以 cur 一定不会在 1~7 的范围之外；rest 变量的含义是还剩多少步，例子给的 K 代表最开始走的时候的剩余步数，走的过程中剩余步数一定是减小的，所以 rest 一定不会在 0~9 范围之外。那么 cur 和 rest 组合的所有情况可以组成一张二维表。<br>图 4-2 中，列对应的是 cur（范围为 1~7），行对应的是 rest（范围为 0~9），其实谁做行对应，谁做列对应是无所谓的，只要能枚举所有的组合即可。任何一个状态 walk(cur,rest)都一定可以放在这张表中。这张表是一个二维数组，记为 dp[][]，那么 walk(cur,rest)的返回值就是 dp[rest][cur]。<br>3) N=7, M=4, K=9, P=5 的最终答案，就是 dp[9][4]位置的值。<br>那么如何求出这个值呢？<br>4) 递归过程的 base case 是指问题的规模小到什么程度，就不需要再划分子问题，答案就可以直接得到了。walk 函数中的 base case 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> cur == P ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 rest==0 时，如果 cur==P，返回 1；否则返回 0。本题中 P=5。所以可以把表的第一行填好，表中第一行的所有状态都是最简单且不需要依赖其他位置的。<br>5) base case 之外的情况都是普遍位置，在 walk 函数中如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> walk(N, <span class="number">2</span>, rest - <span class="number">1</span>, P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur == N) &#123;</span><br><span class="line">    <span class="keyword">return</span> walk(N, N - <span class="number">1</span>, rest - <span class="number">1</span>, P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> walk(N, cur + <span class="number">1</span>, rest - <span class="number">1</span>, P) + walk(N, cur - <span class="number">1</span>, rest - <span class="number">1</span>, P);</span><br></pre></td></tr></table></figure>
<p>如果 cur 在 1 位置，最终返回值 dp[rest][cur]=dp[rest-1][2]；如果 cur 在 N 位置，最终返回值 dp[rest][cur]=dp[rest-1][N-1]；如果 cur 在中间位置，dp[rest][cur]=dp[rest-1][cur-1]+dp[rest-1][cur+1]。<br>这说明每一行的值都只依赖上一行的值，那么如果有了一行的值，就可以推出整张表。<br>6) 返回 dp[9][4]的值，答案是 116。<br>这个套路是非常好用的，一旦尝试函数确定了，优化是不需要再考虑原始题意的，只需要考虑状态依赖关系，填好表即可。如果你已经积累了大量动态规划的技巧并且已经运用自如，这个套路对你来讲可能并不重要。但情况往往是绝大多数人对动态规划理解不深刻，经验不丰富，本书提供的套路解法会帮你尽快建立起对动态规划题目的感觉。从尝试出发，一切优化水到渠成。本书还有很多题目涉及这个套路，还会帮读者强化这个内容。但是有效性的尝试过程，本套路是失效的，这类题目在面试中出现的概率极低。<br>本题动态规划的解法就是把规模为 NxK 的表填好，填写每一个位置的值都是 O(1)的时间复杂度，所以总的时间复杂度为 O(NxK)，请看如下的 ways2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ways2</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> M, <span class="type">int</span> K, <span class="type">int</span> P)</span> &#123;</span><br><span class="line">    <span class="comment">// 参数无效直接返回 0</span></span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">2</span> || K &lt; <span class="number">1</span> || M &lt; <span class="number">1</span> || M &gt; N || P &lt; <span class="number">1</span> || P &gt; N) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[K + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][P] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= K; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == N) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][N - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[K][M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本题动态规划+空间压缩的解法，请看如下的 ways3 方法。空间压缩技巧在本章“最短路径和”问题的解答中已经详细介绍过了，这里不再详述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ways3</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> M, <span class="type">int</span> K, <span class="type">int</span> P)</span> &#123;</span><br><span class="line">    <span class="comment">// 参数无效直接返回 0</span></span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">2</span> || K &lt; <span class="number">1</span> || M &lt; <span class="number">1</span> || M &gt; N || P &lt; <span class="number">1</span> || P &gt; N) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    dp[P] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= K; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftUp</span> <span class="operator">=</span> dp[<span class="number">1</span>];<span class="comment">// 左上角的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= N; j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> dp[j];</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[j] = dp[j + <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == N) &#123;</span><br><span class="line">                dp[j] = leftUp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = leftUp + dp[j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            leftUp = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="换钱的方法数"><a href="#换钱的方法数" class="headerlink" title="换钱的方法数"></a>换钱的方法数</h2><p><strong>题目</strong></p>
<p>给定数组 arr，arr 中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数 aim，代表要找的钱数，求换钱有多少种方法。</p>
<p><strong>举例</strong></p>
<p>arr=[5,10,25,1], aim=0。<br>组成 0 元的方法有 1 种，就是所有面值的货币都不用。所以返回 1。</p>
<p>arr=[5,10,25,1], aim=15。<br>组成 15 元的方法有 6 种，分别为 3 张 5 元、1 张 10 元+1 张 5 元、1 张 10 元+5 张 1 元、10 张 1 元+1 张 5 元、2 张 5 元+5 张 1 元和 15 张 1 元。所以返回 6。</p>
<p>arr=[3,5], aim=2。<br>任何方法都无法组成 2 元。所以返回 0。</p>
<p><strong>解答</strong></p>
<p>本书将由浅入深地给出所有的解法，最后解释最优解。这道题的经典之处在于它可以体现暴力递归、记忆搜索和动态规划之间的关系，并可以在动态规划的基础上进行再一次优化。请读者把本书“机器人达到指定位置方法数”问题所提到的套路联系起来。<br>首先介绍暴力递归的方法。如果 arr=[5,10,25,1]，aim=1000，分析过程如下：</p>
<ol>
<li>用 0 张 5 元的货币，让[10,25,1]组成剩下的 1000，最终方法数记为 res1。</li>
<li>用 1 张 5 元的货币，让[10,25,1]组成剩下的 995，最终方法数记为 res2。</li>
<li>用 2 张 5 元的货币，让[10,25,1]组成剩下的 990，最终方法数记为 res3。<br>……</li>
<li>用 200 张 5 元的货币，让[10,25,1]组成剩下的 0，最终方法数记为 res201。<br>那么 res1+res2+…+res201 的值就是总的方法数。根据如上的分析过程定义递归函数 process1(arr,index,aim)，它的含义是如果用 arr[index..N-1]这些面值的钱组成 aim，返回总的方法数。具体实现参见如下代码中的 coins1 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coins1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process1(arr, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">process1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (index == arr.length) &#123;</span><br><span class="line">        res = aim == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; arr[index] * i &lt;= aim; i++) &#123;</span><br><span class="line">            res += process1(arr, index + <span class="number">1</span>, aim - arr[index] * i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来介绍基于暴力递归初步优化的方法，也就是记忆搜索的方法。暴力递归之所以暴力，是因为存在大量的重复计算。比如上面的例子，当已经使用 0 张 5 元+1 张 10 元的情况下，后续应该求[25,1]组成剩下的 990 的方法总数。当已经使用 2 张 5 元+0 张 10 元的情况下，后续还是求[25,1]组成剩下的 990 的方法总数。两种情况都要求 process1(arr,2,990)。类似这样的重复计算在暴力递归的过程中大量发生，所以暴力递归方法的时间复杂度非常高，并且与 arr 中钱的面值有关，最差情况为 O(aim^N)。<br>记忆化搜索的优化方式。process1(arr,index,aim)中 arr 是始终不变的，变化的只有 index 和 aim，所以可以用 p(index,aim)表示一个递归过程。重复计算之所以大量发生，是因为每一个递归过程的结果都没记下来，所以下次还要重复去求。我们可以事先准备好一个 map，每计算完一个递归过程，都将结果记录到 map 中。当下次进行同样的递归过程之前，先在 map 中查询这个递归过程是否已经计算过，如果已经计算过，就把值拿出来直接用，如果没计算过，需要再进入递归过程。具体请参看如下代码中的 coins2 方法，它和 coins1 方法的区别就是准备好全局变量 map，记录已经计算过的递归过程的结果，防止下次重复计算。因为本题的递归过程可由两个变量表示，所以 map 是一张二维表。map[i][j]表示递归过程 p(i,j)的返回值。另外有一些特殊值，map[i][j]==0 表示递归过程 p(i,j)从来没有计算过。map[i][j]==-1 表示递归过程 p(i,j)计算过，但返回值是 0。如果 map[i][j]的值既不等于 0，也不等于 -1，记为 a，则表示递归过程 p(i,j)的返回值是 a。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coins2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> process2(arr, <span class="number">0</span>, aim, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">process2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> aim, <span class="type">int</span>[][] map)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (index == arr.length) &#123;</span><br><span class="line">        res = aim == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mapValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; arr[index] * i &lt;= aim; i++) &#123;</span><br><span class="line">            mapValue = map[index + <span class="number">1</span>][aim - arr[index] * i];</span><br><span class="line">            <span class="keyword">if</span> (mapValue != <span class="number">0</span>) &#123;</span><br><span class="line">                res += mapValue == -<span class="number">1</span> ? <span class="number">0</span> : mapValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += process2(arr, index + <span class="number">1</span>, aim - arr[index] * i, map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map[index][aim] = res == <span class="number">0</span> ? -<span class="number">1</span> : res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记忆化搜索的方法是针对暴力递归最初级的优化技巧，分析递归函数的状态可以由哪些变量表示，做出相应维度和大小的 map 即可。记忆化搜索方法的时间复杂度为 O(N×aim^2)，我们在解释完下面的方法后，再来具体解释为什么是这个时间复杂度。<br>动态规划方法。其实就是本书“机器人达到指定位置方法数”问题所提到的套路。生成行数为 N、列数为 aim+1 的矩阵 dp，dp[i][j]的含义是在使用 arr[0..i]货币的情况下，组成钱数 j 有多少种方法。dp[i][j]的值求法如下：</p>
<ol>
<li>对于矩阵 dp 第一列的值 dp[..][0]，表示组成钱数为 0 的方法数，很明显是 1 种，也就是不使用任何货币。所以 dp 第一列的值统一设置为 1。</li>
<li>对于矩阵 dp 第一行的值 dp[0][..]，表示只能使用 arr[0]这一种货币的情况下，组成钱的方法数，比如，arr[0]=5 时，能组成的钱数只有 0, 5, 10, 15, …。所以，令 dp[0][k<em>arr[0]]=1 (0&lt;=k</em>arr[0]&lt;=aim, k 为非负整数)。</li>
<li>除第一行和第一列的其他位置，记为位置(i,j)。dp[i][j]的值是以下几个值的累加。<ul>
<li>完全不用 arr[i]货币，只使用 arr[0..i-1]货币时，方法数为 dp[i-1][j]。</li>
<li>用 1 张 arr[i]货币，剩下的钱用 arr[0..i-1]货币组成时，方法数为 dp[i-1][j-arr[i]]。</li>
<li>用 2 张 arr[i]货币，剩下的钱用 arr[0..i-1]货币组成时，方法数为 dp[i-1][j-2*arr[i]]。<br>……</li>
<li>用 k 张 arr[i]货币，剩下的钱用 arr[0..i-1]货币组成时，方法数为 dp[i-1][j-k<em>arr[i]]。j-k</em>arr[i]&gt;=0, k 为非负整数。</li>
</ul>
</li>
<li>最终 dp[N-1][aim]的值就是最终结果。<br>具体过程请参看如下代码中的 coins3 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coins3</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length][aim + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; arr[<span class="number">0</span>] * j &lt;= aim; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][arr[<span class="number">0</span>] * j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= aim; j++) &#123;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; j - arr[i] * k &gt;= <span class="number">0</span>; k++) &#123;</span><br><span class="line">                num += dp[i - <span class="number">1</span>][j - arr[i] * k];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[arr.length - <span class="number">1</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在最差的情况下，对位置(i,j)来说，求解 dp[i][j]的计算过程需要枚举 dp[i-1][0..j]上的所有值，dp 一共有 N×aim 个位置，所以总体的时间复杂度为 O(N×aim^2)。<br>下面解释之前记忆化搜索方法的时间复杂度为什么也是 O(N×aim^2)，因为记忆化搜索方法在本质上等价于动态规划方法。记忆化搜索的方法说白了就是不关心到达某一个递归过程的路径，只是单纯地对计算过的递归过程进行记录，避免重复的递归过程，而动态规划的方法则是规定好每一个递归过程的计算顺序，依次进行计算，后计算的过程严格依赖前面计算过的过程。两者都是空间换时间的方法，也都有枚举的过程，区别就在于动态规划规定计算顺序，而记忆搜索不用规定。所以记忆化搜索方法的时间复杂度也是 O(N×aim^2)。两者各有优缺点，如果将暴力递归过程简单地优化成记忆搜索的方法，递归函数依然在使用，这在工程上的开销较大。而动态规划方法严格规定了计算顺序，可以将递归计算变成顺序计算，这是动态规划方法具有的优势。其实记忆搜索的方法也有优势，本题就很好地体现了。比如，arr=[20000,10000,1000], aim=200000000。如果是动态规划的计算方法，要严格计算 3×200000000 个位置。而对于记忆搜索来说，因为面值最小的钱为 1000，所以百位为(1~9)、十位为(1~9)或各位为(1~9)的钱数是不可能出现的，当然也就没必要计算。通过本例可以知道，记忆化搜索是对必须要计算的递归过程才去计算并记录的。<br>接下来介绍时间复杂度为 O(N×aim)的动态规划方法。我们来看上一个动态规划方法中，求 dp[i][j]值时的步骤 3，这也是最关键的枚举过程：除第一行和第一列的其他位置，记为位置(i,j)。dp[i][j]的值是以下几个值的累加。</p>
<ul>
<li>完全不用 arr[i]货币，只使用 arr[0..i-1]货币时，方法数为 dp[i-1][j]。</li>
<li>用 1 张 arr[i]货币，剩下的钱用 arr[0..i-1]货币组成时，方法数为 dp[i-1][j-arr[i]]。</li>
<li>用 2 张 arr[i]货币，剩下的钱用 arr[0..i-1]货币组成时，方法数为 dp[i-1][j-2*arr[i]]。<br>……</li>
<li>用 k 张 arr[i]货币，剩下的钱用 arr[0..i-1]货币组成时，方法数为 dp[i-1][j-k<em>arr[i]]。j-k</em>arr[i]&gt;=0, k 为非负整数。<br>步骤 3 中，第 1 种情况的方法数为 dp[i-1][j]，而第 2 种情况一直到第 k 种情况的方法数累加值其实就是 dp[i][j-arr[i]]的值。所以步骤 3 可以简化为 dp[i][j]=dp[i-1][j]+dp[i][j-arr[i]]。一下省去了枚举的过程，时间复杂度也减小至 O(N×aim)，具体请参看如下代码中的 coins4 方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coins4</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length][aim + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; arr[<span class="number">0</span>] * j &lt;= aim; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][arr[<span class="number">0</span>] * j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= aim; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            dp[i][j] += j - arr[i] &gt;= <span class="number">0</span> ? dp[i][j - arr[i]] : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[arr.length - <span class="number">1</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为 O(N×aim)的动态规划方法再结合空间压缩的技巧。空间压缩的原理请读者参考本书“矩阵的最小路径和”问题，这里不再详述。请参看如下代码中的 coins5 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coins5</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[aim + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; arr[<span class="number">0</span>] * j &lt;= aim; j++) &#123;</span><br><span class="line">        dp[arr[<span class="number">0</span>] * j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= aim; j++) &#123;</span><br><span class="line">            dp[j] += j - arr[i] &gt;= <span class="number">0</span> ? dp[j - arr[i]] : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们得到了最优解，是时间复杂度为 O(N×aim)、额外空间复杂度 O(aim)的方法。</p>
<p><strong>扩展</strong></p>
<p>通过本题目的优化过程，可以梳理出暴力递归通用的优化过程。对于在面试中遇到的具体题目，面试者一旦想到暴力递归的过程，其实之后的优化过程是水到渠成的。首先看写出来的暴力递归函数，找出有哪些参数是不发生变化的，忽略这些变量。只看那些变化并且可以表示递归过程的参数，找出这些参数之后，记忆搜索的方法其实可以很轻易地写出来，因为只是简单的修改，计算完就记录到 map 中，并在下次直接拿来使用，没计算过则依然进行递归计算。接下来观察记忆搜索过程中使用的 map 结构，看看该结构某一个具体位置的值是通过哪些位置的值求出的，被依赖的位置先求，就能改出动态规划的方法，也就是本书“机器人达到指定位置方法数”问题提到的套路。改出的动态规划方法中，如果有枚举的过程，看看枚举过程是否可以继续优化，常规的方法既有本题所实现的通过表达式来化简枚举状态的方式，也有本书的“丢棋子问题”、“画匠问题”和“邮局选址问题”所涉及的四边形不等式的相关内容，有兴趣的读者可以进一步学习。</p>
<h2 id="打气球的最大分数"><a href="#打气球的最大分数" class="headerlink" title="打气球的最大分数"></a>打气球的最大分数</h2><p><strong>题目</strong></p>
<p>给定一个数组 arr，代表一排有分数的气球。每打爆一个气球都能获得分数，假设打爆气球的分数为 X，获得分数的规则如下：<br>1) 如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 L；如果被打爆气球的右边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 R。获得分数为 L×X×R。<br>2) 如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 L；如果被打爆气球的右边所有气球都已经被打爆。获得分数为 L×X。<br>3) 如果被打爆气球的左边所有气球都已经被打爆；如果被打爆气球的右边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 R；如果被打爆气球的右边所有气球都已经被打爆。获得分数为 X×R。<br>4) 如果被打爆气球的左边和右边所有的气球都已经被打爆。获得分数为 X。<br>目标是打爆所有气球，获得每次打爆的分数。通过选择打爆气球的顺序，可以得到不同的总分，请返回能获得的最大分数。</p>
<p><strong>举例</strong></p>
<p>arr = {3,2,5}<br>如果先打爆 3，获得 3×2；再打爆 2，获得 2×5；最后打爆 5，获得 5。最后总分 21。<br>如果先打爆 3，获得 3×2；再打爆 5，获得 2×5；最后打爆 2，获得 2。最后总分 18。<br>如果先打爆 2，获得 3×2×5；再打爆 3，获得 3×5；最后打爆 5，获得 5。最后总分 50。<br>如果先打爆 2，获得 3×2×5；再打爆 5，获得 3×5；最后打爆 3，获得 3。最后总分 48。<br>如果先打爆 5，获得 2×5；再打爆 3，获得 3×2；最后打爆 2，获得 2。最后总分 18。<br>如果先打爆 5，获得 2×5；再打爆 2，获得 3×2；最后打爆 3，获得 3。最后总分 19。<br>能获得的最大分数为 50。</p>
<p><strong>解答</strong></p>
<p>这道题我们使用暴力递归优化成动态规划的套路，不熟悉套路的读者请先阅读本书“机器人达到指定位置方法数”问题的解答。本题先实现尝试做出所有可能打爆方法的暴力递归过程。只有尝试方法是最重要的，而且只要尝试方法确定，固定套路可以总结如何去尝试。<br>假设打爆 arr[L..R]这个范围上所有的气球，并且假设 arr[L-1]和 arr[R+1]的气球都没有被打爆。尝试的过程为 process 函数，最后获得的最大分数为 process(L,R)。依次尝试，如果每个气球最后被打爆，具体为：<br>如果 arr[L]是最后被打爆的，也就是先把 arr[L+1..R]范围上的气球都打完之后，再打爆 arr[L]。先把 arr[L+1..R]范围上的气球都打完能够获得的最大分数为 process(L+1,R)。因为此时 arr[L+1..R]的气球都打完了，所以 arr[L]的左边为 arr[L-1]，右边为 arr[R+1]。最后打爆 arr[L]获得的分数为 arr[L-1]<em>arr[L]</em>arr[R+1]。总分为 arr[L-1]<em>arr[L]</em>arr[R+1]+process(L+1,R)。<br>如果 arr[L+1]是最后被打爆的，也就是先把 arr[L,L]和 arr[L+2..R]范围上的气球都打完之后，再打爆 arr[L+1]。先把 arr[L,L]范围上的气球都打完能够获得的最大分数为 process(L,L)，把 arr[L+2..R]范围上的气球都打完能够获得的最大分数为 process(L+2,R)。因为此时 arr[L,L]和 arr[L+2..R]的气球都打完了，所以 arr[L+1]的左边为 arr[L-1]，右边为 arr[R+1]。最后打爆 arr[L+1]获得的分数为 arr[L-1]<em>arr[L+1]</em>arr[R+1]。总分为 process(L,L)+process(L+2,R)+arr[L-1]<em>arr[L+1]</em>arr[R+1]。<br>……<br>如果 arr[i]是最后被打爆的 (L &lt; i &lt; R)，也就是先把 arr[L..i-1]和 arr[i+1..R]范围上的气球都打完之后，再打爆 arr[i]。把 arr[L..i-1]范围上的气球都打完能够获得的最大分数为 process(L,i-1)。把 arr[i+1..R]范围上的气球都打完能够获得的最大分数为 process(i+1,R)。因为此时 arr[L..i-1]和 arr[i+1..R]的气球都打完了，所以 arr[i]的左边为 arr[L-1]，右边为 arr[R+1]。最后打爆 arr[i]获得的分数为 arr[L-1]<em>arr[i]</em>arr[R+1]。总分为 process(L,i-1)+process(i+1,R)+arr[L-1]<em>arr[i]</em>arr[R+1]。<br>……<br>如果 arr[R]是最后被打爆的，也就是先把 arr[L..R-1]范围上的气球都打完之后，再打爆 arr[R]。先把 arr[L..R-1]范围上的气球都打完能够获得的最大分数为 process(L,R-1)。因为此时 arr[L..R-1]的气球都打完了，所以 arr[R]的左边为 arr[L-1]，右边为 arr[R+1]。最后打爆 arr[R]获得的分数为 arr[L-1]<em>arr[R]</em>arr[R+1]。总分为 process(L,R-1)+arr[L-1]<em>arr[R]</em>arr[R+1]。<br>以上所有的尝试方案中，哪个方案的总分最大，哪个就是 process(L,R)的返回值。以上解释的所有尝试过程请看如下的 process 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打爆 arr[L..R]范围上的所有气球，返回最大的分数</span></span><br><span class="line"><span class="comment">// 假设 arr[L-1]和 arr[R+1]一定没有被打爆</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123; <span class="comment">// 如果 arr[L..R]范围上只有一个气球，直接打爆即可</span></span><br><span class="line">        <span class="keyword">return</span> arr[L - <span class="number">1</span>] * arr[L] * arr[R + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后打爆 arr[L]的方案与最后打爆 arr[R]的方案，先比较一下</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(</span><br><span class="line">            arr[L - <span class="number">1</span>] * arr[L] * arr[R + <span class="number">1</span>] + process(arr, L + <span class="number">1</span>, R),</span><br><span class="line">            arr[L - <span class="number">1</span>] * arr[R] * arr[R + <span class="number">1</span>] + process(arr, L, R - <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 尝试中间位置的气球最后被打爆的每一种方案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> L + <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line">        max = Math.max(max,</span><br><span class="line">                arr[L - <span class="number">1</span>] * arr[i] * arr[R + <span class="number">1</span>] + process(arr, L, i - <span class="number">1</span>)</span><br><span class="line">                        + process(arr, i + <span class="number">1</span>, R));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果把 arr 的开头和结尾补上 1，然后打爆除两头的 1 还剩下的位置，就是答案。比如 arr={3,2,5}，先生成一个辅助数组 help={1,3,2,5,1}，然后打爆 help[1..3]范围上（即{3,2,5}）的所有气球即可，这么做可以避免判断边界所带来的编程烦恼。主方法请看如下的 maxCoins1 方法，尝试的解法已经完全实现了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxCoins1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">2</span>];</span><br><span class="line">    help[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    help[N + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        help[i + <span class="number">1</span>] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(help, <span class="number">1</span>, N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暴力递归改动态规划。假设 arr={4,2,3,5,1,6}，生成的 help={1,4,2,3,5,1,6,1}，求的是打爆 help[1..6]上的所有气球获得的最大分数。利用优化套路过程如下：<br>前提：尝试过程是无后效性的。process(L,R)解决的问题就是打爆 help[L..R]上所有的气球获得的最大分数，不管如何到达的 process(L,R)，返回值一定是固定的。<br>1) 可变参数 L 和 R 一旦确定，返回值就确定了。<br>2) 如果可变参数 L 和 R 组合的所有情况组成一张表，这张表一定可以装下所有的返回值。L 变量的含义是 help 中的位置，所以 L 一定不会在 1~6 的范围之外；R 变量的含义是 help 中的位置，所以 L 一定不会在 1~6 范围之外，那么 L 和 R 组合的所有情况如图 4-6 所示，这是一个正方形矩阵。<br>在图 4-6 中，行对应 L，列对应 R。枚举了 L 和 R 所有的组合即可，其中第 0 行、第 7 行、第 0 列和第 7 列是永远不会用到的，这些位置在图中已经用叉号标出。因为 process(L,R)表达的含义是在 help[L..R]这个范围上做尝试，所以 L 不可能大于 R，也就是说，这张表中不含对角线的下半区(L&gt;R)是永远不会用到的，这些位置在图中已经用圆圈标出。任何一个状态 process(L,R)都一定可以放在剩下的位置中，这张表记为 dp[][]。<br>3) 我们的最终状态是 process(1,6)，也就是 dp[1][6]的值，在表中已经用星号标出。如何求出这个值呢？<br>4) 根据 process(L,R)函数的 base case，填写初始的位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">    <span class="keyword">return</span> help[L - <span class="number">1</span>] * help[L] * help[R + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>L==R 时，就是图 4-6 中的对角线位置，如果对角线位置是 dp[i][i]，那么 dp[i][i]=help[i-1]<em>help[i]</em>help[i+1]。填写之后如图 4-7 所示。<br>5) base case 之外的情况都是普遍位置，在 process(L,R)函数中如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(</span><br><span class="line">        help[L - <span class="number">1</span>] * help[L] * help[R + <span class="number">1</span>] + process(help, L + <span class="number">1</span>, R),</span><br><span class="line">        help[L - <span class="number">1</span>] * help[R] * help[R + <span class="number">1</span>] + process(help, L, R - <span class="number">1</span>));</span><br><span class="line"><span class="comment">// 尝试中间位置的气球最后被打爆的每一种方案</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> L + <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line">    max = Math.max(max,</span><br><span class="line">            help[L - <span class="number">1</span>] * help[i] * help[R + <span class="number">1</span>] + process(help, L, i - <span class="number">1</span>)</span><br><span class="line">                    + process(help, i + <span class="number">1</span>, R));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用看代码的方式分析状态依赖不直观，可以用分析 dp 表的方式。比如 dp[1][6]这个位置（星号），依赖哪些位置呢？根据 process(L,R)的代码，分析出 process(1,6)依赖的位置有：<br>1) process(2,6)，最后打爆 help[1]时的依赖，图 4-8 中的 A。<br>2) process(1,5)，最后打爆 help[6]时的依赖，图 4-8 中的 B。<br>3) process(1,1)，最后打爆 help[2]时的依赖，图 4-8 中的 C。<br>4) process(3,6)，最后打爆 help[2]时的依赖，图 4-8 中的 D。<br>5) process(1,2)，最后打爆 help[3]时的依赖，图 4-8 中的 E。<br>6) process(4,6)，最后打爆 help[3]时的依赖，图 4-8 中的 F。<br>7) process(1,3)，最后打爆 help[4]时的依赖，图 4-8 中的 G。<br>8) process(5,6)，最后打爆 help[4]时的依赖，图 4-8 中的 H。<br>9) process(1,4)，最后打爆 help[5]时的依赖，图 4-8 中的 I。<br>10) process(6,6)，最后打爆 help[5]时的依赖，图 4-8 中的 J。<br>这说明 dp[L][R]的值都只依赖同一行左边和同一列下边的有效位置，已经标为无效的位置依然不需要。所以，除去对角线，剩下的位置应该怎么填呢？先填最下面的行，从左往右进行填写；填好一行之后，再从左往右填写上一行。最终填写到有效部分的最上面一行，最右的有效位置就是答案。按照这种顺序求解任何一个位置的值时，这个位置左边和下面的位置一定已经被填写过了。<br>6) 返回 dp[1][6]的值就是答案。<br>本题动态规划的解法就是填写一个规模 O(N^2)表的上半区，填写每一个位置的时候，都有一个时间复杂度 O(N)的枚举过程，所以整体的时间复杂度为 O(N^3)。具体实现请看如下的 maxCoins2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxCoins2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">2</span>];</span><br><span class="line">    help[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    help[N + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        help[i + <span class="number">1</span>] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">2</span>][N + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        dp[i][i] = help[i - <span class="number">1</span>] * help[i] * help[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> N; L &gt;= <span class="number">1</span>; L--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> L + <span class="number">1</span>; R &lt;= N; R++) &#123;</span><br><span class="line">            <span class="comment">// 求解 dp[L][R]，表示 help[L..R]上打爆所有气球的最大分数</span></span><br><span class="line">            <span class="comment">// 最后打爆 help[L]的方案</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">finalL</span> <span class="operator">=</span> help[L - <span class="number">1</span>] * help[L] * help[R + <span class="number">1</span>] + dp[L + <span class="number">1</span>][R];</span><br><span class="line">            <span class="comment">// 最后打爆 help[R]的方案</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">finalR</span> <span class="operator">=</span> help[L - <span class="number">1</span>] * help[R] * help[R + <span class="number">1</span>] + dp[L][R - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 最后打爆 help[L]的方案和最后打爆 help[R]的方案，先比较一下</span></span><br><span class="line">            dp[L][R] = Math.max(finalL, finalR);</span><br><span class="line">            <span class="comment">// 尝试中间位置的气球最后被打爆的每一种方案</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> L + <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line">                dp[L][R] = Math.max(dp[L][R],</span><br><span class="line">                        help[L - <span class="number">1</span>] * help[i] * help[R + <span class="number">1</span>] + dp[L][i - <span class="number">1</span>]</span><br><span class="line">                                + dp[i + <span class="number">1</span>][R]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p><strong>题目</strong></p>
<p>给定数组 arr，返回 arr 的最长递增子序列。</p>
<p><strong>举例</strong></p>
<p>arr=[2,1,5,3,6,4,8,9,7]，返回的最长递增子序列为[1,3,4,8,9]。</p>
<p><strong>解答</strong></p>
<h3 id="方法一：时间复杂度-O-N-2"><a href="#方法一：时间复杂度-O-N-2" class="headerlink" title="方法一：时间复杂度 O(N^2)"></a>方法一：时间复杂度 O(N^2)</h3><p>先介绍时间复杂度为 O(N^2)的方法，具体过程如下：</p>
<ol>
<li>生成长度为 N 的数组 dp，dp[i]表示在以 arr[i]这个数结尾的情况下，arr[0..i]中的最长递增子序列长度。</li>
<li>对第一个数 arr[0]来说，令 dp[0]=1。接下来从左到右依次算出每个位置的数结尾的情况下，最长递增子序列长度。</li>
<li>假设计算到位置 i，求以 arr[i]结尾情况下的最长递增子序列长度，即 dp[i]。如果最长递增子序列以 arr[i]结尾，那么在 arr[0..i-1]中所有比 arr[i]小的数都可以作为倒数第二个数。在这么多倒数第二个数的选择中，以哪个数结尾的最大递增子序列更大，就选哪个数作为倒数第二个数，所以 dp[i]=max{dp[j]+1} (0&lt;=j&lt;i, arr[j]&lt;arr[i])。如果 arr[0..i-1]中所有的数都不比 arr[i]小，令 dp[i]=1 即可，说明以 arr[i]结尾情况下的最长递增子序列只包含 arr[i]。</li>
</ol>
<p>按照步骤 1~步骤 3 可以计算出 dp 数组，具体过程请参看如下代码中的 getdp1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getdp1(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来解释如何根据求出的 dp 数组得到最长递增子序列。以题目的例子来说明，arr=[2,1,5,3,6,4,8,9,7]，求出的数组 dp=[1,1,2,2,3,3,4,5,4]。</p>
<ol>
<li>遍历 dp 数组，找到最大值以及位置。在本例中，最大值为 5，位置为 7，说明最终的最长递增子序列的长度为 5，并且应该以 arr[7]这个数（arr[7]==9）结尾。</li>
<li>从 arr 数组的位置 7 开始从右向左遍历。如果对某一个位置 i，既有 arr[i]&lt;arr[7]，又有 dp[i]==dp[7]-1，说明 arr[i]可以作为最长递增子序列的倒数第二个数。在本例中，arr[6]&lt;arr[7]并且 dp[6]==dp[7]-1，所以 8 应该作为最长递增子序列的倒数第二个数。</li>
<li>从 arr 数组的位置 6 开始继续向左遍历，按照同样的过程找到倒数第三个数。在本例中，位置 5 满足 arr[5]&lt;arr[6]，并且 dp[5]==dp[6]-1，同时位置 4 也满足。选 arr[5]或者 arr[4]作为倒数第三个数都可以。</li>
<li>重复这样的过程，直到所有的数都找出来。</li>
</ol>
<p>dp 数组包含每一步决策的信息，其实根据 dp 数组找出最长递增子序列的过程就是从某一个位置开始逆序还原决策路径的过程。具体过程请参看如下代码中的 generateLIS 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] generateLIS(<span class="type">int</span>[] arr, <span class="type">int</span>[] dp) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] &gt; len) &#123;</span><br><span class="line">            len = dp[i];</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] lis = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    lis[--len] = arr[index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[index] &amp;&amp; dp[i] == dp[index] - <span class="number">1</span>) &#123;</span><br><span class="line">            lis[--len] = arr[i];</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个过程的主方法参看如下代码中的 lis1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] lis1(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = getdp1(arr);</span><br><span class="line">    <span class="keyword">return</span> generateLIS(arr, dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：时间复杂度-O-N-logN"><a href="#方法二：时间复杂度-O-N-logN" class="headerlink" title="方法二：时间复杂度 O(N*logN)"></a>方法二：时间复杂度 O(N*logN)</h3><p>很明显，计算 dp 数组过程的时间复杂度为 O(N^2)，根据 dp 数组得到最长递增子序列过程的时间复杂度为 O(N)，所以整个过程的时间复杂度为 O(N^2)。如果要让时间复杂度达到 O(NlogN)，只要让计算 dp 数组的过程达到时间复杂度 O(NlogN)即可，之后根据 dp 数组生成最长递增子序列的过程是一样的。</p>
<p>时间复杂度 O(NlogN)生成 dp 数组的过程是利用二分查找来进行的优化。先生成一个长度为 N 的数组 ends，初始时 ends[0]=arr[0]，其他位置上的值为 0。生成整型变量 right，初始时 right=0。在从左到右遍历 arr 数组的过程中，求解 dp[i]的过程需要使用 ends 数组和 right 变量，所以这里解释一下其含义。遍历的过程中，ends[0..right]为有效区，ends[right+1..N-1]为无效区。对有效区上的位置 b，如果 ends[b]==c，则表示遍历到目前为止，在所有长度为 b+1 的递增序列中，最小的结尾数是 c。无效区的位置没有意义。</p>
<p>比如，arr=[2,1,5,3,6,4,8,9,7]，初始时 dp[0]=1，ends[0]=2，right=0。ends[0..0]为有效区。</p>
<ol>
<li>遍历到 arr[1]==1。ends 有效区=[2]，在有效区中找到最左边大于或等于 arr[1]的数。发现是 ends[0]，表示以 arr[1]结尾的最长递增序列只有 arr[1]，所以令 dp[1]=1。然后令 ends[0]=1，因为遍历到目前为止，在所有长度为 1 的递增序列中，最小的结尾数是 1，不再是 2。</li>
<li>遍历到 arr[2]==5。ends 有效区=[1]，在有效区中找到最左边大于或等于 arr[2]的数。发现没有这样的数，表示以 arr[2]结尾的最长递增序列长度=ends 有效区长度+1，所以令 dp[2]=2。ends 整个有效区都没有比 arr[2]更大的数，说明发现了比 ends 有效区长度更长的递增序列，于是把有效区扩大，ends 有效区=[1,5]。</li>
<li>遍历到 arr[3]==3。ends 有效区=[1,5]，在有效区中用二分法找到最左边大于或等于 arr[3]的数。发现是 ends[1]，表示以 arr[3]结尾的最长递增序列长度为 2，所以令 dp[3]=2。然后令 ends[1]=3，因为遍历到目前为止，在所有长度为 2 的递增序列中，最小的结尾数是 3，不再是 5。</li>
<li>遍历到 arr[4]==6。ends 有效区=[1,3]，在有效区中用二分法找到最左边大于或等于 arr[4]的数。发现没有这样的数，表示以 arr[4]结尾的最长递增序列长度=ends 有效区长度+1，所以令 dp[4]=3。ends 整个有效区都没有比 arr[4]更大的数，说明发现了比 ends 有效区长度更长的递增序列，于是把有效区扩大，ends 有效区=[1,3,6]。</li>
<li>遍历到 arr[5]==4。ends 有效区=[1,3,6]，在有效区中用二分法找到最左边大于或等于 arr[5]的数。发现是 ends[2]，表示以 arr[5]结尾的最长递增序列长度为 3，所以令 dp[5]=3。然后令 ends[2]=4，表示在所有长度为 3 的递增序列中，最小的结尾数变为 4。</li>
<li>遍历到 arr[6]==8。ends 有效区=[1,3,4]，在有效区中用二分法找到最左边大于或等于 arr[6]的数。发现没有这样的数，表示以 arr[6]结尾的最长递增序列长度=ends 有效区长度+1，所以令 dp[6]=4。ends 整个有效区都没有比 arr[6]更大的数，说明发现了比 ends 有效区长度更长的递增序列，于是把有效区扩大，ends 有效区=[1,3,4,8]。</li>
<li>遍历到 arr[7]==9。ends 有效区=[1,3,4,8]，在有效区中用二分法找到最左边大于或等于 arr[7]的数。发现没有这样的数，表示以 arr[7]结尾的最长递增序列长度=ends 有效区长度+1，所以令 dp[7]=5。ends 整个有效区都没有比 arr[7]更大的数，于是把有效区扩大，ends 有效区=[1,3,4,8,9]。</li>
<li>遍历到 arr[8]==7。ends 有效区=[1,3,4,8,9]，在有效区中用二分法找到最左边大于或等于 arr[8]的数。发现是 ends[3]，表示以 arr[8]结尾的最长递增序列长度为 4，所以令 dp[8]=4。然后令 ends[3]=7，表示在所有长度为 4 的递增序列中，最小的结尾数变为 7。</li>
</ol>
<p>具体过程请参看如下代码中的 getdp2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getdp2(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    ends[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = right;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; ends[m]) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right = Math.max(right, l);</span><br><span class="line">        ends[l] = arr[i];</span><br><span class="line">        dp[i] = l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 O(NlogN)方法的主方法参看如下代码中的 lis2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] lis2(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = getdp2(arr);</span><br><span class="line">    <span class="keyword">return</span> generateLIS(arr, dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="信封嵌套问题"><a href="#信封嵌套问题" class="headerlink" title="信封嵌套问题"></a>信封嵌套问题</h2><p><strong>题目</strong></p>
<p>给定一个 N 行 2 列的二维数组，每一个小数组的两个值分别代表一个信封的长和宽。如果信封 A 的长和宽都小于信封 B，那么信封 A 可以放在信封 B 里，请返回信封最多嵌套多少层。</p>
<p><strong>举例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">matrix = &#123;</span><br><span class="line">    &#123;<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>,<span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>,<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">4</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信封最多可以套 4 层，从里到外分别是{1,2},{2,3},{3,4},{4,5}，所以返回 4。</p>
<p><strong>要求</strong></p>
<p>时间复杂度为 O(NlogN)。</p>
<p><strong>解答</strong></p>
<p>解答这道题需要使用的算法原型为本书“最长递增子序列”问题，请读者在阅读本题解析之前，确保已经理解本书关于这个算法原型问题解答的最优解。</p>
<p>首先把 N 个长度为 2 的小数组变成信封数组。然后对信封数组排序，排序的策略为，按照长度从小到大排序，长度相等的信封之间按照宽度从大到小排序，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Envelope</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> wid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Envelope</span><span class="params">(<span class="type">int</span> weight, <span class="type">int</span> hight)</span> &#123;</span><br><span class="line">        len = weight;</span><br><span class="line">        wid = hight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnvelopeComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Envelope&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Envelope o1, Envelope o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.len != o2.len ? o1.len - o2.len : o2.wid - o1.wid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Envelope[] getSortedEnvelopes(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">    Envelope[] res = <span class="keyword">new</span> <span class="title class_">Envelope</span>[matrix.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        res[i] = <span class="keyword">new</span> <span class="title class_">Envelope</span>(matrix[i][<span class="number">0</span>], matrix[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(res, <span class="keyword">new</span> <span class="title class_">EnvelopeComparator</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如原问题给出的例子，排序之后的结果为一个信封对象的数组，如下所示。<br>信封 1: 长:1 宽:3<br>信封 2: 长:1 宽:2<br>信封 3: 长:2 宽:4<br>信封 4: 长:2 宽:3<br>信封 5: 长:2 宽:2<br>信封 6: 长:3 宽:6<br>信封 7: 长:3 宽:4<br>信封 8: 长:3 宽:2<br>信封 9: 长:4 宽:5</p>
<p>接下来在排序后的这个信封数组中忽略长度，只看宽度数组，也就是只看{3,2,4,3,2,6,4,2,5}这个数组的最长递增子序列长度是多少即可。为什么呢？这与我们的排序策略有关，按照长度从小到大排序，长度相等的信封之间按照宽度从大到小排序。</p>
<p>我们假设有一个信封 X，处在排序之后数组中的某个位置，长度为 Xlen，宽度为 Xwid。我们要求出必须以 X 作为最外面信封的情况，最多套几层。那么信封 X 之后的信封一定不能放在 X 里，因为之后信封的长度都大于或等于 Xlen。分析一下信封 X 之前的信封，因为排序策略是按照长度从小到大排序的，所以 X 之前的信封长度要么小于 X，要么等于 X：</p>
<ol>
<li>如果 X 之前的信封长度小于 X 的长度。那么只要之前信封的宽度小于 X 的宽度，一定可以放在 X 内。所以在宽度组成的数组中，X 的宽度如果作为最后一个数，求宽度数组的最长递增子序列即可。</li>
<li>如果 X 之前的信封长度等于 X 的长度。因为长度相等的信封之间按照宽度从大到小排序，所以这些信封的宽度一定大于或等于 X 的宽度，这样就不可能是 X 的宽度作为最后一个数的情况下，宽度数组的最长递增子序列的一部分。</li>
</ol>
<p>所以，只要求 X 的宽度作为最后一个数的情况下，宽度数组的最长递增子序列长度即可。</p>
<p>比如，在例子中的信封 7，宽度为 4，以信封 7 结尾的宽度数组为{3,2,4,3,2,6,4}，必须以信封 7 结尾的宽度数组中，最长递增子序列为{2,3,4}。所以必须以信封 7 作为最外层的情况下，最多套 3 层。也就是说，在这个排序策略下，只要 X 之前的信封宽度小于 X 的宽度，长度也必须小于 X 的长度。求一个数组的最长递增子序列，是我们之前讲过的一个算法原型，直接利用即可。主过程代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxEnvelopes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    Envelope[] envelopes = getSortedEnvelopes(matrix);</span><br><span class="line">    <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[matrix.length];</span><br><span class="line">    ends[<span class="number">0</span>] = envelopes[<span class="number">0</span>].wid;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; envelopes.length; i++) &#123;</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = right;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (envelopes[i].wid &gt; ends[m]) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right = Math.max(right, l);</span><br><span class="line">        ends[l] = envelopes[i].wid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><p><strong>题目</strong></p>
<p>给定一个整数 n，代表汉诺塔游戏中从小到大放置的 n 个圆盘，假设开始时所有的圆盘都放在左边的柱子上，想按照汉诺塔游戏的要求把所有的圆盘都移到右边的柱子上。实现函数打印最优移动轨迹。</p>
<p><strong>举例</strong></p>
<p>n=1 时，打印：<br>move from left to right<br>n=2 时，打印：<br>move from left to mid<br>move from left to right<br>move from mid to right</p>
<p><strong>进阶问题</strong></p>
<p>给定一个整型数组 arr，其中只含有 1、2 和 3，代表所有圆盘目前的状态，1 代表左柱，2 代表中柱，3 代表右柱，arr[i]的值代表第 i+1 个圆盘的位置。比如，arr=[3,3,2,1]，代表第 1 个圆盘在右柱上、第 2 个圆盘在右柱上、第 3 个圆盘在中柱上、第 4 个圆盘在左柱上。如果 arr 代表的状态是最优移动轨迹过程中出现的状态，返回 arr 这种状态是最优移动轨迹中的第几个状态。如果 arr 代表的状态不是最优移动轨迹过程中出现的状态，则返回-1。</p>
<p><strong>进阶举例</strong></p>
<p>arr=[1,1]。两个圆盘目前都在左柱上，也就是初始状态，所以返回 0。<br>arr=[2,1]。第一个圆盘在中柱上、第二个圆盘在左柱上，这个状态是 2 个圆盘的汉诺塔游戏中最优移动轨迹的第 1 步，所以返回 1。<br>arr=[3,3]。第一个圆盘在右柱上、第二个圆盘在右柱上，这个状态是 2 个圆盘的汉诺塔游戏中最优移动轨迹的第 3 步，所以返回 3。<br>arr=[2,2]。第一个圆盘在中柱上、第二个圆盘在中柱上，这个状态是 2 个圆盘的汉诺塔游戏中最优移动轨迹从来不会出现的状态，所以返回-1。</p>
<p><strong>进阶要求</strong></p>
<p>如果 arr 长度为 N，请实现时间复杂度为 O(N)、额外空间复杂度为 O(1)的方法。</p>
<p><strong>解答</strong></p>
<p>原问题。假设有 from 柱子、mid 柱子和 to 柱子，都从 from 的圆盘 1~i 完全移动到 to，最优过程为：<br>步骤 1：为圆盘 1~i-1 从 from 移动到 mid。<br>步骤 2：为单独把圆盘 i 从 from 移动到 to。<br>步骤 3：为把圆盘 1~i-1 从 mid 移动到 to。如果圆盘只有 1 个，直接把这个圆盘从 from 移动到 to 即可。</p>
<p>打印最优移动轨迹的方法参见如下代码中的 hanoi 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        func(n, <span class="string">&quot;left&quot;</span>, <span class="string">&quot;mid&quot;</span>, <span class="string">&quot;right&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> n, String from, String mid, String to)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;move from &quot;</span> + from + <span class="string">&quot; to &quot;</span> + to);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        func(n - <span class="number">1</span>, from, to, mid);</span><br><span class="line">        func(<span class="number">1</span>, from, mid, to);</span><br><span class="line">        func(n - <span class="number">1</span>, mid, from, to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进阶问题。首先求都在 from 柱子上的圆盘 1~i，如果都移动到 to 上的最少步骤数假设为 S(i)。根据上面的步骤，S(i)=步骤 1 的步骤总数+1+步骤 3 的步骤总数=S(i-1)+1+S(i-1)，S(1)=1。所以 S(i)+1=2(S(i-1)+1)，S(1)+1==2。根据等比数列求和公式得到 S(i)+1=2^i，所以 S(i)=2^i-1。</p>
<p>对于数组 arr 来说，arr[N-1]表示最大圆盘 N 在哪个柱子上，情况有以下三种。</p>
<ul>
<li>圆盘 N 在左柱上，说明步骤 1 或者没有完成，或者已经完成，需要考查圆盘 1~N-1 的状况。</li>
<li>圆盘 N 在右柱上，说明步骤 1 已经完成，起码走完了 2^(N-1)-1 步。步骤 2 也已经完成，起码又走完了 1 步，所以当前状况起码是最优步骤的 2^(N-1)步，剩下的步骤怎么确定还得继续考查圆盘 1~N-1 的状况。</li>
<li>圆盘 N 在中柱上，这是不可能的，最优步骤中不可能让圆盘 N 处在中柱上，直接返回-1。</li>
</ul>
<p>所以整个过程可以总结为：对圆盘 1~i 来说，如果目标为从 from 到 to，那么情况有三种：</p>
<ul>
<li>圆盘 i 在 from 上，需要继续考查圆盘 1~i-1 的状况，圆盘 1~i-1 的目标为从 from 到 mid。</li>
<li>圆盘 i 在 to 上，说明起码走完了 2^(i-1)步，剩下的步骤怎么确定还得继续考查圆盘 1~i-1 的状况，圆盘 1~i-1 的目标为从 mid 到 to。</li>
<li>圆盘 i 在 mid 上，直接返回-1。</li>
</ul>
<p>整个过程参看如下代码中的 step1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">step1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(arr, arr.length - <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> from, <span class="type">int</span> mid, <span class="type">int</span> to)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] != from &amp;&amp; arr[i] != to) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] == from) &#123;</span><br><span class="line">        <span class="keyword">return</span> process(arr, i - <span class="number">1</span>, from, to, mid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> process(arr, i - <span class="number">1</span>, mid, from, to);</span><br><span class="line">        <span class="keyword">if</span> (rest == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; i) + rest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>step1 方法是递归函数，递归最多调用 N 次，并且每步的递归函数再调用递归函数的次数最多一次。在每个递归过程中，除去递归调用的部分，剩下过程的时间复杂度为 O(1)，所以 step1 方法的时间复杂度为 O(N)。但是因为递归函数需要函数栈的关系，step1 方法的额外空间复杂度为 O(N)。所以为了达到题目的要求，需要将整个过程改成非递归的方法，具体请参看如下代码中的 step2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">step2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != from &amp;&amp; arr[i] != to) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == to) &#123;</span><br><span class="line">            res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            tmp = from;</span><br><span class="line">            from = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp = to;</span><br><span class="line">            to = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = tmp;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最长公共子序列问题"><a href="#最长公共子序列问题" class="headerlink" title="最长公共子序列问题"></a>最长公共子序列问题</h2><p><strong>题目</strong></p>
<p>给定两个字符串 str1 和 str2，返回两个字符串的最长公共子序列。</p>
<p><strong>举例</strong></p>
<p>str1=”1A2C3D4B56”，str2=”B1D23CA45B6A”。<br>“123456”或者”12C4B6”都是最长公共子序列，返回哪一个都行。</p>
<p><strong>解答</strong></p>
<p>本题是非常经典的动态规划问题，先来介绍求解动态规划表的过程。如果 str1 的长度为 M，str2 的长度为 N，生成大小为 MxN 的矩阵 dp，行数为 M，列数为 N。dp[i][j]的含义是 str1[0..i]与 str2[0..j]的最长公共子序列的长度。从左到右，再从上到下计算矩阵 dp。</p>
<ol>
<li>矩阵 dp 第一列即 dp[0..M-1][0]，dp[i][0]的含义是 str1[0..i]与 str2[0]的最长公共子序列长度。str2[0]只有一个字符，所以 dp[i][0]最大为 1。如果 str1[i]==str2[0]，令 dp[i][0]=1，一旦 dp[i][0]被设置为 1，之后的 dp[i+1..M-1][0]也都为 1。比如，str1[0..M-1]=”ABCDE”，str2[0]=”B”。str1[0]为”A”，与 str2[0]不相等，所以 dp[0][0]=0。str1[1]为”B”，与 str2[0]相等，所以 str1[0..1]与 str2[0]的最长公共子序列为”B”，令 dp[1][0]=1。之后的 dp[2..4][0]肯定都是 1，因为 str[0..2]、str[0..3]和 str[0..4]与 str2[0]的最长公共子序列肯定有”B”。</li>
<li>矩阵 dp 第一行即 dp[0][0..N-1]与步骤 1 同理，如果 str1[0]==str2[j]，则令 dp[0][j]=1，一旦 dp[0][j]被设置为 1，之后的 dp[0][j+1..N-1]也都为 1。</li>
<li>对其他位置(i,j)，dp[i][j]的值只可能来自以下三种情况。<ul>
<li>可能是 dp[i-1][j]，代表 str1[0..i-1]与 str2[0..j]的最长公共子序列长度。比如，str1=”A1BC2”，str2=”AB34C”。str1[0..3]（即”A1BC”）与 str2[0..4]（即”AB34C”）的最长公共子序列为”ABC”，即 dp[3][4]为 3。str1[0..4]（即”A1BC2”）与 str2[0..4]（即”AB34C”）的最长公共子序列也是”ABC”，所以 dp[4][4]也为 3。</li>
<li>可能是 dp[i][j-1]，代表 str1[0..i]与 str2[0..j-1]的最长公共子序列长度。比如，str1=”A1B2C”，str2=”AB3C4”。str1[0..4]（即”A1B2C”）与 str2[0..3]（即”AB3C”）的最长公共子序列为”ABC”，即 dp[4][3]为 3。str1[0..4]（即”A1B2C”）与 str2[0..4]（即”AB3C4”）的最长公共子序列也是”ABC”，所以 dp[4][4]也为 3。</li>
<li>如果 str1[i]==str2[j]，还可能是 dp[i-1][j-1]+1。比如 str1=”ABCD”，str2=”ABCD”。str1[0..2]（即”ABC”）与 str2[0..2]（即”ABC”）的最长公共子序列为”ABC”，即 dp[2][2]为 3。因为 str1[3]==str2[3]==”D”，所以 str1[0..3]与 str2[0..3]的最长公共子序列是”ABCD”。<br>这三个可能的值中，选最大的作为 dp[i][j]的值。具体过程请参看如下代码中的 getdp 方法。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] getdp(<span class="type">char</span>[] str1, <span class="type">char</span>[] str2) &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[str1.length][str2.length];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = str1[<span class="number">0</span>] == str2[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; str1.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], str1[i] == str2[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; str2.length; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = Math.max(dp[<span class="number">0</span>][j - <span class="number">1</span>], str1[<span class="number">0</span>] == str2[j] ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; str1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; str2.length; j++) &#123;</span><br><span class="line">            dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (str1[i] == str2[j]) &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dp 矩阵中最右下角的值代表 str1 整体和 str2 整体的最长公共子序列的长度。通过整个 dp 矩阵的状态，可以得到最长公共子序列。具体方法如下：</p>
<ol>
<li>从矩阵的右下角开始，有三种移动方式：向上、向左、向左上。假设移动的过程中，i 表示此时的行数，j 表示此时的列数，同时用一个变量 res 来表示最长公共子序列。</li>
<li>如果 dp[i][j]大于 dp[i-1][j]和 dp[i][j-1]，说明之前在计算 dp[i][j]的时候，一定是选择了决策 dp[i-1][j-1]+1，可以确定 str1[i]等于 str2[j]，并且这个字符一定属于最长公共子序列，把这个字符放进 res，然后向左上方移动。</li>
<li>如果 dp[i][j]等于 dp[i-1][j]，说明之前在计算 dp[i][j]的时候，dp[i-1][j-1]+1 这个决策不是必须选择的决策，向上方移动即可。</li>
<li>如果 dp[i][j]等于 dp[i][j-1]，与步骤 3 同理，向左方移动。</li>
<li>如果 dp[i][j]同时等于 dp[i-1][j]和 dp[i][j-1]，向上还是向下无所谓，选择其中一个即可，反正不会错过必须选择的字符。<br>也就是说，通过 dp 求解最长公共子序列的过程就是还原出当时如何求解 dp 的过程，来自哪个策略，就朝哪个方向移动。全部过程请参看如下代码中的 lcse 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">lcse</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str1 == <span class="literal">null</span> || str2 == <span class="literal">null</span> || str1.equals(<span class="string">&quot;&quot;</span>) || str2.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] chs1 = str1.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] chs2 = str2.toCharArray();</span><br><span class="line">    <span class="type">int</span>[][] dp = getdp(chs1, chs2);</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> chs1.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> chs2.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span>[] res = <span class="keyword">new</span> <span class="title class_">char</span>[dp[m][n]];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> res.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; dp[m][n] == dp[m][n - <span class="number">1</span>]) &#123;</span><br><span class="line">            n--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m &gt; <span class="number">0</span> &amp;&amp; dp[m][n] == dp[m - <span class="number">1</span>][n]) &#123;</span><br><span class="line">            m--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[index--] = chs1[m];</span><br><span class="line">            m--;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算 dp 矩阵中的某个位置就是简单比较相关的 3 个位置的值而已，所以时间复杂度为 O(1)，动态规划表 dp 的大小为 MxN，所以计算 dp 矩阵的时间复杂度为 O(MxN)。通过 dp 得到最长公共子序列的过程为 O(M+N)，因为向左最多移动 N 个位置，向上最多移动 M 个位置，所以总的时间复杂度为 O(MxN)，额外空间复杂度为 O(MxN)。如果题目不要求返回最长公共子序列，只想求最长公共子序列的长度，那么可以用空间压缩的方法将额外空间复杂度减小为 O(min{M,N})。有兴趣的读者请阅读本书“矩阵的最小路径和”问题，这里不再详述。</p>
<h2 id="最长公共子串问题"><a href="#最长公共子串问题" class="headerlink" title="最长公共子串问题"></a>最长公共子串问题</h2><p><strong>题目</strong></p>
<p>给定两个字符串 str1 和 str2，返回两个字符串的最长公共子串。</p>
<p><strong>举例</strong></p>
<p>str1=”1AB2345CD”，str2=”12345EF”，返回”2345”。</p>
<p><strong>要求</strong></p>
<p>如果 str1 长度为 M，str2 长度为 N，实现时间复杂度为 O(MxN)，额外空间复杂度为 O(1)的方法。</p>
<p><strong>解答</strong></p>
<p>经典动态规划的方法可以做到时间复杂度为 O(MxN)，额外空间复杂度为 O(MxN)，经过优化之后的实现可以把额外空间复杂度从 O(MxN)降至 O(1)，我们先来介绍经典方法。</p>
<p>首先需要生成动态规划表。生成大小为 MxN 的矩阵 dp，行数为 M，列数为 N。dp[i][j]的含义是，在必须把 str1[i]和 str2[j]当作公共子串最后一个字符的情况下，公共子串最长能有多长。比如，str1=”A1234B”，str2=”CD1234”，dp[3][4]的含义是在必须把 str1[3]（即’3’）和 str2[4]（即’3’）当作公共子串最后一个字符的情况下，公共子串最长能有多长。这种情况下的最长公共子串为”123”，所以 dp[3][4]为 3。再如，str1=”A12E4B”，str2=”CD12F4”，dp[3][4]的含义是在必须把 str1[3]（即’E’）和 str2[4]（即’F’）当作公共子串最后一个字符的情况下，公共子串最长能有多长。这种情况下，根本不能构成公共子串，所以 dp[3][4]为 0。介绍了 dp[i][j]的意义后，接下来介绍 dp[i][j]怎么求。具体过程如下：</p>
<ol>
<li>矩阵 dp 第一列即 dp[0..M-1][0]。对某一个位置(i,0)来说，如果 str1[i]==str2[0]，令 dp[i][0]=1，否则令 dp[i][0]=0。比如 str1=”ABAC”，str2[0]=”A”。dp 矩阵第一列上的值依次为 dp[0][0]=1, dp[1][0]=0, dp[2][0]=1, dp[3][0]=0。</li>
<li>矩阵 dp 第一行即 dp[0][0..N-1]与步骤 1 同理。对某一个位置(0,j)来说，如果 str1[0]==str2[j]，令 dp[0][j]=1，否则令 dp[0][j]=0。</li>
<li>其他位置按照从左到右，再从上到下来计算，dp[i][j]的值只可能有两种情况。<ul>
<li>如果 str1[i]!=str2[j]，说明在必须把 str1[i]和 str2[j]当作公共子串最后一个字符是不可能的，令 dp[i][j]=0。</li>
<li>如果 str1[i]==str2[j]，说明 str1[i]和 str2[j]可以作为公共子串的最后一个字符，从最后一个字符向前能扩多大的长度呢？就是 dp[i-1][j-1]的值，所以令 dp[i][j]=dp[i-1][j-1]+1。</li>
</ul>
</li>
</ol>
<p>如果 str1=”abcde”，str2=”bebcd”。计算的 dp 矩阵如下：<br>  b e b c d<br>a 0 0 0 0 0<br>b 1 0 1 0 0<br>c 0 0 0 2 0<br>d 0 0 0 0 3<br>e 0 1 0 0 0</p>
<p>计算 dp 矩阵的具体过程请参看如下代码中的 getdp 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] getdp(<span class="type">char</span>[] str1, <span class="type">char</span>[] str2) &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[str1.length][str2.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str1[i] == str2[<span class="number">0</span>]) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; str2.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str1[<span class="number">0</span>] == str2[j]) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; str1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; str2.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1[i] == str2[j]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成动态规划表 dp 之后，得到最长公共子串是非常容易的。比如，上边生成的 dp 中，最大值是 dp[3][4]==3，说明最长公共子串的长度为 3。最长公共子串的最后一个字符是 str1[3]，当然也是 str2[4]，因为两个字符一样。那么最长公共子串为从 str1[3]开始向左一共 3 字节的子串，即 str1[1..3]，当然也是 str2[2..4]。总之，遍历 dp 找到最大值及其位置，最长公共子串自然可以得到。具体过程请参看如下代码中的 lcst1 方法，也是整个过程的主方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">lcst1</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str1 == <span class="literal">null</span> || str2 == <span class="literal">null</span> || str1.equals(<span class="string">&quot;&quot;</span>) || str2.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] chs1 = str1.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] chs2 = str2.toCharArray();</span><br><span class="line">    <span class="type">int</span>[][] dp = getdp(chs1, chs2);</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chs1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; chs2.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i][j] &gt; max) &#123;</span><br><span class="line">                end = i;</span><br><span class="line">                max = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str1.substring(end - max + <span class="number">1</span>, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典动态规划的方法需要大小为 MxN 的 dp 矩阵，但实际上是可以减小至 O(1)的，因为我们注意到计算每一个 dp[i][j]的时候，最多只需要其左上方 dp[i-1][j-1]的值，所以按照斜线方向来计算所有的值，只需要一个变量就可以计算出所有位置的值。</p>
<p>每一条斜线在计算之前生成整型变量 len，len 表示左上方位置的值，初始时 len=0。从斜线最左上的位置开始向右下方依次计算每个位置的值，假设计算到位置(i,j)，此时 len 表示位置(i-1,j-1)的值。如果 str1[i]==str2[j]，那么位置(i,j)的值为 len+1，如果 str1[i]!=str2[j]，那么位置(i,j)的值为 0。计算后将 len 更新成位置(i,j)的值，然后计算下一个位置，即(i+1,j+1)位置的值。依次计算下去就可以得到斜线上每个位置的值，然后算下一条斜线。用全局变量 max 记录所有位置的值中的最大值。最大值出现时，用全局变量 end 记录其位置即可。具体过程请参看如下代码中的 lcst2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">lcst2</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str1 == <span class="literal">null</span> || str2 == <span class="literal">null</span> || str1.equals(<span class="string">&quot;&quot;</span>) || str2.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] chs1 = str1.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] chs2 = str2.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 斜线开始位置的行</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> chs2.length - <span class="number">1</span>; <span class="comment">// 斜线开始位置的列</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录最大长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 最大长度更新时，记录子串的结尾位置</span></span><br><span class="line">    <span class="keyword">while</span> (row &lt; chs1.length) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> col;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从(i,j)开始向右下方遍历</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; chs1.length &amp;&amp; j &lt; chs2.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chs1[i] != chs2[j]) &#123;</span><br><span class="line">                len = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录最大值，以及结束字符的位置</span></span><br><span class="line">            <span class="keyword">if</span> (len &gt; max) &#123;</span><br><span class="line">                end = i;</span><br><span class="line">                max = len;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (col &gt; <span class="number">0</span>) &#123; <span class="comment">// 斜线开始位置的列先向左移动</span></span><br><span class="line">            col--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 列移动到最左之后，行向下移动</span></span><br><span class="line">            row++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str1.substring(end - max + <span class="number">1</span>, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="子数组异或和为-0-的最多划分"><a href="#子数组异或和为-0-的最多划分" class="headerlink" title="子数组异或和为 0 的最多划分"></a>子数组异或和为 0 的最多划分</h2><p><strong>题目</strong></p>
<p>数组异或和的定义：把数组中所有的数异或起来得到的值。<br>给定一个整型数组 arr，其中可能有正、有负、有零。你可以随意把整个数组切成若干个不相容的子数组，求异或和为 0 的子数组最多能有多少个？</p>
<p><strong>举例</strong></p>
<p>arr={3,2,1,9,0,7,0,2,1,3}</p>
<p>把数组分割成{3,2,1}、{9}、{0}、{7}、{0}、{2,1,3}是最优分割，因为其中{3,2,1}、{0}、{0}、{2,1,3}这四个子数组的异或和为 0，并且是所有的分割方案中，能切出最多异或和为 0 的子数组的方案，返回 4。</p>
<p><strong>要求</strong></p>
<p>如果 arr 长度为 N，时间复杂度 O(N)。</p>
<p><strong>解答</strong></p>
<p>本题利用动态规划，假设 arr 长度为 N，生成长度为 N 的数组 dp[]。dp[i]的含义是如果在 arr[0..i]上做分割，异或和为 0 的子数组最多能有多少个。如果可以从左到右依次求出 dp[0]、dp[1]…dp[i-1]、dp[i]..dp[N-1]。那么 dp[N-1]的值就是：如果在 arr[0..N-1]上做分割，异或和为 0 的子数组最多能有多少个，也就是最终答案。</p>
<p>现在假设 dp[0]~dp[i-1]已经求出，如何求出 dp[i]就是最关键的问题。为了分析这个问题，我们假设 arr[0..i]上存在最优分割。显而易见的是，分割出来的最后一个子数组一定包含 arr[i]，那么这个最优分割的最后一个子数组只可能有如下两种情况。</p>
<ol>
<li>最优分割的最后一个子数组，异或和不等于 0。</li>
<li>最优分割的最后一个子数组，异或和等于 0。</li>
</ol>
<p>对于情况 1），如果最优分割的最后一个子数组异或和不等于 0，那么 dp[i]的值等于 dp[i-1]。可以这样来理解这个结论，既然在 arr[0..i]上做最优分割，并且切出来的异或和为 0 的子数组和 arr[i]没有关系，那么 arr[0..i-1]最多能切多少个，arr[0..i]上就能切多少个。</p>
<p>对于情况 2），如果最优分割的最后一个子数组异或和等于 0。假设 arr[k..i]就是最优分割的最后一个子数组，并且异或和等于 0，那么 dp[i]的值等于 dp[k-1]+1。可以这样理解这个结论，如果我们已经知道在 arr[0..i]上的最优分割，并且最后一个分割出的子数组是 arr[k..i]，也知道 arr[k..i]的异或和是 0。那么在 arr[0..i]上最多能分割出几个异或和为 0 的子数组呢？就是 arr[0..k-1]上最多能够分割出的数量(dp[k-1])，再加上 arr[k..i]这部分，就是答案，dp[i]=dp[k-1]+1。那么如何求出 k 这个位置，就变成了唯一需要关心的问题。</p>
<p>在 arr[0..i]上的最优分割中，如果最后一个子数组异或和等于 0，且 arr[k..i]就是最后一个子数组。那么 k 到 i 之间的任何一个位置 j (k&lt;j&lt;i)，都不可能有 arr[j..i]的异或和等于 0。这是因为，如果 arr[k..i]的异或和为 0，中间如果还存在一个 j 位置，使得 arr[j..i]==0，那么就可以推出 arr[k..j-1]的异或和也为 0。这样，arr[k..i]就可以分割出 arr[k..j-1]和 arr[j..i]两部分，那么岂不是比原来我们假设的最优分割更优？推出的结论与假设矛盾，所以 k 到 i 之间的任何一个位置 j (k&lt;j&lt;i)都不可能有 arr[j..i]的异或和等于 0。那我们就知道 k 位置怎么求了，在 i 位置的左边所有位置中，k 一定是离 i 最近且 arr[k..i]异或和为 0 的位置。对于其他的任何位置 j，如果也能让 arr[j..i]的异或和为 0，那么 j 位置离 i 位置的距离一定比 k 位置离 i 位置的距离远。问题得到了进一步转化，现在我们关心：如果来到 i 位置，怎么求离 i 位置最近的 k 位置，使得 arr[k..i]异或和为 0。</p>
<p>如果我们记下 arr[0..0]的异或和、arr[0..1]的异或和……arr[0..i-1]的异或和。现在来到 i 位置，并且 arr[0..i]的异或和为 eor，我们只要知道 eor 上一次出现在什么位置，也就求出了 k 位置。举个例子：</p>
<p>arr={6, 3, 2, 1}<br>位置：0 1 2 3</p>
<p>展示一下来到 i==3 位置时，怎么求 k 位置。<br>先准备一张表 map，key：某一个异或和；value：key 这个异或和上次出现的位置。<br>提前在 map 里放入一条记录(key=0, value=-1)，表示没遍历 arr 之前，就有 0 这个异或和。<br>遍历到 0 位置时，arr[0..0]的异或和为 6，把(6,0)这个记录放入 map。<br>此时 map 为：<br>(key=0, value=-1)<br>(key=6, value=0)</p>
<p>遍历到 1 位置时，arr[0..1]的异或和为 5，把(5,1)这个记录放入 map。<br>此时 map 为：<br>(key=0, value=-1)<br>(key=6, value=0)<br>(key=5, value=1)</p>
<p>遍历到 2 位置时，arr[0..2]的异或和为 7，把(7,2)这个记录放入 map。<br>此时 map 为：<br>(key=0, value=-1)<br>(key=6, value=0)<br>(key=5, value=1)<br>(key=7, value=2)</p>
<p>遍历到 3 位置时，arr[0..3]的异或和为 6。怎么求 k？在 map 中看异或和为 6 上次出现的位置，是 0 位置。所以知道 arr[1..3]就是 arr[k..i]，1 位置就是 k 位置。</p>
<p>情况 2）的分析结束。dp[i]=dp[k-1]+1，k 为在 i 位置左边，离 i 位置最近的使得 arr[k..i]的异或和为 0 的位置。</p>
<p>两种情况中哪一个值更大，哪一个就是 dp[i]的值，即 dp[i]=Max{dp[i-1], dp[k-1]+1}。<br>全部流程请看 mostEOR 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mostEOR</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">eor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = arr[<span class="number">0</span>] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    map.put(arr[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        eor ^= arr[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(eor)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">preEorIndex</span> <span class="operator">=</span> map.get(eor);</span><br><span class="line">            dp[i] = preEorIndex == -<span class="number">1</span> ? <span class="number">1</span> : (dp[preEorIndex] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i]);</span><br><span class="line">        map.put(eor, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小编辑代价"><a href="#最小编辑代价" class="headerlink" title="最小编辑代价"></a>最小编辑代价</h2><p><strong>题目</strong></p>
<p>给定两个字符串 str1 和 str2，再给定三个整数 ic、dc 和 rc，分别代表插入、删除和替换一个字符的代价，返回将 str1 编辑成 str2 的最小代价。</p>
<p><strong>举例</strong></p>
<p>str1=”abc”，str2=”adc”，ic=5，dc=3，rc=2。<br>从”abc”编辑成”adc”，把’b’替换成’d’是代价最小的，所以返回 2。<br>str1=”abc”，str2=”adc”，ic=5，dc=3，rc=100。<br>从”abc”编辑成”adc”，先删除’b’，然后插入’d’是代价最小的，所以返回 8。<br>str1=”abc”，str2=”abc”，ic=5，dc=3，rc=2。<br>不用编辑了，本来就是一样的字符串，所以返回 0。</p>
<p><strong>解答</strong></p>
<p>如果 str1 的长度为 M，str2 的长度为 N，经典动态规划的方法可以达到时间复杂度为 O(MxN)，额外空间复杂度为 O(MxN)。如果结合空间压缩的技巧，可以把额外空间复杂度减至 O(min{M,N})。</p>
<p>先来介绍经典动态规划的方法。首先生成大小为(M+1)x(N+1)的矩阵 dp，dp[i][j]的值代表 str1[0..i-1]编辑成 str2[0..j-1]的最小代价。举个例子，str1=”ab12cd3”，str2=”abcdf”，ic=5，dc=3，rc=2。dp 是一个 8x6 的矩阵，最终计算结果如下。<br>‘’ ‘a’ ‘b’ ‘c’ ‘d’ ‘f’<br>‘’ 0 5 10 15 20 25<br>‘a’ 3 0 5 10 15 20<br>‘b’ 6 3 0 5 10 15<br>‘1’ 9 6 3 2 7 12<br>‘2’ 12 9 6 5 4 9<br>‘c’ 15 12 9 6 7 6<br>‘d’ 18 15 12 9 6 9<br>‘3’ 21 18 15 12 9 8</p>
<p>下面具体说明 dp 矩阵每个位置的值是如何计算的。</p>
<ol>
<li>dp[0][0]=0，表示 str1 空的子串编辑成 str2 空的子串的代价为 0。</li>
<li>矩阵 dp 第一列即 dp[0..M-1][0]。dp[i][0]表示 str1[0..i-1]编辑成空串的最小代价，毫无疑问，是把 str1[0..i-1]所有的字符删除的代价，所以 dp[i][0]=dc*i。</li>
<li>矩阵 dp 第一行即 dp[0][0..N-1]。dp[0][j]表示空串编辑成 str2[0..j-1]的最小代价，毫无疑问，是在空串里插入 str2[0..j-1]所有字符的代价，所以 dp[0][j]=ic*j。</li>
<li>其他位置按照从左到右，再从上到下来计算，dp[i][j]的值只可能有以下四种情况。<ul>
<li>str1[0..i-1]可以先编辑成 str1[0..i-2]，也就是删除字符 str1[i-1]，然后由 str1[0..i-2]编辑成 str2[0..j-1]，dp[i-1][j]表示 str1[0..i-2]编辑成 str2[0..j-1]的最小代价，那么 dp[i][j]可能等于 dc+dp[i-1][j]。</li>
<li>str1[0..i-1]可以先编辑成 str2[0..j-2]，然后将 str2[0..j-2]插入字符 str2[j-1]，编辑成 str2[0..j-1]，dp[i][j-1]表示 str1[0..i-1]编辑成 str2[0..j-2]的最小代价，那么 dp[i][j]可能等于 dp[i][j-1]+ic。</li>
<li>如果 str1[i-1]!=str2[j-1]。先把 str1[0..i-1]中 str1[0..i-2]的部分变成 str2[0..j-2]，然后把字符 str1[i-1]替换成 str2[j-1]，这样 str1[0..i-1]就编辑成 str2[0..j-1]了。dp[i-1][j-1]表示 str1[0..i-2]编辑成 str2[0..j-2]的最小代价，那么 dp[i][j]可能等于 dp[i-1][j-1]+rc。</li>
<li>如果 str1[i-1]==str2[j-1]。先把 str1[0..i-1]中 str1[0..i-2]的部分变成 str2[0..j-2]，因为此时字符 str1[i-1]等于 str2[j-1]，所以 str1[0..i-1]已经编辑成 str2[0..j-1]了。dp[i-1][j-1]表示 str1[0..i-2]编辑成 str2[0..j-2]的最小代价，那么 dp[i][j]可能等于 dp[i-1][j-1]。</li>
</ul>
</li>
<li>以上四种可能的值中，选最小值作为 dp[i][j]的值。dp 最右下角的值就是最终结果。具体过程请参看如下代码中的 minCost1 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCost1</span><span class="params">(String str1, String str2, <span class="type">int</span> ic, <span class="type">int</span> dc, <span class="type">int</span> rc)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str1 == <span class="literal">null</span> || str2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] chs1 = str1.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] chs2 = str2.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> chs1.length + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> chs2.length + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[row][col];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dc * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = ic * j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chs1[i - <span class="number">1</span>] == chs2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + rc;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = Math.min(dp[i][j], dp[i][j - <span class="number">1</span>] + ic);</span><br><span class="line">            dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][j] + dc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典动态规划方法结合空间压缩的方法。空间压缩的原理请读者参考本书“矩阵的最小路径和”问题，这里不再详述。但是本题空间压缩的方法有一点特殊。在“矩阵的最小路径和”问题中，dp[i][j]依赖两个位置的值 dp[i-1][j]和 dp[i][j-1]，滚动数组从左到右更新是没有问题的，因为在求 dp[j]的时候，dp[j]没有更新之前相当于 dp[i-1][j]的值，dp[j-1]的值已经更新过，相当于 dp[i][j-1]的值。而本题 dp[i][j]依赖 dp[i-1][j]、dp[i][j-1]和 dp[i-1][j-1]的值，所以滚动数组从左到右更新时，还需要一个变量来保存 dp[j-1]没更新之前的值，也就是左上角的 dp[i-1][j-1]。</p>
<p>理解上述过程后，就不难发现该过程确实只用了一个 dp 数组，但 dp 长度等于 str2 的长度加 1（即 N+1），而不是 O(min{M,N})。所以还要把 str1 和 str2 中长度较短的一个作为列对应的字符串，长度较长的作为行对应的字符串。上面介绍的动态规划方法都是把 str2 作为列对应的字符串，如果 str1 做了列对应的字符串，把插入代价 ic 和删除代价 dc 交换一下即可。</p>
<p>具体过程请参看如下代码中的 minCost2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCost2</span><span class="params">(String str1, String str2, <span class="type">int</span> ic, <span class="type">int</span> dc, <span class="type">int</span> rc)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str1 == <span class="literal">null</span> || str2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] chs1 = str1.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] chs2 = str2.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] longs = chs1.length &gt;= chs2.length ? chs1 : chs2;</span><br><span class="line">    <span class="type">char</span>[] shorts = chs1.length &lt; chs2.length ? chs1 : chs2;</span><br><span class="line">    <span class="keyword">if</span> (chs1.length &lt; chs2.length) &#123; <span class="comment">// str2 较长就交换 ic 和 dc 的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ic;</span><br><span class="line">        ic = dc;</span><br><span class="line">        dc = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[shorts.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= shorts.length; i++) &#123;</span><br><span class="line">        dp[i] = ic * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= longs.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> dp[<span class="number">0</span>]; <span class="comment">// pre 表示左上角的值</span></span><br><span class="line">        dp[<span class="number">0</span>] = dc * i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= shorts.length; j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> dp[j]; <span class="comment">// dp[j]没更新前先保存下来</span></span><br><span class="line">            <span class="keyword">if</span> (longs[i - <span class="number">1</span>] == shorts[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[j] = pre;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = pre + rc;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[j] = Math.min(dp[j], dp[j - <span class="number">1</span>] + ic);</span><br><span class="line">            dp[j] = Math.min(dp[j], tmp + dc);</span><br><span class="line">            pre = tmp; <span class="comment">// pre 变成 dp[j]没更新前的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[shorts.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串的交错组成"><a href="#字符串的交错组成" class="headerlink" title="字符串的交错组成"></a>字符串的交错组成</h2><p><strong>题目</strong></p>
<p>给定三个字符串 str1、str2 和 aim，如果 aim 包含且仅包含来自 str1 和 str2 的所有字符，而且在 aim 中属于 str1 的字符之间保持原来在 str1 中的顺序，属于 str2 的字符之间保持原来在 str2 中的顺序，那么称 aim 是 str1 和 str2 的交错组成。实现一个函数，判断 aim 是否是 str1 和 str2 交错组成。</p>
<p><strong>举例</strong></p>
<p>str1=”AB”，str2=”12”。那么”AB12”、”A1B2”、”A12B”、”1A2B”和”1AB2”等都是 str1 和 str2 的交错组成。</p>
<p><strong>解答</strong></p>
<p>如果 str1 的长度为 M，str2 的长度为 N，经典动态规划的方法可以达到时间复杂度为 O(MxN)，额外空间复杂度为 O(MxN)。如果结合空间压缩的技巧，可以把额外空间复杂度减至 O(min{M,N})。</p>
<p>先来介绍经典动态规划的方法。首先，aim 如果是 str1 和 str2 的交错组成，aim 的长度一定是 M+N，否则直接返回 false。然后生成大小为(M+1)x(N+1)布尔类型的矩阵 dp，dp[i][j]的值代表 aim[0..i+j-1]能否被 str1[0..i-1]和 str2[0..j-1]交错组成。计算 dp 矩阵的时候，是从左到右，再从上到下计算的，dp[M][N]也就是 dp 矩阵中最右下角的值，表示 aim 整体能否被 str1 整体和 str2 整体交错组成，也就是最终结果。下面具体说明 dp 矩阵每个位置的值是如何计算的。</p>
<ol>
<li>dp[0][0]=true。aim 为空串时，当然可以被 str1 为空串和 str2 为空串交错组成。</li>
<li>矩阵 dp 第一列即 dp[0..M-1][0]。dp[i][0]表示 aim[0..i-1]能否只被 str1[0..i-1]交错组成。如果 aim[0..i-1]等于 str1[0..i-1]，则令 dp[i][0]=true，否则令 dp[i][0]=false。</li>
<li>矩阵 dp 第一行即 dp[0][0..N-1]。dp[0][j]表示 aim[0..j-1]能否只被 str2[0..j-1]交错组成。如果 aim[0..j-1]等于 str1[0..j-1]，则令 dp[0][j]=true，否则令 dp[0][j]=false。</li>
<li>对其他位置(i,j)，dp[i][j]的值由下面的情况决定。<ul>
<li>dp[i-1][j]代表 aim[0..i+j-2]能否被 str1[0..i-2]和 str2[0..j-1]交错组成，如果可以，那么如果再有 str1[i-1]等于 aim[i+j-1]，说明 str1[i-1]又可以作为交错组成 aim[0..i+j-1]的最后一个字符。令 dp[i][j]=true。</li>
<li>dp[i][j-1]代表 aim[0..i+j-2]能否被 str1[0..i-1]和 str2[0..j-2]交错组成，如果可以，那么如果再有 str2[j-1]等于 aim[i+j-1]，说明 str1[j-1]又可以作为交错组成 aim[0..i+j-1]的最后一个字符。令 dp[i][j]=true。</li>
<li>如果第 1 种情况和第 2 种情况都不满足，令 dp[i][j]=false。</li>
</ul>
</li>
</ol>
<p>具体过程请参看如下代码中的 isCross1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCross1</span><span class="params">(String str1, String str2, String aim)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str1 == <span class="literal">null</span> || str2 == <span class="literal">null</span> || aim == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] ch1 = str1.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] ch2 = str2.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] chaim = aim.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (chaim.length != ch1.length + ch2.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[ch1.length + <span class="number">1</span>][ch2.length + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= ch1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch1[i - <span class="number">1</span>] != chaim[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= ch2.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch2[j - <span class="number">1</span>] != chaim[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= ch1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= ch2.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ch1[i - <span class="number">1</span>] == chaim[i + j - <span class="number">1</span>] &amp;&amp; dp[i - <span class="number">1</span>][j])</span><br><span class="line">                    || (ch2[j - <span class="number">1</span>] == chaim[i + j - <span class="number">1</span>] &amp;&amp; dp[i][j - <span class="number">1</span>])) &#123;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[ch1.length][ch2.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典动态规划方法结合空间压缩的方法。空间压缩的原理请读者参考本书“矩阵的最小路径和”问题，这里不再详述。实际进行空间压缩的时候，比较 str1 和 str2 中哪个长度较小，长度较小的那个作为列对应的字符串，然后生成和较短字符串长度一样的一维数组 dp，滚动更新即可。</p>
<p>具体请参看如下代码中的 isCross2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCross2</span><span class="params">(String str1, String str2, String aim)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str1 == <span class="literal">null</span> || str2 == <span class="literal">null</span> || aim == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] ch1 = str1.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] ch2 = str2.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] chaim = aim.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (chaim.length != ch1.length + ch2.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] longs = ch1.length &gt;= ch2.length ? ch1 : ch2;</span><br><span class="line">    <span class="type">char</span>[] shorts = ch1.length &lt; ch2.length ? ch1 : ch2;</span><br><span class="line">    <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[shorts.length + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= shorts.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shorts[i - <span class="number">1</span>] != chaim[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= longs.length; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">0</span>] &amp;&amp; longs[i - <span class="number">1</span>] == chaim[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= shorts.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((longs[i - <span class="number">1</span>] == chaim[i + j - <span class="number">1</span>] &amp;&amp; dp[j])</span><br><span class="line">                    || (shorts[j - <span class="number">1</span>] == chaim[i + j - <span class="number">1</span>] &amp;&amp; dp[j - <span class="number">1</span>])) &#123;</span><br><span class="line">                dp[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[shorts.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="龙与地下城游戏问题"><a href="#龙与地下城游戏问题" class="headerlink" title="龙与地下城游戏问题"></a>龙与地下城游戏问题</h2><p><strong>题目</strong></p>
<p>给定一个二维数组 map，含义是一张地图，例如，如下矩阵：<br>-2 -3 3<br>-5 -10 1<br>0 30 -5<br>游戏的规则如下：</p>
<ul>
<li>骑士从左上角出发，每次只能向右或向下走，最后到达右下角见到公主。</li>
<li>地图中每个位置的值代表骑士要遭遇的事情。如果是负数，说明此处有怪兽，要让骑士损失血量。如果是非负数，代表此处有血瓶，能让骑士回血。</li>
<li>骑士从左上角到右下角的过程中，走到任何一个位置时，血量都不能少于 1。<br>为了保证骑士能见到公主，初始血量至少是多少？根据 map，返回初始血量。</li>
</ul>
<p><strong>解答</strong></p>
<p>先介绍经典动态规划的方法，定义和地图大小一样的矩阵，记为 dp，dp[i][j]的含义是如果骑士要走上位置(i,j)，并且从该位置选一条最优的路径，最后走到右下角，骑士起码应该具备的血量。根据 dp 的定义，我们最终需要的是 dp[0][0]的结果。以题目的例子来说，map[2][2]的值为-5，所以骑士若要走上这个位置，需要 6 点血才能让自己不死。同时位置(2,2)已经是右下角的位置，即没有后续的路径，所以 dp[2][2]==6。<br>那么 dp[i][j]的值应该怎么计算呢？<br>骑士还要面临向下还是向右的选择，dp[i][j+1]是骑士选择当前向右走并最终达到右下角的血量要求。同理，dp[i+1][j]是向下走的要求。如果骑士决定向右走，那么骑士在当前位置加完血或者扣完血之后的血量只要等于 dp[i][j+1]即可。骑士在加血或扣血之前的血量要求（也就是在没有踏上(i,j)位置之前的血量要求），就是 dp[i][j+1]-map[i][j]。同时，骑士血量要随时不少于 1，所以向右的要求为 max{dp[i][j+1]-map[i][j], 1}。如果骑士决定向下走，分析方式相同，向下的要求为 max{dp[i+1][j]-map[i][j], 1}。<br>骑士可以有两种选择，当然要选最优的一条，所以 dp[i][j]=min{向右的要求, 向下的要求}。<br>计算 dp 矩阵时从右下角开始计算，选择依次从右至左，再从下到上的计算方式即可。<br>具体请参看如下代码中的 minHP1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minHP1</span><span class="params">(<span class="type">int</span>[][] m)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">null</span> || m.length == <span class="number">0</span> || m[<span class="number">0</span>] == <span class="literal">null</span> || m[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> m.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> m[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[row][col];</span><br><span class="line">    row--;</span><br><span class="line">    col--;</span><br><span class="line">    dp[row][col] = m[row][col] &gt; <span class="number">0</span> ? <span class="number">1</span> : -m[row][col] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> col - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        dp[row][j] = Math.max(dp[row][j + <span class="number">1</span>] - m[row][j], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">down</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i][col] = Math.max(dp[i + <span class="number">1</span>][col] - m[i][col], <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> col - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            right = Math.max(dp[i][j + <span class="number">1</span>] - m[i][j], <span class="number">1</span>);</span><br><span class="line">            down = Math.max(dp[i + <span class="number">1</span>][j] - m[i][j], <span class="number">1</span>);</span><br><span class="line">            dp[i][j] = Math.min(right, down);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 map 大小为 MxN，经典动态规划方法的时间复杂度为 O(MxN)，额外空间复杂度为 O(MxN)。结合空间压缩之后可以将额外空间复杂度降至 O(min{M,N})。空间压缩的原理请读者参考本书“矩阵的最小路径和”问题，这里不再详述。请参看如下代码中的 minHP2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minHP2</span><span class="params">(<span class="type">int</span>[][] m)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">null</span> || m.length == <span class="number">0</span> || m[<span class="number">0</span>] == <span class="literal">null</span> || m[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> Math.max(m.length, m[<span class="number">0</span>].length);</span><br><span class="line">    <span class="type">int</span> <span class="variable">less</span> <span class="operator">=</span> Math.min(m.length, m[<span class="number">0</span>].length);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">rowmore</span> <span class="operator">=</span> more == m.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[less];</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> m[m.length - <span class="number">1</span>][m[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">    dp[less - <span class="number">1</span>] = tmp &gt; <span class="number">0</span> ? <span class="number">1</span> : -tmp + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> less - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        row = rowmore ? more - <span class="number">1</span> : j;</span><br><span class="line">        col = rowmore ? j : more - <span class="number">1</span>;</span><br><span class="line">        dp[j] = Math.max(dp[j + <span class="number">1</span>] - m[row][col], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">choosen1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">choosen2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> more - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        row = rowmore ? i : less - <span class="number">1</span>;</span><br><span class="line">        col = rowmore ? less - <span class="number">1</span> : i;</span><br><span class="line">        dp[less - <span class="number">1</span>] = Math.max(dp[less - <span class="number">1</span>] - m[row][col], <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> less - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            row = rowmore ? i : j;</span><br><span class="line">            col = rowmore ? j : i;</span><br><span class="line">            choosen1 = Math.max(dp[j] - m[row][col], <span class="number">1</span>);</span><br><span class="line">            choosen2 = Math.max(dp[j + <span class="number">1</span>] - m[row][col], <span class="number">1</span>);</span><br><span class="line">            dp[j] = Math.min(choosen1, choosen2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数字字符串转换为字母组合的种数"><a href="#数字字符串转换为字母组合的种数" class="headerlink" title="数字字符串转换为字母组合的种数"></a>数字字符串转换为字母组合的种数</h2><p><strong>题目</strong></p>
<p>给定一个字符串 str，str 全部由数字字符组成，如果 str 中某一个或某相邻两个字符组成的子串值在 1~26 之间，则这个子串可以转换为一个字母。规定”1”转换为”A”，”2”转换为”B”，”3”转换为”C”……”26”转换为”Z”。写一个函数，求 str 有多少种不同的转换结果，并返回种数。</p>
<p><strong>举例</strong></p>
<p>str=”1111”。<br>能转换出的结果有”AAAA”、”LAA”、”ALA”、”AAL”和”LL”，返回 5。<br>str=”01”。<br>“0”没有对应的字母，而”01”根据规定不可转换，返回 0。<br>str=”10”。<br>能转换出的结果是”J”，返回 1。</p>
<p><strong>解答</strong></p>
<p>暴力递归的方法。假设 str 的长度为 N，先定义递归函数 p(i)(0&lt;=i&lt;=N)。p(i)的含义是 str[0..i-1]已经转换完毕，而 str[i..N-1]还没转换的情况下，最终合法的转换种数有多少并返回。特别指出，p(N)表示 str[0..N-1]（也就是 str 的整体）都已经转换完，没有后续的字符了，那么合法的转换种数为 1，即 p(N)=1。比如，str=”111123”，p(4)表示 str[0..3]（即”1111”）已经转换完毕，具体结果是什么不重要，反正已经转换完毕并且不可变，没转换的部分是 str[4..5]（即”23”），可转换的只有两种，即”BC”或”W”，所以 p(4)=2。p(6)表示 str 整体已经转换完毕，所以 p(6)=1。那么 p(i)如何计算呢？只有以下四种情况。</p>
<ul>
<li>如果 i==N。根据上文对 p(N)=1 的解释，直接返回 1。</li>
<li>如果不满足情况 1，又有 str[i]==’0’。str[0..i-1]已经转换完毕，而 str[i..N-1]此时又以’0’开头，str[i..N-1]无论怎样都不可能合法转换，所以直接返回 0。</li>
<li>如果不满足情况 1 和情况 2，说明 str[i]属于’1’~’9’，str[i]可以转换为’A’~’I’，那么 p(i)的值一定包含 p(i+1)的值，即 p(i)=p(i+1)。</li>
<li>如果不满足情况 1 和情况 2，说明 str[i]属于’1’~’9’，如果又有 str[i..i+1]在”10”~”26”之间，str[i..i+1]可以转换为’J’~’Z’，那么 p(i)的值一定也包含 p(i+2)的值，即 p(i)+=p(i+2)。</li>
</ul>
<p>具体过程请参看如下代码中的 num1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">num1</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span> || str.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] chs = str.toCharArray();</span><br><span class="line">    <span class="keyword">return</span> process(chs, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">char</span>[] chs, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == chs.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (chs[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> process(chs, i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; chs.length &amp;&amp; (chs[i] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + chs[i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> &lt; <span class="number">27</span>) &#123;</span><br><span class="line">        res += process(chs, i + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上过程中，p(i)最多可能会有两个递归分支 p(i+1)和 p(i+2)，一共有 N 层递归，所以时间复杂度为 O(2^N)，额外空间复杂度就是递归使用的函数栈的大小，为 O(N)。但是研究一下递归函数 p 就会发现，p(i)最多依赖 p(i+1)和 p(i+2)的值，这是可以从后往前进行顺序计算的，也就是先计算 p(N)和 p(N-1)，然后根据这两个值计算 p(N-2)，再根据 p(N-1)和 p(N-2)计算 p(N-3)，最后根据 p(1)和 p(2)计算出 p(0)即可。类似斐波那契数列的求解过程，只不过斐波那契数列是从前往后计算的，这里是从后往前计算而已。具体过程请参看如下代码中的 num2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">num2</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span> || str.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] chs = str.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> chs[chs.length - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> chs.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chs[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            next = cur;</span><br><span class="line">            cur = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp = cur;</span><br><span class="line">            <span class="keyword">if</span> ((chs[i] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + chs[i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> &lt; <span class="number">27</span>) &#123;</span><br><span class="line">                cur += next;</span><br><span class="line">            &#125;</span><br><span class="line">            next = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为是顺序计算，所以 num2 方法的时间复杂度为 O(N)，同时只用了 cur、next 和 tmp 进行滚动更新，所以额外空间复杂度为 O(1)。但是本题并不能像斐波那契数列问题那样用矩阵乘法的优化方法将时间复杂度优化到 O(logN)，这是因为斐波那契数列是严格的 f(i)=f(i-1)+f(i-2)，但是本题并不严格，str[i]的具体情况决定了 p(i)是等于 0 还是等于 p(i+1)或 p(i+1)+p(i+2)。有状态转移的表达式不可以用矩阵乘法将时间复杂度优化到 O(logN)。但如果 str 只由字符’1’和字符’2’组成，比如”12121121212122”，那么就可以使用矩阵乘法的方法将时间复杂度优化为 O(logN)。因为 str[i]都可以单独转换成字母，str[i..i+1]也都可以一起转换成字母，此时一定有 p(i)=p(i+1)+p(i+2)。总之，可以使用矩阵乘法的前提是递归表达式不会发生转移。</p>
<h2 id="表达式得到期望结果的组成种数"><a href="#表达式得到期望结果的组成种数" class="headerlink" title="表达式得到期望结果的组成种数"></a>表达式得到期望结果的组成种数</h2><p><strong>题目</strong></p>
<p>给定一个只由 0（假）、1（真）、&amp;（逻辑与）、|（逻辑或）和^（异或）五种字符组成的字符串 express，再给定一个布尔值 desired。返回 express 能有多少种组合方式，可以达到 desired 的结果。</p>
<p><strong>举例</strong></p>
<p>express=”1^0|0|1”，desired=false。<br>只有 1^((0|0)|1)和 1^(0|(0|1))的组合可以得到 false，返回 2。<br>express=”1”，desired=false。<br>无组合则可以得到 false，返回 0。</p>
<p><strong>解答</strong></p>
<p>首先应该判断 express 是否符合题目要求，比如”1^”和”10”，都不是有效的表达式。总结起来有以下三个判断标准：</p>
<ul>
<li>表达式的长度必须是奇数。</li>
<li>表达式下标为偶数位置的字符一定是’0’或者’1’。</li>
<li>表达式下标为奇数位置的字符一定是’&amp;’、’|’或’^’。<br>只要符合上述三个标准，表达式必然是有效的。具体参看如下代码中的 isValid 方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[] exp)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((exp.length &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; exp.length; i = i + <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((exp[i] != <span class="string">&#x27;1&#x27;</span>) &amp;&amp; (exp[i] != <span class="string">&#x27;0&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; exp.length; i = i + <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((exp[i] != <span class="string">&#x27;&amp;&#x27;</span>) &amp;&amp; (exp[i] != <span class="string">&#x27;|&#x27;</span>) &amp;&amp; (exp[i] != <span class="string">&#x27;^&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暴力递归方法。在判断 express 符合标准之后，将 express 划分成左右两部分，求出各种划分的情况下，能得到 desired 的种数是多少。以本题的例子进行举例说明，express 为”1^0|0|1”，desired 为 false，总的种数求法如下：</p>
<ul>
<li>第 1 个划分为’^’，左部分为”1”，右部分为”0|0|1”，因为当前划分的逻辑符号为^，所以要想在此划分下得到 false，包含的可能性有两种：左部分为真，右部分为真；左部分为假，右部分为假。<br>结果 1 = 左部分为真的种数 × 右部分为真的种数 + 左部分为假的种数 × 右部分为假的种数。</li>
<li>第 2 个划分为’|’，左部分为”1^0”，右部分为”0|1”，因为当前划分的逻辑符号为|，所以要想在此划分下得到 false，包含的可能性只有一种，即左部分为假，右部分为假。<br>结果 2 = 左部分为假的种数 × 右部分为假的种数。</li>
<li>第 3 个划分为’|’，左部分为”1^0|0”，右部分为”1”，因为当前划分的逻辑符号为|，所以结果 3 = 左部分为假的种数 × 右部分为假的种数。</li>
<li>结果 1+结果 2+结果 3 就是总的种数。也就是说，一个字符串中有几个逻辑符号，就有多少种划分，把每种划分能够得到最终 desired 值的种数全加起来，就是总的种数。</li>
</ul>
<p>现在系统地总结一下划分符号和 desired 的情况。<br>① 划分符号为^，desired 为 true 的情况下：<br>种数 = 左部分为真的种数 × 右部分为假的种数 + 左部分为假的种数 × 右部分为真的种数。<br>② 划分符号为^，desired 为 false 的情况下：<br>种数 = 左部分为真的种数 × 右部分为真的种数 + 左部分为假的种数 × 右部分为假的种数。<br>③ 划分符号为&amp;，desired 为 true 的情况下：<br>种数 = 左部分为真的种数 × 右部分为真的种数。<br>④ 划分符号为&amp;，desired 为 false 的情况下：<br>种数 = 左部分为真的种数 × 右部分为假的种数 + 左部分为假的种数 × 右部分为真的种数 + 左部分为假的种数 × 右部分为假的种数。<br>⑤ 划分符号为|，desired 为 true 的情况下：<br>种数 = 左部分为真的种数 × 右部分为假的种数 + 左部分为假的种数 × 右部分为真的种数 + 左部分为真的种数 × 右部分为真的种数。<br>⑥ 划分符号为|，desired 为 false 的情况下：<br>种数 = 左部分为假的种数 × 右部分为假的种数。</p>
<p>根据如上总结，以 express 中的每一个逻辑符号来划分 express，每种划分都求出各自的种数，再把种数累加起来，就是 express 达到 desired 总的种数。每次划分出的左右两部分递归求解即可。具体过程请参看如下代码中的 num1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">num1</span><span class="params">(String express, <span class="type">boolean</span> desired)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (express == <span class="literal">null</span> || express.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] exp = express.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (!isValid(exp)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p(exp, desired, <span class="number">0</span>, exp.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">p</span><span class="params">(<span class="type">char</span>[] exp, <span class="type">boolean</span> desired, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exp[l] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> desired ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> desired ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (desired) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l + <span class="number">1</span>; i &lt; r; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (exp[i]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">                    res += p(exp, <span class="literal">true</span>, l, i - <span class="number">1</span>) * p(exp, <span class="literal">true</span>, i + <span class="number">1</span>, r);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:</span><br><span class="line">                    res += p(exp, <span class="literal">true</span>, l, i - <span class="number">1</span>) * p(exp, <span class="literal">false</span>, i + <span class="number">1</span>, r);</span><br><span class="line">                    res += p(exp, <span class="literal">false</span>, l, i - <span class="number">1</span>) * p(exp, <span class="literal">true</span>, i + <span class="number">1</span>, r);</span><br><span class="line">                    res += p(exp, <span class="literal">true</span>, l, i - <span class="number">1</span>) * p(exp, <span class="literal">true</span>, i + <span class="number">1</span>, r);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">                    res += p(exp, <span class="literal">true</span>, l, i - <span class="number">1</span>) * p(exp, <span class="literal">false</span>, i + <span class="number">1</span>, r);</span><br><span class="line">                    res += p(exp, <span class="literal">false</span>, l, i - <span class="number">1</span>) * p(exp, <span class="literal">true</span>, i + <span class="number">1</span>, r);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l + <span class="number">1</span>; i &lt; r; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (exp[i]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">                    res += p(exp, <span class="literal">false</span>, l, i - <span class="number">1</span>) * p(exp, <span class="literal">true</span>, i + <span class="number">1</span>, r);</span><br><span class="line">                    res += p(exp, <span class="literal">true</span>, l, i - <span class="number">1</span>) * p(exp, <span class="literal">false</span>, i + <span class="number">1</span>, r);</span><br><span class="line">                    res += p(exp, <span class="literal">false</span>, l, i - <span class="number">1</span>) * p(exp, <span class="literal">false</span>, i + <span class="number">1</span>, r);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:</span><br><span class="line">                    res += p(exp, <span class="literal">false</span>, l, i - <span class="number">1</span>) * p(exp, <span class="literal">false</span>, i + <span class="number">1</span>, r);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">                    res += p(exp, <span class="literal">true</span>, l, i - <span class="number">1</span>) * p(exp, <span class="literal">true</span>, i + <span class="number">1</span>, r);</span><br><span class="line">                    res += p(exp, <span class="literal">false</span>, l, i - <span class="number">1</span>) * p(exp, <span class="literal">false</span>, i + <span class="number">1</span>, r);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个长度为 N 的 express，假设计算 express[i..j]的过程记为 p(i,j)，那么计算 p(0,N-1)需要计算 p(0,0)与 p(1,N-1)、p(0,1)与 p(2,N-1)…p(0,i)与 p(i+1,N-1)…p(0,N-2)与 p(N-1,N-1)，起码 2N 种状态。对每一组 p(0,i)与 p(i+1,N-1)来说，两者相加的划分种数又是 N-1 种，所以起码要计算 2(N-1)种状态。所以用 num1 方法来计算一个长度为 N 的 express，总的时间复杂度为 O(N!)，额外空间复杂度为 O(N)，因为函数栈的大小为 N。之所以用暴力递归方法的时间复杂度这么高，是因为每一种状态计算过后没有保存下来，导致重复计算的大量发生。</p>
<p>动态规划的方法。如果 express 长度为 N，生成两个大小为 NxN 的矩阵 t 和 f，t[j][i]表示 express[j..i]组成 true 的种数，f[j][i]表示 express[j..i]组成 false 的种数。t[j][i]和 f[j][i]的计算方式还是枚举 express[j..i]上的每种划分。具体过程请参看如下代码中的 num2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">num2</span><span class="params">(String express, <span class="type">boolean</span> desired)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (express == <span class="literal">null</span> || express.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] exp = express.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (!isValid(exp)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] t = <span class="keyword">new</span> <span class="title class_">int</span>[exp.length][exp.length];</span><br><span class="line">    <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[exp.length][exp.length];</span><br><span class="line">    t[<span class="number">0</span>][<span class="number">0</span>] = exp[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = exp[<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; exp.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">        t[i][i] = exp[i] == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        f[i][i] = exp[i] == <span class="string">&#x27;1&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j -= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j; k &lt; i; k += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exp[k + <span class="number">1</span>] == <span class="string">&#x27;&amp;&#x27;</span>) &#123;</span><br><span class="line">                    t[j][i] += t[j][k] * t[k + <span class="number">2</span>][i];</span><br><span class="line">                    f[j][i] += (f[j][k] + t[j][k]) * f[k + <span class="number">2</span>][i] + f[j][k] * t[k + <span class="number">2</span>][i];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exp[k + <span class="number">1</span>] == <span class="string">&#x27;|&#x27;</span>) &#123;</span><br><span class="line">                    t[j][i] += (f[j][k] + t[j][k]) * t[k + <span class="number">2</span>][i] + t[j][k] * f[k + <span class="number">2</span>][i];</span><br><span class="line">                    f[j][i] += f[j][k] * f[k + <span class="number">2</span>][i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    t[j][i] += f[j][k] * t[k + <span class="number">2</span>][i] + t[j][k] * f[k + <span class="number">2</span>][i];</span><br><span class="line">                    f[j][i] += f[j][k] * f[k + <span class="number">2</span>][i] + t[j][k] * t[k + <span class="number">2</span>][i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> desired ? t[<span class="number">0</span>][t.length - <span class="number">1</span>] : f[<span class="number">0</span>][f.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>矩阵 t 和 f 的大小为 NxN，每个位置在计算的时候都有枚举的过程，所以动态规划方法的时间复杂度为 O(N^3)，额外空间复杂度为 O(N^2)。</p>
<h2 id="排成一条线的纸牌博弈问题"><a href="#排成一条线的纸牌博弈问题" class="headerlink" title="排成一条线的纸牌博弈问题"></a>排成一条线的纸牌博弈问题</h2><p><strong>题目</strong></p>
<p>给定一个整型数组 arr，代表数值不同的纸牌排成一条线。玩家 A 和玩家 B 依次拿走每张纸牌，规定玩家 A 先拿，玩家 B 后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家 A 和玩家 B 都绝顶聪明。请返回最后获胜者的分数。</p>
<p><strong>举例</strong></p>
<p>arr=[1,2,100,4]。<br>开始时，玩家 A 只能拿走 1 或 4。如果玩家 A 拿走 1，则排列变为[2,100,4]，接下来玩家 B 可以拿走 2 或 4，然后继续轮到玩家 A。如果开始时玩家 A 拿走 4，则排列变为[1,2,100]，接下来玩家 B 可以拿走 1 或 100，然后继续轮到玩家 A。玩家 A 作为绝顶聪明的人不会先拿 4，因为拿 4 之后，玩家 B 将拿走 100。所以玩家 A 会先拿 1，让排列变为[2,100,4]，接下来玩家 B 不管怎么选，100 都会被玩家 A 拿走。玩家 A 会获胜，分数为 101。所以返回 101。<br>arr=[1,100,2]。<br>开始时，玩家 A 不管拿 1 还是 2，玩家 B 作为绝顶聪明的人，都会把 100 拿走。玩家 B 会获胜，分数为 100。所以返回 100。</p>
<p><strong>解答</strong></p>
<p>暴力递归的方法。定义递归函数 f(i,j)，表示如果 arr[i..j]这个排列上的纸牌被绝顶聪明的人先拿，最终能获得什么分数。定义递归函数 s(i,j)，表示如果 arr[i..j]这个排列上的纸牌被绝顶聪明的人后拿，最终能获得什么分数。<br>首先分析 f(i,j)，具体过程如下：</p>
<ol>
<li>如果 i==j（即 arr[i..j]）上只剩一张纸牌。当然会被先拿纸牌的人拿走，所以返回 arr[i]。</li>
<li>如果 i!=j。当前拿纸牌的人有两种选择，要么拿走 arr[i]，要么拿走 arr[j]。如果拿走 arr[i]，那么排列将剩下 arr[i+1..j]。对当前的玩家来说，面对 arr[i+1..j]排列的纸牌，他成了后拿的人，所以后续他能获得的分数为 s(i+1,j)。如果拿走 arr[j]，那么排列将剩下 arr[i..j-1]。对当前的玩家来说，面对 arr[i..j-1]排列的纸牌，他成了后拿的人，所以后续他能获得的分数为 s(i,j-1)。作为绝顶聪明的人，必然会在两种决策中选最优的。所以返回 max{arr[i]+s(i+1,j), arr[j]+s(i,j-1)}。</li>
</ol>
<p>然后分析 s(i,j)，具体过程如下：</p>
<ol>
<li>如果 i==j（即 arr[i..j]）上只剩一张纸牌。作为后拿纸牌的人必然什么也得不到，返回 0。</li>
<li>如果 i!=j。根据函数 s 的定义，玩家的对手会先拿纸牌。对手要么拿走 arr[i]，要么拿走 arr[j]。如果对手拿走 arr[i]，那么排列将剩下 arr[i+1..j]，然后轮到玩家先拿。如果对手拿走 arr[j]，那么排列将剩下 arr[i..j-1]，然后轮到玩家先拿。对手也是绝顶聪明的人，必然会把最差的情况留给玩家。所以返回 min{f(i+1,j), f(i,j-1)}。</li>
</ol>
<p>具体过程请参看如下代码中的 win1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">win1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(f(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>), s(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(arr[i] + s(arr, i + <span class="number">1</span>, j), arr[j] + s(arr, i, j - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">s</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(f(arr, i + <span class="number">1</span>, j), f(arr, i, j - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暴力递归的方法中，递归函数一共有 N 层，并且是 f 和 s 交替出现的。f(i,j)会有 s(i+1,j)和 s(i,j-1)两个递归分支，s(i,j)也会有 f(i+1,j)和 f(i,j-1)两个递归分支。所以整体的时间复杂度为 O(2^N)，额外空间复杂度为 O(N)。下面介绍动态规划的方法，如果 arr 长度为 N，生成两个大小为 NxN 的矩阵 f 和 s，f[i][j]表示函数 f(i,j)的返回值，s[i][j]表示函数 s(i,j)的返回值。规定一下两个矩阵的计算方向即可。具体过程请参看如下代码中的 win2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">win2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length][arr.length];</span><br><span class="line">    <span class="type">int</span>[][] s = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length][arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        f[j][j] = arr[j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> j - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            f[i][j] = Math.max(arr[i] + s[i + <span class="number">1</span>][j], arr[j] + s[i][j - <span class="number">1</span>]);</span><br><span class="line">            s[i][j] = Math.min(f[i + <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(f[<span class="number">0</span>][arr.length - <span class="number">1</span>], s[<span class="number">0</span>][arr.length - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上的 win2 方法中，矩阵 f 和 s 一共有 O(N^2)个位置，每个位置计算的过程都是 O(1)的比较过程，所以 win2 方法的时间复杂度为 O(N^2)，额外空间复杂度为 O(N^2)。</p>
<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p><strong>题目</strong></p>
<p>给定数组 arr，arr[i]==k 代表可以从位置 i 向右跳 1~k 个距离。比如，arr[2]==3，代表可以从位置 2 跳到位置 3、位置 4 或位置 5。如果从位置 0 出发，返回最少跳几次能跳到 arr 最后的位置上。</p>
<p><strong>举例</strong></p>
<p>arr=[3,2,3,1,1,4]。<br>arr[0]==3，选择跳到位置 2；arr[2]==3，可以跳到最后的位置。所以返回 2。</p>
<p><strong>要求</strong></p>
<p>如果 arr 长度为 N，要求实现时间复杂度为 O(N)、额外空间复杂度为 O(1) 的方法。</p>
<p><strong>解答</strong></p>
<p>具体过程如下：</p>
<ol>
<li>整型变量 jump，代表目前跳了多少步。整型变量 cur，代表如果只能跳 jump 步，最远能够达到的位置。整型变量 next，代表如果再多跳一步，最远能够达到的位置。初始时，jump=0, cur=0, next=0。</li>
<li>从左到右遍历 arr，假设遍历到位置 i。<br> 1) 如果 cur&gt;=i，说明跳 jump 步可以到达位置 i，此时什么也不做。<br> 2) 如果 cur&lt;i，说明只跳 jump 步不能到达位置 i，需要多跳一步才行。此时令 jump++，cur=next。表示多跳了一步，cur 更新成跳 jump+1 步能够达到的位置，即 next。<br> 3) 将 next 更新成 Math.max(next, i+arr[i])，表示下一次多跳一步到达的最远位置。</li>
<li>最终返回 jump 即可。<br>具体过程请查看如下代码中的 jump 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">jump</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur &lt; i) &#123;</span><br><span class="line">            jump++;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        next = Math.max(next, i + arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jump;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组中的最长连续序列"><a href="#数组中的最长连续序列" class="headerlink" title="数组中的最长连续序列"></a>数组中的最长连续序列</h2><p><strong>题目</strong></p>
<p>给定无序数组 arr，返回其中最长的连续序列的长度。</p>
<p><strong>举例</strong></p>
<p>arr=[100,4,200,1,3,2]，最长的连续序列为[1,2,3,4]，所以返回 4。</p>
<p><strong>解答</strong></p>
<p>本题利用哈希表可以实现时间复杂度为 O(N)、额外空间复杂度为 O(N) 的方法。具体过程如下：</p>
<ol>
<li>生成哈希表 HashMap<Integer, Integer> map，key 代表遍历过的某个数，value 代表 key 这个数所在的最长连续序列的长度。同时 map 还可以表示 arr 中的一个数之前是否出现过。</li>
<li>从左到右遍历 arr，假设遍历到 arr[i]。如果 arr[i]之前出现过，直接遍历下一个数，只处理之前没出现过的 arr[i]。首先在 map 中加入记录 (arr[i],1)，代表目前 arr[i]单独作为一个连续序列。然后看 map 中是否含有 arr[i]-1，如果有，则说明 arr[i]-1 所在的连续序列可以和 arr[i]合并，合并后记为 A 序列。利用 map 可以得到 A 序列的长度，记为 lenA，最小值记为 leftA，最大值记为 rightA，只在 map 中更新与 leftA 和 rightA 有关的记录，更新成 (leftA,lenA) 和 (rightA,lenA)。<br>接下来看 map 中是否含有 arr[i]+1，如果有，则说明 arr[i]+1 所在的连续序列可以和 A 合并，合并后记为 B 序列。利用 map 可以得到 B 序列的长度为 lenB，最小值记为 leftB，最大值记为 rightB，只在 map 中更新与 leftB 和 rightB 有关的记录，更新成 (leftB,lenB) 和 (rightB,lenB)。</li>
<li>遍历过程中用全局变量 max 记录每次合并出的序列的长度最大值，最后返回 max。<br>整个过程中，只是每个连续序列最小值和最大值在 map 中的记录有意义，中间数的记录不再更新，因为再也不会使用到。这是因为我们只处理之前没出现过的数，如果一个没出现过的数能够把某个连续区间扩大，或把某两个连续区间连在一起，毫无疑问，只需要 map 中有关这个连续区间最小值和最大值的记录。<br>具体过程请查看如下代码中的 longestConsecutive 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(arr[i])) &#123;</span><br><span class="line">            map.put(arr[i], <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(arr[i] - <span class="number">1</span>)) &#123;</span><br><span class="line">                max = Math.max(max, merge(map, arr[i] - <span class="number">1</span>, arr[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(arr[i] + <span class="number">1</span>)) &#123;</span><br><span class="line">                max = Math.max(max, merge(map, arr[i], arr[i] + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(HashMap&lt;Integer, Integer&gt; map, <span class="type">int</span> less, <span class="type">int</span> more)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> less - map.get(less) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> more + map.get(more) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> right - left + <span class="number">1</span>;</span><br><span class="line">    map.put(left, len);</span><br><span class="line">    map.put(right, len);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="N-皇后问题"><a href="#N-皇后问题" class="headerlink" title="N 皇后问题"></a>N 皇后问题</h2><p><strong>题目</strong></p>
<p>N 皇后问题是指在 N×N 的棋盘上要摆 N 个皇后，要求任何两个皇后不同行、不同列，也不在同一条斜线上。给定一个整数 n，返回 n 皇后的摆法有多少种。</p>
<p><strong>举例</strong></p>
<p>n=1，返回 1。<br>n=2 或 3，2 皇后和 3 皇后问题无论怎么摆都不行，返回 0。<br>n=8，返回 92。</p>
<p><strong>解答</strong></p>
<p>本题是非常著名的问题，甚至可以用人工智能相关算法和遗传算法进行求解，同时可以用多线程技术达到缩短运行时间的效果。本书不涉及专项算法，仅提供在面试过程中 10 至 20 分钟内可以用代码实现的解法。</p>
<p><strong>方法一：基本递归</strong></p>
<p>如果在 (i,j) 位置（第 i 行第 j 列）放置了一个皇后，接下来在哪些位置不能放置皇后呢？</p>
<ol>
<li>整个第 i 行的位置都不能放置。</li>
<li>整个第 j 列的位置都不能放置。</li>
<li>如果位置 (a,b) 满足 |a-i|==|b-j|，说明 (a,b) 与 (i,j) 处在同一条斜线上，也不能放置。</li>
</ol>
<p>把递归过程直接设计成逐行放置皇后的方式，可以避开条件 1 的那些不能放置的位置。接下来用一个数组保存已经放置的皇后位置，假设数组为 record，record[i] 的值表示第 i 行皇后所在的列数。在递归计算到第 i 行第 j 列时，查看 record[0..k] (k&lt;i) 的值，看是否有 j 相等的值，若有，则说明 (i,j) 不能放置皇后，再看是否有 |k-i|==|record[k]-j|，若有，也说明 (i,j) 不能放置皇后。</p>
<p>具体过程请参看如下代码中的 num1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">num1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">return</span> process1(<span class="number">0</span>, record, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">process1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span>[] record, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isValid(record, i, j)) &#123;</span><br><span class="line">            record[i] = j;</span><br><span class="line">            res += process1(i + <span class="number">1</span>, record, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span>[] record, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == record[k] || Math.abs(record[k] - j) == Math.abs(i - k)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法二：位运算加速（最优解）</strong></p>
<p>基本过程与上面的方法一样，但使用了位运算来加速。具体加速的递归过程中，找到每一行还有哪些位置可以放置皇后的判断过程。因为整个过程比较自然，所以先列出代码，然后对代码进行解释，请参看如下代码中的 num2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">num2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 因为本方法中位运算的载体是 int 型变量，所以该方法只能算 1~32 皇后问题</span></span><br><span class="line">    <span class="comment">// 如果想计算更多的皇后问题，需使用包含更多位的变量</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span> || n &gt; <span class="number">32</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">upperLim</span> <span class="operator">=</span> n == <span class="number">32</span> ? -<span class="number">1</span> : (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> process2(upperLim, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">process2</span><span class="params">(<span class="type">int</span> upperLim, <span class="type">int</span> colLim, <span class="type">int</span> leftDiaLim, <span class="type">int</span> rightDiaLim)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (colLim == upperLim) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mostRightOne</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    pos = upperLim &amp; (~(colLim | leftDiaLim | rightDiaLim));</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos != <span class="number">0</span>) &#123;</span><br><span class="line">        mostRightOne = pos &amp; (~pos + <span class="number">1</span>);</span><br><span class="line">        pos = pos - mostRightOne;</span><br><span class="line">        res += process2(upperLim, colLim | mostRightOne,</span><br><span class="line">                (leftDiaLim | mostRightOne) &lt;&lt; <span class="number">1</span>,</span><br><span class="line">                (rightDiaLim | mostRightOne) &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong><br>num2 方法中，变量 <code>upperLim</code> 表示当前行哪些位置是可以放置皇后的，1 代表可以放置，0 代表不能放置。8 皇后问题中，初始时 <code>upperLim</code> 为 <code>00000000000000000000000011111111</code>，即 32 位整数的 255。32 皇后问题中，初始时 <code>upperLim</code> 为 <code>11111111111111111111111111111111</code>，即 32 位整数的 -1。</p>
<p>接下来解释一下 <code>process2</code> 方法，先介绍每个参数：</p>
<ul>
<li><code>upperLim</code>：已经解释过了，而且这个变量的值在递归过程中是始终不变的。</li>
<li><code>colLim</code>：表示递归计算到上一行为止，在哪些列上已经放置了皇后，1 代表已经放置，0 代表没有放置。</li>
<li><code>leftDiaLim</code>：表示递归计算到上一行为止，因为受已经放置的所有皇后的左下方斜线的影响，导致当前行不能放置皇后，1 代表不能放置，0 代表可以放置。例如，如果在第 0 行第 4 列放置了皇后，计算到第 1 行时，第 0 行皇后的左下方斜线影响的是第 1 行第 3 列。当计算到第 2 行时，第 0 行皇后的左下方斜线影响的是第 2 行第 2 列。也就是说，<code>leftDiaLim</code> 每次左移一位，就可以得到之前所有皇后的左下方斜线对当前行的影响。</li>
<li><code>rightDiaLim</code>：表示递归计算到上一行为止，因为已经受放置的所有皇后的右下方斜线的影响，导致当前行不能放置皇后的位置，1 代表不能放置，0 代表可以放置。与 <code>leftDiaLim</code> 变量类似，<code>rightDiaLim</code> 每右移一位，就可以得到之前所有皇后的右下方斜线对当前行的影响。</li>
</ul>
<p><code>process2</code> 方法的返回值代表剩余的皇后在之前皇后的影响下，有多少种合法的摆法。其中，变量 <code>pos</code> 代表当前行在 <code>colLim</code>、<code>leftDiaLim</code> 和 <code>rightDiaLim</code> 这三个状态的影响下，还有哪些位置是可供选择的，1 代表可以选择，0 代表不能选择。变量 <code>mostRightOne</code> 代表在 <code>pos</code> 中，最右边的 1 在什么位置。然后从右到左依次筛选出 <code>pos</code> 中可选择的位置进行递归尝试。</p>
<h1 id="字符串问题"><a href="#字符串问题" class="headerlink" title="字符串问题"></a>字符串问题</h1><h2 id="判断两个字符串是否互为变形词"><a href="#判断两个字符串是否互为变形词" class="headerlink" title="判断两个字符串是否互为变形词"></a>判断两个字符串是否互为变形词</h2><p><strong>题目</strong></p>
<p>给定两个字符串 str1 和 str2，如果 str1 和 str2 中出现的字符种类一样且每种字符出现的次数也一样，那么 str1 与 str2 互为变形词。请实现函数判断两个字符串是否互为变形词。</p>
<p><strong>举例</strong></p>
<p>str1=”123”, str2=”231”, 返回 true。<br>str1=”123”, str2=”2331”, 返回 false。</p>
<p><strong>解答</strong></p>
<p>如果字符串 str1 和 str2 长度不同，直接返回 false。如果长度相同，假设出现字符的编码值在 0~255 之间，那么先申请一个长度为 256 的整型数组 map，map[a]=b 代表字符编码为 a 的字符出现了 b 次，初始时 map[0..255]的值都是 0。然后遍历字符串 str1，统计每种字符出现的数量，比如遍历到字符’a’，其编码值为 97，则令 map[97]++。这样 map 就成了 str1 中每种字符的词频统计表。然后遍历字符串 str2，每遍历到一个字符，都在 map 中把词频减下来，比如遍历到字符’a’，其编码值为 97，则令 map[97]—，如果减少之后的值小于 0，直接返回 false。如果遍历完 str2，map 中的值也没出现负值，则返回 true。<br>具体请查看如下代码中的 isDeformation 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDeformation</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str1 == <span class="literal">null</span> || str2 == <span class="literal">null</span> || str1.length() != str2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] chas1 = str1.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] chas2 = str2.toCharArray();</span><br><span class="line">    <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chas1.length; i++) &#123;</span><br><span class="line">        map[chas1[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chas2.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[chas2[i]]-- == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果字符的类型有很多，可以用哈希表代替长度为 256 的整型数组，但整体过程不变。如果字符的种类为 M，str1 和 str2 的长度为 N，那么该方法的时间复杂度为 O(N)，额外空间复杂度为 O(M)。</p>
<h2 id="判断两个字符串是否互为旋转词"><a href="#判断两个字符串是否互为旋转词" class="headerlink" title="判断两个字符串是否互为旋转词"></a>判断两个字符串是否互为旋转词</h2><p><strong>题目</strong></p>
<p>如果一个字符串为 str，把字符串 str 前面任意的部分挪到后面形成的字符串叫作 str 的旋转词。比如 str=”12345”，str 的旋转词有”12345”、”23451”、”34512”、”45123”和”51234”。给定两个字符串 a 和 b，请判断 a 和 b 是否互为旋转词。</p>
<p><strong>举例</strong></p>
<p>a=”cdab”，b=”abcd”，返回 true。<br>a=”1ab2”，b=”ab12”，返回 false。<br>a=”2ab1”，b=”ab12”，返回 true。</p>
<p><strong>要求</strong></p>
<p>如果 a 和 b 长度不一样，那么 a 和 b 必然不互为旋转词，可以直接返回 false。当 a 和 b 长度一样，都为 N 时，要求解法的时间复杂度为 O(N)。</p>
<p><strong>解答</strong></p>
<p>本题的解法非常简单，如果 a 和 b 的长度不一样，字符串 a 和 b 不可能互为旋转词。如果 a 和 b 长度一样，先生成一个大字符串 b2，b2 是两个字符串 b 拼在一起的结果，即 String b2 = b + b。然后看 b2 中是否包含字符串 a，如果包含，说明字符串 a 和 b 互为旋转词，否则说明两个字符串不互为旋转词。这是为什么呢？举例说明，假设 a=”cdab”，b=”abcd”。b2=”abcdabcd”，b2[0..3]==”abcd”是 b 的旋转词，b2[1..4]==”bcda”是 b 的旋转词……b2[i..i+3]都是 b 的旋转词，b2[4..7]==”abcd”是 b 的旋转词。由此可见，如果一个字符串 b 长度为 N。在通过 b 生成的 b2 中，任意长度为 N 的子串都是 b 的旋转词，并且 b2 中包含字符串 b 的所有旋转词。所以这种方法是有效的，请参看如下代码中的 isRotation 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRotation</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span> || a.length() != b.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">b2</span> <span class="operator">=</span> b + b;</span><br><span class="line">    <span class="keyword">return</span> getIndexOf(b2, a) != -<span class="number">1</span>; <span class="comment">// getIndexOf -&gt; KMP Algorithm</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isRotation 方法中，getIndexOf 函数的功能是如果 b2 中包含 a，则返回 a 在 b2 中的开始位置，如果不包含 a，则返回-1，即 getIndexOf 是解决匹配问题的函数，如果想让整个过程在 O(N)的时间复杂度内完成，那么字符串匹配问题也需要在 O(N)的时间复杂度内完成。这正是 KMP 算法做的事情，getIndexOf 函数就是 KMP 算法的实现。若要了解 KMP 算法的过程和实现，请参看本书“KMP 算法”的内容。</p>
<h2 id="将整数字符串转成整数值"><a href="#将整数字符串转成整数值" class="headerlink" title="将整数字符串转成整数值"></a>将整数字符串转成整数值</h2><p><strong>题目</strong></p>
<p>给定一个字符串 str，如果 str 符合日常书写的整数形式，并且属于 32 位整数的范围，返回 str 所代表的整数值，否则返回 0。</p>
<p><strong>举例</strong></p>
<p>str=”123”, 返回 123。<br>str=”023”, 因为”023”不符合日常的书写习惯，所以返回 0。<br>str=”A13”, 返回 0。<br>str=”0”, 返回 0。<br>str=”2147483647”, 返回 2147483647。<br>str=”2147483648”, 因为溢出了，所以返回 0。<br>str=”-123”, 返回 -123。</p>
<p><strong>解答</strong></p>
<p>解决本题的方法有很多，本书仅提供一种供读者参考。首先检查 str 是否符合日常书写的整数形式，具体判断如下：</p>
<ol>
<li>如果 str 不以 “-” 开头，也不以数字字符开头，例如，str==”A12”，返回 false。</li>
<li>如果 str 以 “-” 开头，但是 str 的长度为 1，即 str==”-“，返回 false。如果 str 的长度大于 1，但是 “-” 的后面紧跟着 “0”，例如，str==”-0”或”-012”，返回 false。</li>
<li>如果 str 以 “0” 开头，但是 str 的长度大于 1，例如，str==”023”，返回 false。</li>
<li>如果经过步骤 1~步骤 3 都没有返回，接下来检查 str[1..N-1]是否都是数字字符，如果有一个不是数字字符，则返回 false。如果都是数字字符，说明 str 符合日常书写，返回 true。</li>
</ol>
<p>具体检查过程请参看如下代码中的 isValid 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[] chas)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (chas[<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span> &amp;&amp; (chas[<span class="number">0</span>] &lt; <span class="string">&#x27;0&#x27;</span> || chas[<span class="number">0</span>] &gt; <span class="string">&#x27;9&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (chas[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; (chas.length == <span class="number">1</span> || chas[<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (chas[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; chas.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; chas.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chas[i] &lt; <span class="string">&#x27;0&#x27;</span> || chas[i] &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 str 不符合日常书写的整数形式，根据题目要求，直接返回 0 即可。如果符合，则进行如下转换过程。</p>
<ol>
<li>生成 4 个变量。布尔型常量 posi，表示转换的结果是负数还是非负数，这完全由 str 开头的字符决定，如果以 “-” 开头，那么转换的结果一定是负数，则 posi 为 false，否则 posi 为 true。整型常量 minq，minq 等于 Integer.MIN_VALUE/10，即 32 位整数最小值除以 10 得到的商，其意义稍后说明。整型常量 minr，minr 等于 Integer.MIN_VALUE%10，即 32 位整数最小值除以 10 得到的余数，其意义稍后说明。整型变量 res，转换的结果，初始时 res=0。</li>
<li>32 位整数的最小值为-2147483648，32 位整数的最大值为 2147483647。可以看出，最小值的绝对值比最大值的绝对值大 1，所以转换过程中绝对值一律以负数的形式出现，然后根据 posi 决定最后返回什么。比如 str=”123”，转换完成后的结果是-123，posi=true，所以最后返回 123。再如 str=”-123”，转换完成后的结果是-123，posi=false，所以最后返回 -123。比如 str=”-2147483648”，转换完成后的结果是-2147483648，posi=false，所以最后返回-2147483648。比如 str=”2147483648”，转换完成后的结果是-2147483648，posi=true，此时发现-2147483648 变成 2147483648 会产生溢出，所以返回 0。也就是说，既然负数比正数拥有更大的绝对值范围，那么转换过程中一律以负数的形式记录绝对值，最后再决定返回的数到底是什么。</li>
<li>如果 str 以’-‘开头，从 str[1]开始从左往右遍历 str，否则从 str[0]开始从左往右遍历 str。举例说明转换过程，比如 str=”123”，遍历到’1’时，res=res<em>10+(-1)==-1，遍历到’2’时，res=res</em>10+(-2)==-12，遍历到’3’时，res=res<em>10+(-3)==-123。比如 str=”-123”，字符’-‘跳过，从字符’1’开始遍历，res=res</em>10+(-1)==-1，遍历到’2’时，res=res<em>10+(-2)==-12，遍历到’3’时，res=res</em>10+(-3)==-123。遍历的过程中如何判断 res 已经溢出了？假设当前字符为 a，那么’0’-a 就是当前字符所代表的数字的负数形式，记为 cur。如果在 res 加上 cur 之前，发现 res 已经小于 minq，那么 res 加上 cur 之后一定会溢出，比如 str=”3333333333”，遍历完倒数第二个字符后，res==-333333333 &lt; minq==-214748364，所以当遍历到最后一个字符时，res*10 肯定会产生溢出。如果在 res 加上 cur 之前，发现 res 等于 minq，但又发现 cur 小于 minr，那么 res 加上 cur 之后一定会溢出，比如 str=”2147483649”，遍历完倒数第二个字符后，res==-214748364 == minq，当遍历到最后一个字符时发现 cur==-9 &lt; minr==-8，那么 res 加上 cur 之后一定会溢出。出现任何一种溢出情况时，直接返回 0。</li>
<li>遍历后得到的 res 根据 posi 的符号决定返回值。如果 posi 为 true，说明结果应该返回正，否则说明应该返回负。如果 res 正好是 32 位整数的最小值，同时又有 posi 为 true，说明溢出，直接返回 0。</li>
</ol>
<p>全部过程请参看如下代码中的 convert 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">convert</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span> || str.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 不能转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] chas = str.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (!isValid(chas)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 不能转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">posi</span> <span class="operator">=</span> chas[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minq</span> <span class="operator">=</span> Integer.MIN_VALUE / <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minr</span> <span class="operator">=</span> Integer.MIN_VALUE % <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> posi ? <span class="number">0</span> : <span class="number">1</span>; i &lt; chas.length; i++) &#123;</span><br><span class="line">        cur = <span class="string">&#x27;0&#x27;</span> - chas[i];</span><br><span class="line">        <span class="keyword">if</span> ((res &lt; minq) || (res == minq &amp;&amp; cur &lt; minr)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 不能转</span></span><br><span class="line">        &#125;</span><br><span class="line">        res = res * <span class="number">10</span> + cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (posi &amp;&amp; res == Integer.MIN_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 不能转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> posi ? -res : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串的统计字符串"><a href="#字符串的统计字符串" class="headerlink" title="字符串的统计字符串"></a>字符串的统计字符串</h2><p><strong>题目</strong></p>
<p>给定一个字符串 str，返回 str 的统计字符串。例如，”aaabbadddffc”的统计字符串为”a_3_b_2_a_1_d_3_f_2_c_1”。</p>
<p><strong>补充问题</strong>：给定一个字符串的统计字符串 cstr，再给定一个整数 index，返回 cstr 所代表的原始字符串上的第 index 个字符。例如，”a_1_b_100”所代表的原始字符串上第 0 个字符是’a’，第 50 个字符是’b’。</p>
<p><strong>解答</strong></p>
<p><strong>原问题</strong>。解决原问题的方法有很多，本书仅提供一种供读者参考。具体过程如下：</p>
<ol>
<li>如果 str 为空，那么统计字符串不存在。</li>
<li>如果 str 不为空。首先生成 String 类型的变量 res，表示统计字符串，还有整型变量 num，代表当前字符的数量。初始时字符串 res 只包含 str 的第 0 个字符（str[0]），同时 num=1。</li>
<li>从 str[1]位置开始，从左到右遍历 str，假设遍历到 i 位置。如果 str[i]==str[i-1]，说明当前连续出现的字符（str[i-1]）还没结束，令 num++，然后继续遍历下一个字符。如果 str[i]!=str[i-1]，说明当前连续出现的字符（str[i-1]）已经结束，令 res=res+”<em>“+num+”</em>“+str[i]，然后令 num=1，继续遍历下一个字符。以题目给出的例子进行说明，在开始遍历”aaabbadddffc”之前，res=”a”，num=1。遍历 str[1~2]时，字符’a’一直处在连续的状态，所以 num 增加到 3。遍历 str[3]时，字符’a’连续状态停止，令 res=res+”<em>“+3+”</em>“+”b”（即”a_3_b”），num=1。遍历 str[4]，字符’b’在连续状态，num 增加到 2。遍历 str[5]时，字符’a’连续状态停止，令 res 为”a_3_b_2_a”，num=1。依此类推，当遍历到最后一个字符时，res 为”a_3_b_2_a_1_d_3_f_2_c”，num=1。</li>
<li>对于步骤 3 中的每一个字符，无论是连续还是不连续，都是在发现一个新字符时再将这个字符连续出现的次数放在 res 的最后。当遍历结束时，最后字符的次数还没有放入 res，所以，最后令 res=res+”_”+num。在步骤 3 的例子中，当遍历结束时，res 为”a_3_b_2_a_1_d_3_f_2_c”，num=1，最后需要把 num 加在 res 后面，令 res 变为”a_3_b_2_a_1_d_3_f_2_c_1”，然后再返回。</li>
</ol>
<p>具体过程请参看如下代码中的 getCountString 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getCountString</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span> || str.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] chs = str.toCharArray();</span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> String.valueOf(chs[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chs[i] != chs[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            res = concat(res, String.valueOf(num), String.valueOf(chs[i]));</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> concat(res, String.valueOf(num), <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + <span class="string">&quot;_&quot;</span> + s2 + (s3.equals(<span class="string">&quot;&quot;</span>) ? s3 : <span class="string">&quot;_&quot;</span> + s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>补充问题</strong>。求解的具体过程如下：</p>
<ol>
<li>布尔型变量 stage，stage 为 true 表示目前处在遇到字符的阶段，stage 为 false 表示目前处在遇到连续字符统计的阶段。字符型变量 cur，表示在 上一个遇到字符阶段时，遇到的是 cur 字符。整型变量 num，表示在上一个遇到连续字符统计的阶段时，字符出现的数量。整型变量 sum，表示目前遍历到 cstr 的位置相当于原子字符串的什么位置。初始时，stage=true，cur=0（字符编码为 0 表示空字符），num=0，sum=0。</li>
<li>从左到右遍历 cstr，举例说明这个过程，cstr=”a<em>100_b_2_c_4”，index=105。遍历完 str[0]==’a’后，记录下遇到字符’a’，即 cur=’a’。遇到 str[1]==’</em>‘，表示该转阶段了，从遇到字符的阶段变为遇到连续字符统计的阶段，即 stage=!stage。遇到 str[2]==’1’时，num=1；遇到 str[3]==’0’时，num=10；遇到 str[4]==’0’时，num=100；遇到 str[5]==’_’，表示遇到连续字符统计的阶段变为遇到字符的阶段；遇到 str[6]==’b’，一个新的字符出现了，此时令 sum+=num（即 sum=100），sum 表示目前原字符串走到什么位置了，此时发现 sum 并未到达 index 位置，说明还要继续遍历，记录下遇到了字符’b’，即 cur=’b’，然后令 num=0，因为字符’a’的统计已经完成，现在 num 开始表示字符’b’的连续数量。也就是说，每遇到一个新的字符，都把上一个已经完成的统计数 num 加到 sum 上，再看 sum 是否到达 index，如果已到达，就返回上一个字符 cur，如果没到达，就继续遍历。</li>
<li>每个字符的统计都在遇到新字符时加到 sum 上，所以当遍历完成时，最后一个字符的统计数并不会加到 sum 上，要单独加。</li>
</ol>
<p>具体过程请参看如下代码中的 getCharAt 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getCharAt</span><span class="params">(String cstr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cstr == <span class="literal">null</span> || cstr.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] chs = cstr.toCharArray();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">stage</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chs[i] == <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">            stage = !stage;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stage) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; index) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            cur = chs[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + chs[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum + num &gt; index ? cur : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断字符数组中是否所有的字符都只出现过一次"><a href="#判断字符数组中是否所有的字符都只出现过一次" class="headerlink" title="判断字符数组中是否所有的字符都只出现过一次"></a>判断字符数组中是否所有的字符都只出现过一次</h2><p><strong>题目</strong></p>
<p>给定一个字符类型数组 chas[]，判断 chas 中是否所有的字符都只出现过一次，请根据以下不同的两种要求实现两个函数。</p>
<p><strong>举例</strong></p>
<p>chas=[‘a’,’b’,’c’]，返回 true；chas=[‘1’,’2’,’1’]，返回 false。</p>
<p><strong>要求</strong></p>
<ol>
<li>实现时间复杂度为 O(N)的方法。</li>
<li>在保证额外空间复杂度为 O(1)的前提下，请实现时间复杂度尽量低的方法。</li>
</ol>
<p><strong>解答</strong></p>
<p><strong>要求 1</strong>。遍历一遍 chas，用 map 记录每种字符出现的情况，这样就可以在遍历时发现字符重复出现的情况，map 可以用长度固定的数组实现，也可以用哈希表实现。具体请参看如下代码中的 isUnique1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUnique1</span><span class="params">(<span class="type">char</span>[] chas)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (chas == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span>[] map = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chas.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[chas[i]]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map[chas[i]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>要求 2</strong>。整体思路是先将 chas 排序，排序后相同的字符就放在一起，然后判断有没有重复字符就会变得非常容易，所以问题的关键是选择什么样的排序算法。因为必须保证额外空间复杂度为 O(1)，所以本题是考查面试者对经典排序算法在额外空间复杂度方面的理解程度。首先，任何时间复杂度为 O(N)的排序算法做不到额外空间复杂度为 O(1)，因为这些排序算法不是基于比较的排序算法，所以有多少个数都得“装下”，然后按照一定顺序“倒出”来完成排序。具体细节请读者查询相关图书中有关桶排序、基数排序、计数排序等内容。然后看时间复杂度 O(NlogN)的排序算法，常见的有归并排序、快速排序、希尔排序和堆排序。归并排序首先被排除，因为归并排序中有两个小组并成一个大组的过程，这个过程需要辅助数组才能完成，尽管归并排序可以使用手摇算法将额外空间复杂度降至 O(1)，但这样最差情况下的时间复杂度会因此上升至 O(N^2)。快速排序也被排除，因为无论选择递归实现还是非递归实现，快速排序的额外空间复杂度最低，为 O(logN)，不能达到 O(1)的程度。希尔排序同样被排除，因为希尔排序的时间复杂度并不固定，成败完全在于步长的选择，如果选择不当，时间复杂度会变成 O(N^2)。这四种经典排序中，只有堆排序可以做到额外空间复杂度为 O(1)的情况下，时间复杂度还能稳定地保持 O(NlogN)。那么堆排序就是答案，面试者似乎只要写出堆排序的大体过程，要求 2 的实现就能完成。<br>但遗憾的是，虽然堆排序的确是答案，但大部分资料提供的堆排序的实现却是基于递归函数实现的。而我们知道递归函数需要使用函数栈空间，这样堆排序的额外空间复杂度就增加至 O(logN)。所以，如果真正想达到要求 2 的实现，面试者需要用非递归的方式实现堆排序。要求 2 的实现请参看如下代码中的 isUnique2 方法，其中的 heapSort 方法是堆排序的非递归实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUnique2</span><span class="params">(<span class="type">char</span>[] chas)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (chas == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heapSort(chas);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; chas.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chas[i] == chas[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">char</span>[] chas)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chas.length; i++) &#123;</span><br><span class="line">        heapInsert(chas, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> chas.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(chas, <span class="number">0</span>, i);</span><br><span class="line">        heapify(chas, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">char</span>[] chas, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">        parent = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (chas[parent] &lt; chas[i]) &#123;</span><br><span class="line">            swap(chas, parent, i);</span><br><span class="line">            i = parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">char</span>[] chas, <span class="type">int</span> i, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chas[left] &gt; chas[i]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; chas[right] &gt; chas[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(chas, largest, i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i = largest;</span><br><span class="line">        left = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        right = i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] chas, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> chas[index1];</span><br><span class="line">    chas[index1] = chas[index2];</span><br><span class="line">    chas[index2] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在有序但含有空的数组中查找字符串"><a href="#在有序但含有空的数组中查找字符串" class="headerlink" title="在有序但含有空的数组中查找字符串"></a>在有序但含有空的数组中查找字符串</h2><p><strong>题目</strong></p>
<p>给定一个字符串数组 strs[]，在 strs 中有些位置为 null，但在不为 null 的位置上，其字符串是按照字典顺序由小到大依次出现的。再给定一个字符串 str，请返回 str 在 strs 中出现的最左的位置。</p>
<p><strong>举例</strong></p>
<p>strs=[null,”a”,null,”a”,null,”b”,null,”c”], str=”a”, 返回 1。<br>strs=[null,”a”,null,”a”,null,”b”,null,”c”], str=null, 只要 str 为 null，就返回-1。<br>strs=[null,”a”,null,”a”,null,”b”,null,”c”], str=”d”, 返回-1。</p>
<p><strong>解答</strong></p>
<p>本题的解法尽可能多地使用了二分查找，具体过程如下：</p>
<ol>
<li>假设在 strs[left..right]上进行查找的过程，全局整型变量 res 表示字符串 str 在 strs 中最左的位置。初始时，left=0, right=strs.length-1, res=-1。</li>
<li>令 mid=(left+right)/2，则 strs[mid]为 strs[left..right]中间位置的字符串。</li>
<li>如果字符串 strs[mid]与 str 一样，说明找到了 str，令 res=mid。但要找的是最左的位置，还要在左半区寻找，看有没有更左的 str 出现，所以令 right=mid-1，然后重复步骤 2。</li>
<li>如果字符串 strs[mid]与 str 不一样，并且 strs[mid]!=null，此时可以比较 strs[mid]和 str，如果 strs[mid]的字典顺序比 str 小，说明整个左半区不会出现 str，需要在右半区寻找，所以令 left=mid+1，然后重复步骤 2。</li>
<li>如果字符串 strs[mid]与 str 不一样，并且 strs[mid]==null，此时从 mid 开始，从右到左遍历左半区（即 strs[left..mid]）。如果整个左半区都为 null，那么继续用二分的方式在右半区上查找（即令 left=mid+1），然后重复步骤 2。如果整个左半区不都为 null，假设从右到左遍历 strs[left..mid]时，发现第一个不为 null 的位置是 i，那么把 str 和 strs[i]进行比较。如果 strs[i]字典顺序小于 str，同样说明整个左半区没有 str，令 left=mid+1，然后重复步骤 2。如果 strs[i]字典顺序等于 str，说明找到 str，令 res=i，但要找的是最左的位置，还要在 strs[left..i-1]上寻找，看有没有更左的 str 出现，所以令 right=i-1，然后重复步骤 2。如果 strs[i]字典顺序大于 str，说明 strs[i..right]上都没有 str，需要在 strs[left..i-1]上查找，所以令 right=i-1，然后重复步骤 2。<br>具体过程请参看如下代码中的 getIndex 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(String[] strs, String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span> || str == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> strs.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (strs[mid] != <span class="literal">null</span> &amp;&amp; strs[mid].equals(str)) &#123;</span><br><span class="line">            res = mid;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strs[mid] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[mid].compareTo(str) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = mid;</span><br><span class="line">            <span class="keyword">while</span> (strs[i] == <span class="literal">null</span> &amp;&amp; --i &gt;= left)</span><br><span class="line">                ;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; left || strs[i].compareTo(str) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = strs[i].equals(str) ? i : res;</span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串的调整与替换"><a href="#字符串的调整与替换" class="headerlink" title="字符串的调整与替换"></a>字符串的调整与替换</h2><p><strong>题目</strong></p>
<p>给定一个字符类型的数组 chas[]，chas 右半区全为空字符，左半区不含有空字符。现在想将左半区中所有的空格字符替换成”%20”，假设 chas 右半区足够大，可以满足替换所需要的空间，请完成替换函数。</p>
<p><strong>举例</strong></p>
<p>如果把 chas 的左半区看作字符串，为”a b c”，假设 chas 的右半区足够大。替换后，chas 的左半区为”a%20b%20%20c”。</p>
<p><strong>要求</strong></p>
<p>替换函数的时间复杂度为 O(N)，额外空间复杂度为 O(1)。</p>
<p><strong>补充问题</strong>：给定一个字符类型的数组 chas[]，其中只含有数字字符和“<em>”字符。现在想把所有的“</em>”字符挪到 chas 的左边，数字字符挪到 chas 的右边。请完成调整函数。</p>
<p><strong>举例</strong></p>
<p>如果把 chas 看作字符串，为”12<strong>345”。调整后 chas 为”</strong>12345”。</p>
<p><strong>要求</strong></p>
<ol>
<li>调整函数的时间复杂度为 O(N)，额外空间复杂度为 O(1)。</li>
<li>不得改变数字字符从左到右出现的顺序。</li>
</ol>
<p><strong>解答</strong></p>
<p><strong>原问题</strong>。遍历一遍可以得到两个信息，chas 的左半区有多大，记为 len，左半区的空格数有多少，记为 num，那么可知空格字符被“%20”替代后，长度将是 len+2×num。接下来从左半区的最后一个字符开始逆序遍历，同时将字符复制到新长度最后的位置，并依次向左逆序复制。遇到空格字符就依次对“0”、“2”和“%”进行复制。这样就可以得到替换后的 chas 数组。具体过程请参看如下代码中的 replace 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replace</span><span class="params">(<span class="type">char</span>[] chas)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (chas == <span class="literal">null</span> || chas.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; len &lt; chas.length &amp;&amp; chas[len] != <span class="number">0</span>; len++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chas[len] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> len + num * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt; -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chas[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            chas[j--] = chas[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            chas[j--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            chas[j--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            chas[j--] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>补充问题</strong>。依然是从右向左逆序复制，遇到数字字符则直接复制，遇到“<em>”字符不复制。把数字字符复制完后，再把左半区全部设置成“</em>”即可。具体请参看如下代码中的 modify 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">(<span class="type">char</span>[] chas)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (chas == <span class="literal">null</span> || chas.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> chas.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> chas.length - <span class="number">1</span>; i &gt; -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chas[i] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            chas[j--] = chas[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; j &gt; -<span class="number">1</span>;) &#123;</span><br><span class="line">        chas[j--] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上两道题目都是利用逆序复制这个技巧，其实很多字符串问题也和这个小技巧有关。字符串的面试题一般不会太难，很多题目都是考查代码实现能力的。</p>
<h2 id="翻转字符串"><a href="#翻转字符串" class="headerlink" title="翻转字符串"></a>翻转字符串</h2><p><strong>题目</strong></p>
<p>给定一个字符类型的数组 chas，请在单词间做逆序调整。只要做到单词的顺序逆序即可，对空格的位置没有特别要求。</p>
<p><strong>举例</strong></p>
<p>如果把 chas 看作字符串为”dog loves pig”，调整成”pig Loves dog”。<br>如果把 chas 看作字符串为”I’m a student.”，调整成”student. a I’m”。</p>
<p><strong>补充问题</strong>：给定一个字符类型的数组 chas 和一个整数 size，请把大小为 size 的左半区整体移到右半区，右半区整体移到左边。</p>
<p><strong>举例</strong></p>
<p>如果把 chas 看作字符串为”ABCDE”，size=3，调整成”DEABC”。</p>
<p><strong>要求</strong></p>
<p>如果 chas 长度为 N，两道题都要求时间复杂度为 O(N)，额外空间复杂度为 O(1)。</p>
<p><strong>解答</strong></p>
<p><strong>原问题</strong>。首先把 chas 整体逆序。在逆序之后，遍历 chas 找到每一个单词，然后把每个单词里的字符逆序处理即可。比如“dog loves pig”，先整体逆序变为“gip sevol god”，然后每个单词进行逆序处理就变成了“pig loves dog”。逆序之后找每一个单词的逻辑，做到不出错即可。<br>全部过程请参看如下代码中的 rotateWord 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotateWord</span><span class="params">(<span class="type">char</span>[] chas)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (chas == <span class="literal">null</span> || chas.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(chas, <span class="number">0</span>, chas.length - <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chas.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chas[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            l = i == <span class="number">0</span> || chas[i - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span> ? i : l;</span><br><span class="line">            r = i == chas.length - <span class="number">1</span> || chas[i + <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span> ? i : r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l != -<span class="number">1</span> &amp;&amp; r != -<span class="number">1</span>) &#123;</span><br><span class="line">            reverse(chas, l, r);</span><br><span class="line">            l = -<span class="number">1</span>;</span><br><span class="line">            r = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] chas, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        tmp = chas[start];</span><br><span class="line">        chas[start] = chas[end];</span><br><span class="line">        chas[end] = tmp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>补充问题</strong>，<strong>方法一</strong>。先把 chas[0..size-1]部分逆序处理，再把 chas[size..N-1]部分逆序处理，最后把 chas 整体逆序处理即可。比如，chas=”ABCDE”，size=3。先把 chas[0..2]部分逆序处理，chas 变为”CBADE”，再把 chas[3..4]部分逆序处理，chas 变为”CBAED”，最后把 chas 整体逆序处理，chas 变为”DEABC”。具体过程请参看如下代码中的 rotate1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rotate1</span><span class="params">(<span class="type">char</span>[] chas, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (chas == <span class="literal">null</span> || size &lt;= <span class="number">0</span> || size &gt;= chas.length) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(chas, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">    reverse(chas, size, chas.length - <span class="number">1</span>);</span><br><span class="line">    reverse(chas, <span class="number">0</span>, chas.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法二</strong>。用举例的方式来说明这个过程，chas=”1234567ABCD”，size=7。</p>
<ol>
<li>左部分为”1234567”，右部分为”ABCD”，右部分的长度为 4，比左部分小，所以把左部分前 4 个字符与右部分交换，chas[0..10]变为”ABCD5671234”。右部分小，所以右部分”ABCD”换过去后再也不需要移动，剩下的部分为 chas[4..10]=”5671234”。左部分大，所以换过来的”1234”视为下一步的右部分，下一步的左部分为“567”。</li>
<li>左部分为”567”，右部分为”1234”，左部分的长度为 3，比右部分小，所以把右部分的后 3 个字符与左部分交换，chas[4..10]变为”2341567”。左部分小，所以左部分”567”换过去后再也不需要移动，剩下的部分为 chas[4..7]=”2341”。右部分大，所以换过来的”234”视为下一步的左部分，下一步的右部分为”1”。</li>
<li>左部分为”234”，右部分为”1”。右部分的长度为 1，比左部分小，所以把左部分前 1 个字符与右部分交换，chas[4..7]变为”1342”。右部分小，所以右部分”1”换过去后再也不需要移动，剩下的部分为 chas[5..7]=”342”。左部分大，所以换过来的”2”视为下一步的右部分，下一步的左部分为”34”。</li>
<li>左部分为”34”，右部分为”2”。右部分的长度为 1，比左部分小，所以把左部分前 1 个字符与右部分交换，chas[5..7]变为”243”。右部分小，所以右部分”2”换过去后再也不需要移动，剩下的部分为 chas[6..7]=”43”。左部分大，所以换过来的”3”视为下一步的右部分，下一步的左部分为”4”。</li>
<li>左部分为”4”，右部分为”3”。一旦发现左部分跟右部分的长度一样，那么左部分和右部分完全交换即可，chas[6..7]变为”34”，整个过程结束，chas 已经变为”ABCD1234567”。</li>
</ol>
<p>如果每一次左右部分的划分进行 M 次交换，那么都有 M 个字符再也不需要移动，而字符数一共为 N，所以交换行为最多发生 N 次。另外，如果某一次划分出的左右部分长度一样，那么交换完成后将不会再有新的划分，所以在很多时候交换操作会少于 N 次。比如，chas=”1234ABCD”，size=4，最开始左部分为”1234”，右部分为”ABCD”，左右两个部分完全交换后为”ABCD1234”，同时不会有后续的划分，所以，这种情况下一共只有 4 次交换操作。具体过程请参看如下代码中的 rotate2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate2</span><span class="params">(<span class="type">char</span>[] chas, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (chas == <span class="literal">null</span> || size &lt;= <span class="number">0</span> || size &gt;= chas.length) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> chas.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lpart</span> <span class="operator">=</span> size;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rpart</span> <span class="operator">=</span> chas.length - size;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> Math.min(lpart, rpart);</span><br><span class="line">    <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> lpart - rpart;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        exchange(chas, start, end, s);</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            start += s;</span><br><span class="line">            lpart = d;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end -= s;</span><br><span class="line">            rpart = -d;</span><br><span class="line">        &#125;</span><br><span class="line">        s = Math.min(lpart, rpart);</span><br><span class="line">        d = lpart - rpart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exchange</span><span class="params">(<span class="type">char</span>[] chas, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> end - size + <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line">        tmp = chas[start];</span><br><span class="line">        chas[start] = chas[i];</span><br><span class="line">        chas[i] = tmp;</span><br><span class="line">        start++;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完美洗牌问题"><a href="#完美洗牌问题" class="headerlink" title="完美洗牌问题"></a>完美洗牌问题</h2><p><strong>题目</strong></p>
<p>给定一个长度为偶数的数组 arr，长度记为 2×N。前 N 个为左部分，后 N 个为右部分。arr 就可以表示为{L1,L2,..,Ln,R1,R2,..,Rn}。请将数组调整成{R1,L1,R2,L2,..,Rn,Ln}的样子。</p>
<p><strong>举例</strong></p>
<p>arr={1,2,3,4,5,6}，调整之后为{4,1,5,2,6,3}。</p>
<p><strong>进阶问题</strong>：给定一个数组 arr，请将数组调整为依次相邻的数字总是先&lt;=、再&gt;=的关系，并交替下去。比如数组中有五个数字，调整成{a,b,c,d,e}，使之满足 a&lt;=b&gt;=c&lt;=d&gt;=e。</p>
<p><strong>要求</strong></p>
<p>原问题要求时间复杂度为 O(N)，额外空间复杂度为 O(1)。<br>进阶问题要求时间复杂度为 O(NlogN)，额外空间复杂度为 O(1)。</p>
<p><strong>解答</strong></p>
<p>读者在阅读本题解法之前，需要先阅读本书“翻转字符串”问题中的进阶问题解法。原问题就是完美洗牌问题，最苛刻的要求是额外空间复杂度为 O(1)。这要求调整过程是原地调整算法，不能生成额外数组辅助。先看 arr 长度为 2×3 的例子，下面列出了调整前和调整后数字的位置变化，以后下标都设下标是从 1 开始的。<br>调整前的数字: a b c d e f<br>调整前的位置: 1 2 3 4 5 6<br>调整后的数字: d a e b f c<br>调整后的位置: 4 1 5 2 6 3<br>调整前的位置: 1 2 3 4 5 6<br>依然假设 arr 长度为 2×N，可以总结一下调整前的 i 位置上的数，在调整之后来到什么位置。如果调整前位置 i 在左半区（i&lt;=N），调整之后会来到 2×i 位置；如果调整前 i 在右半区（i&gt;N），调整之后会来到 2×(i-N)-1 位置。N=数组长度/2。参见如下的 modifyIndex1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的长度为 len，调整前的位置是 i，返回调整之后的位置</span></span><br><span class="line"><span class="comment">// 下标不从 0 开始，从 1 开始</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">modifyIndex1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= len / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * (i - (len / <span class="number">2</span>)) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个规律可以进一步总结为：<br>调整前    调整后<br>i     -&gt; (2*i)%(len+1)</p>
<p>其实不做进一步的总结，也不会影响什么。总之，写出一个函数来描述位置变化即可。参见如下的 modifyIndex2 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的长度为 len，调整前的位置是 i，返回调整之后的位置</span></span><br><span class="line"><span class="comment">// 下标不从 0 开始，从 1 开始</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">modifyIndex2</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> * i) % (len + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，原始位置 i 去往什么位置其实只由一个公式决定。那么初始想法就是，能不能利用“下标连续推”的方式调整好所有的数字呢？我们举个例子了解什么叫“下标连续推”。<br>调整前的数字: a b c d<br>调整前的位置: 1 2 3 4<br>调整后的数字: c a d b<br>调整后的位置: 3 1 4 2<br>调整前的位置: 1 2 3 4<br>从 1 位置出发开始调整数组，位置变化的函数假设为 m，m(1)=2，所以 a 直接放在 2 位置上，并且把位于 2 位置的 b 推了出来。b 原来的位置是 2，m(2)=4，所以 b 直接放在 4 位置上，并且把位于 4 位置的 d 推了出来。d 原来的位置是 4，m(4)=3，所以 d 直接放在 3 位置上，并且把位于 3 位置的 c 推了出来。c 原来的位置是 3，m(3)=1，所以 c 直接放在 1 位置上，因为 1 位置就是最初的开始位置，所以“下标连续推”过程停止。所有数字都来到了正确的位置上，数组调整正确。<br>这个思路很不错，有点类似于一个环状的多米诺骨牌。从一张牌开始连续推倒下一张牌，最终还会回到原位置。之所以强调这是一个环，是因为不管从哪个位置出发，最后的位置一定能够回到出发的位置，并且“下标连续推”的过程只使用了几次 m 函数，并不需要任何中间状态被记录，额外空间复杂度为 O(1)。但遗憾的是，对于任意长度为偶数的数组，可能由多条环组成。比如长度为 6 的数组，如下：<br>调整前的数字: a b c d e f<br>调整前的位置: 1 2 3 4 5 6<br>如果从 1 位置出发，每一步根据 m 函数来到下一个位置，那么“下标连续推”的过程：a(1)推出 b(2)，b(2)推出 d(4)，d(4)回到 1 位置。也就是 1-&gt;2-&gt;4-&gt;1 这条环。但是此时数组还有需要调整的数字。<br>还需要调整的数字（X 代表已经调整好的数据）为：X X c X e f。<br>所以还需要从 3 位置出发，再进行一轮“下标连续推”的过程：c(3)推出 f(6)，f(6)推出 e(5)，e(5)回到 3 位置。也就是 3-&gt;6-&gt;5-&gt;3 这条环。此时数组中所有的数字才调整完毕。</p>
<p>数组长度不同，环的数量也不同，并且任何一条环一定不和其他的环共享任何数字。但是麻烦的地方在于，你不能去记录哪些位置是经历过“下标连续推”过程的，因为一旦记录了，额外空间复杂度就不再是 O(1)。这就要求我们必须找到一个简洁的公式。可以根据长度的值，直接算出每一条环的出发位置。然后从这些出发位置开始都经历一遍“下标连续推”。存在这样的公式吗？这里直接把完美洗牌问题论文中的结论告诉读者，有兴趣的读者可以去证明。如果数组长度为 2*N==(3^k)-1，那么出发位置有 k 个，依次为 1,3,9,..3^(k-1)。k&gt;=1。比如数组长度为 2 时，2=3^1-1，所以出发位置只有 1 个，也就是 1 位置 3^0。比如数组长度为 8 时，8=3^2-1，所以出发位置有 2 个，依次为 1,3。比如数组长度为 26 时，26=3^3-1，所以出发位置有 3 个，依次为 1,3,9。<br>可是这个结论只能解决数组长度为 3^k-1 的特殊情况，如果数组长度为一个普通的偶数，又该怎么解决呢？下面用一个例子来展示如果数组长度为一个普通的偶数该如何解决。比如数组长度为 12 的时候，数组如下：<br>L1 L2 L3 L4 L5 L6 R1 R2 R3 R4 R5 R6<br>目标调整成：<br>R1 L1 R2 L2 R3 L3 R4 L4 R5 L5 R6 L6<br>首先计算一下，小于或等于 12，并且是离 12 最近的，满足 3^k-1 的数是谁（2,8,26,…），是 8。这代表想先得到调整结果的前 8 个，也就是想先得到：<br>R1 L1 R2 L2 R3 L3 R4 L4<br>为了做到这一点，先在原数组[L5 L6 R1 R2 R3 R4]这一段上做调整，在这段上，认为左部分是[L5 L6]，右部分是[R1 R2 R3 R4]。左部分放到这一段的右边，右部分放到这一段的左边。相关内容请阅读本书“翻转字符串”问题中的进阶问题解法。数组先调整成：<br>L1 L2 L3 L4 R1 R2 R3 R4 L5 L6 R5 R6<br>此时数组的前 8 个数为[L1 L2 L3 L4 R1 R2 R3 R4]，并且长度是满足 3^k-1 关系的，就可以利用之前的结论进行调整了。数组还没调整的数字就是[L5 L6 R5 R6]这一段，长度为 4，如下所示（X 为已经调好不需要再考虑的位置）：<br>X X X X X X X X L5 L6 R5 R6<br>长度为 12 的数组已经搞定了 8 个，还剩下 4 个。接下来计算一下小于或等于 4，并且是离 4 最近的，满足 3^k-1 的数是谁（2,8,26,…），是 2。这代表想先在剩余的[L5 L6 R5 R6]中，得到调整结果的前 2 个[R5 L5]。为了做到这一点，在剩余的部分中先在[L6 R5]这一段上做调整。认为左部分是[L6]，右部分是[R5]。左部分放到这一段的右边，右部分放到这一段的左边。剩余部分在调整之后就变成[L5 R5 L6 R6]。此时剩余部分的前 2 个数为[L5 R5]，并且长度是满足 3^k-1 关系的，就可以利用之前的结论进行调整了。数组还没调整的数字就剩[L6 R6]这一段了，长度为 2，如下所示（X 为已经调好不需要再考虑的位置）：<br>X X X X X X X X X X L6 R6<br>最后这个部分是长度为 2 的，并且长度是满足 3^k-1 关系的，就可以利用之前的结论进行调整了。整个数组就调整完毕。<br>长度为一个任意偶数，都一定可以把这个偶数拆成一块块长度满足 3^k-1 的部分。比如长度为 126，类比之前的流程，会先拆出长度为 80（即 3^4-1）的块先解决；剩余的长度为 46，再拆出长度为 26（即 3^3-1）的块解决；剩余长度为 20，再拆出长度为 8（即 3^2-1）的块解决；剩余长度为 12，接下来拆出的块为 8,2,2。任何一个偶数都可如此。解决每一个块的时候，额外空间复杂度都是 O(1)。每一个块解决之后，后续都不需要再碰，所以时间复杂度为 O(N)。全部过程如 shuffle 方法所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="comment">// 数组必须不为空，且长度为偶数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr != <span class="literal">null</span> &amp;&amp; arr.length != <span class="number">0</span> &amp;&amp; (arr.length &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        shuffle(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 arr[L..R]上做完美洗牌的调整</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (R - L + <span class="number">1</span> &gt; <span class="number">0</span>) &#123; <span class="comment">// 切成一块一块的解决，每一块的长度满足(3^k)-1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> R - L + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算小于或等于 len 且距离 len 最近的，满足(3^k)-1 的数</span></span><br><span class="line">        <span class="comment">// 也就是找到最大的 k，满足 3^k &lt;= len+1</span></span><br><span class="line">        <span class="keyword">while</span> (base &lt;= (len + <span class="number">1</span>) / <span class="number">3</span>) &#123;</span><br><span class="line">            base *= <span class="number">3</span>;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前要解决长度为 base-1 的块，一半就是再除以 2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> (base - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// [L..R]的中点位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 要旋转的左部分为[L+half...mid], 右部分为 arr[mid+1..mid+half]</span></span><br><span class="line">        <span class="comment">// 注意，这里 arr 下标是 0 开始的</span></span><br><span class="line">        rotate(arr, L + half, mid, mid + half);</span><br><span class="line">        <span class="comment">// 旋转完成后，从 L 开始算起，长度为 base-1 的部分进行下标连续推</span></span><br><span class="line">        cycles(arr, L, base - <span class="number">1</span>, k);</span><br><span class="line">        <span class="comment">// 解决了前 base-1 的部分，剩下的部分继续处理</span></span><br><span class="line">        L = L + base - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 start 位置开始，往右 len 的长度这一段做下标连续推</span></span><br><span class="line"><span class="comment">// 出发位置依次为 1,3,9...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cycles</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> len, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到每一个出发位置 trigger，一共 k 个</span></span><br><span class="line">    <span class="comment">// 每一个 trigger 都进行下标连续推</span></span><br><span class="line">    <span class="comment">// 出发位置是从 1 开始算的，而数组下标是从 0 开始算的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, trigger = <span class="number">1</span>; i &lt; k; i++, trigger *= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preValue</span> <span class="operator">=</span> arr[trigger + start - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> modifyIndex2(trigger, len);</span><br><span class="line">        <span class="keyword">while</span> (cur != trigger) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[cur + start - <span class="number">1</span>];</span><br><span class="line">            arr[cur + start - <span class="number">1</span>] = preValue;</span><br><span class="line">            preValue = tmp;</span><br><span class="line">            cur = modifyIndex2(cur, len);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[cur + start - <span class="number">1</span>] = preValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [L..M]为左部分，[M+1..R]为右部分，左右两部分互换</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> M, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">    reverse(arr, L, M);</span><br><span class="line">    reverse(arr, M + <span class="number">1</span>, R);</span><br><span class="line">    reverse(arr, L, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [L..R]做逆序调整</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[L];</span><br><span class="line">        arr[L++] = arr[R];</span><br><span class="line">        arr[R--] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>进阶问题</strong>。首先把整个数组排序，要用额外空间复杂度为 O(1)的排序，比如堆排序。如果数组长度是偶数，然后把排序之后的数组调整成[L1 R1 L2 R2 … Ln Rn]即可。举个例子，比如 arr 排序之后是[1,2,3,4,5,6]，调整成[1,4,2,5,3,6]就是题目要求的大小关系。完美洗牌问题能调整成[R1 L1 R2 L2 … Rn Ln]。再只需要遍历一遍，把[R1 L1]、[R2 L2]、…、[Rn Ln]每一对里的两个数换一下位置即可。如果数组长度是奇数，arr[0]位置的数不用动，把后面剩下的长度为偶数的部分看作是[L1 L2 … Ln R1 R2 … Rn]，然后用完美洗牌问题调整成[R1 L1 R2 L2 … Rn Ln]即可。举个例子，比如 arr 排序之后是[1,2,3,4,5]，不管 1 这个数，剩下的部分是[2,3,4,5]，调整成[4,2,5,3]，那么数组整体变成[1,4,2,5,3]，就是题目要求的大小关系。具体过程如 wiggleSort 方法所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wiggleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 假设这个排序的额外空间复杂度是 O(1)，当然系统提供的排序并不是，</span></span><br><span class="line">    <span class="comment">// 你可以自己实现一个堆排序</span></span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line">    <span class="keyword">if</span> ((arr.length &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        shuffle(arr, <span class="number">1</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shuffle(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">            arr[i + <span class="number">1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除多余字符得到字典序最小的字符串"><a href="#删除多余字符得到字典序最小的字符串" class="headerlink" title="删除多余字符得到字典序最小的字符串"></a>删除多余字符得到字典序最小的字符串</h2><p><strong>题目</strong></p>
<p>给定一个全和小写字母的字符串 str，删除多余字符，使得每种字符只保留一个，并让最终结果字符串的字典序最小。</p>
<p><strong>举例</strong></p>
<p>str=”acbc”，删掉第一个’c’，得到”abc”，是所有结果字符串中字典序最小的。<br>str=”dbcacbca”，删掉第一个’b’、第一个’c’、第二个’c’、第二个’a’，得到”dabc”，是所有结果字符串中字典序最小的。</p>
<p><strong>解答</strong></p>
<p>不考虑怎么去删除，应考虑怎么去挑选。str 的结果字符串记为 res，假设 str 长度为 N，其中有 K 种不同的字符，那么 res 长度为 K。思路是怎么在 str 中从左到右依次挑选出 res[0]、res[1]、…、res[K-1]。举个例子，str[0..9]=”baacbaccac”，一共 3 种字符，所以在 str 中从左到右依次找到 res[0..2]。</p>
<ol>
<li>建立 str[0..9]的字频统计，b 有 2 个、a 有 4 个、c 有 4 个。</li>
<li>从左往右遍历 str[0..9]，遍历到字符的字频统计减 1，当发现某一种字符的字频统计已经为 0 时，遍历停止。在例子中当遍历完”baacb”时，字频统计为 b 有 0 个、a 有 2 个、c 有 3 个，发现 b 的字频已经为 0，所以停止遍历，当前遍历到 str[4]。str[5..9]为”accac”已经没有 b 了，而流程是在 str 中从左到右依次挑选出 res[0]、res[1]、res[2]，所以，如果 str[5..9]中任何一个字符被挑选成为 res[0]，之后过程是在挑选位置的右边继续挑选，那么一定错过了 b 字符，所以在 str[0..4]上挑选 res[0]。</li>
<li>在 str[0..4]上找到字典序最小的字符，即 str[1]==’a’，它就是 res[0]。</li>
<li>在挑选字符 str[1]的右边，字符串”acbaccac”，删掉所有的’a’字符变为”cbccc”，令 str=”cbccc”，下面找 res[1]。</li>
<li>建立 str[0..4]的字频统计，b 有 1 个、c 有 4 个。</li>
<li>从左往右遍历 str[0..4]，遍历到字符的字频统计减 1，当发现某一种字符的字频统计已经为 0 时，遍历停止。当遍历完”cb”时，字频统计为 b 有 0 个、c 有 3 个，发现 b 的字频已经为 0，所以停止遍历，当前遍历到 str[1]。str[2..4]为”ccc”已经没有 b 了，所以如果 str[2..4]中任何一个字符被挑选成为 res[1]，之后的过程是在挑选位置的右边继续挑选，那么一定错过了 b 字符，所以在 str[0..1]上挑选 res[1]。</li>
<li>在 str[0..1]上找到字典序最小的字符，即 str[1]==’b’，它就是 res[1]。</li>
<li>在挑选字符 str[1]的右边，字符串为”ccc”，删掉所有的’b’字符，仍为”ccc”，令 str=”ccc”，下面找 res[2]。</li>
<li>建立 str[0..2]的字频统计，c 有 3 个。</li>
<li>从左往右遍历 str[0..2]，遍历到字符的字频统计减 1，当发现某一种字符的字频统计已经为 0 时，遍历停止。当遍历完”ccc”时，字频统计为 c，有 0 个，当前遍历到 str[2]。右边没有字符了，当然无法成为 res[2]，所以在 str[0..2]上挑选 res[2]。</li>
<li>在 str[0..2]上找到字典序最小的字符，即 str[0]==’c’，它就是 res[2]。整个过程结束。</li>
</ol>
<p>如上过程虽然是用例子来说明的，但是整个过程其实比较简单。根据字频统计，遍历 str 时找到一个前缀 str[0..R]，然后在 str[0..R]中找到最小 ASCII 码的字符 str[X]，就是结果字符串的当前字符。然后令 str=(str[X+1..R]去掉所有 str[X]得到的字符串)，重复整个过程，找到结果字符串的下一个字符，直到 res 生成完毕。如果 str 长度为 N，不同的字符有 K 种，每找到一个 res[i]，都要重新建立字频统计以及在整个字符串中删除已经找到的字符，所以时间复杂度为 O(K×N)。根据题目描述，str 中全是小写字母，所以 K 不会超过 26，则时间复杂度为 O(N)。全部过程的代码实现请看如下 removeDuplicateLetters 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">removeDuplicateLetters</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="comment">// 小写字母 ASCII 码值范围为[97~122]，所以用长度为 26 的数组做次数统计</span></span><br><span class="line">    <span class="comment">// 如果 map[i] &gt; -1，则代表 ASCII 码值为 i 的字符不需考虑</span></span><br><span class="line">    <span class="comment">// 如果 map[i] == -1，则代表 ASCII 码值为 i 的字符不再考虑</span></span><br><span class="line">    <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        map[str[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] res = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (R != str.length) &#123;</span><br><span class="line">        <span class="comment">// 如果当前字符是不再考虑的，直接跳过</span></span><br><span class="line">        <span class="comment">// 如果当前字符出现的次数减 1 之后，后面还能出现，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (map[str[R] - <span class="string">&#x27;a&#x27;</span>] == -<span class="number">1</span> || --map[str[R] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            R++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前字符需要考虑并且之后不会再出现</span></span><br><span class="line">            <span class="comment">// 在 str[L..R]上所有需要考虑的字符中，找到 ASCII 码最小字符的位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pick</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> L; i &lt;= R; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map[str[i] - <span class="string">&#x27;a&#x27;</span>] != -<span class="number">1</span></span><br><span class="line">                        &amp;&amp; (pick == -<span class="number">1</span> || str[i] &lt; str[pick])) &#123;</span><br><span class="line">                    pick = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把 ASCII 码最小的字符放到挑选结果中</span></span><br><span class="line">            res[index++] = str[pick];</span><br><span class="line">            <span class="comment">// 在上一个 for 循环中，str[L..R]范围内每种字符出现的次数都减少了</span></span><br><span class="line">            <span class="comment">// 需要把 str[pick + 1..R]中每种字符出现的次数加回来</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> pick + <span class="number">1</span>; i &lt;= R; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map[str[i] - <span class="string">&#x27;a&#x27;</span>] != -<span class="number">1</span>) &#123; <span class="comment">// 只增加以后需要考虑字符的次数</span></span><br><span class="line">                    map[str[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 选出 ASCII 码最小的字符，以后不再考虑了</span></span><br><span class="line">            map[str[pick] - <span class="string">&#x27;a&#x27;</span>] = -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 继续在 str[pick + 1......]上重复这个过程</span></span><br><span class="line">            L = pick + <span class="number">1</span>;</span><br><span class="line">            R = L;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(res, <span class="number">0</span>, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组中两个字符串的最小距离"><a href="#数组中两个字符串的最小距离" class="headerlink" title="数组中两个字符串的最小距离"></a>数组中两个字符串的最小距离</h2><p><strong>题目</strong></p>
<p>给定一个字符串数组 strs，再给定两个字符串 str1 和 str2，返回在 strs 中 str1 与 str2 的最小距离，如果 str1 或 str2 为 null，或不在 strs 中，返回-1。</p>
<p><strong>举例</strong></p>
<p>strs=[“1”,”3”,”3”,”3”,”2”,”3”,”1”], str1=”1”, str2=”2”, 返回 2。<br>strs=[“CD”], str1=”CD”, str2=”AB”, 返回-1。</p>
<p><strong>进阶问题</strong>：如果查询发生的次数有很多，如何把每次查询的时间复杂度降为 O(1)？</p>
<p><strong>解答</strong></p>
<p><strong>原问题</strong>。从左到右遍历 strs，用变量 last1 记录最近一次出现 str1 的位置，用变量 last2 记录最近一次出现 str2 的位置。如果遍历到 str1，那么 i-last2 的值就是当前的 str1 和左边离它最近的 str2 之间的距离。如果遍历到 str2，那么 i-last1 的值就是当前的 str2 和左边离它最近的 str1 之间的距离。用变量 min 记录这些距离的最小值即可。请参看如下的 minDistance 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String[] strs, String str1, String str2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str1 == <span class="literal">null</span> || str2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str1.equals(str2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">last1</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">last2</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs[i].equals(str1)) &#123;</span><br><span class="line">            min = Math.min(min, last2 == -<span class="number">1</span> ? min : i - last2);</span><br><span class="line">            last1 = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (strs[i].equals(str2)) &#123;</span><br><span class="line">            min = Math.min(min, last1 == -<span class="number">1</span> ? min : i - last1);</span><br><span class="line">            last2 = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min == Integer.MAX_VALUE ? -<span class="number">1</span> : min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>进阶问题</strong>。其实是通过数组 strs 先生成某种记录，在查询时通过记录进行查询。本书提供了一种记录的结构供读者参考，如果 strs 的长度为 N，那么生成记录的时间复杂度为 O(N^2)，记录的空间复杂度为 O(N^2)，在生成记录之后，单次查询操作的时间复杂度可降为 O(1)。本书实现的记录其实是一个哈希表 HashMap<String, HashMap<String, Integer>&gt;，这是一个 key 为 string 类型、value 为哈希表类型的哈希表。为了描述清楚，我们把这个哈希表叫作外哈希表，把 value 代表的哈希表叫作内哈希表。外哈希表的 key 代表 strs 中的某种字符串，key 所对应的内哈希表表示其他字符串到 key 字符串的最小距离。比如，当 strs 为[“1”,”3”,”3”,”3”,”2”,”3”,”1”]时，生成的记录如下（外哈希表）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">key</th>
<th style="text-align:left">Value (Value 仍为一个哈希表，记为内哈希表)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">“1”</td>
<td style="text-align:left">(“2”, 2) -&gt; “1”到”2”的最小距离为 2<br>(“3”, 1) -&gt; “1”到”3”的最小距离为 1</td>
</tr>
<tr>
<td style="text-align:left">“2”</td>
<td style="text-align:left">(“1”, 2) -&gt; “2”到”1”的最小距离为 2<br>(“3”, 1) -&gt; “2”到”3”的最小距离为 1</td>
</tr>
<tr>
<td style="text-align:left">“3”</td>
<td style="text-align:left">(“1”, 1) -&gt; “3”到”1”的最小距离为 1<br>(“2”, 1) -&gt; “3”到”2”的最小距离为 1</td>
</tr>
</tbody>
</table>
</div>
<p>如果生成了这种结构的记录，那么查询 str1 和 str2 的最小距离时只用两次哈希查询操作就可以完成。<br>如下代码的 Record 类就是这种记录结构的具体实现，建立记录过程就是 Record 类的构造函数，Record 类中的 minDistance 方法就是做单次查询的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, HashMap&lt;String, Integer&gt;&gt; record;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Record</span><span class="params">(String[] strArr)</span> &#123;</span><br><span class="line">        record = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, HashMap&lt;String, Integer&gt;&gt;();</span><br><span class="line">        HashMap&lt;String, Integer&gt; indexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strArr.length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">curStr</span> <span class="operator">=</span> strArr[i];</span><br><span class="line">            update(indexMap, curStr, i);</span><br><span class="line">            indexMap.put(curStr, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HashMap&lt;String, Integer&gt; indexMap, String str, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!record.containsKey(str)) &#123;</span><br><span class="line">            record.put(str, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;String, Integer&gt; strMap = record.get(str);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; lastEntry : indexMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> lastEntry.getKey();</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> lastEntry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (!key.equals(str)) &#123;</span><br><span class="line">                HashMap&lt;String, Integer&gt; lastMap = record.get(key);</span><br><span class="line">                <span class="type">int</span> <span class="variable">curMin</span> <span class="operator">=</span> i - index;</span><br><span class="line">                <span class="keyword">if</span> (strMap.containsKey(key)) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">preMin</span> <span class="operator">=</span> strMap.get(key);</span><br><span class="line">                    <span class="keyword">if</span> (curMin &lt; preMin) &#123;</span><br><span class="line">                        strMap.put(key, curMin);</span><br><span class="line">                        lastMap.put(str, curMin);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    strMap.put(key, curMin);</span><br><span class="line">                    lastMap.put(str, curMin);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str1 == <span class="literal">null</span> || str2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str1.equals(str2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (record.containsKey(str1) &amp;&amp; record.get(str1).containsKey(str2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> record.get(str1).get(str2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串的转换路径问题"><a href="#字符串的转换路径问题" class="headerlink" title="字符串的转换路径问题"></a>字符串的转换路径问题</h2><p><strong>题目</strong></p>
<p>给定两个字符串，记为 start 和 to，再给定一个字符串列表 list，list 中一定包含 to，list 中没有重复字符串。所有的字符串都是小写的。规定 start 每次只能改变一个字符，最终的目标是彻底变成 to，但是每次变成的新字符串必须在 list 中存在。请返回所有最短的变换路径。</p>
<p><strong>举例</strong></p>
<p>start=”abc”, end=”cab”, list={“cab”, “acc”, “cbc”, “ccc”, “cac”, “cbb”, “aab”, “abb”}</p>
<p>转换路径的方法有很多种，但所有最短的转换路径如下：<br>abc -&gt; abb -&gt; aab -&gt; cab<br>abc -&gt; abb -&gt; cbb -&gt; cab<br>abc -&gt; cbc -&gt; cac -&gt; cab<br>abc -&gt; cbc -&gt; cbb -&gt; cab</p>
<p><strong>解答</strong></p>
<p><strong>步骤 1</strong>：把 start 加入 list，然后根据 list 生成每一个字符串的 nexts 信息。nexts 具体是指如果只改变一个字符，该字符串可以变成哪些字符串。比如，例子中的 list，先把”abc”加入 list，然后根据 list 生成信息如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">字符串</th>
<th style="text-align:left">nexts 信息</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">acc</td>
<td style="text-align:left">abc, ccc</td>
</tr>
<tr>
<td style="text-align:left">abb</td>
<td style="text-align:left">aab, cbb, abc</td>
</tr>
<tr>
<td style="text-align:left">ccc</td>
<td style="text-align:left">acc, cac, cbc</td>
</tr>
<tr>
<td style="text-align:left">cbb</td>
<td style="text-align:left">abb, cab, cbc</td>
</tr>
<tr>
<td style="text-align:left">abc</td>
<td style="text-align:left">abb, cbc, acc</td>
</tr>
<tr>
<td style="text-align:left">aab</td>
<td style="text-align:left">abb, cab</td>
</tr>
<tr>
<td style="text-align:left">cac</td>
<td style="text-align:left">cbc, cab, ccc</td>
</tr>
<tr>
<td style="text-align:left">cab</td>
<td style="text-align:left">aab, cbb, cac</td>
</tr>
<tr>
<td style="text-align:left">cbc</td>
<td style="text-align:left">abc, cac, cbb, ccc</td>
</tr>
</tbody>
</table>
</div>
<p>如何生成每一个字符串的 nexts 信息呢？首先把 list 中所有的字符串放入哈希表 set 中，这样检查某个字符串是否在 list 中，就可以通过查询 set 来实现，这么做是因为哈希表查询的时间复杂度为 O(1)，比遍历 list 查询某个字符串是否在其中要快得多。后续过程举例说明，比如字符串”acc”，要生成它的 nexts 信息。<br>因为所有的字符串都是小写，所以看”bcc”、”ccc”、”dcc”、”ecc”…”zcc”哪些在 set 中，就把那些放到”acc”的 nexts 列表中；然后看”aac”、”abc”、”adc”、”aec”…”azc”哪些在 set 中，就把那些放到”acc”的 nexts 列表中；最后看”aca”、”acb”、”acd”、”ace”…”acz”哪些在 set 中，就把那些放到”acc”的 nexts 列表中。也就是说，某个位置的字符都从 a~z 枚举，哪些在 set 中，就把哪些放到 nexts 列表中，但是不加入原始字符串。步骤 1 的代码实现请看如下的 getNexts 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> HashMap&lt;String, ArrayList&lt;String&gt;&gt; <span class="title function_">getNexts</span><span class="params">(List&lt;String&gt; words)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; dict = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(words);</span><br><span class="line">    HashMap&lt;String, ArrayList&lt;String&gt;&gt; nexts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.size(); i++) &#123;</span><br><span class="line">        nexts.put(words.get(i), <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.size(); i++) &#123;</span><br><span class="line">        nexts.put(words.get(i), getNext(words.get(i), dict));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nexts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;String&gt; <span class="title function_">getNext</span><span class="params">(String word, Set&lt;String&gt; dict)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[] chs = word.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; cur &lt;= <span class="string">&#x27;z&#x27;</span>; cur++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chs[i] != cur) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> chs[i];</span><br><span class="line">                chs[i] = cur;</span><br><span class="line">                <span class="keyword">if</span> (dict.contains(String.valueOf(chs))) &#123;</span><br><span class="line">                    res.add(String.valueOf(chs));</span><br><span class="line">                &#125;</span><br><span class="line">                chs[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤 2</strong>：有了每个字符串的 nexts 信息之后，相当于我们有了一张图，每个字符串相当于图中的一个点，nexts 信息相当于这个点的所有邻接节点。接下来从 start 字符串出发，利用 nexts 信息和宽度优先遍历的方式，求出每一个字符串到 start 的最短距离。图 5-1 中从”abc”出发，生成的距离信息如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">字符串</th>
<th style="text-align:left">到 start 的最短距离</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">abb</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">acc</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">cbb</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">ccc</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">abc</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">aab</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">cac</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">cbc</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">cab</td>
<td style="text-align:left">3</td>
</tr>
</tbody>
</table>
</div>
<p>步骤 2 的代码实现请看如下的 getDistances 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> HashMap&lt;String, Integer&gt; <span class="title function_">getDistances</span><span class="params">(String start,</span></span><br><span class="line"><span class="params">                                             HashMap&lt;String, ArrayList&lt;String&gt;&gt; nexts)</span> &#123;</span><br><span class="line">    HashMap&lt;String, Integer&gt; distances = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    distances.put(start, <span class="number">0</span>);</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(start);</span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    set.add(start);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (String str : nexts.get(cur)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(str)) &#123;</span><br><span class="line">                distances.put(str, distances.get(cur) + <span class="number">1</span>);</span><br><span class="line">                queue.add(str);</span><br><span class="line">                set.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤 3</strong>：从 start 出发往下走，保证每一步走到的字符串 cur 到 start 的最短距离都在加 1。如果能到 to，收集整条路。图 5-2 中从”abc”出发，每一步都通过字符串的 nexts 信息往下走，但是必须保证到 start 的最短距离是+1 递增的。图中画叉号的路都是因为最短距离没有+1 递增而终止了，最后对号的是在走的过程中遇到了 to，整条路应该记录下来。整个过程是标准的深度优先遍历，往下走的过程中，因为有最短距离要不停+1 递增的限制，所以走的岔路不可能无穷尽地展开，也不可能形成环。与题目的例子一样，答案为 4 条最短路径。步骤 3 的代码实现参见如下的 getShortestPaths 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getShortestPaths</span><span class="params">(String cur, String to,</span></span><br><span class="line"><span class="params">                              HashMap&lt;String, ArrayList&lt;String&gt;&gt; nexts,</span></span><br><span class="line"><span class="params">                              HashMap&lt;String, Integer&gt; distances, LinkedList&lt;String&gt; solution,</span></span><br><span class="line"><span class="params">                              List&lt;List&lt;String&gt;&gt; res)</span> &#123;</span><br><span class="line">    solution.add(cur);</span><br><span class="line">    <span class="keyword">if</span> (to.equals(cur)) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(solution));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String next : nexts.get(cur)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (distances.get(next) == distances.get(cur) + <span class="number">1</span>) &#123;</span><br><span class="line">                getShortestPaths(next, to, nexts, distances, solution, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    solution.pollLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程结束。这道题非常经典，图的宽度优先和深度优先遍历都用到了，考查非常全面。全部过程的主方法请看如下的 findMinPaths 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">findMinPaths</span><span class="params">(String start, String to,</span></span><br><span class="line"><span class="params">                                       List&lt;String&gt; list)</span> &#123;</span><br><span class="line">    list.add(start);</span><br><span class="line">    HashMap&lt;String, ArrayList&lt;String&gt;&gt; nexts = getNexts(list);</span><br><span class="line">    HashMap&lt;String, Integer&gt; distances = getDistances(start, nexts);</span><br><span class="line">    LinkedList&lt;String&gt; pathList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    getShortestPaths(start, to, nexts, distances, pathList, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加最少字符使字符串整体都是回文字符串"><a href="#添加最少字符使字符串整体都是回文字符串" class="headerlink" title="添加最少字符使字符串整体都是回文字符串"></a>添加最少字符使字符串整体都是回文字符串</h2><p><strong>题目</strong><br>给定一个字符串str，如果可以在str的任意位置添加字符，请返回在添加字符最少的情况下，让str整体都是回文字符串的一种结果。</p>
<p><strong>举例</strong><br>str=”ABA”，str本身就是回文串，返回”ABA”。<br>str=”AB”，可以在’A’之前添加’B’，返回”BAB”；也可以在’B’之后添加’A’，返回”ABA”。</p>
<p><strong>解答</strong></p>
<ol>
<li><p><strong>计算最少添加字符数（DP）</strong><br>定义动态规划表 <code>dp[i][j]</code> 表示 <code>str[i..j]</code> 最少需要添加几个字符才能变成回文串。</p>
<ul>
<li>如果 <code>str[i] == str[j]</code>，则 <code>dp[i][j] = dp[i+1][j-1]</code>。</li>
<li>如果 <code>str[i] != str[j]</code>，则 <code>dp[i][j] = Math.min(dp[i+1][j], dp[i][j-1]) + 1</code>。</li>
<li>基础情况：对角线 <code>dp[i][i] = 0</code>，对角线相邻 <code>dp[i][i+1]</code> 根据字符是否相等为 0 或 1。</li>
</ul>
</li>
<li><p><strong>构建回文串（方法一：基于DP表回溯）</strong><br>根据 <code>dp</code> 表还原路径：</p>
<ul>
<li>如果 <code>str[i] == str[j]</code>，说明这两个字符可以作为回文的两端，<code>res</code> 左右填入该字符，<code>i++</code>, <code>j--</code>。</li>
<li>如果 <code>str[i] != str[j]</code>，检查 <code>dp</code> 值来源：<ul>
<li>若 <code>dp[i][j-1]</code> 更小，说明优先处理 <code>str[i..j-1]</code>，<code>str[j]</code> 需要配对，<code>res</code> 左右填入 <code>str[j]</code>，<code>j--</code>。</li>
<li>若 <code>dp[i+1][j]</code> 更小，说明优先处理 <code>str[i+1..j]</code>，<code>str[i]</code> 需要配对，<code>res</code> 左右填入 <code>str[i]</code>，<code>i++</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>构建回文串（方法二：基于最长回文子序列）</strong><br>进阶问题：如果已经给定了 <code>str</code> 的最长回文子序列 <code>strlps</code>，如何在 <code>O(N)</code> 时间内构建结果？</p>
<ul>
<li>类似于“洋葱剥皮”：<code>strlps</code> 是核心，<code>str</code> 是外层。</li>
<li>遍历 <code>str</code> 和 <code>strlps</code>，如果 <code>str</code> 当前两端字符与 <code>strlps</code> 当前两端字符不匹配，说明 <code>str</code> 的该字符是多余的（不在 LPS 中），需要将其复制一份填入结果的两端。</li>
<li>如果匹配，则填入该字符并收缩 <code>strlps</code> 的范围。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成DP表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] getDP(<span class="type">char</span>[] str) &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[str.length][str.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; str.length; j++) &#123;</span><br><span class="line">            dp[j - <span class="number">1</span>][j] = str[j - <span class="number">1</span>] == str[j] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> j - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[i] == str[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法一：根据DP表构建回文串</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPalindrome1</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] chas = str.toCharArray();</span><br><span class="line">        <span class="type">int</span>[][] dp = getDP(chas);</span><br><span class="line">        <span class="type">char</span>[] res = <span class="keyword">new</span> <span class="title class_">char</span>[chas.length + dp[<span class="number">0</span>][chas.length - <span class="number">1</span>]];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> chas.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">resl</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">resr</span> <span class="operator">=</span> res.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chas[i] == chas[j]) &#123;</span><br><span class="line">                res[resl++] = chas[i++];</span><br><span class="line">                res[resr--] = chas[j--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i][j - <span class="number">1</span>] &lt; dp[i + <span class="number">1</span>][j]) &#123;</span><br><span class="line">                res[resl++] = chas[j];</span><br><span class="line">                res[resr--] = chas[j--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[resl++] = chas[i];</span><br><span class="line">                res[resr--] = chas[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法二：根据最长回文子序列构建（进阶）</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPalindrome2</span><span class="params">(String str, String strips)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] chas = str.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] lps = strips.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] res = <span class="keyword">new</span> <span class="title class_">char</span>[chas.length * <span class="number">2</span> - lps.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">chaL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">chaR</span> <span class="operator">=</span> chas.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lpsL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lpsR</span> <span class="operator">=</span> lps.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">resL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">resR</span> <span class="operator">=</span> res.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmpL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmpR</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (lpsL &lt;= lpsR) &#123;</span><br><span class="line">            tmpL = chaL;</span><br><span class="line">            tmpR = chaR;</span><br><span class="line">            <span class="keyword">while</span> (chas[chaL] != lps[lpsL]) &#123;</span><br><span class="line">                chaL++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (chas[chaR] != lps[lpsR]) &#123;</span><br><span class="line">                chaR--;</span><br><span class="line">            &#125;</span><br><span class="line">            set(res, resL, resR, chas, tmpL, chaL, tmpR, chaR);</span><br><span class="line">            resL += chaL - tmpL + tmpR - chaR;</span><br><span class="line">            resR -= chaL - tmpL + tmpR - chaR;</span><br><span class="line">            res[resL++] = chas[chaL++];</span><br><span class="line">            res[resR--] = chas[chaR--];</span><br><span class="line">            lpsL++;</span><br><span class="line">            lpsR--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">char</span>[] res, <span class="type">int</span> resL, <span class="type">int</span> resR, <span class="type">char</span>[] chas, <span class="type">int</span> ls, <span class="type">int</span> le, <span class="type">int</span> rs, <span class="type">int</span> re)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ls; i &lt; le; i++) &#123;</span><br><span class="line">            res[resL++] = chas[i];</span><br><span class="line">            res[resR--] = chas[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> re; i &gt; rs; i--) &#123;</span><br><span class="line">            res[resL++] = chas[i];</span><br><span class="line">            res[resR--] = chas[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="括号字符串的有效性和最长有效长度"><a href="#括号字符串的有效性和最长有效长度" class="headerlink" title="括号字符串的有效性和最长有效长度"></a>括号字符串的有效性和最长有效长度</h2><p><strong>题目</strong><br>给定一个字符串str，判断是不是整体有效的括号字符串。</p>
<p><strong>举例</strong><br>str=”()”，返回true；str=”((()))”，返回true；str=”()()”，返回true。<br>str=”())”。返回false；str=”()(“，返回false；str=”()a()”，返回false。<br>补充问题：给定一个括号字符串str，返回最长的有效括号子串。</p>
<p><strong>举例</strong><br>str=”(()())”，返回6；str=”())”，返回2；str=”()(()()(“，返回4。</p>
<p><strong>解答</strong><br>原问题。判断过程如下：</p>
<ol>
<li>从左到右遍历字符串str，判断每一个字符是不是’(‘或’)’，如果不是，就直接返回false。</li>
<li>遍历到每一个字符时，都检查到目前为止’(‘和’)’的数量，如果’)’更多，则直接返回false。</li>
<li>遍历后检查’(‘和’)’的数量，如果一样多，则返回true，否则返回false。<br>具体过程参看如下代码中的isValid方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span> || str.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] chas = str.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chas.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chas[i] != <span class="string">&#x27;)&#x27;</span> &amp;&amp; chas[i] != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (chas[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; --status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (chas[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            status++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充问题。用动态规划求解，可以做到时间复杂度为O(N)，额外空间复杂度为O(N)。首先生成长度和str字符串一样的数组dp[]，dp[i]值的含义为str[0..i]中必须以字符str[i]结尾的最长有效括号子串长度。那么dp[i]值可以按如下方式求解：</p>
<ol>
<li>dp[0]=0。只含有一个字符肯定不是有效括号字符串，长度自然是0。</li>
<li>从左到右依次遍历str[1..N-1]的每个字符，假设遍历到str[i]。</li>
<li>如果str[i]==’(‘，有效括号字符串必然是以’)’结尾，而不是以’(‘结尾，所以dp[i]=0。</li>
<li>如果str[i]==’)’，那么以str[i]结尾的最长有效括号子串可能存在。dp[i-1]的值代表必须以str[i-1]结尾的最长有效括号子串的长度，所以，如果i-dp[i-1]-1位置上的字符是’(‘，就能与当前位置的str[i]字符再配出一对有效括号。比如”(()())”，假设遍历到最后一个字符’)’，必须以倒数第二个字符结尾的最长有效括号子串是”()”，找到这个子串之前的字符，即i-dp[i-1]-1位置的字符，发现是’(‘，所以它可以和最后一个字符再配出一对有效括号。如果该情况发生，dp[i]的值起码是dp[i-1]+2，但还有一部分长度容易被人忽略。比如，”()(())”，假设遍历到最后一个字符’)’，通过上面的过程找到的必须以最后字符结尾的最长有效括号子串起码是”(())”，但是前面还有一段”()”，可以和”(())”结合在一起构成更大的有效括号子串。也就是说，str[i-dp[i-1]-1]和str[i]配成了一对，这时还应该把dp[i-dp[i-1]-2]的值加到dp[i]中，这样做表示把str[i-dp[i-1]-2]结尾的最长有效括号子串接到前面，才能得到以当前字符结尾的最长有效括号子串。</li>
<li>dp[0..N-1]中的最大值就是最终结果。<br>具体过程请参看如下代码中的maxLength方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxLength</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span> || str.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] chas = str.toCharArray();</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[chas.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; chas.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chas[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            pre = i - dp[i - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (pre &gt;= <span class="number">0</span> &amp;&amp; chas[pre] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span> + (pre &gt; <span class="number">0</span> ? dp[pre - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="公式字符串求值"><a href="#公式字符串求值" class="headerlink" title="公式字符串求值"></a>公式字符串求值</h2><p><strong>题目</strong><br>给定一个字符串str，str表示一个公式，公式里可能有整数、加减乘除符号和左右括号，返回公式的计算结果。</p>
<p><strong>举例</strong><br>str=”48<em>((70-65)-43)+8</em>1”，返回-1816。<br>str=”3+1<em>4”，返回7。<br>str=”3+(1</em>4)”，返回7。</p>
<p><strong>说明</strong></p>
<ol>
<li>可以认为给定的字符串一定是正确的公式，即不需要对str做公式有效性检查。</li>
<li>如果是负数，就需要用括号括起来，比如”4<em>(-3)”。但如果负数作为公式的开头或括号部分的开头，则可以没有括号，比如”-3</em>4”和”(-3*4)”都是合法的。</li>
<li>不用考虑计算过程中会发生溢出的情况。</li>
</ol>
<p><strong>解答</strong><br>本题考查面试者设计程序和代码实现的能力，实现方式有很多，本书提供一种方法供读者参考。假设 <code>value</code> 方法是一个递归过程，具体解释如下。<br>从左到右遍历 <code>str</code>，开始遍历或者遇到字符 <code>(</code> 时，就进行递归过程。当发现 <code>str</code> 遍历完，或者遇到字符 <code>)</code> 时，递归过程就结束。<br>比如 <code>3*(4+5)+7</code>，一开始遍历就进入递归过程 <code>value(str, 0)</code>，在递归过程 <code>value(str, 0)</code> 中继续遍历 <code>str</code>，当遇到字符 <code>(</code> 时，递归过程 <code>value(str, 0)</code> 又重复调用递归过程 <code>value(str, 3)</code>。然后在递归过程 <code>value(str, 3)</code> 中继续遍历 <code>str</code>，当遇到字符 <code>)</code> 时，递归过程 <code>value(str, 3)</code> 结束，并向递归过程 <code>value(str, 0)</code> 返回两个结果，第一结果是 <code>value(str, 3)</code> 遍历过的公式字符串的结果，即 <code>4+5</code>=9，第二个结果是 <code>value(str, 3)</code> 遍历到的位置，即字符 <code>)</code> 的位置==6。递归过程 <code>value(str, 0)</code> 收到这两个结果后，既可知道交给 <code>value(str, 3)</code> 过程处理的字符串结果是多少（<code>(4+5)</code> 的结果是 9），又可知道自己下一步该从什么位置继续遍历（该从位置 6 的下一个位置（即位置 7）继续遍历）。总之，<code>value</code> 方法的第二个参数代表递归过程是从什么位置开始的，返回的结果是一个长度为 2 的数组，记为 <code>res</code>。<code>res[0]</code> 表示这个递归过程计算的结果，<code>res[1]</code> 表示这个递归过程遍历到 <code>str</code> 的什么位置。</p>
<p>既然在递归过程中遇到 <code>(</code> 就交给下一层的递归过程处理，自己只用接收 <code>(</code> 和 <code>)</code> 之间的公式字符串的结果，所以对所有的递归过程来说，可以看作计算的公式都是不含 <code>(</code> 和 <code>)</code> 字符的。比如，对递归过程 <code>value(str, 0)</code> 来说，实际上计算的公式是 <code>3*9+7</code>，<code>(4+5)</code> 的部分交给递归过程 <code>value(str, 3)</code> 处理，拿到结果 9 之后，再从字符 <code>+</code> 继续。所以，只要想清楚如何计算一个不含 <code>(</code> 和 <code>)</code> 的公式字符串，整个实现就完成了。</p>
<p>全部过程请参看如下代码中的 <code>getValue</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(String exp)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value(exp.toCharArray(), <span class="number">0</span>)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] value(<span class="type">char</span>[] chars, <span class="type">int</span> i) &#123;</span><br><span class="line">        Deque&lt;String&gt; deq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] bra = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; chars.length &amp;&amp; chars[i] != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; chars[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                pre = pre * <span class="number">10</span> + chars[i++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars[i] != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                addNum(deq, pre);</span><br><span class="line">                deq.addLast(String.valueOf(chars[i++]));</span><br><span class="line">                pre = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bra = value(chars, i + <span class="number">1</span>);</span><br><span class="line">                pre = bra[<span class="number">0</span>];</span><br><span class="line">                i = bra[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addNum(deq, pre);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; getNum(deq), i &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(Deque&lt;String&gt; deq, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!deq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">top</span> <span class="operator">=</span> deq.pollLast();</span><br><span class="line">            <span class="keyword">if</span> (top.equals(<span class="string">&quot;+&quot;</span>) || top.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                deq.addLast(top);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = Integer.valueOf(deq.pollLast());</span><br><span class="line">                num = top.equals(<span class="string">&quot;*&quot;</span>) ? (cur * num) : (cur / num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        deq.addLast(String.valueOf(num));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">(Deque&lt;String&gt; deq)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">add</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!deq.isEmpty()) &#123;</span><br><span class="line">            cur = deq.pollFirst();</span><br><span class="line">            <span class="keyword">if</span> (cur.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                add = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                add = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num = Integer.valueOf(cur);</span><br><span class="line">                res += add ? num : (-num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0-左边必有-1-的二进制字符串数量"><a href="#0-左边必有-1-的二进制字符串数量" class="headerlink" title="0 左边必有 1 的二进制字符串数量"></a>0 左边必有 1 的二进制字符串数量</h2><p><strong>题目</strong><br>给定一个整数 N，求由 “0” 字符与 “1” 字符组成的长度为 N 的所有字符串中，满足 “0” 字符的左边必有 “1” 字符的字符串数量。</p>
<p><strong>举例</strong><br>N=1。由 “0” 与 “1” 组成，长度为 1 的所有字符串：”0”、”1”。只有字符串 “1” 满足要求，所以返回 1。<br>N=2。由 “0” 与 “1” 组成，长度为 2 的所有字符串：”00”、”01”、”10”、”11”。只有字符串 “10” 和 “11” 满足要求，所以返回 2。<br>N=3。由 “0” 与 “1” 组成，长度为 3 的所有字符串：”000”、”001”、”010”、”011”、”100”、”101”、”110”、”111”。字符串 “101”、”110”、”111” 满足要求，所以返回 3。</p>
<p><strong>解答</strong></p>
<ol>
<li><p><strong>递归方法（$O(2^N)$）</strong><br>分析题目要求，“0”字符的左边必有“1”字符，说明最高位（第 1 位）必须是 ‘1’。<br>假设 $p(i)$ 表示 $0 \sim i-1$ 位置上的字符已经确定，且符合要求，第 $i-1$ 位置的字符为 ‘1’ 时，如果穷举 $i \sim N-1$ 位置上的所有情况，会产生多少种符合要求的字符串。</p>
<ul>
<li>如果位置 $i$ 放 ‘1’，那么 $i$ 位置是 ‘1’，符合要求，接下来就是求解 $p(i+1)$。</li>
<li>如果位置 $i$ 放 ‘0’，那么要求位置 $i+1$ 必须是 ‘1’（因为 ‘0’ 左边必须是 ‘1’，这里 ‘0’ 左边是 $i-1$ 的 ‘1’，符合；但 ‘0’ 自己作为左边时，右边 $i+1$ 必须是 ‘1’ 才能让 ‘0’ 合法？不对，题目是“0左边必有1”，只要当前是0，前一个必须是1。既然 $i-1$ 是 1，那么 $i$ 可以是 0。如果 $i$ 是 0，那么 $i$ 作为 $i+1$ 的左边， $i+1$ 必须不能是 0 吗？题目只说 0 左边必有 1。</li>
</ul>
<p>重新梳理：</p>
<ul>
<li>如果 $i$ 位置放 ‘1’，那么 $i$ 位置就是 ‘1’，对 $i+1$ 位置没有特殊限制（只要 $i+1$ 满足题目全局要求即可），问题规模缩小为 $p(i+1)$。</li>
<li>如果 $i$ 位置放 ‘0’，由于 $i-1$ 是 ‘1’，这个 ‘0’ 是合法的。但是这个 ‘0’ 处在 $i$ 位置，它作为 $i+1$ 位置的左边，会导致 $i+1$ 位置必须是 ‘1’（因为 $i+1$ 如果是 0，左边 $i$ 必须是 1，但 $i$ 是 0，矛盾）。所以如果 $i$ 放 ‘0’，$i+1$ 必须放 ‘1’。确定了 $i$ 和 $i+1$，问题规模缩小为 $p(i+2)$。</li>
<li>所以 $p(i) = p(i+1) + p(i+2)$。</li>
<li>初始状态：$p(N) = 1$（所有都确定了，算 1 种），$p(N-1) = 2$（最后一位可以是 0 或 1，因为前一位是 1）。</li>
</ul>
<p>这实际上就是斐波那契数列。</p>
</li>
<li><p><strong>动态规划/迭代方法（$O(N)$）</strong><br>当 N 分别为 1, 2, 3, 4, 5… 时，结果为 1, 2, 3, 5, 8…<br>这就是斐波那契数列 $F(N)$，其中 $F(1)=1, F(2)=2, F(i)=F(i-1)+F(i-2)$。<br>可以用简单的循环实现。</p>
</li>
<li><p><strong>矩阵乘法方法（$O(\log N)$）</strong><br>既然是斐波那契数列，可以用矩阵乘法加速求解。</p>
<script type="math/tex; mode=display">
\begin{bmatrix} F(n) & F(n-1) \end{bmatrix} = \begin{bmatrix} F(n-1) & F(n-2) \end{bmatrix} \times \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}</script><p>通过矩阵快速幂可以在 $O(\log N)$ 时间内求出结果。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法一：暴力递归 O(2^N)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> process(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> process(i + <span class="number">1</span>, n) + process(i + <span class="number">2</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法二：迭代求解 O(N)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            tmp = cur;</span><br><span class="line">            cur += pre;</span><br><span class="line">            pre = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法三：矩阵乘法 O(logN)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum3</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] base = &#123; &#123; <span class="number">1</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span> &#125; &#125;;</span><br><span class="line">        <span class="type">int</span>[][] res = matrixPower(base, n - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * res[<span class="number">0</span>][<span class="number">0</span>] + res[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] matrixPower(<span class="type">int</span>[][] m, <span class="type">int</span> p) &#123;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[m.length][m[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] tmp = m;</span><br><span class="line">        <span class="keyword">for</span> (; p != <span class="number">0</span>; p &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                res = muliMatrix(res, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = muliMatrix(tmp, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] muliMatrix(<span class="type">int</span>[][] m1, <span class="type">int</span>[][] m2) &#123;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[m1.length][m2[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m2[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; m2.length; k++) &#123;</span><br><span class="line">                    res[i][j] += m1[i][k] * m2[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拼接所有字符串产生字典顺序最小的大写字符串"><a href="#拼接所有字符串产生字典顺序最小的大写字符串" class="headerlink" title="拼接所有字符串产生字典顺序最小的大写字符串"></a>拼接所有字符串产生字典顺序最小的大写字符串</h2><p><strong>题目</strong><br>给定一个字符串类型的数组 strs，请找到一种拼接顺序，使得将所有的字符串拼接起来组成的大写字符串是所有可能性中字典顺序最小的，并返回这个大写字符串。</p>
<p><strong>举例</strong><br>strs=[ “abc”, “de” ]，可以拼成”abcde”，也可以拼成”deabc”，但前者的字典顺序更小，所以返回”abcde”。<br>strs=[ “b”, “ba” ]，可以拼成”bba”，也可以拼成”bab”，但后者的字典顺序更小，所以返回”bab”。</p>
<p><strong>解答</strong><br>有一种思路为：先把 strs 中的字符串按照字典顺序排序，然后将串起来的结果返回。这么做是错误的，比如题目中的例子 2，按照字典排序结果是 B、BA，串起来的大写字符串为”BBA”，但是字典顺序最小的大写字符串是”BAB”，所以按照单个字符串的字典顺序进行排序的想法是行不通的。如果要排序，应该按照下文描述的标准进行排序。</p>
<p>假设有两个字符串，分别记为 a 和 b。a 和 b 拼起来的字符串表示为 a.b。那么如果 a.b 的字典顺序小于 b.a，就把字符串 a 放在前面，否则把字符串 b 放在前面。每两个字符串之间都按照这个标准进行比较，以此标准排序后，再次串起来的大写字符串就是结果。</p>
<p>本题的解法看似非常简单，但解法有效性的证明却比较复杂。在这里不得不提醒读者，这道题的解题方法可以划进贪心算法的范畴，这种有效的比较方式就是我们的贪心策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (a + b).compareTo(b + a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">lowestString</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据新的比较方式排序</span></span><br><span class="line">        Arrays.sort(strs, <span class="keyword">new</span> <span class="title class_">MyComparator</span>());</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            res += strs[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="找到字符串的最长无重复字符子串"><a href="#找到字符串的最长无重复字符子串" class="headerlink" title="找到字符串的最长无重复字符子串"></a>找到字符串的最长无重复字符子串</h2><p><strong>题目</strong><br>给定一个字符串 str，返回 str 的最长无重复字符子串的长度。</p>
<p><strong>举例</strong><br>str=”abcd”，返回 4。<br>str=”aabcb”，最长无重复字符子串为”abc”，返回 3。</p>
<p><strong>要求</strong><br>如果 str 的长度为 N，请实现时间复杂度为 O(N) 的方法。</p>
<p><strong>解答</strong><br>如果 str 长度为 N，字符编码范围是 M，本题可做到时间复杂度为 O(N)，额外空间复杂度为 O(M)。下面介绍这种方法的具体实现。</p>
<ol>
<li>在遍历 str 之前，先申请几个变量。哈希表 map，key 表示某个字符，value 为这个字符最近一次出现的位置。整型变量 pre，如果当前遍历到字符 <code>str[i]</code>，pre 表示在必须以 <code>str[i-1]</code> 字符结尾的情况下，最长无重复字符子串开始位置的前一个位置，初始时 pre=-1。整型变量 len，记录以每一个字符结尾的情况下，最长无重复字符子串长度的最大值，初始时，len=0。从左到右依次遍历 str，假设现在遍历到 <code>str[i]</code>，接下来求在必须以 <code>str[i]</code> 结尾的情况下，最长无重复字符子串的长度。</li>
<li><code>map(str[i])</code> 的值表示之前的遍历中最近一次出现 <code>str[i]</code> 字符的位置，假设在 a 位置。想要以 <code>str[i]</code> 结尾的最长无重复子串，a 位置必然不能包含进来，因为 <code>str[a]</code> 等于 <code>str[i]</code>。</li>
<li>根据 pre 的定义，pre+1 表示在必须以 <code>str[i-1]</code> 字符结尾的情况下，最长无重复字符子串的开始位置。也就是说，以 <code>str[i-1]</code> 结尾的最长无重复子串是向左扩到 pre 位置停止的。</li>
<li>如果 pre 位置在 a 位置的左边，因为 <code>str[a]</code> 不能包含进来，而 <code>str[a+1..i-1]</code> 上都是不重复的，所以以 <code>str[i]</code> 结尾的最长无重复字符子串就是 <code>str[a+1..i]</code>。如果 pre 位置在 a 位置的右边，以 <code>str[i-1]</code> 结尾的最长无重复子串是向左扩到 pre 位置停止的。所以以 <code>str[i]</code> 结尾的最长无重复子串向左扩到 pre 位置也必然会停止，而且 <code>str[pre+1..i-1]</code> 这一段肯定不含有 <code>str[i]</code>，所以以 <code>str[i]</code> 结尾的最长无重复字符子串就是 <code>str[pre+1..i]</code>。</li>
<li>计算完长度之后，pre 位置和 a 位置哪一个在右边，就作为新的 pre 值。然后计算下一个位置的字符，整个过程中求得所有长度的最大值用 len 记录下来返回即可。<br>具体请参看如下代码中的 <code>maxUnique</code> 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxUnique</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] chas = str.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">            map[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != chas.length; i++) &#123;</span><br><span class="line">            pre = Math.max(pre, map[chas[i]]);</span><br><span class="line">            cur = i - pre;</span><br><span class="line">            len = Math.max(len, cur);</span><br><span class="line">            map[chas[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="找到指定的新类型字符"><a href="#找到指定的新类型字符" class="headerlink" title="找到指定的新类型字符"></a>找到指定的新类型字符</h2><p><strong>题目</strong><br>新类型字符的定义如下：</p>
<ol>
<li>新类型字符是长度为 1 或者 2 的字符串。</li>
<li>表现形式可以仅是小写字母，例如，”e”；也可以是大写字母+小写字母，例如，”Ab”；还可以是大写字母+大写字母，例如，”DC”。<br>现在给定一个字符串 str，str 一定是若干新类型字符正确组合的结果。比如”eaCCBi”，由新类型字符”e”、”a”、”CC”和”Bi”拼成。再给定一个整数 k，代表 str 中的位置。请返回被 k 位置指定的新类型字符。</li>
</ol>
<p><strong>举例</strong><br>str=”aaABCDEcBCg”。</p>
<ol>
<li>k=7 时，返回”Ec”。</li>
<li>k=4 时，返回”CD”。</li>
<li>k=10 时，返回”g”。</li>
</ol>
<p><strong>解答</strong><br>一种笨方法是从 str[0] 开始，从左到右依次划分出新类型字符，到 k 位置的时候就知道指向的新类型字符是什么。比如 str=”aaABCDEcBCg”，k=7。从左到右可以依次划分出”a”、”a”、”AB”、”CD”。然后发现 str[7] 是大写字母’E’，所以被指定的新类型字符一定是”EC”，返回即可。</p>
<p>更快的方法。从 k-1 位置开始，向左统计连续出现的大写字母的数量记为 uNum，遇到小写字母就停止。</p>
<ul>
<li>如果 uNum 为奇数，str[k-1..k] 是被指定的新类型字符，见例子 1。</li>
<li>如果 uNum 为偶数且 str[k] 是大写字母，str[k..k+1] 是被指定的新类型字符，见例子 2。</li>
<li>如果 uNum 为偶数且 str[k] 是小写字母，str[k] 是被指定的新类型字符，见例子 3。</li>
</ul>
<p>具体过程请参看如下代码中的 <code>pointNewchar</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pointNewchar</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.equals(<span class="string">&quot;&quot;</span>) || k &lt; <span class="number">0</span> || k &gt;= s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] chas = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">uNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Character.isUpperCase(chas[i])) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            uNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((uNum &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s.substring(k - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Character.isUpperCase(chas[k])) &#123;</span><br><span class="line">            <span class="keyword">return</span> s.substring(k, k + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(chas[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="旋变字符串问题"><a href="#旋变字符串问题" class="headerlink" title="旋变字符串问题"></a>旋变字符串问题</h2><p><strong>题目</strong><br>一个字符串可以分解成多种二叉树结构。如果 str 长度为 1，认为不可分解；如果 str 长度为 N (N&gt;1)，左部分长度可以为 1~N-1，剩下的为右部分的长度。左部分和右部分都可以按照同样的逻辑，继续分解。形成的所有结构都是 str 的二叉树结构。比如，字符串”abcd”，可以分解成五种结构，分别如图 5-3~图 5-7 所示。<br>（此处省略图示，图示展示了字符串分解为二叉树的不同形态，例如 “abcd” 分为 “a” 和 “bcd”，”bcd” 再分…）</p>
<p>任何一个 str 的二叉树结构中，如果两个节点有共同的父节点，那么这两个节点可以交换位置，这两个节点叫作一个交换组。一个结构会有很多交换组，每个交换组都可以选择进行交换或者不交换，最终形成一个新的结构，这个新结构所代表的字符串叫作 str 的旋变字符串。比如，在图 5-7 中的交换组有 a 和 b、ab 和 c、abc 和 d。如果让 a 和 b 的组交换，让 ab 和 c 的组不交换，让 abc 和 d 的组交换，形成的结构如图 5-8 所示。<br>（此处省略图示，图示展示了 “abcd” 经过部分交换变为 “dbac”）</p>
<p>这个新结构所代表的字符串为”dbac”，叫作”abcd”的旋变字符串。也就是说，一个字符串 str 的旋变字符串是非常多的，str 可以形成很多种结构，每一种结构都有很多交换组，每一个交换组都可以选择交换或者不交换，形成的每一个新的字符串都叫 str 的旋变字符串。<br>给定两个字符串 str1 和 str2，判断 str2 是不是 str1 的旋变字符串。</p>
<p><strong>要求</strong><br>str1 和 str2 长度为 N，时间复杂度做到 $O(N^4)$。</p>
<p><strong>解答</strong><br>首先判断 str1 和 str2 包含的字符种类是否一样且每一种字符出现的数量也一样，如果不满足，str2 一定不是 str1 的旋变字符串。<br>接下来可能很多读者会根据如此灵活的旋变变化猜一个结论：str1 所有字符的全排列中，每一种都是 str1 的旋变字符串。这个猜测是不对的。比如 str1=”abcd”，str2=”cadb”，str2 就不是 str1 的旋变字符串。理由如下：</p>
<ol>
<li>如果让”abcd”最开始划分的左部分为”abc”，右部分为”d”。想要最终得到”cadb”，’c’就要在’d’的左边。所以左部分和右部分不能交换。这样左部分的’b’就会继续留在’d’的左边。但是在最终结果中，’b’在’d’的右边。所以这种划分无论怎么交换都不能得到”cadb”。</li>
<li>如果让”abcd”最开始划分的左部分为”ab”，右部分为”cd”。想要最终得到”cadb”，’c’就要在’a’的左边。所以左部分和右部分必须交换。这样右部分的’d’就会移动到左部分’a’的右边。但是在最终结果中，’b’和’d’在’a’的右边。所以这种划分无论怎么交换都不能得到”cadb”。</li>
<li>如果让”abcd”最开始划分的左部分为”a”，右部分为”bcd”。想要最终得到”cadb”，’c’就要在’a’的左边。所以左部分和右部分必须交换。这样右部分的’b’和’d’就会移动到左部分’a’的左边。但是在最终结果中，’b’和’d’在’a’的右边。所以这种划分无论怎么交换都不能得到”cadb”。</li>
</ol>
<p>以上三种情况已经穷举了”abcd”第一次分割的所有可能性，”abcd”没有旋变出”cadb”的可能性。进而说明，str1 所有字符的全排列中，每一种是 str1 旋变字符串的猜测是不成立的。</p>
<p>验证 str1 和 str2 包含的字符种类是否一样且每一种字符出现的数量也一样的过程，请看如下的 <code>sameTypeSameNumber</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sameTypeSameNumber</span><span class="params">(<span class="type">char</span>[] str1, <span class="type">char</span>[] str2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str1.length != str2.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str1.length; i++) &#123;</span><br><span class="line">        map[str1[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str2.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--map[str2[i]] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题使用了暴力递归优化成动态规划的套路，不熟悉套路的读者请先阅读本书“机器人达到指定位置方法数”问题的解答。本题先验证 str2 是不是 str1 的旋变字符串的所有可能会尝试。只有尝试方法最重要，而且没有任何固定套路可以总结如何去尝试。要判断 str2 是不是 str1 的旋变字符串，思路是尝试每一种 str1 的初次划分。比如，如果 str1 和 str2 长度为 N，判断 <code>str1[0..N-1]</code> 和 <code>str2[0..N-1]</code> 是否互为旋变字符串的过程如下：</p>
<ol>
<li>如果 <code>str1[0..0]</code> 和 <code>str2[0..0]</code> 互为旋变，并且 <code>str1[1..N-1]</code> 和 <code>str2[1..N-1]</code> 互为旋变，则 str1 和 str2 互为旋变字符串；如果 <code>str1[0..0]</code> 和 <code>str2[N-1..N-1]</code> 互为旋变，并且 <code>str1[1..N-1]</code> 和 <code>str2[0..N-2]</code> 互为旋变，则 str1 和 str2 互为旋变字符串。</li>
<li>如果 <code>str1[0..1]</code> 和 <code>str2[0..1]</code> 互为旋变，并且 <code>str1[2..N-1]</code> 和 <code>str2[2..N-1]</code> 互为旋变，则 str1 和 str2 互为旋变字符串；如果 <code>str1[0..1]</code> 和 <code>str2[N-2..N-1]</code> 互为旋变，并且 <code>str1[2..N-1]</code> 和 <code>str2[0..N-3]</code> 互为旋变，则 str1 和 str2 互为旋变字符串。<br>…<br>i. 如果 <code>str1[0..i]</code> 和 <code>str2[0..i]</code> 互为旋变，并且 <code>str1[i+1..N-1]</code> 和 <code>str2[i+1..N-1]</code> 互为旋变，则 str1 和 str2 互为旋变字符串；如果 <code>str1[0..i]</code> 和 <code>str2[N-i-1..N-1]</code> 互为旋变，并且 <code>str1[i+1..N-1]</code> 和 <code>str2[0..N-i-2]</code> 互为旋变，则 str1 和 str2 互为旋变字符串。<br>…<br>N-2. 如果 <code>str1[0..N-2]</code> 和 <code>str2[0..N-2]</code> 互为旋变，并且 <code>str1[N-1..N-1]</code> 和 <code>str2[N-1..N-1]</code> 互为旋变，则 str1 和 str2 互为旋变字符串；如果 <code>str1[0..N-2]</code> 和 <code>str2[1..N-1]</code> 互为旋变，并且 <code>str1[N-1..N-1]</code> 和 <code>str2[0..0]</code> 互为旋变，则 str1 和 str2 互为旋变字符串。<br>N-1. 如果 <code>str1[0..N-1]</code> 和 <code>str2[0..N-1]</code> 每个对应位置上的字符都相等，则 str1 和 str2 互为旋变字符串。</li>
</ol>
<p>一共枚举 N 种情况。有一个可以算出是旋变就返回 true，都算不出来则返回 false。<br>根据如上分析，现在推广到这样一个问题，判断 str1 从 L1 开始往右长度为 size 的子串和 str2 从 L2 开始往右长度为 size 的子串是否互为旋变字符串，代码请看如下的 <code>process</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 str1[从 L1 开始往右长度为 size 的子串] 和 str2[从 L2 开始往右长度为 size 的子串] 是否互为旋变字符串</span></span><br><span class="line"><span class="comment">// 在 str1 中的这一段和 str2 中的这一段是等长的，所以只用一个参数 size</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(<span class="type">char</span>[] str1, <span class="type">char</span>[] str2, <span class="type">int</span> L1, <span class="type">int</span> L2, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> str1[L1] == str2[L2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 枚举每一种情况，有一个计算出互为旋变就返回 true，都算不出来则返回 false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">leftPart</span> <span class="operator">=</span> <span class="number">1</span>; leftPart &lt; size; leftPart++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((process(str1, str2, L1, L2, leftPart) &amp;&amp;</span><br><span class="line">                process(str1, str2, L1 + leftPart, L2 + leftPart, size - leftPart))</span><br><span class="line">                ||</span><br><span class="line">                (process(str1, str2, L1, L2 + size - leftPart, leftPart) &amp;&amp;</span><br><span class="line">                        process(str1, str2, L1 + leftPart, L2, size - leftPart))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终答案是 str1[从 0 开始往右长度为 N 的子串] 和 str2[从 0 开始往右长度为 N 的子串] 是否互为旋变字符串，所以全部过程请看如下的 <code>isScramble1</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isScramble1</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((s1 == <span class="literal">null</span> &amp;&amp; s2 != <span class="literal">null</span>) || (s1 != <span class="literal">null</span> &amp;&amp; s2 == <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s1 == <span class="literal">null</span> &amp;&amp; s2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s1.equals(s2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] str1 = s1.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] str2 = s2.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (!sameTypeSameNumber(str1, str2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> s1.length();</span><br><span class="line">    <span class="keyword">return</span> process(str1, str2, <span class="number">0</span>, <span class="number">0</span>, N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暴力递归改动态规划，利用优化套路过程如下：<br>前提是尝试过程是无后效性的。<code>process(L1, L2, size)</code> 解决的问题就是 str1[从 L1 开始往右长度为 N 的子串] 和 str2[从 L2 开始往右长度为 N 的子串] 是否互为旋变字符串，不管如何到达 <code>process(L1, L2, size)</code> 状态，返回值一定是固定的。<br>1) 可变参数 L1、L2、size 一旦确定，返回值就确定了。<br>2) 如果可变参数 L1、L2、size 组合的所有情况组成一张表，这张表一定可以装下所有的返回值。假设 str1 和 str2 长度为 N，L1 和 L2 变量的含义分别是 str1 中的位置和 str2 中的位置，所以 L1 和 L2 一定不会在 0~N-1 的范围之外。size 的含义是长度为 size 的子串，所以 size 一定不会在 1~N 的范围之外。那么这三个参数的全部组合构成一个立方体，记为 <code>dp[N][N][N+1]</code>，第一维对应 L1，第二维对应 L2，第三维（高）对应 size。<br>3) 我们要的最终状态是 <code>process(0,0,N)</code>，也就是 <code>dp[0][0][N]</code> 的值。<br>4) 根据 <code>process(L1, L2, size)</code> 函数的 base case，填写初始的位置：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> str1[L1] == str2[L2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   size==1 时，就是由 L1 和 L2 的轴组成的二维平面。根据 base case 填写 <code>dp[0..N-1][0..N-1][1]</code> 的逻辑。<br>5) base case 之外的情况都是普遍位置，在 <code>process(L1, L2, size)</code> 函数中如下：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举每一种情况，有一个计算出互为旋变就返回 true，都算不出来则返回 false</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">leftPart</span> <span class="operator">=</span> <span class="number">1</span>; leftPart &lt; size; leftPart++) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((process(str1, str2, L1, L2, leftPart) &amp;&amp;</span><br><span class="line">            process(str1, str2, L1 + leftPart, L2 + leftPart, size - leftPart))</span><br><span class="line">            ||</span><br><span class="line">            (process(str1, str2, L1, L2 + size - leftPart, leftPart) &amp;&amp;</span><br><span class="line">                    process(str1, str2, L1 + leftPart, L2, size - leftPart))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   分析代码发现 <code>process(a, b, size)</code> 依赖的子状态的假设为 <code>process(c, d, size&#39;)</code>，size’ 总是小于 size 的。这说明如果来到 <code>dp[a][b][k]</code> 位置，这个位置在计算时所依赖的状态一定位于 k 层二维平面的下方，即依赖 size &lt; k 层的二维平面中的某些位置。所以，我们一定可以从 size=1 层依次推出 size=2 层、size=3 层……size=N 层。同一层的位置之间没有任何依赖关系。根据尝试的代码，写出填写 dp 其他位置的过程。<br>6) 返回 <code>dp[0][0][N]</code> 的值就是答案。<br>本题动态规划的解法就是填写一个规模为 $O(N^3)$ 的立方体，填写每一个位置的时候，都有一个时间复杂度为 $O(N)$ 的枚举过程，所以整体的时间复杂度为 $O(N^4)$。具体实现请看如下的 <code>isScramble2</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sameTypeSameNumber</span><span class="params">(<span class="type">char</span>[] str1, <span class="type">char</span>[] str2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str1.length != str2.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str1.length; i++) &#123;</span><br><span class="line">            map[str1[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str2.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--map[str2[i]] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isScramble2</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s1 == <span class="literal">null</span> &amp;&amp; s2 != <span class="literal">null</span>) || (s1 != <span class="literal">null</span> &amp;&amp; s2 == <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s1 == <span class="literal">null</span> &amp;&amp; s2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s1.equals(s2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] str1 = s1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] str2 = s2.toCharArray();</span><br><span class="line">        <span class="keyword">if</span> (!sameTypeSameNumber(str1, str2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> s1.length();</span><br><span class="line">        <span class="type">boolean</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[N][N][N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">L1</span> <span class="operator">=</span> <span class="number">0</span>; L1 &lt; N; L1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">L2</span> <span class="operator">=</span> <span class="number">0</span>; L2 &lt; N; L2++) &#123;</span><br><span class="line">                dp[L1][L2][<span class="number">1</span>] = str1[L1] == str2[L2];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一层 for 循环含义是：依次填 size=2 层、size=3 层……size=N 层，每一层都是一个二维平面</span></span><br><span class="line">        <span class="comment">// 第二、三层 for 循环含义是：在具体的一层中，整个面都要填写，所以用两个 for 循环去填一个二维平面</span></span><br><span class="line">        <span class="comment">// L1 的取值范围是[0,N-size]，</span></span><br><span class="line">        <span class="comment">// 因为从 L1 出发往右长度为 size 的子串，L1 是不能从 N-size+1 出发的，这样往右就不够 size 个字符</span></span><br><span class="line">        <span class="comment">// L2 的取值范围同理</span></span><br><span class="line">        <span class="comment">// 第 4 层 for 循环完全是递归函数怎么写，这里就怎么改</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">2</span>; size &lt;= N; size++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">L1</span> <span class="operator">=</span> <span class="number">0</span>; L1 &lt;= N - size; L1++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">L2</span> <span class="operator">=</span> <span class="number">0</span>; L2 &lt;= N - size; L2++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">leftPart</span> <span class="operator">=</span> <span class="number">1</span>; leftPart &lt; size; leftPart++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((dp[L1][L2][leftPart] &amp;&amp;</span><br><span class="line">                                dp[L1 + leftPart][L2 + leftPart][size - leftPart])</span><br><span class="line">                                ||</span><br><span class="line">                                (dp[L1][L2 + size - leftPart][leftPart] &amp;&amp;</span><br><span class="line">                                        dp[L1 + leftPart][L2][size - leftPart])) &#123;</span><br><span class="line">                            dp[L1][L2][size] = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小包含子串的长度"><a href="#最小包含子串的长度" class="headerlink" title="最小包含子串的长度"></a>最小包含子串的长度</h2><p><strong>题目</strong><br>给定字符串 str1 和 str2，求 str1 的子串中含有 str2 所有字符的最小子串长度。</p>
<p><strong>举例</strong><br>str1=”abcde”，str2=”ac”。因为”abc”包含 str2 所有的字符，并且在满足这一条件的 str1 的所有子串中，”abc”是最短的，返回 3。<br>str1=”12345”，str2=”344”。最小包含子串不存在，返回 0。</p>
<p><strong>解答</strong><br>如果 str1 的长度为 N，str2 的长度为 M，本书提供的方法时间复杂度为 O(N)。<br>如果 str1 或者 str2 为空，或者 N 小于 M，那么最小包含子串必然不存在，直接返回 0。接下来讨论一般情况，即 str1 和 str2 不为空且 N 不小于 M。为了便于理解，现在以 str1=”adabbca”、str2=”acb”来举例说明整个过程。</p>
<ol>
<li>在开始遍历 str1 之前，先通过遍历 str2 生成哈希表 map，key 为 char 类型，value 为 int 类型。每条记录的意义是，对于 key 字符，str1 字符串目前还欠 str2 字符串 value 个。</li>
<li>需要定义如下 4 个变量。<br>1) left：遍历 str1 的过程中，str1[left..right]表示被框住的子串，所以 left 表示这个子串的左边界，初始时，left=0。<br>2) right：right 表示被框住子串的右边界，初始时，right=0。<br>3) match：表示对所有的字符来说，str1[left..right]目前一共欠 str2 多少个。对本例来说，初始时，match=3，即开始时欠 1 个’a’、1 个’c’和 1 个’b’。<br>4) minLen：最终想要的结果为最小包含子串的长度，初始时为 32 位整数最大值。</li>
<li><p>接下来开始通过 right 变量从左到右遍历 str1。<br>1) right==0，str1[0]==’a’。在 map 中把 key 为’a’的 value 减 1，减完后变为(‘a’,0)。减完之后 value 为 0，说明减之前大于 0，那么 str1 归还了 1 个’a’，match 值也要减 1，表示对 str2 的所有字符来说，str1 目前归还了 1 个。<br>2) right==1，str1[1]==’d’。在 map 中，把 key 为’d’的 value 减 1，但是发现 map 中没有 key 为’d’的记录，就加一条记录 (‘d’,-1)，表示’d’字符 str1 多归还了 1 个。此时 value 为-1，说明当前这个字符是 str2 不需要（或多余）的，所以 match 不变。<br>3) …（中间过程省略，核心逻辑是 right 向右扩，更新 map 和 match，当 match 为 0 时，说明当前窗口包含了 str2 所有字符，此时开始尝试 left 向右缩，更新 minLen）</p>
<p>具体逻辑：当 match 第一次变成了 0，说明遍历到目前为止，str1 把需要归还的字符都还完了，此时被框住的子串也就是 str1[0..right]，肯定是包含 str2 所有字符的。但是当前被框住的子串是必须以位置 right 结尾的情况下最短的吗？不一定，因为有些字符归还得很“多余”，所以还要继续让 left 向右缩。</p>
<p>left 开始往右移动，如果 map[str1[left]] &lt; 0，说明 str1 即便拿回这个字符，也不会欠 str2。所以拿回来，令记录加 1，left++。直到 map[str1[left]] == 0，说明 str1 如果拿回这个位置的字符，就要亏欠 str2 了，所以此时 left 停止向右移动。str1[left..right]就是在必须以位置 right 结尾的情况下最小窗口子串。minLen 更新。</p>
<p>然后 left 继续向右移动一步（即 left++），这就意味着窗口不再包含 left 位置的字符，于是 map[str1[left]]变成 1，match++（表示又欠了一个字符），然后 right 继续向右寻找下一个满足条件的窗口。</p>
</li>
</ol>
<p>具体请参看如下代码中的 <code>minLength</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minLength</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str1 == <span class="literal">null</span> || str2 == <span class="literal">null</span> || str1.length() &lt; str2.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] chas1 = str1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] chas2 = str2.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != chas2.length; i++) &#123;</span><br><span class="line">            map[chas2[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">match</span> <span class="operator">=</span> chas2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (right != chas1.length) &#123;</span><br><span class="line">            map[chas1[right]]--;</span><br><span class="line">            <span class="keyword">if</span> (map[chas1[right]] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                match--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (match == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (map[chas1[left]] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    map[chas1[left++]]++;</span><br><span class="line">                &#125;</span><br><span class="line">                minLen = Math.min(minLen, right - left + <span class="number">1</span>);</span><br><span class="line">                match++;</span><br><span class="line">                map[chas1[left++]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="number">0</span> : minLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回文最少分割数"><a href="#回文最少分割数" class="headerlink" title="回文最少分割数"></a>回文最少分割数</h2><p><strong>题目</strong><br>给定一个字符串 str，返回把 str 全部切成回文子串的最小分割数。</p>
<p><strong>举例</strong><br>str=”ABA”。<br>不需要切割，str 本身就是回文串，所以返回 0。<br>str=”ACDCDCDAD”。<br>最少需要切 2 次变成 3 个回文子串，比如”A”、”CDCDC”和”DAD”，所以返回 2。</p>
<p><strong>解答</strong><br>本题是一个经典的动态规划的题目。定义动态规划数组 dp，dp[i]的含义是子串 str[i..len-1]至少需要切割几次，才能把 str[i..len-1]全部切成回文子串。那么，dp[0]就是最后的结果。<br>从右往左依次计算 dp[i]的值，i 初始为 len-1，具体计算过程如下：</p>
<ol>
<li>假设 j 位置处在 i 与 len-1 位置之间（$i \le j &lt; len$），如果 str[i..j]是回文串，那么 dp[i]的值可能是 dp[j+1]+1，其含义是在 str[i..len-1]上，既然 str[i..j]是一个回文串，那么它可以自己作为一个分割的部分，剩下的部分（即 str[j+1..len-1]）继续做最经济的切割，而 dp[j+1]值的含义正好是 str[j+1..len-1]的最少回文分割数。</li>
<li>根据步骤 1 的方式，让 j 在 i 到 len-1 位置上枚举，那么所有可能情况中的最小值就是 dp[i]的值，即 $dp[i] = \min { dp[j+1]+1 \quad (i \le j &lt; len, \text{且 } str[i..j] \text{必须是回文串}) }$。</li>
<li>如何方便快速地判断 str[i..j]是否是回文串呢？具体过程如下。<br>1) 定义一个二维数组 boolean[][] p，如果 p[i][j]值为 true，说明字符串 str[i..j]是回文串，否则不是。在计算 dp 数组的过程中，希望能够同步、快速地计算出矩阵 p。<br>2) p[i][j]如果为 true，一定是以下三种情况：<ul>
<li>str[i..j]由 1 个字符组成。</li>
<li>str[i..j]由 2 个字符组成且 2 个字符相等。</li>
<li>str[i+1..j-1]是回文串，即 p[i+1][j-1]为 true，且 str[i]==str[j]，即 str[i..j]上首尾两个字符相等。<br>3) 在计算 dp 数组的过程中，位置 i 是从右向左依次计算的。而对每一个 i 来说，又依次从 i 位置向右枚举所有的位置 j ($i \le j &lt; len$)，以此来决策出 dp[i]的值。所以对 p[i][j]来说，p[i+1][j-1]的值一定已经计算过。这就使判断一个子串是否为回文串变得极为方便。</li>
</ul>
</li>
<li>最终返回 dp[0]的值，过程结束。全部过程请参看如下代码中的 <code>minCut</code> 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCut</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] chas = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> chas.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        dp[len] = -<span class="number">1</span>;</span><br><span class="line">        <span class="type">boolean</span>[][] p = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chas[i] == chas[j] &amp;&amp; (j - i &lt; <span class="number">2</span> || p[i + <span class="number">1</span>][j - <span class="number">1</span>])) &#123;</span><br><span class="line">                    p[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串匹配问题"><a href="#字符串匹配问题" class="headerlink" title="字符串匹配问题"></a>字符串匹配问题</h2><p><strong>题目</strong><br>给定字符串 str，其中绝对不含有字符’.’和’<em>‘。再给定字符串 exp，其中可以含有’.’或’</em>‘，’<em>‘字符不能是 exp 的首字符，并且任意两个’</em>‘字符不相邻。exp 中的’.’代表任何一个字符，exp 中的’<em>‘表示’</em>‘的前一个字符可以有 0 个或者多个。请写一个函数，判断 str 是否能被 exp 匹配。</p>
<p><strong>举例</strong><br>str=”abc”，exp=”abc”，返回 true。<br>str=”abc”，exp=”a.c”，exp 中单个’.’可以代表任意字符，所以返回 true。<br>str=”abcd”，exp=”.<em>“。exp 中’</em>‘的前一个字符是’.’，所以可表示任意数量的’.’字符，当 exp 是”….”时与”abcd”匹配，返回 true。<br>str=””，exp=”..<em>“。exp 中’</em>‘的前一个字符是’.’，可表示任意数量的’.’字符，但是”.<em>“之前还有一个’.’字符，该字符不受’</em>‘的影响，所以 str 起码有一个字符才能被 exp 匹配。所以返回 false。</p>
<p><strong>解答</strong><br>首先解决 str 和 exp 有效性的问题。根据描述，str 中不能含有’.’和’<em>‘，exp 中’</em>‘字符不能是首字符，并且任意两个’*’字符不相邻。具体请参看如下代码中的 <code>isValid</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[] s, <span class="type">char</span>[] e)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;*&#x27;</span> || s[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; e.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; (i == <span class="number">0</span> || e[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看如何用递归方法解这道题，如下代码中的 <code>isMatch</code> 方法是递归解法的主函数，<code>process</code> 方法是递归的主要过程，先列出代码，然后详细解释过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String str, String exp)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span> || exp == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] e = exp.toCharArray();</span><br><span class="line">    <span class="keyword">return</span> isValid(s, e) ? process(s, e, <span class="number">0</span>, <span class="number">0</span>) : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(<span class="type">char</span>[] s, <span class="type">char</span>[] e, <span class="type">int</span> si, <span class="type">int</span> ei)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ei == e.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> si == s.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ei + <span class="number">1</span> == e.length || e[ei + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> si != s.length &amp;&amp; (e[ei] == s[si] || e[ei] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &amp;&amp; process(s, e, si + <span class="number">1</span>, ei + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (si != s.length &amp;&amp; (e[ei] == s[si] || e[ei] == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (process(s, e, si, ei + <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        si++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(s, e, si, ei + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面解释一下递归过程，<code>process</code> 函数的意义是：从 str 的 si 位置开始，一直到 str 结束位置的子串，即 str[si..slen]，是否能被从 exp 的 ei 位置开始一直到 exp 结束位置的子串（即 exp[ei..elen]）匹配，所以 <code>process(s,e,0,0)</code> 就是最终返回的结果。<br>那么在递归过程中如何判断 str[si..slen]是否能被 exp[ei..elen]匹配呢？<br>假设当前判断到 str 的 si 位置和 exp 的 ei 位置，即 <code>process(s,e,si,ei)</code>。</p>
<ol>
<li>如果 ei 为 exp 的结束位置（ei==elen），si 也是 str 的结束位置，返回 true，因为””可以匹配””。如果 si 不是 str 的结束位置，返回 false，这是显而易见的。</li>
<li>如果 ei 位置的下一个字符（e[ei+1]）不为’*’。那么就必须关注 str[si]字符能否和 exp[ei]字符匹配。如果 str[si]与 exp[ei]能匹配（e[ei] == s[si] || e[ei] == ‘.’），还要关注 str 后续的部分能否被 exp 后续的部分匹配，即 <code>process(s,e,si+1,ei+1)</code> 的返回值。如果 str[si]与 exp[ei]不能匹配，当前字符都不匹配，当然不用计算后续的，直接返回 false。</li>
<li>如果当前 ei 位置的下一个字符（e[ei+1]）为’<em>‘字符。<br>1) 如果 str[si]与 exp[ei]不能匹配，那么只能让 exp[ei..ei+1]这个部分为””，也就是 exp[ei+1]==’</em>‘字符的前一个字符 exp[ei]的数量为 0 才行，然后考察 <code>process(s,e,si,ei+2)</code> 的返回值。举个例子，str[si..slen]为”bXXX”，”XXX”代指字符’b’之后的字符串。exp[ei..elen]为”a<em>YYY”，”YYY”代指字符’</em>‘之后的字符串。当前无法匹配(‘a’!=’b’)，所以让”a<em>“为””，然后考察 str[si..slen]（即”bXXX”）能否被 exp[ei+2..elen]（即”YYY”）匹配。<br>2) 如果 str[si]与 exp[ei]能匹配，这种情况下举例说明。<br>str[si..slen]为”aaaaaXXX”，”XXX”指不再连续出现’a’字符的后续字符串。exp[ei..elen]为”a</em>YYY”，”YYY”指字符’<em>‘之后的后续字符串。<br>如果令”a”和”a</em>“匹配，且有”aaaaXXX”和”YYY”匹配，可以返回 true。<br>如果令”aa”和”a<em>“匹配，且有”aaaXXX”和”YYY”匹配，可以返回 true。<br>如果令”aaa”和”a</em>“匹配，且有”aaXXX”和”YYY”匹配，可以返回 true。<br>如果令”aaaa”和”a<em>“匹配，且有”aXXX”和”YYY”匹配，可以返回 true。<br>如果令”aaaaa”和”a</em>“匹配，且有”XXX”和”YYY”匹配，可以返回 true。<br>也就是说，exp[ei..ei+1]（即”a*”）的部分如果能匹配 str 后续很多位置的时候，只要有一个返回 true，就可以直接返回 true。<br>整个递归过程结束。</li>
</ol>
<p>在分析完如上递归过程之后，来看递归函数的结构。我们很容易发现递归函数 <code>process(s,e,si,ei)</code> 在每次调用的时候，有两个参数是始终不变的（s 和 e），所以代表 process 函数状态的就是 si 和 ei 值的组合。所以，如果把递归函数 p 在所有不同参数（si 和 ei）的情况下的所有返回值看作一个范围，这个范围就是(slen+1)<em>(elen+1)的一个二维数组，并且 p(si,ei)在整个递归过程中依赖的总是 p(si+1,ei+1)或者 p(si+k(k&gt;=0),ei+2)，假设二维数组 dp[i][j]代表 p(i,j)的返回值，dp[i][j]就只是依赖 dp[i+1][j+1]或者 dp[i+k(k&gt;=0)][j+2]的值。进一步可以看出，想要求 dp[i][j]的值，只需要 (i,j) 位置右下方的某些值。所以只要从二维数组的右下角开始，从右到左，再下到上计算出二维数组 dp 中每个位置的值就可以，dp[0][0]就是最终结果。p(i,j)的递归过程如何，dp[i][j]的值就怎样去计算。这种方法实际上就是动态规划的方法，省去了递归过程中很多重复计算的过程。<br>先从右到左计算 dp[slen][…]，也就是二维数组 dp 中的最后一行，dp[slen][elen]值的含义是 str 已经结束，剩下的字符串为””，exp 也已经结束，剩下的字符串为””，所以此时 exp 可以匹配 str，dp[slen][elen]=true。对于 dp[slen][0..elen-1]的部分，dp[slen][i]的含义是 str 已经结束，剩下的字符串为””，exp 却没有结束，剩下的字符串为 exp[i..elen-1]，什么情况下 exp[i..elen-1]可以匹配””？只能是不停地重复出现”X</em>“这种方式。比如，exp[i..elen-1]为”a<em>b</em>c<em>“，这种情况下，exp[i+1..elen-1]根本不合法，匹配不了””。如果 exp[i..elen-1]=”A</em>“，可以匹配””。如果 exp[i..elen-1]=”A<em>B</em>“，也能匹配””。也就是说，在从右向左计算 dp[slen][0..elen-1]的过程中，看 exp 是不是从右往左重复出现”X<em>“，如果是重复出现，那么如果 exp[i]=’X’, exp[i+1]=’</em>‘，令 dp[slen][i]=true，如果 exp[i]!=’*’, exp[i+1]!=’X’, 令 dp[slen][i]=false。如果不是重复出现，最后一行后面的部分（即 dp[slen][0..i]）全都是 false。这样就搞定了 dp[][]最后一行的值。<br>再看 dp[][]除右下角的值之外，最后一列其他位置的值，即 dp[0..slen-1][elen]。这表示如果 exp 已经结束，而 str 还没结束。显然，exp 为””，匹配不了任何非空字符串，所以 dp[0..slen-1][elen]都为 false。<br>接着看 dp[][]倒数第二列的值，即 dp[0..slen-1][elen-1]。这表示如果 exp 还剩一个字符（即 exp[elen-1]），而 str 还剩 1 个字符或多个字符。很明显，str 还剩多个字符的情况下，exp 匹配不了。str 还剩 1 个字符的情况下（即 str[slen-1]），如果和 exp[elen-1]相等，则可以匹配，或者 exp[elen-1]==’.’的情况下可以匹配。<br>因为 dp[i][j]只依赖 dp[i+1][j+1]或者 dp[i+k]<a href="k&gt;=0">j+2</a>的值，所以在单独计算完最后一行、最后一列与倒数第二列之后，剩下的位置在从右到左，再从下到上计算 dp 值的时候，所有依赖的值都被计算出来，直接拿过来用即可。如果 str 的长度为 N，exp 的长度为 M，因为有枚举的过程，所以时间复杂度为 $O(N^2 \times M)$，额外空间复杂度为 $O(N \times M)$。具体请参看如下代码中的 <code>isMatchDP</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatchDP</span><span class="params">(String str, String exp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || exp == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] e = exp.toCharArray();</span><br><span class="line">        <span class="keyword">if</span> (!isValid(s, e)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = initDPMap(s, e);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length - <span class="number">1</span>; i &gt; -<span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> e.length - <span class="number">2</span>; j &gt; -<span class="number">1</span>; j -= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e[j + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = (s[i] == e[j] || e[j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                            &amp;&amp; dp[i + <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">si</span> <span class="operator">=</span> i;</span><br><span class="line">                    <span class="keyword">while</span> (si != s.length &amp;&amp; (s[si] == e[j] || e[j] == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dp[si][j + <span class="number">2</span>]) &#123;</span><br><span class="line">                            dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        si++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (dp[i][j] != <span class="literal">true</span>) &#123;</span><br><span class="line">                        dp[i][j] = dp[si][j + <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span>[][] initDPMap(<span class="type">char</span>[] s, <span class="type">char</span>[] e) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slen</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">elen</span> <span class="operator">=</span> e.length;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[slen + <span class="number">1</span>][elen + <span class="number">1</span>];</span><br><span class="line">        dp[slen][elen] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> elen - <span class="number">2</span>; j &gt; -<span class="number">1</span>; j = j - <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e[j] != <span class="string">&#x27;*&#x27;</span> &amp;&amp; e[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dp[slen][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (slen &gt; <span class="number">0</span> &amp;&amp; elen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e[elen - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span> || s[slen - <span class="number">1</span>] == e[elen - <span class="number">1</span>])) &#123;</span><br><span class="line">                dp[slen - <span class="number">1</span>][elen - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字典树（前缀树）的实现"><a href="#字典树（前缀树）的实现" class="headerlink" title="字典树（前缀树）的实现"></a>字典树（前缀树）的实现</h2><p><strong>题目</strong><br>字典树又称为前缀树或 Trie 树，是处理字符串常见的数据结构。假设组成所有单词的字符仅是“a”~“z”，请实现字典树结构，并包含以下四个主要功能。</p>
<ul>
<li>void insert(String word)：添加 word，可重复添加。</li>
<li>void delete(String word)：删除 word，如果 word 添加过多次，仅删除一个。</li>
<li>boolean search(String word)：查询 word 是否在字典树中。</li>
<li>int prefixNumber(String pre)：返回以字符串 pre 为前缀的单词数量。</li>
</ul>
<p><strong>解答</strong><br>字典树是一种树形结构，优点是利用字符串的公共前缀来节约存储空间。<br>字典树的基本性质如下：</p>
<ul>
<li>根节点没有字符路径。除根节点外，每一个节点都被一个字符路径找到。</li>
<li>从根节点出发到任何一个节点，如果将沿途经过的字符连接起来，一定为某个加入过的字符串的前缀。</li>
<li>每个节点向下所有的字符路径上的字符都不同。</li>
</ul>
<p>在字典树上添加一个单词的步骤同理，这里不再详述。下面介绍有关字典树节点的类型，参见如下代码中的 TrieNode 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> path;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> end;</span><br><span class="line">    <span class="keyword">public</span> TrieNode[] map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">        path = <span class="number">0</span>;</span><br><span class="line">        end = <span class="number">0</span>;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TrieNode 类中，path 表示有多少个单词共用这个节点，end 表示有多少个单词以这个节点结尾，map 是一个哈希表结构，key 代表该节点的一条字符路径，value 表示字符路径指向的节点，根据题目的说明，map 是长度为 26 的数组，在字符种类较多的情况下，可以选择用真实的哈希表结构实现 map。介绍完 TrieNode 后，下面详细介绍本题的 Trie 树类如何实现。</p>
<ul>
<li>void insert(String word)：假设单词 word 的长度为 N，从左到右遍历 word 中的每个字符，并依次从头节点开始根据每一个 word[i]，找到下一个节点。如果找的过程中节点不存在，就建立新节点，记为 a，并令 a.path=1。如果节点存在，记为 b，令 b.path++。通过最后一个字符（word[N-1]）找到最后一个节点时记为 e，令 e.path++，e.end++。</li>
<li>boolean search(String word)：从左到右遍历 word 中的每个字符，并依次从头节点开始根据每一个 word[i]，找到下一个节点。如果找的过程中节点不存在，说明这个单词的整个部分没有添加进 Trie 树，否则找的过程节点不可能不存在，直接返回 false。如果能通过 word[N-1]找到最后一个节点，记为 e，如果 e.end!=0，说明有单词通过 word[N-1]的字符路径，并以节点 e 结尾，返回 true。如果 e.end==0，返回 false。</li>
<li>void delete(String word)：先调用 search(word)，看 word 是否在 Trie 树中，若在，则执行后面的过程，若不在，则直接返回。从左到右遍历 word 中的每个字符，并依次从头节点开始根据每一个 word[i]找到下一个节点。在找的过程中，把遍历过每一个节点的 path 值减 1。如果发现下一个节点的 path 值减完之后已经为 0，直接从当前节点的 map 中删除后续的所有路径，并返回即可。如果遍历到最后一个节点，记为 e，令 e.path—, e.end—。</li>
<li>int prefixNumber(String pre)：和查找操作同理，根据 pre 不断找到节点，假设最后的节点记为 e，返回 e.path 的值即可。</li>
</ul>
<p>全部实现过程请参看如下代码中的 Trie 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] chs = word.toCharArray();</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        node.path++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">            index = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.map[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.map[index] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.map[index];</span><br><span class="line">            node.path++;</span><br><span class="line">        &#125;</span><br><span class="line">        node.end++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (search(word)) &#123;</span><br><span class="line">            <span class="type">char</span>[] chs = word.toCharArray();</span><br><span class="line">            <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            node.path--;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                index = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (node.map[index].path-- == <span class="number">1</span>) &#123;</span><br><span class="line">                    node.map[index] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.map[index];</span><br><span class="line">            &#125;</span><br><span class="line">            node.end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] chs = word.toCharArray();</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">            index = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.map[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.map[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.end != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">prefixNumber</span><span class="params">(String pre)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] chs = pre.toCharArray();</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">            index = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.map[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.map[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="子数组的最大异或和"><a href="#子数组的最大异或和" class="headerlink" title="子数组的最大异或和"></a>子数组的最大异或和</h2><p><strong>题目</strong><br>数组异或和的定义：把数组中所有的数异或起来得到的值。<br>给定一个整型数组 arr，其中可能有正、有负、有零，求其中子数组的最大异或和。</p>
<p><strong>举例</strong><br>arr={3}。<br>数组只有 1 个数，所以只有一个子数组，就是这个数组本身，最大异或和为 3。<br>arr={3, -28, -29, 2}。<br>子数组有很多，但是{-28, -29}这个子数组的异或和为 7，是所有子数组中最大的。</p>
<p><strong>要求</strong><br>如果 arr 长度为 N，时间复杂度 $O(N)$。</p>
<p><strong>解答</strong><br>$O(N^3)$ 的解法。枚举所有的子数组，对每一个子数组都用遍历其中所有数字并异或起来的方式求出异或和，那么最大异或和一定能得到。因为一个数组中，子数组的数量为 $O(N^2)$，对每个子数组都遍历的代价是 $O(N)$，所以暴力方法的时间复杂度为 $O(N^3)$。这和题目要求的时间复杂度 $O(N)$ 相去甚远，本书不去实现。</p>
<p>$O(N^2)$ 的解法。异或运算有如下性质：<br>1) 满足交换律和结合律，即只要是同一批数字，不管异或顺序如何，得到的结果都一样。<br>2) 如果 $a \oplus b == c$，那么有 $a == c \oplus b$ 和 $b == c \oplus a$。<br>3) 0 和任何数字 N 异或的结果为 N，任何数字 N 和自己异或的结果为 0。<br>假设 arr[i..j] ($i \le j$) 这个子数组的异或和用 xor[i..j]来表示。也就是说，xor[0..j] = xor[0..i-1] ^ xor[i..j]，则可以推出 xor[i..j] = xor[0..j] ^ xor[0..i-1]。<br>解法过程如下：<br>1) 生成长度和 arr 一样的数组，记为 eor，eor[i]的含义为 arr[0..i]这个子数组的异或和，只遍历 arr 一遍就可以生成 eor 数组。<br>2) 在以 j 位置结尾的情况下，看下面一系列的子数组异或和哪个最大，最大的那个就是必须以 j 结尾的所有子数组中最大的异或和。<br>   xor[0..j] = eor[j] ^ 0<br>   xor[1..j] = eor[j] ^ eor[0]<br>   …<br>   xor[i..j] = eor[j] ^ eor[i-1]<br>   …<br>   xor[j..j] = eor[j] ^ eor[j-1]<br>3) 尝试每一个位置都作为结尾位置，并求出在这个位置结尾情况下最大的异或和，全局最大的那个就是答案。<br>流程如 <code>maxXorSubarray1</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxXorSubarray1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] eor = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    eor[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        eor[i] = eor[i - <span class="number">1</span>] ^ arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= j; i++) &#123;</span><br><span class="line">            max = Math.max(max, i == <span class="number">0</span> ? eor[j] : eor[j] ^ eor[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>maxXorSubarray1</code> 方法是尝试以 j 位置结尾的情况下，最大的异或和是多少，然后尝试每一个结尾，答案一定能出来。假设以 j 位置结尾时我们是这么做的：<br>xor[0..j] = eor[j] ^ 0<br>xor[1..j] = eor[j] ^ eor[0]<br>…<br>xor[i..j] = eor[j] ^ eor[i-1]<br>…<br>xor[j..j] = eor[j] ^ eor[j-1]<br>我们要的是 max（以 j 结尾时的 max），即 max=(xor[0..j], xor[1..j], …, xor[j..j]中最大的一项)。也就是说，max = eor[j] ^ (从 0, eor[0], eor[1], …, eor[j-1]中挑一个出来)。<code>maxXorSubarray1</code> 方法其实并不知道挑哪个，也不知道怎么挑，所以只能都试一遍。</p>
<p>最优解 $O(N)$ 的解法。大体的过程和 <code>maxXorSubarray1</code> 方法一样，但是知道怎么挑，并且利用前缀树这个结构，将挑选的过程加速。当求以 j 位置结尾的情况下的最大子数组异或和，需要 0, eor[0], eor[1], …, eor[j-1], eor[j]的全体，假设这些值都是二进制数，并且 0, eor[0], eor[1], …, eor[j-1]都加入到了一棵前缀树里。<br>假设一棵前缀树内放入了 0、eor[0]、eor[1]、eor[2]、eor[3]、eor[4]。<br>eor[5] ^ (和谁结合？)，得到的最大值记为 X，X 就是必须以 4 结尾的情况下，子数组最大异或和。<br>eor[5]为 0110，如果能够选择，让高位先变 1，得到的结果就是最大的。比如，eor[5]从高位到低位的数字是 0、1、1、0，如果能够依次遇到 1、0、0、1 就好了，这样异或之后就能得到最大值 1111，如果不能完美地遇到 1、0、0、1，也希望先满足高位异或之后变成 1 这个需求。现在来看前缀树，从 A 点开始，有走向 1 的路到达 C 点，从 C 点开始有走向 0 的路到达 F 点，这说明 eor[5]从高位到低位的前两个数字 0、1，是可以满足这两个数字能依次遇到 1 和 0 的，那就先满足。而 eor[5]从高位到低位的第三个数字是 1，我们希望能走 0 的路，可是从 F 往下没有 0 的路，只能走向 1 的路到达 G；eor[5]从高位到低位的第四个数字是 0，我们希望能走 1 的路，从 G 往下有 1 的路，所以继续满足，最后到达 P 点。沿途走过的路依次为 1、0、1、1，那么这条路径就是所有可能性中的最优路径，最优路径得到之后是 1011，也就是 eor[0]的值，0110 ^ 1011 = 1101。<br>eor[5] ^ (挑选出了 eor[0]) =&gt; 得到值 1101，必须以 4 结尾的情况下，子数组最大异或和为 1101。<br>因为前缀树就是从前到后依次把样本每一位的信息存到树中，所以，如果把策略定成先满足高位异或之后变成 1 这个需求，前缀树可以很好地完成挑选这个过程，而不用去尝试每一个样本。这就是最优解的核心。<br>现在把长度只有 4 位的二进制数的例子推广到 32 位，并且最高位是符号位的情况。假设当前数组的结束位置是 j，eor[j]就是一个普通的整数，选择最优的异或路径过程如下：<br>1) 对于最高位符号位的数字，不管 eor[j]是正数还是负数，我们都希望异或之后是正数，因为我们要的是最大值，所以 eor[j]的最高位如果是 0，希望能走 0 的路，因为这样异或之后符号位是 0，为正数；eor[j]的最高位如果是 1，希望走 1 的路，因为这样异或之后符号位是 0，为正数。如果不能选择，只能被迫走唯一的路。<br>2) 走过最高位之后，从左到右（也就是从高到低）依次考虑 K 的每一位数字，因为总是应该先满足高位的需求。eor[j]的当前位数字如果是 0，希望能走 1 的路；K 的最高位如果是 1，希望走 0 的路。如果不能选择，只能被迫走唯一的路。<br>3) 当 32 步都走完时，eor[j]该和谁异或也就知道了，异或后就是最大值，也是以 j 作为结尾的情况下子数组的最大异或和。<br>全部过程如 <code>maxXorSubarray2</code> 方法所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前缀树的节点类型，每个节点向下只可能有走向 0 或 1 的路</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> Node[] nexts = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于本题，定制前缀树的实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumTrie</span> &#123;</span><br><span class="line">        <span class="comment">// 头节点</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把某个数字 newNum 加入到这棵前缀树里</span></span><br><span class="line">        <span class="comment">// num 是一个 32 位的整数，所以加入的过程一共走 32 步</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> newNum)</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">move</span> <span class="operator">=</span> <span class="number">31</span>; move &gt;= <span class="number">0</span>; move--) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">path</span> <span class="operator">=</span> ((newNum &gt;&gt; move) &amp; <span class="number">1</span>);</span><br><span class="line">                cur.nexts[path] = cur.nexts[path] == <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">Node</span>() : cur.nexts[path];</span><br><span class="line">                cur = cur.nexts[path];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给定一个 eorj，eorj 表示 eor[j]，即以 j 位置结尾的情况下，arr[0..j]的异或和</span></span><br><span class="line">        <span class="comment">// 因为之前把 eor[0]，eor[1]，…，eor[j-1]都加入了前缀树，所以可以选择出一条最优路径</span></span><br><span class="line">        <span class="comment">// maxXor 方法就是把最优路径找到，并且返回 eor[j]与最优路径结合之后得到的最大异或和</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxXor</span><span class="params">(<span class="type">int</span> eorj)</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">move</span> <span class="operator">=</span> <span class="number">31</span>; move &gt;= <span class="number">0</span>; move--) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">path</span> <span class="operator">=</span> (eorj &gt;&gt; move) &amp; <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 期待的路</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">best</span> <span class="operator">=</span> move == <span class="number">31</span> ? path : (path ^ <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 实际走的路</span></span><br><span class="line">                best = cur.nexts[best] != <span class="literal">null</span> ? best : (best ^ <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// (path ^ best) 为当前位异或完的结果</span></span><br><span class="line">                res |= (path ^ best) &lt;&lt; move;</span><br><span class="line">                cur = cur.nexts[best];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxXorSubarray2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">eor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">NumTrie</span> <span class="variable">numTrie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumTrie</span>();</span><br><span class="line">        numTrie.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            eor ^= arr[j];</span><br><span class="line">            max = Math.max(max, numTrie.maxXor(eor));</span><br><span class="line">            numTrie.add(eor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="大数据和空间限制"><a href="#大数据和空间限制" class="headerlink" title="大数据和空间限制"></a>大数据和空间限制</h1><h2 id="认识布隆过滤器"><a href="#认识布隆过滤器" class="headerlink" title="认识布隆过滤器"></a>认识布隆过滤器</h2><p><strong>题目</strong></p>
<p>不安全网页的黑名单包含 100 亿个黑名单网页，每个网页的 URL 最多占用 64B。现在想要实现一个网页过滤系统，利用该系统可以根据网页的 URL 判断该网页是否在黑名单上，请设计该系统。</p>
<p><strong>要求</strong></p>
<ol>
<li>该系统允许有万分之一以下的判断失误率。</li>
<li>使用的额外空间不要超过 30GB。</li>
</ol>
<p><strong>解答</strong></p>
<p>如果把黑名单中所有的 URL 通过数据库或哈希表保存下来，就可以对每条 URL 进行查询，但是每个 URL 有 64B，数量是 100 亿个，所以至少需要 640GB 的空间，不满足要求 2。</p>
<p>如果面试者遇到网页黑名单系统、垃圾邮件过滤系统、爬虫的网址判重系统等题目，又看到系统容忍一定程度的失误率，但是对空间要求比较严格，那么很可能是面试官希望面试者具备布隆过滤器的知识。</p>
<p>布隆过滤器（Bloom Filter）由 Burton Howard Bloom 于 1970 年提出，它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
<p><strong>哈希函数（散列函数）</strong></p>
<p>哈希函数的输入域可以是非常大的范围，比如任意一个字符串，但是输出域是固定的范围，假设为 $S$，并具有如下性质：</p>
<ol>
<li>典型的哈希函数都有无限的输入值域。</li>
<li>当哈希函数传入相同的输入值时，返回值一样。</li>
<li>当哈希函数传入不同的输入值时，返回值可能一样，也可能不一样。这是因为输出域统一是 $S$，所以会有不同的输入值对应在 $S$ 中的一个元素上。</li>
<li><strong>最重要的性质是很多不同的输入值所得到的返回值会均匀地分布在 $S$ 上</strong>。</li>
</ol>
<p>第 1~3 点性质是哈希函数的基础，第 4 点性质是评价一个哈希函数优劣的关键。不同的输入值所得到的返回值越均匀地分布在 $S$ 上，哈希函数就越优秀，并且这种均匀分布与输入值出现的规律无关。比如 “aaa1”、”aaa2”、”aaa3” 三个输入值比较类似，但经过优秀的哈希函数计算后的结果应该相差非常大。</p>
<p><strong>布隆过滤器原理</strong></p>
<p>假设有一个长度为 $m$ 的 bit 类型的数组，即数组中的每一个位置只占一个 bit，每一个 bit 只有 0 和 1 两种状态。<br>再假设一共有 $k$ 个哈希函数，这些函数的输出域 $S$ 都大于或等于 $m$，并且这些哈希函数都足够优秀，彼此之间也完全独立。</p>
<ol>
<li><p><strong>添加元素</strong>：<br>对同一个输入对象（假设是一个字符串，记为 URL），经过 $k$ 个哈希函数算出来的结果也是独立的。算出来的每一个结果都对 $m$ 取余（% $m$），然后在 bit array 上把相应的位置设置为 1（涂黑）。<br>处理完所有的输入对象后，bitMap 中已经有相当多的位置被涂黑。至此，一个布隆过滤器生成完毕，这个布隆过滤器代表之前所有输入对象组成的集合。</p>
</li>
<li><p><strong>检查元素</strong>：<br>假设一个对象为 a，想检查它是否是之前的输入对象，就把 a 通过 $k$ 个哈希函数算出 $k$ 个值，然后把 $k$ 个值取余（% $m$），就得到在 [0, $m$-1] 范围上的 $k$ 个值。接下来在 bitMap 上看这些位置是不是都为黑。</p>
<ul>
<li>如果有一个不为黑，说明 a 一定不在这个集合里。</li>
<li>如果都为黑，说明 a 在这个集合里，但可能有误判。</li>
<li><strong>误判解释</strong>：如果 a 的确是输入对象，那么在生成布隆过滤器时，bitMap 中相应的 $k$ 个位置一定已经涂黑了，所以在检查阶段，a 一定不会被漏过，这个不会产生误判。会产生误判的是，a 明明不是输入对象，但如果在生成布隆过滤器的阶段因为输入对象过多，而 bitMap 过小，则会导致 bitMap 绝大多数的位置都已经变黑。那么在检查 a 时，可能 a 对应的 $k$ 个位置都是黑的，从而错误地认为 a 是输入对象。通俗地说，布隆过滤器的失误类型是“宁可错杀三千，绝不放过一个”。</li>
</ul>
</li>
</ol>
<p><strong>布隆过滤器的实现设计</strong></p>
<p>布隆过滤器到底该怎么实现？如果 bitMap 的大小 $m$ 相比输入对象的个数 $n$ 过小，失误率会变大。接下来介绍根据 $n$ 的大小和我们想达到的失误率 $p$，如何确定布隆过滤器的大小 $m$ 和哈希函数的个数 $k$。</p>
<p>对于本题：</p>
<ul>
<li>黑名单中样本的个数 $n = 100$ 亿。</li>
<li>失误率 $p = 0.01\%$。</li>
<li>每个样本的大小为 64B。这个信息不会影响布隆过滤器的大小，只和选择哈希函数有关。一般的哈希函数都可以接收 64B 的输入对象，所以使用布隆过滤器还有一个好处是不用顾忌单个样本的大小，它丝毫不能影响布隆过滤器的大小。</li>
</ul>
<p><strong>1. 确定布隆过滤器的大小 $m$</strong></p>
<p>公式：</p>
<script type="math/tex; mode=display">m = - \frac{n \times \ln p}{(\ln 2)^2}</script><p>根据公式计算出 $m = 19.19n$，向上取整为 $20n$，即需要 2000 亿个 bit，也就是 25GB。</p>
<p><strong>2. 确定哈希函数的个数 $k$</strong></p>
<p>公式：</p>
<script type="math/tex; mode=display">k = \ln 2 \times \frac{m}{n} = 0.7 \times \frac{m}{n}</script><p>计算出哈希函数的个数为 $k \approx 14$ 个。</p>
<p><strong>3. 结果</strong></p>
<p>用 25GB 的 bitMap 再单独实现 14 个哈希函数，根据如上描述生成布隆过滤器即可。<br>因为我们在确定布隆过滤器大小的过程中选择了向上取整，所以还要用如下公式确定布隆过滤器真实的失误率：</p>
<script type="math/tex; mode=display">p_{true} = (1 - e^{-\frac{nk}{m}})^k</script><p>根据这个公式算出真实的失误率为 0.006%，这是比 0.01% 更低的失误率。</p>
<p><strong>补充：白名单策略</strong></p>
<p>布隆过滤器会有误报，对已经发现的误报样本可以通过建立白名单来防止误报。比如，已发现“aaaaaa5”这个样本不在布隆过滤器中，但是每次计算后的结果都显示其在布隆过滤器中，那么就可以把这个样本加入白名单中，以后就可以知道这个样本确实不在布隆过滤器中。</p>
<blockquote>
<p>本节文章参考了作者 Allen Sun 的网文，在此对他表示特别感谢。</p>
<h2 id="只用-2GB-内存在-20-亿个整数中找到出现次数最多的数"><a href="#只用-2GB-内存在-20-亿个整数中找到出现次数最多的数" class="headerlink" title="只用 2GB 内存在 20 亿个整数中找到出现次数最多的数"></a>只用 2GB 内存在 20 亿个整数中找到出现次数最多的数</h2></blockquote>
<p><strong>题目</strong></p>
<p>有一个包含 20 亿个全是 32 位整数的大文件，在其中找到出现次数最多的数。</p>
<p><strong>要求</strong></p>
<p>内存限制为 2GB。</p>
<p><strong>解答</strong></p>
<p>想要在很多整数中找到出现次数最多的数，通常的做法是使用哈希表对出现的每一个数做词频统计。哈希表的 key 是某一个整数，value 是这个数出现的次数。</p>
<ul>
<li>key (整数) 占用 4B。</li>
<li>value (次数) 占用 4B（20 亿次可以用 32 位整数表示，不会溢出）。</li>
<li>一条记录 (key, value) 需要占用 8B。</li>
</ul>
<p>当哈希表记录数为 2 亿个时，需要至少 1.6GB 的内存。</p>
<p>如果 20 亿个数中不同的数超过 2 亿种，最极端的情况是 20 亿个数都不同，那么在哈希表中可能需要产生 20 亿条记录，这样内存会不够用（需要 16GB），所以一次性用哈希表统计 20 亿个数的办法是有很大风险的。</p>
<p><strong>解决办法</strong></p>
<p>把包含 20 亿个数的大文件用哈希函数分成 16 个小文件。</p>
<ul>
<li>根据哈希函数的性质，同一种数不可能被散列到不同的小文件上。</li>
<li>同时每个小文件中不同的数一定不会大于 2 亿种（假设哈希函数足够优秀）。</li>
</ul>
<p><strong>步骤</strong>：</p>
<ol>
<li>将大文件通过哈希函数分散到 16 个小文件中。</li>
<li>对每一个小文件用哈希表来统计其中每种数出现的次数。</li>
<li>得到 16 个小文件中各自出现次数最多的数，以及各自的次数统计。</li>
<li>选出这 16 个小文件各自的第一名中谁出现的次数最多即可。</li>
</ol>
<p><strong>总结</strong></p>
<p>把一个大的集合通过哈希函数分配到多台机器中，或者分配到多个文件里，这种技巧是处理大数据面试时最常用的技巧之一。<br>到底分配到多少台机器、分配到多少个文件，在解题时一定要确定下来。本题确定分成 16 个文件，就是根据内存限制 2GB 的条件来确定的（20亿 / 16 ≈ 1.25亿，1.25亿 * 8B ≈ 1GB &lt; 2GB，保险起见）。</p>
<h2 id="40-亿个非负整数中找到未出现的数"><a href="#40-亿个非负整数中找到未出现的数" class="headerlink" title="40 亿个非负整数中找到未出现的数"></a>40 亿个非负整数中找到未出现的数</h2><p><strong>题目</strong></p>
<p>32 位无符号整数的范围是 0 ~ 4 294 967 295，现在有一个正好包含 40 亿个无符号整数的文件，所以在整个范围中必然有未出现过的数。<br>可以使用最多 1GB 的内存，怎么找到所有未出现过的数？</p>
<p><strong>进阶</strong>：内存限制为 10MB，但是只用找到一个没出现过的数即可。</p>
<p><strong>解答</strong></p>
<p><strong>原问题</strong></p>
<p>假设用哈希表来保存出现过的数，那么如果 40 亿个数都不同，则哈希表的记录数为 40 亿条。存一个 32 位整数需要 4B，所以最差情况下需要 40 亿 $\times$ 4B = 160 亿字节，大约需要 16GB 的空间，这是不符合要求的。</p>
<p>哈希表需要占用很多空间，我们可以使用 bit map 的方式来表示数出现的情况。具体说是申请一个长度为 4 294 967 295 的 bit 类型的数组 <code>bitArr</code>，<code>bitArr</code> 上的每个位置只可以表示 0 或 1 状态。8 个 bit 为 1B，所以长度为 4 294 967 295 的 bit 类型的数组占用 500MB 空间。</p>
<p><strong>怎么使用这个 <code>bitArr</code> 数组呢？</strong><br>就是遍历这 40 亿个无符号数，例如，遇到 7000，就把 <code>bitArr[7000]</code> 设置为 1。遇到所有的数时，就把 <code>bitArr</code> 相应位置的值设置为 1。<br>遍历完成后，再遍历 <code>bitArr</code>，哪个位置上的值没被设置为 1，这个数就不在 40 亿个数中。例如，发现 <code>bitArr[8001] == 0</code>，那么 8001 就是没出现过的数，遍历完 <code>bitArr</code> 之后，所有没出现的数都找出来了。</p>
<p><strong>进阶问题</strong></p>
<p>现在只有 10MB 的内存，但只要求找到其中一个没出现过的数即可。</p>
<p>首先，0 ~ 4 294 967 295 这个范围是可以平均分成 64 个区间的，每个区间是 67 108 864 个数。<br>例如：</p>
<ul>
<li>第 0 区间 (0 ~ 67 108 863)</li>
<li>第 1 区间 (67 108 864 ~ 134 217 728)</li>
<li>…</li>
<li>第 $i$ 区间 (67 108 864 $\times$ $i$ ~ 67 108 864 $\times$ ($i$+1) - 1)</li>
<li>…</li>
<li>第 63 区间 (4 227 858 432 ~ 4 294 967 295)</li>
</ul>
<p>因为一共有 40 亿个数，所以，如果统计落在每一个区间上的数有多少，肯定有至少一个区间上的计数少于 67 108 864。利用这一点可以找出其中一个没出现过的数。具体过程如下：</p>
<ol>
<li><p><strong>第一次遍历</strong>：<br>先申请长度为 64 的整型数组 <code>countArr[0..63]</code>，用来统计区间 $i$ 上的数有多少。<br>遍历 40 亿个数，根据当前数是多少来决定哪一个区间上的计数增加。例如，如果当前数是 3 422 552 090，3 422 552 090 / 67 108 864 = 51，所以第 51 区间上的计数增加 <code>countArr[51]++</code>。<br>遍历完 40 亿个数之后，遍历 <code>countArr</code>，必然会有某一个位置上的值 (<code>countArr[i]</code>) 小于 67 108 864，表示第 $i$ 区间上至少有一个数没出现过。我们肯定会找到至少一个这样的区间。<br>此时使用的内存就是 <code>countArr</code> 的大小 (64 $\times$ 4B)，是非常小的。</p>
</li>
<li><p><strong>第二次遍历</strong>：<br>假设找到第 37 区间上的计数小于 67 108 864，以下为第二次遍历的过程。</p>
<ol>
<li>申请长度为 67 108 864 的 bit map，这占用大约 8MB 的空间，记为 <code>bitArr[0..67108863]</code>。</li>
<li>再遍历一次 40 亿个数，此时的遍历只关注落在第 37 区间上的数，记为 <code>num</code> (<code>num</code> / 67 108 864 == 37)，其他区间的数全部忽略。</li>
<li>如果步骤 2 的 <code>num</code> 在第 37 区间上，将 <code>bitArr[num - 67108864 * 37]</code> 的值设置为 1，也就是只做第 37 区间上的数的 <code>bitArr</code> 映射。</li>
<li>遍历完 40 亿个数之后，在 <code>bitArr</code> 上必然存在没被设置成 1 的位置，假设第 $i$ 个位置上的值没设置成 1，那么 67 108 864 $\times$ 37 + $i$ 这个数就是一个没出现过的数。</li>
</ol>
</li>
</ol>
<p><strong>总结一下进阶的解法</strong>：</p>
<ol>
<li>根据 10MB 的内存限制，确定统计区间的大小，就是第二次遍历时的 <code>bitArr</code> 大小。</li>
<li>利用区间计数的方式，找到那个计数不足的区间，这个区间上肯定有没出现的数。</li>
<li>对这个区间上的数做 bit map 映射，再遍历 bit map，找到一个没出现的数即可。<h2 id="找到-100-亿个-URL-中重复的-URL-及搜索词汇的-Top-K-问题"><a href="#找到-100-亿个-URL-中重复的-URL-及搜索词汇的-Top-K-问题" class="headerlink" title="找到 100 亿个 URL 中重复的 URL 及搜索词汇的 Top K 问题"></a>找到 100 亿个 URL 中重复的 URL 及搜索词汇的 Top K 问题</h2></li>
</ol>
<p><strong>题目</strong></p>
<p>有一个包含 100 亿个 URL 的大文件，假设每个 URL 占用 64B，请找出其中所有重复的 URL。</p>
<p><strong>补充问题</strong>：某搜索公司一天的用户搜索词汇是海量的（百亿数据量），请设计一种求出每天热门 Top 100 词汇的可行办法。</p>
<p><strong>解答</strong></p>
<p>原问题的解法使用解决大数据问题的一种常规方法：把大文件通过哈希函数分配到机器，或者通过哈希函数把大文件拆成小文件，一直进行这种划分，直到划分的结果满足资源限制的要求。<br>首先，要向面试官询问在资源上的限制有哪些，包括内存、计算时间等要求。在明确了限制要求之后，可以将每条 URL 通过哈希函数分配到若干台机器或者拆分成若干个小文件，这里的“若干”由具体的资源限制来计算出精确的数量。</p>
<p>例如，将 100 亿字节的大文件通过哈希函数分配到 100 台机器上，然后每一台机器分别统计分给自己的 URL 中是否有重复的 URL，同时哈希函数的性质决定了同一条 URL 不可能分给不同的机器；或者在单机上将大文件通过哈希函数拆成 1000 个小文件，对每一个小文件再利用哈希表遍历，找出重复的 URL；还可以再分给机器或拆完文件之后进行排序，排序过后再看是否有重复的 URL 出现。<br>总之，牢记一点，很多大数据问题都离不开分流，要么是用哈希函数把大文件的内容分配给不同的机器，要么是用哈希函数把大文件拆成小文件，然后处理每一个小数量的集合。</p>
<p><strong>补充问题解答</strong></p>
<p>补充问题最开始还是用哈希分流的思路来处理，把包含百亿数据量的词汇文件分流到不同的机器上，具体多少台机器由面试官规定或者由更多的限制来决定。<br>对每一台机器来说，如果分到的数据量依然很大，比如，内存不够或存在其他问题，可以再用哈希函数把每台机器的分流文件拆成更小的文件处理。<br>处理每一个小文件的时候，通过哈希表统计每种词及其词频，哈希表记录建立完成后，再遍历哈希表，遍历哈希表的过程中使用大小为 100 的小根堆来选出每一个小文件的 Top 100（整体未排序的 Top 100）。<br>每一个小文件都有自己词频的小根堆（整体未排序的 Top 100），将小根堆里的词按照词频排序，就得到了每个小文件的排序后 Top 100。<br>然后把各个小文件排序后的 Top 100 进行外排序或者继续利用小根堆，就可以选出每台机器上的 Top 100。<br>不同机器之间的 Top 100 再进行外排序或者继续利用小根堆，最终求出整个百亿数据量中的 Top 100。</p>
<p>对于 Top K 的问题，除用哈希函数分流和用哈希表做词频统计之外，还经常用堆结构和外排序的手段进行处理。</p>
<h2 id="40-亿个非负整数中找到出现两次的数和所有数的中位数"><a href="#40-亿个非负整数中找到出现两次的数和所有数的中位数" class="headerlink" title="40 亿个非负整数中找到出现两次的数和所有数的中位数"></a>40 亿个非负整数中找到出现两次的数和所有数的中位数</h2><p><strong>题目</strong></p>
<p>32 位无符号整数的范围是 0 ~ 4 294 967 295，现在有 40 亿个无符号整数，可以使用最多 1GB 的内存，找出所有出现了两次的数。</p>
<p><strong>补充问题</strong>：可以使用最多 10MB 的内存，怎么找到这 40 亿个整数的中位数？</p>
<p><strong>解答</strong></p>
<p><strong>原问题：找出出现两次的数</strong></p>
<p>可以用 <strong>bit map</strong> 的方式来表示数出现的情况。具体地说，是申请一个长度为 4 294 967 295 $\times$ 2 的 bit 类型的数组 <code>bitArr</code>，用 2 个位置表示一个数出现的词频。</p>
<ul>
<li>1B 占用 8 个 bit，所以长度为 4 294 967 295 $\times$ 2 的 bit 类型的数组占用 1GB 空间。</li>
</ul>
<p><strong>怎么使用这个 <code>bitArr</code> 数组？</strong><br>遍历这 40 亿个无符号数：</p>
<ul>
<li>如果初次遇到 <code>num</code>，就把 <code>bitArr[num * 2 + 1]</code> 和 <code>bitArr[num * 2]</code> 设置为 01。</li>
<li>如果第二次遇到 <code>num</code>，就把 <code>bitArr[num * 2 + 1]</code> 和 <code>bitArr[num * 2]</code> 设置为 10。</li>
<li>如果第三次遇到 <code>num</code>，就把 <code>bitArr[num * 2 + 1]</code> 和 <code>bitArr[num * 2]</code> 设置为 11。</li>
<li>以后再遇到 <code>num</code>，发现此时 <code>bitArr[num * 2 + 1]</code> 和 <code>bitArr[num * 2]</code> 已经被设置为 11，就不再做任何设置。</li>
</ul>
<p>遍历完成后，再依次遍历 <code>bitArr</code>，如果发现 <code>bitArr[i * 2 + 1]</code> 和 <code>bitArr[i * 2]</code> 设置为 10，那么 $i$ 就是出现了两次的数。</p>
<p><strong>补充问题：找到中位数（内存 10MB）</strong></p>
<p>用 <strong>分区间</strong> 的方式处理。<br>长度为 2MB 的无符号整型数组占用的空间为 8MB，所以将区间的数量定为 4 294 967 295 / 2M，向上取整为 2148 个区间。</p>
<ul>
<li>第 0 区间：0 ~ 2M-1</li>
<li>第 1 区间：2M ~ 4M-1</li>
<li>…</li>
<li>第 $i$ 区间：2M $\times$ $i$ ~ 2M $\times$ ($i$+1) - 1</li>
<li>…</li>
</ul>
<p><strong>步骤 1：定位中位数所在的区间</strong><br>申请一个长度为 2148 的无符号整型数组 <code>arr[0..2147]</code>，<code>arr[i]</code> 表示第 $i$ 区间有多少个数。<code>arr</code> 占用空间非常小，必然小于 10MB。<br>然后遍历 40 亿个数，如果遍历到当前数为 <code>num</code>，先看 <code>num</code> 落在哪个区间上 (<code>num</code> / 2M)，然后将对应的进行 <code>arr[num / 2M]++</code> 操作。<br>这样遍历下来，就得到了每一个区间的数的出现状况，通过累加每个区间的出现次数，就可以找到 40 亿个数的中位数（也就是第 20 亿个数）到底落在哪个区间上。<br>比如，0 ~ $K$-1 区间上数的个数为 19.998 亿，但是发现当加上第 $K$ 个区间上数的个数之后就超过了 20 亿，那么可以知道第 20 亿个数是第 $K$ 区间上的数，并且可以知道第 20 亿个数是第 $K$ 区间上的第 0.002 亿个数。</p>
<p><strong>步骤 2：在特定区间内找到中位数</strong><br>接下来申请一个长度为 2MB 的无符号整型数组 <code>countArr[0..2M-1]</code>，占用空间 8MB。<br>然后遍历 40 亿个数，此时只关心处在第 $K$ 区间的数，记为 <code>numi</code>，其他的数忽略。然后将 <code>countArr[numi - K * 2M]++</code>，也就是只对第 $K$ 区间的数做频率统计。<br>这次遍历完 40 亿个数之后，就得到了第 $K$ 区间的词频统计结果 <code>countArr</code>，最后只在第 $K$ 区间上找到第 0.002 亿个数即可。</p>
<h2 id="一致性哈希算法的基本原理"><a href="#一致性哈希算法的基本原理" class="headerlink" title="一致性哈希算法的基本原理"></a>一致性哈希算法的基本原理</h2><p><strong>题目</strong></p>
<p>工程师常使用服务器集群来设计和实现数据缓存，以下是常见的策略：</p>
<ol>
<li>无论是添加、查询还是删除数据，都先将数据的 id 通过哈希函数转换成一个哈希值，记为 <code>key</code>。</li>
<li>如果目前机器有 $N$ 台，则计算 <code>key % N</code> 的值，这个值就是该数据所属的机器编号，无论是添加、删除还是查询操作，都只在这台机器上进行。</li>
</ol>
<p>请分析这种缓存策略可能带来的问题，并提出改进的方案。</p>
<p><strong>解答</strong></p>
<p><strong>传统哈希策略的问题</strong></p>
<p>题目中描述的缓存策略潜在的问题是：如果增加或删除机器（$N$ 变化），代价会很高。所有的数据都不得不根据 id 重新计算一遍哈希值，并将哈希值对新的机器数进行取模操作，然后进行大规模的数据迁移。</p>
<p><strong>改进方案：一致性哈希算法</strong></p>
<p>一致性哈希算法是一种很好的数据缓存设计方案。<br>我们假设数据的 id 通过哈希函数转换成的哈希值范围是 $2^{32}$，也就是 0 ~ ($2^{32}$-1) 的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的<strong>环形</strong>。</p>
<p><strong>1. 数据与机器的映射</strong></p>
<ul>
<li><strong>数据映射</strong>：一个数据 id 在计算出哈希值之后，认为对应到环中的一个位置上。</li>
<li><strong>机器映射</strong>：想象有三台机器也处在这样一个环中，这三台机器在环中的位置根据机器 id 计算出的哈希值来决定。</li>
<li><strong>归属规则</strong>：一条数据如何确定归属哪台机器呢？首先把该数据的 id 用哈希函数算出哈希值，并映射到环中相应的位置，然后<strong>顺时针</strong>寻找离这个位置最近的机器，那台机器就是该数据的归属。</li>
</ul>
<p><strong>2. 增加/删除机器的处理</strong></p>
<ul>
<li><strong>增加机器</strong>：假设在环中 m1 和 m2 之间增加一台新机器 m3。<ul>
<li>在没有添加 m3 之前，从 m1 到 m2 位置上的这一段是 m2 掌管范围的一部分。</li>
<li>添加 m3 之后，则统一归属于 m3，同时要把这一段旧数据从 m2 迁移到 m3 上。</li>
<li><strong>优点</strong>：添加机器时的调整代价是比较小的，只需要迁移一部分数据。</li>
</ul>
</li>
<li><strong>删除机器</strong>：在删除机器时也一样，只要把要删除机器的数据全部复制到顺时针找到的下一台机器上即可。比如，删除机器 m2，那么只用把 m2 上的数据（包括 data2）迁移到 m1 上即可（假设 m1 是 m2 顺时针的下一台）。</li>
</ul>
<p><strong>3. 数据倾斜与虚拟节点</strong></p>
<p><strong>问题</strong>：如果机器较少，很有可能造成机器在整个环上的分布不均匀，从而导致机器之间的负载不均衡。<br><strong>解决</strong>：引入<strong>虚拟节点</strong>机制。</p>
<ul>
<li>即对每一台机器通过不同的哈希函数计算出多个哈希值，对多个位置都放置一个服务节点，称为虚拟节点。</li>
<li>具体做法可以在机器 ip 地址或主机名的后面增加编号或端口号来实现。例如，可以为每台机器计算两个虚拟节点，分别计算 m1-1、m1-2、m2-1 和 m2-2 的哈希值。</li>
<li>于是形成四个虚拟节点，节点数变多了，根据哈希函数的性质，平衡性自然会变好。</li>
<li>此时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射。</li>
</ul>
<p><strong>虚拟节点映射表示例</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">虚拟节点</th>
<th style="text-align:left">对应的实际节点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">m1-1</td>
<td style="text-align:left">m1</td>
</tr>
<tr>
<td style="text-align:left">m1-2</td>
<td style="text-align:left">m1</td>
</tr>
<tr>
<td style="text-align:left">m2-1</td>
<td style="text-align:left">m2</td>
</tr>
<tr>
<td style="text-align:left">m2-2</td>
<td style="text-align:left">m2</td>
</tr>
</tbody>
</table>
</div>
<p>当某一条数据计算出归属于某一个虚拟节点时，再根据映射表跳转，数据将最终归属于实际的机器。<br>同样，虚拟节点间的数据迁移等操作也都可以根据对应关系，变成实际机器之间的数据迁移操作。<br>通过让每台机器分配数量较多的虚拟节点去抢占哈希环，数量多起来之后，哈希函数的离散性就可以得到很好的体现，然后每台机器就可以按照所占虚拟节点的比例来分配负载了。</p>
<h2 id="岛问题"><a href="#岛问题" class="headerlink" title="岛问题"></a>岛问题</h2><p><strong>题目</strong></p>
<p>给定一个二维数组 <code>matrix</code>，其中只有 0 和 1 两种值，每个位置都与其上下左右相邻。如果一堆 1 可以连成一片，这片区域叫做一个岛。返回 <code>matrix</code> 中岛的数量。</p>
<p><strong>举例</strong><br><code>matrix</code> =<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 0 1 1</span><br><span class="line">1 0 1 1</span><br><span class="line">0 0 0 0</span><br><span class="line">1 0 1 0</span><br></pre></td></tr></table></figure><br>返回 4</p>
<p><code>matrix</code> =<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 1 1 0</span><br><span class="line">1 1 0 1</span><br></pre></td></tr></table></figure><br>返回 2。最右下角的 1 不与左上角的岛相邻，是单独的一个岛。</p>
<p><strong>进阶问题</strong>：<br>如果 <code>matrix</code> 规模巨大，一般实现的方法会用一个 CPU 来计算出结果，时间就非常长。如果你有多个 CPU，或者说有多个计算单元，请设计一种并行算法来解决这个问题，当 <code>matrix</code> 规模巨大时，任务是可以并行执行的，时间不会太长。</p>
<p><strong>解答</strong></p>
<p><strong>原问题（非并行算法）</strong></p>
<p>从左往右遍历每一行，整体从上往下遍历所有的行。<br>如果来到一个是 1 的位置，开始一个“感染”过程，就是从当前位置出发，把连成一片的 1 全部变成 2。“感染”过程结束后，继续遍历 <code>matrix</code>，直到结束。有多少次“感染”的过程，就有多少个岛。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countIslands</span><span class="params">(<span class="type">int</span>[][] m)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">null</span> || m[<span class="number">0</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> m.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> m[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                infect(m, i, j, N, M);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设m矩阵的大小为N行M列，从i行j列开始“感染”过程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infect</span><span class="params">(<span class="type">int</span>[][] m, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> N, <span class="type">int</span> M)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果i行j列位置已经越界，或者这个位置上不是1，退出“感染”过程。</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= N || j &lt; <span class="number">0</span> || j &gt;= M || m[i][j] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m[i][j] = <span class="number">2</span>; <span class="comment">// 对于访问过的位置，值都变成2，所以每个位置只会“感染”一次，不可能死循环</span></span><br><span class="line">    infect(m, i + <span class="number">1</span>, j, N, M); <span class="comment">// “感染”下位置</span></span><br><span class="line">    infect(m, i - <span class="number">1</span>, j, N, M); <span class="comment">// “感染”上位置</span></span><br><span class="line">    infect(m, i, j - <span class="number">1</span>, N, M); <span class="comment">// “感染”左位置</span></span><br><span class="line">    infect(m, i, j + <span class="number">1</span>, N, M); <span class="comment">// “感染”右位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于值不为 1 的位置，“感染”过程和主过程如果访问到，都会直接跳过这个位置。对于所有值为 1 的位置，感染过程只会访问 1 次，然后就会把值改为 2，以后再访问到这个位置，“感染”过程和主过程都会直接跳过这个位置。所以该方法的时间复杂度为 $O(N \times M)$。</p>
<p><strong>进阶问题（并行算法）</strong></p>
<p>如果整个矩阵被划分成左、右两部分，而且两部分几乎同样大小，那么如何正确求解岛的数量。</p>
<p><strong>核心逻辑</strong>：</p>
<ol>
<li>左、右两部分用两个 CPU 单独计算岛的数量，假设算出左部分岛的数量为 2，右部分岛的数量为 2，但是矩阵整体岛的数量是 1。为什么单独求两部分岛的总数 $\ge$ 矩阵整体岛的数量？这是因为我们把左右两部分分开之后，有可能使原本属于一个岛的区域被划分成了两个区域。原本是连通的部分，现在被分割了。所以需要设计两部分合并在一起时，减少岛数量的逻辑。</li>
<li>收集左部分的右边界信息。对于被“感染”的位置，则收集这个位置是由哪个开始位置“感染”来的。</li>
<li>收集右部分的左边界信息。对于被“感染”的位置，就收集这个位置是由哪个开始位置“感染”来的。</li>
<li><strong>合并过程</strong>：<ul>
<li>目前左部分和右部分岛总数为 4，记为 <code>all=4</code>。我们把 A、B、C、D 设置放入 4 个集合里，也就是并查集的初始化过程，四个集合分别为 <code>&#123;A&#125;</code>, <code>&#123;B&#125;</code>, <code>&#123;C&#125;</code>, <code>&#123;D&#125;</code>。然后从上往下查看左部分的右边界和右部分的左边界。</li>
<li>右边界第 1 个 2 是 A“感染”来的，这个 2 的右边（就是右部分的左边界）也是 2，是 C “感染”来的，这就产生了连通。查询 A 和 C 是否属于一个集合，发现不是。这说明 A“感染”的区域和 C “感染”的区域原本是连通的，但是因为分割变成两部分。所以 <code>all=4</code> 应该变成 <code>all=3</code>，也就是考虑连通情况之后，应该减少一个岛。然后把 A 所在的集合与 C 所在的集合进行合并，集合的情况变为 <code>&#123;A,C&#125;</code>, <code>&#123;B&#125;</code>, <code>&#123;D&#125;</code>。此时 A“感染”的区域和 C “感染”的区域共属于一个集合，说明连通在了一起。</li>
<li>右边界第 2 个 2 是 B 感染来的，这个 2 的右边（就是右部分的左边界）也是 2，是 C “感染”来的，这就产生了连通。查询 B 和 C 是否属于一个集合，发现不是。这说明 B“感染”的区域和 C“感染”的区域原本是连通的，但是因为分割变成两部分。所以 <code>all=3</code> 应该变成 <code>all=2</code>，也就是考虑连通情况之后，应该减少一个岛。然后把 B 所在的集合与 C 所在的集合进行合并，集合的情况变为 <code>&#123;A,C,B&#125;</code>, <code>&#123;D&#125;</code>。此时 A、B、C“感染”的区域共属于一个集合，说明连通在了一起。</li>
<li>右边界第 3 个 2 是 B“感染”来的，这个 2 的右边（就是右部分的左边界）也是 2，是 D “感染”来的，这就产生了连通。查询 B 和 D 是否属于一个集合，发现不是。这说明 B“感染”的区域和 D“感染”的区域原本是连通的，但是因为分割变成两部分。所以 <code>all=2</code> 应该变成 <code>all=1</code>，也就是考虑连通情况之后，应该减少一个岛。然后把 B 所在的集合与 D 所在的集合进行合并，集合的情况变为 <code>&#123;A,C,B,D&#125;</code>。此时 A、B、C、D“感染”的区域共属于一个集合，说明连通在了一起。</li>
<li>右边界第 4 个 2 是 A“感染”来的，这个 2 的右边（就是右部分的左边界）也是 2，是 D “感染”来的，这就产生了连通。查询 A 和 D 是否属于一个集合，发现是。说明之前这两部分一定有其他的连通途径，并且已经连通了。所以不减少岛的数量。此时遍历该结束，整体的岛数量是 1。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong><br>我们正是利用了<strong>并查集</strong>可以快速查询两个元素是否属于同一个集合，并且可以快速合并两个元素各自集合的操作来实现合并过程的。<br>在合并的过程中只需要关注左部分的右边界与右部分的左边界，其他部分的信息一律不需要关注，这个代价是非常低的。<br>所以总的并行过程为两步：</p>
<ol>
<li>并行计算两部分岛的数量以及收集边界信息。</li>
<li>利用并查集实现减少岛的过程。</li>
</ol>
<p>这比用一个 CPU 从头遍历到尾明显更快。如果有很多 CPU 或者计算单元，我们可以把整个 <code>matrix</code> 等分地切成多个部分，对每部分都计算岛数量，以及每个部分四个边界的信息都收集。在合并的时候，依然利用并查集结构实现任意相邻两部分的合并，速度就更快了。<br>同时，并查集这个结构的实现也可以用分布式内存技术，所以本题可以进一步扩展成为一个系统设计题。</p>
<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="不用额外变量交换两个整数的值"><a href="#不用额外变量交换两个整数的值" class="headerlink" title="不用额外变量交换两个整数的值"></a>不用额外变量交换两个整数的值</h2><p><strong>题目</strong></p>
<p>如何不用任何额外变量交换两个整数的值？</p>
<p><strong>解答</strong></p>
<p>如果给定整数 a 和 b，用以下三行代码即可交换 a 和 b 的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>
<p><strong>如何理解这三行代码的具体功能呢？</strong></p>
<p>首先要理解异或运算的特点：</p>
<ol>
<li>假设 <code>a</code> 异或 <code>b</code> 的结果记为 <code>c</code>，<code>c</code> 就是 <code>a</code> 整数位信息和 <code>b</code> 整数位信息的所有不同信息。<ul>
<li>比如，<code>a = 4 = 100</code>，<code>b = 3 = 011</code>，<code>a ^ b = c = 111</code>。</li>
</ul>
</li>
<li><code>a</code> 异或 <code>c</code> 的结果就是 <code>b</code>。<ul>
<li>比如 <code>a = 4 = 100</code>，<code>c = 111</code>，<code>a ^ c = 011 = 3 = b</code>。</li>
</ul>
</li>
<li><code>b</code> 异或 <code>c</code> 的结果就是 <code>a</code>。<ul>
<li>比如 <code>b = 3 = 011</code>，<code>c = 111</code>，<code>b ^ c = 100 = 4 = a</code>。</li>
</ul>
</li>
</ol>
<p><strong>执行过程分析</strong>：</p>
<p>在执行上面三行代码之前，假设有 <code>a</code> 信息和 <code>b</code> 信息。</p>
<ol>
<li><code>a = a ^ b</code>：执行完第一行代码之后，<code>a</code> 变成了 <code>c</code>（<code>a ^ b</code>），<code>b</code> 还是 <code>b</code>。</li>
<li><code>b = a ^ b</code>：执行完第二行代码之后，<code>a</code> 仍然是 <code>c</code>，<code>b</code> 变成了 <code>a</code>（因为 <code>c ^ b = a</code>）。</li>
<li><code>a = a ^ b</code>：执行完第三行代码之后，<code>a</code> 变成了 <code>b</code>（因为 <code>c ^ a = b</code>，此时 <code>b</code> 已经是原来的 <code>a</code> 了，这里其实是 <code>c ^ (原来的a) = 原来的b</code>）。</li>
</ol>
<p>过程结束，a 和 b 完成交换。<br>位运算的题目基本上都带有靠经验积累才会做的特征，也就是在准备阶段需要做足够多的题，面试时才会有良好的感觉。</p>
<h2 id="不用做任何比较判断找出两个数中较大的数"><a href="#不用做任何比较判断找出两个数中较大的数" class="headerlink" title="不用做任何比较判断找出两个数中较大的数"></a>不用做任何比较判断找出两个数中较大的数</h2><p><strong>题目</strong></p>
<p>给定两个 32 位整数 a 和 b，返回 a 和 b 中较大的。</p>
<p><strong>要求</strong></p>
<p>不用做任何比较判断。</p>
<p><strong>解答</strong></p>
<p><strong>方法一：利用减法结果的符号</strong></p>
<p>得到 <code>a - b</code> 的值的符号，就可以知道是返回 a 还是返回 b。<br><code>sign</code> 函数的功能是返回整数 <code>n</code> 的符号，正数和 0 返回 1，负数则返回 0。<br><code>flip</code> 函数的功能是如果 <code>n</code> 为 1，返回 0，如果 <code>n</code> 为 0，返回 1。</p>
<p>如果 <code>a - b</code> 的结果为 0 或正数，那么 <code>scA</code> 为 1，<code>scB</code> 为 0；如果 <code>a - b</code> 的值为负数，那么 <code>scA</code> 为 0，<code>scB</code> 为 1。<br>所以 <code>return a * scA + b * scB</code> 就是根据 <code>a - b</code> 的值的状况，选择要返回 a，要么返回 b。</p>
<p><strong>局限性</strong>：如果 <code>a - b</code> 的值出现溢出，返回结果就不正确。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">flip</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n ^ <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sign</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> flip((n &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMax1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a - b;</span><br><span class="line">    <span class="type">int</span> <span class="variable">scA</span> <span class="operator">=</span> sign(c);</span><br><span class="line">    <span class="type">int</span> <span class="variable">scB</span> <span class="operator">=</span> flip(scA);</span><br><span class="line">    <span class="keyword">return</span> a * scA + b * scB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法二：解决溢出问题</strong></p>
<p>彻底解决溢出问题。溢出只可能发生在 a 和 b 符号不同的情况下（例如正数减负数可能溢出），如果 a 和 b 符号相同，<code>a - b</code> 绝不会溢出。</p>
<p><strong>逻辑分析</strong>：</p>
<ol>
<li>如果 a 的符号与 b 的符号不同 (<code>difSab == 1</code>, <code>sameSab == 0</code>)：<ul>
<li>如果 a 为 0 或正 (<code>sa == 1</code>, <code>sb == 0</code>)，应该返回 a。</li>
<li>如果 a 为负 (<code>sa == 0</code>, <code>sb == 1</code>)，应该返回 b。</li>
</ul>
</li>
<li>如果 a 的符号与 b 的符号相同 (<code>difSab == 0</code>, <code>sameSab == 1</code>)，这种情况下 <code>a - b</code> 的值绝对不会溢出：<ul>
<li>如果 <code>a - b</code> 为 0 或正 (<code>sc == 1</code>)，返回 a。</li>
<li>如果 <code>a - b</code> 为负 (<code>sc == 0</code>)，返回 b。</li>
</ul>
</li>
</ol>
<p><strong>综上所述</strong>，应该返回 a 的条件是：</p>
<ol>
<li>符号不同且 a 为正 (<code>difSab == 1 &amp;&amp; sa == 1</code>)</li>
<li>符号相同且 <code>a - b</code> 为正 (<code>sameSab == 1 &amp;&amp; sc == 1</code>)</li>
</ol>
<p>即 <code>returnA = difSab * sa + sameSab * sc</code>。<br>同理 <code>returnB = flip(returnA)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMax2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a - b;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sa</span> <span class="operator">=</span> sign(a);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sb</span> <span class="operator">=</span> sign(b);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sc</span> <span class="operator">=</span> sign(c);</span><br><span class="line">    <span class="type">int</span> <span class="variable">difSab</span> <span class="operator">=</span> sa ^ sb; <span class="comment">// a和b符号不一样，为1；一样，为0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sameSab</span> <span class="operator">=</span> flip(difSab); <span class="comment">// a和b符号一样，为1；不一样，为0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">returnA</span> <span class="operator">=</span> difSab * sa + sameSab * sc;</span><br><span class="line">    <span class="type">int</span> <span class="variable">returnB</span> <span class="operator">=</span> flip(returnA);</span><br><span class="line">    <span class="keyword">return</span> a * returnA + b * returnB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="只用位运算不用算术运算实现整数的加减乘除运算"><a href="#只用位运算不用算术运算实现整数的加减乘除运算" class="headerlink" title="只用位运算不用算术运算实现整数的加减乘除运算"></a>只用位运算不用算术运算实现整数的加减乘除运算</h2><p><strong>题目</strong></p>
<p>给定两个 32 位整数 a 和 b，可正、可负、可 0。不能使用算术运算符，分别实现 a 和 b 的加减乘除运算。</p>
<p><strong>要求</strong></p>
<p>如果给定的 a 和 b 执行加减乘除的某些结果本来就会导致数据的溢出，那么你实现的函数不必对那些结果负责。</p>
<p><strong>解答</strong></p>
<p><strong>1. 加法运算</strong></p>
<p>用位运算实现加法运算。</p>
<ul>
<li>如果不考虑进位，<code>a^b</code> 就是正确结果（异或运算相当于无进位加法）。</li>
<li>只考虑进位，<code>a&amp;b</code> 的结果再左移一位 <code>(a&amp;b)&lt;&lt;1</code> 就是进位产生的值。</li>
<li>把完全不考虑进位的相加值与只考虑进位产生的进位值相加，就是最终的结果。这是一个循环过程，直到进位产生的值完全消失。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        sum = a ^ b; <span class="comment">// 无进位加法</span></span><br><span class="line">        b = (a &amp; b) &lt;&lt; <span class="number">1</span>; <span class="comment">// 进位信息</span></span><br><span class="line">        a = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 减法运算</strong></p>
<p>实现 <code>a - b</code> 只要实现 <code>a + (-b)</code> 即可。根据二进制补码规则，得到一个数的相反数，就是这个数的二进制数表达取反加 1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">negNum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> add(~n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> add(a, negNum(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 乘法运算</strong></p>
<p>模拟竖式乘法。<code>a * b</code> 的结果可以写成 $a \times 2^0 \times b<em>0 + a \times 2^1 \times b_1 + \dots + a \times 2^{31} \times b</em>{31}$，其中 $b_i$ 为 0 或 1，代表整数 b 的二进制数表达中第 $i$ 位的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">multi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            res = add(res, a);</span><br><span class="line">        &#125;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        b &gt;&gt;&gt;= <span class="number">1</span>; <span class="comment">// 无符号右移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. 除法运算</strong></p>
<p>除法运算其实是乘法的逆运算。先看 a 和 b 都不为负数的情况。<br>例如 <code>a = 286</code>，<code>b = 22</code>。<br>看 a 能包含多少个 b，从 $b \times 2^{31}$ 开始尝试，如果 $a \ge b \times 2^{31}$，说明 a 包含了一个 $b \times 2^{31}$，结果累加 $2^{31}$，然后 a 减去 $b \times 2^{31}$ 继续尝试；否则尝试 $b \times 2^{30}$…<br>以上过程只适用于 a 和 b 都不是负数的情况。如果 a 和 b 中有一个为负数或者都为负数时，可以先转成正数计算，再根据真实符号调整。</p>
<p><strong>除法实现的难点：最小值问题</strong><br>32 位整数最小值为 -2147483648，最大值为 2147483647。最小值的绝对值比最大值的绝对值大 1，所以如果 a 或 b 等于最小值，是转不成对应的正数的（会溢出）。<br>需要特殊处理：</p>
<ol>
<li>如果 a 和 b 都不为最小值，直接使用通用过程。</li>
<li>如果 a 和 b 都为最小值，结果为 1。</li>
<li>如果 a 不为最小值，b 为最小值，结果为 0。</li>
<li><strong>如果 a 为最小值，b 不为最小值</strong>：<ul>
<li>先把 a 增加一点（比如加 1）或者减少一点，让它变成不是最小值，计算出一个结果。</li>
<li>例如计算 <code>(a+1)/b</code>，得到结果 <code>c</code>。</li>
<li>计算 <code>a - (c*b)</code>，得到剩余值。</li>
<li>计算 <code>(a - (c*b)) / b</code>，得到修正值。</li>
<li>最终结果为 <code>c + 修正值</code>。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNeg</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> isNeg(a) ? negNum(a) : a;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> isNeg(b) ? negNum(b) : b;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt; -<span class="number">1</span>; i = minus(i, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((x &gt;&gt; i) &gt;= y) &#123;</span><br><span class="line">            res |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            x = minus(x, y &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isNeg(a) ^ isNeg(b) ? negNum(res) : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;divisor is 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == Integer.MIN_VALUE &amp;&amp; b == Integer.MIN_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == Integer.MIN_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == Integer.MIN_VALUE) &#123;</span><br><span class="line">        <span class="comment">// a是最小值，无法转正数，特殊处理</span></span><br><span class="line">        <span class="comment">// res = (a + 1) / b</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> div(add(a, <span class="number">1</span>), b);</span><br><span class="line">        <span class="comment">// 最终结果 = res + (a - res * b) / b</span></span><br><span class="line">        <span class="keyword">return</span> add(res, div(minus(a, multi(res, b)), b));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> div(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="整数的二进制数表达中有多少个-1"><a href="#整数的二进制数表达中有多少个-1" class="headerlink" title="整数的二进制数表达中有多少个 1"></a>整数的二进制数表达中有多少个 1</h2><p><strong>题目</strong></p>
<p>给定一个 32 位整数 n，可为 0，可为正，也可为负，返回该整数二进制数表达中 1 的个数。</p>
<p><strong>解答</strong></p>
<p><strong>方法一：逐位检查</strong></p>
<p>最简单的解法，整数 <code>n</code> 每次进行无符号右移一位，检查最右边的 bit 是否为 1 来进行统计。<br>这种方法在最复杂的情况下要经过 32 次循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        res += n &amp; <span class="number">1</span>;</span><br><span class="line">        n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法二：利用 n &amp; (n - 1)</strong></p>
<p>循环次数只与 1 的个数有关。<br>每次进行 <code>n &amp;= (n - 1)</code> 操作时，在 <code>while</code> 循环中就可以忽略掉 bit 位上为 0 的部分。<br><code>n &amp;= (n - 1)</code> 操作的实质是抹掉最右边的 1。<br>例如，<code>n = 01000100</code>，<code>n-1 = 01000011</code>，<code>n &amp; (n-1) = 01000000</code>。<br>下一次，<code>n = 01000000</code>，<code>n-1 = 00111111</code>，<code>n &amp; (n-1) = 00000000</code>。<br>每次操作消除一个 1，直到 <code>n</code> 变为 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法三：利用 n &amp; (~n + 1)</strong></p>
<p><code>n &amp; (~n + 1)</code> 也是移除最右侧的 1 的过程（或者更准确说是提取最右侧的 1）。<br><code>~n + 1</code> 即为 <code>-n</code>（补码）。<code>n &amp; -n</code> 提取出最右侧的 1。<br>例如 <code>n = 01000100</code>，<code>n &amp; (~n + 1) = 00000100</code>。<br>然后 <code>n -= (n &amp; (~n + 1))</code> 就可以抹掉最右侧的 1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count3</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        n -= n &amp; (~n + <span class="number">1</span>);</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法四：并行算法（归并思想）</strong></p>
<p>这种方法通过分组统计 1 的个数来实现，不需要循环。</p>
<ol>
<li>每两个 bit 一组，统计每组中 1 的个数。</li>
<li>每四个 bit 一组，统计每组中 1 的个数（利用上一步的结果）。</li>
<li>依次类推，直到 32 个 bit 为一组。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count4</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    n = (n &amp; <span class="number">0x55555555</span>) + ((n &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    n = (n &amp; <span class="number">0x33333333</span>) + ((n &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    n = (n &amp; <span class="number">0x0f0f0f0f</span>) + ((n &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>);</span><br><span class="line">    n = (n &amp; <span class="number">0x00ff00ff</span>) + ((n &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>);</span><br><span class="line">    n = (n &amp; <span class="number">0x0000ffff</span>) + ((n &gt;&gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>原理解释</strong>：</p>
<ul>
<li><code>0x55555555</code>：二进制 <code>010101...</code>。<code>(n &amp; 0x55555555) + ((n &gt;&gt;&gt; 1) &amp; 0x55555555)</code> 将相邻 2 位相加，存储在 2 位中。</li>
<li><code>0x33333333</code>：二进制 <code>00110011...</code>。将相邻 4 位（由 2 个 2 位组构成）相加，存储在 4 位中。</li>
<li>… 类似归并的过程，组与组之间的数量合并成一个大组。</li>
</ul>
<p>除此以外，还有很多极为“逆天”的算法可以解决这个问题，比如 MIT hackmem 算法等。但对面试来说，那些方法实在是太偏、难、怪，所以本书不再介绍。</p>
<h2 id="在其他数都出现偶数次的数组中找到出现奇数次的数"><a href="#在其他数都出现偶数次的数组中找到出现奇数次的数" class="headerlink" title="在其他数都出现偶数次的数组中找到出现奇数次的数"></a>在其他数都出现偶数次的数组中找到出现奇数次的数</h2><p><strong>题目</strong></p>
<p>给定一个整型数组 <code>arr</code>，其中只有一个数出现了奇数次，其他的数都出现了偶数次，打印这个数。</p>
<p><strong>进阶问题</strong>：有两个数出现了奇数次，其他的数都出现了偶数次，打印这两个数。</p>
<p><strong>要求</strong></p>
<p>时间复杂度为 $O(N)$，额外空间复杂度为 $O(1)$。</p>
<p><strong>解答</strong></p>
<p><strong>原问题</strong></p>
<p>整数 <code>n</code> 与 0 异或的结果是 <code>n</code>，整数 <code>n</code> 与整数 <code>n</code> 异或的结果是 0。而且异或运算满足交换律和结合律。<br>所以，申请一个整型变量 <code>eO</code>，初始化为 0。遍历数组，把 <code>eO</code> 和每个数进行异或 (<code>eO = eO ^ 当前数</code>)。<br>因为其他的数都出现偶数次，偶数次异或的结果为 0，最后 <code>eO</code> 的值就是出现奇数次的那个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printOddTimesNum1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">eO</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cur : arr) &#123;</span><br><span class="line">        eO ^= cur;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(eO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>进阶问题</strong></p>
<p>如果只有 A 和 B 出现了奇数次，那么最后的异或结果 <code>eO</code> 就是 <code>A ^ B</code>。<br>因为 A 不等于 B，所以 <code>eO</code> 一定不等于 0，那么肯定能在 32 位整数 <code>eO</code> 上找到一个不等于 0 的 bit 位，假设是第 $k$ 位不等于 0。<br><code>eO</code> 在第 $k$ 位不等于 0，说明 A 和 B 的第 $k$ 位肯定一个是 1，另一个是 0。<br>接下来再设置一个变量记为 <code>eOhasOne</code>，然后遍历一次数组。在这次遍历时，<code>eOhasOne</code> 只与第 $k$ 位上是 1 的整数异或，其他的数忽略。<br>那么在第二次遍历结束后，<code>eOhasOne</code> 就是 A 或者 B 中的一个，而 <code>eO ^ eOhasOne</code> 就是另外一个出现奇数次的数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printOddTimesNum2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">eO</span> <span class="operator">=</span> <span class="number">0</span>, eOhasOne = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> curNum : arr) &#123;</span><br><span class="line">        eO ^= curNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 提取出 eO 最右侧的 1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rightOne</span> <span class="operator">=</span> eO &amp; (~eO + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cur : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((cur &amp; rightOne) != <span class="number">0</span>) &#123;</span><br><span class="line">            eOhasOne ^= cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(eOhasOne + <span class="string">&quot; &quot;</span> + (eO ^ eOhasOne));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在其他数都出现-k-次的数组中找到只出现一次的数"><a href="#在其他数都出现-k-次的数组中找到只出现一次的数" class="headerlink" title="在其他数都出现 k 次的数组中找到只出现一次的数"></a>在其他数都出现 k 次的数组中找到只出现一次的数</h2><p><strong>题目</strong></p>
<p>给定一个整型数组 <code>arr</code> 和一个大于 1 的整数 <code>k</code>。已知 <code>arr</code> 中只有一个数出现了 1 次，其他的数都出现了 <code>k</code> 次，请返回只出现了 1 次的数。</p>
<p><strong>要求</strong></p>
<p>时间复杂度为 $O(N)$，额外空间复杂度为 $O(1)$。</p>
<p><strong>解答</strong></p>
<p><strong>原理</strong>：利用 $k$ 进制无进位加法。</p>
<p>以下的例子是两个七进制数的无进位相加，即忽略进位相加，比如：</p>
<ul>
<li>七进制数 a：<code>6 4 3 2 6 0 1</code></li>
<li>七进制数 b：<code>3 4 5 0 1 1 1</code></li>
<li>无进位相加结果：<code>2 1 1 2 0 1 2</code></li>
</ul>
<p>可以看出，两个七进制的数 a 和 b，在 $i$ 位上无进位相加的结果就是 $(a(i)+b(i)) \% 7$。<br>同理，$k$ 进制的两个数 c 和 d 在 $i$ 位上无进位相加的结果就是 $(c(i)+d(i)) \% k$。<br>那么，如果 $k$ 个相同的 $k$ 进制数进行无进位相加，相加的结果一定是每一位上都是 0 的 $k$ 进制数。</p>
<p><strong>解题思路</strong>：</p>
<ol>
<li>设置一个变量 <code>eO</code>，它是一个 32 位的 $k$ 进制数，且每个位置上都是 0。</li>
<li>遍历 <code>arr</code>，把遍历到的每一个整数都转换为 $k$ 进制数，然后与 <code>eO</code> 进行无进位相加。</li>
<li>遍历结束时，把 32 位的 $k$ 进制数 <code>eO</code> 转换为十进制整数，就是我们想要的结果。<ul>
<li>因为 $k$ 个相同的 $k$ 进制数无进位相加，结果一定是每一位上都是 0 的 $k$ 进制数，所以那些出现了 $k$ 次的数在累加过程中都会变成 0，最终只剩下出现一次的那个数。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onceNum</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] eO = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        setExclusiveOr(eO, arr[i], k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> getNumFromKSysNum(eO, k);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExclusiveOr</span><span class="params">(<span class="type">int</span>[] eO, <span class="type">int</span> value, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] curKSysNum = getKSysNumFromNum(value, k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != eO.length; i++) &#123;</span><br><span class="line">        eO[i] = (eO[i] + curKSysNum[i]) % k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getKSysNumFromNum(<span class="type">int</span> value, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (value != <span class="number">0</span>) &#123;</span><br><span class="line">        res[index++] = value % k;</span><br><span class="line">        value = value / k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumFromKSysNum</span><span class="params">(<span class="type">int</span>[] eO, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> eO.length - <span class="number">1</span>; i != -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        res = res * k + eO[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数组和矩阵问题"><a href="#数组和矩阵问题" class="headerlink" title="数组和矩阵问题"></a>数组和矩阵问题</h1><h2 id="转圈打印矩阵"><a href="#转圈打印矩阵" class="headerlink" title="转圈打印矩阵"></a>转圈打印矩阵</h2><p><strong>题目</strong></p>
<p>给定一个整型矩阵 <code>matrix</code>，请按照转圈的方式打印它。<br>例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1   2   3   4</span><br><span class="line">5   6   7   8</span><br><span class="line">9   10  11  12</span><br><span class="line">13  14  15  16</span><br></pre></td></tr></table></figure><br>打印结果为：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10</p>
<p><strong>要求</strong></p>
<p>额外空间复杂度为 $O(1)$。</p>
<p><strong>解答</strong></p>
<p><strong>思路</strong>：矩阵分圈处理。<br>在矩阵中用左上角的坐标 <code>(tR, tC)</code> 和右下角的坐标 <code>(dR, dC)</code> 就可以表示一个子矩阵。<br>例如，当 <code>(tR, tC) = (0, 0)</code>、<code>(dR, dC) = (3, 3)</code> 时，表示的子矩阵就是整个矩阵，那么这个子矩阵最外层的部分如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1   2   3   4</span><br><span class="line">5           8</span><br><span class="line">9           12</span><br><span class="line">13  14  15  16</span><br></pre></td></tr></table></figure><br>如果能把这个子矩阵的外层转圈打印出来，结果为：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5。<br>接下来令 <code>tR</code> 和 <code>tC</code> 加 1，即 <code>(tR, tC) = (1, 1)</code>，令 <code>dR</code> 和 <code>dC</code> 减 1，即 <code>(dR, dC) = (2, 2)</code>。此时表示的子矩阵如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6   7</span><br><span class="line">10  11</span><br></pre></td></tr></table></figure><br>再把这个子矩阵转圈打印出来，结果为：6, 7, 11, 10。<br>如果发现左上角坐标跑到了右下角坐标的右方或下方，整个过程就停止。已经打印的所有结果连起来就是我们要求的打印结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">spiralOrderPrint</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tR</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tC</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dR</span> <span class="operator">=</span> matrix.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dC</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (tR &lt;= dR &amp;&amp; tC &lt;= dC) &#123;</span><br><span class="line">        printEdge(matrix, tR++, tC++, dR--, dC--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEdge</span><span class="params">(<span class="type">int</span>[][] m, <span class="type">int</span> tR, <span class="type">int</span> tC, <span class="type">int</span> dR, <span class="type">int</span> dC)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tR == dR) &#123; <span class="comment">// 子矩阵只有一行时</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> tC; i &lt;= dC; i++) &#123;</span><br><span class="line">            System.out.print(m[tR][i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tC == dC) &#123; <span class="comment">// 子矩阵只有一列时</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> tR; i &lt;= dR; i++) &#123;</span><br><span class="line">            System.out.print(m[i][tC] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 一般情况</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curC</span> <span class="operator">=</span> tC;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curR</span> <span class="operator">=</span> tR;</span><br><span class="line">        <span class="keyword">while</span> (curC != dC) &#123;</span><br><span class="line">            System.out.print(m[tR][curC] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            curC++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curR != dR) &#123;</span><br><span class="line">            System.out.print(m[curR][dC] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            curR++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curC != tC) &#123;</span><br><span class="line">            System.out.print(m[dR][curC] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            curC--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curR != tR) &#123;</span><br><span class="line">            System.out.print(m[curR][tC] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            curR--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将正方形矩阵顺时针转动-90°"><a href="#将正方形矩阵顺时针转动-90°" class="headerlink" title="将正方形矩阵顺时针转动 90°"></a>将正方形矩阵顺时针转动 90°</h2><p><strong>题目</strong></p>
<p>给定一个 $N \times N$ 的矩阵 <code>matrix</code>，把这个矩阵调整成顺时针转动 90° 后的形式。<br>例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1   2   3   4</span><br><span class="line">5   6   7   8</span><br><span class="line">9   10  11  12</span><br><span class="line">13  14  15  16</span><br></pre></td></tr></table></figure><br>顺时针转动 90° 后为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">13  9   5   1</span><br><span class="line">14  10  6   2</span><br><span class="line">15  11  7   3</span><br><span class="line">16  12  8   4</span><br></pre></td></tr></table></figure></p>
<p><strong>要求</strong></p>
<p>额外空间复杂度为 $O(1)$。</p>
<p><strong>解答</strong></p>
<p><strong>思路</strong>：矩阵分圈处理。<br>同样使用左上角坐标 <code>(tR, tC)</code> 和右下角坐标 <code>(dR, dC)</code> 来表示一个子矩阵。<br>例如，当 <code>(tR, tC) = (0, 0)</code>、<code>(dR, dC) = (3, 3)</code> 时，子矩阵最外层的部分如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1   2   3   4</span><br><span class="line">5           8</span><br><span class="line">9           12</span><br><span class="line">13  14  15  16</span><br></pre></td></tr></table></figure><br>在这个外圈中：</p>
<ul>
<li>1, 4, 16, 13 为一组，让 1 占据 4 的位置，4 占据 16 的位置，16 占据 13 的位置，13 占据 1 的位置。</li>
<li>2, 8, 15, 9 为一组，继续占据调整。</li>
<li>3, 12, 14, 5 为一组，继续占据调整。</li>
</ul>
<p>通过这种分组调整的方式，可以实现顺时针转动 90°。<br>如果子矩阵的大小是 $M \times M$，一共就有 $M-1$ 组，分别进行占据调整即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tR</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tC</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dR</span> <span class="operator">=</span> matrix.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dC</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (tR &lt; dR) &#123;</span><br><span class="line">        rotateEdge(matrix, tR++, tC++, dR--, dC--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotateEdge</span><span class="params">(<span class="type">int</span>[][] m, <span class="type">int</span> tR, <span class="type">int</span> tC, <span class="type">int</span> dR, <span class="type">int</span> dC)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> dC - tC; <span class="comment">// times 就是总的组数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != times; i++) &#123; <span class="comment">// 一次循环就是一组占据调整</span></span><br><span class="line">        tmp = m[tR][tC + i];</span><br><span class="line">        m[tR][tC + i] = m[dR - i][tC];</span><br><span class="line">        m[dR - i][tC] = m[dR][dC - i];</span><br><span class="line">        m[dR][dC - i] = m[tR + i][dC];</span><br><span class="line">        m[tR + i][dC] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="“之”字形打印矩阵"><a href="#“之”字形打印矩阵" class="headerlink" title="“之”字形打印矩阵"></a>“之”字形打印矩阵</h2><p><strong>题目</strong></p>
<p>给定一个矩阵 <code>matrix</code>，按照“之”字形的方式打印这个矩阵。<br>例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1   2   3   4</span><br><span class="line">5   6   7   8</span><br><span class="line">9   10  11  12</span><br></pre></td></tr></table></figure><br>“之”字形打印的结果为：1, 2, 5, 9, 6, 3, 4, 7, 10, 11, 8, 12。</p>
<p><strong>要求</strong></p>
<p>额外空间复杂度为 $O(1)$。</p>
<p><strong>解答</strong></p>
<p><strong>思路</strong>：</p>
<ol>
<li>上坐标 <code>(tR, tC)</code> 初始为 <code>(0, 0)</code>，先沿着矩阵第一行移动 (<code>tC++</code>)，当到达第一行最右边的元素后，再沿着矩阵最后一列移动 (<code>tR++</code>)。</li>
<li>下坐标 <code>(dR, dC)</code> 初始为 <code>(0, 0)</code>，先沿着矩阵第一列移动 (<code>dR++</code>)，当到达第一列最下边的元素时，再沿着矩阵最后一行移动 (<code>dC++</code>)。</li>
<li>上坐标与下坐标同步移动，每次移动后的上坐标与下坐标的连线就是矩阵中的一条斜线，打印斜线上的元素即可。</li>
<li>如果上次斜线是从左下向右上打印的，这次一定是从右上向左下打印，反之亦然。可以把打印的方向用 boolean 值表示，每次取反即可。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMatrixZigZag</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tR</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tC</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dR</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dC</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">endR</span> <span class="operator">=</span> matrix.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">endC</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">fromUp</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (tR != endR + <span class="number">1</span>) &#123;</span><br><span class="line">        printLevel(matrix, tR, tC, dR, dC, fromUp);</span><br><span class="line">        tR = tC == endC ? tR + <span class="number">1</span> : tR;</span><br><span class="line">        tC = tC == endC ? tC : tC + <span class="number">1</span>;</span><br><span class="line">        dC = dR == endR ? dC + <span class="number">1</span> : dC;</span><br><span class="line">        dR = dR == endR ? dR : dR + <span class="number">1</span>;</span><br><span class="line">        fromUp = !fromUp;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLevel</span><span class="params">(<span class="type">int</span>[][] m, <span class="type">int</span> tR, <span class="type">int</span> tC, <span class="type">int</span> dR, <span class="type">int</span> dC, <span class="type">boolean</span> f)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (f) &#123;</span><br><span class="line">        <span class="keyword">while</span> (tR != dR + <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(m[tR++][tC--] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (dR != tR - <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(m[dR--][dC++] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="找到无序数组中最小的-k-个数"><a href="#找到无序数组中最小的-k-个数" class="headerlink" title="找到无序数组中最小的 k 个数"></a>找到无序数组中最小的 k 个数</h2><p><strong>题目</strong></p>
<p>给定一个无序的整型数组 <code>arr</code>，找到其中最小的 <code>k</code> 个数。</p>
<p><strong>要求</strong></p>
<p>如果数组 <code>arr</code> 的长度为 $N$，排序之后自然可以得到最小的 <code>k</code> 个数，此时时间复杂度与排序的时间复杂度相同，均为 $O(N \log N)$。本题要求实现时间复杂度为 $O(N \log k)$ 和 $O(N)$ 的方法。</p>
<p><strong>解答</strong></p>
<p><strong>方法一：$O(N \log k)$ 的方法</strong></p>
<p>一直维护一个有 <code>k</code> 个数的大根堆，这个堆代表目前选出的 <code>k</code> 个最小的数，在堆里的 <code>k</code> 个元素中堆顶的元素是最小的 <code>k</code> 个数里最大的那个。</p>
<ol>
<li>先将数组前 <code>k</code> 个元素建堆。</li>
<li>接下来遍历整个数组，遍历的过程中看当前数是否比堆顶元素小。<ul>
<li>如果是，就把堆顶的元素替换成当前的数，然后从堆顶的位置调整整个堆，让替换操作后堆的最大元素继续处在堆顶的位置。</li>
<li>如果不是，则不进行任何操作，继续遍历下一个数。</li>
</ul>
</li>
<li>在遍历完成后，堆中的 <code>k</code> 个数就是所有数组中最小的 <code>k</code> 个数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getMinKNumsByHeap(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">1</span> || k &gt; arr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] kHeap = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != k; i++) &#123;</span><br><span class="line">        heapInsert(kHeap, arr[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i != arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; kHeap[<span class="number">0</span>]) &#123;</span><br><span class="line">            kHeap[<span class="number">0</span>] = arr[i];</span><br><span class="line">            heapify(kHeap, <span class="number">0</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kHeap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> value, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    arr[index] = value;</span><br><span class="line">    <span class="keyword">while</span> (index != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[parent] &lt; arr[index]) &#123;</span><br><span class="line">            swap(arr, parent, index);</span><br><span class="line">            index = parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; heapSize) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> left + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">        largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">        <span class="keyword">if</span> (largest == index) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, largest, index);</span><br><span class="line">        index = largest;</span><br><span class="line">        left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法二：$O(N)$ 的方法 (BFPRT 算法)</strong></p>
<p>利用经典的 <strong>BFPRT 算法</strong>，该算法于 1973 年由 Blum、Floyd、Pratt、Rivest 和 Tarjan 联合发明。BFPRT 算法解决的问题是在时间复杂度 $O(N)$ 内，从无序的数组中找到第 $k$ 小的数。<br>显然，如果我们找到了第 $k$ 小的数，那么想求 <code>arr</code> 中最小的 <code>k</code> 个数，就是再遍历一次数组的工作量而已。</p>
<p><strong>BFPRT 算法流程 (<code>select(arr, k)</code>)</strong>：</p>
<ol>
<li>将 <code>arr</code> 中的 $n$ 个元素划分成 $n/5$ 组，每组 5 个元素，如果最后的组不够 5 个元素，那么最后剩下的元素为一组。</li>
<li>对每个组进行插入排序，只针对每个组最多 5 个元素之间的组内排序，组与组之间并不排序。排序后找到每个组的中位数，如果组的元素个数为偶数，这里规定找到下中位数。</li>
<li>步骤 2 中一共会找到 $n/5$ 个中位数，让这些中位数组成一个新的数组，记为 <code>mArr</code>。递归调用 <code>select(mArr, mArr.length / 2)</code>，意义是找到 <code>mArr</code> 数组中的中位数，即 <code>mArr</code> 中第 <code>mArr.length / 2</code> 小的数，记为 <code>pivot</code>（划分值）。</li>
<li>根据 <code>pivot</code> 划分整个 <code>arr</code> 数组（partition 过程）：在 <code>arr</code> 中，比 <code>pivot</code> 小的都在 <code>pivot</code> 的左边，大于 <code>pivot</code> 的都在 <code>pivot</code> 的右边，<code>pivot</code> 在中间。划分完成后，<code>pivot</code> 在 <code>arr</code> 中的位置记为 <code>i</code>。</li>
<li>如果 <code>i == k - 1</code>，说明 <code>pivot</code> 为整个数组中第 <code>k</code> 小的数，直接返回。<ul>
<li>如果 <code>i &lt; k - 1</code>，说明 <code>pivot</code> 处在第 <code>k</code> 小的数的左边，应该在 <code>pivot</code> 的右半区寻找第 <code>k - i - 1</code> 小的数。</li>
<li>如果 <code>i &gt; k - 1</code>，说明 <code>pivot</code> 处在第 <code>k</code> 小的数的右边，应该在 <code>pivot</code> 的左半区寻找第 <code>k</code> 小的数。</li>
</ul>
</li>
</ol>
<p><strong>为什么复杂度是 $O(N)$？</strong><br>$T(N) = T(N/5) + T(7N/10) + O(N)$，可以证明 $T(N)$ 收敛于 $O(N)$。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getMinKNumsByBFPRT(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">1</span> || k &gt; arr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minKth</span> <span class="operator">=</span> getMinKthByBFPRT(arr, k);</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; minKth) &#123;</span><br><span class="line">            res[index++] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; index != res.length; index++) &#123;</span><br><span class="line">        res[index] = minKth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinKthByBFPRT</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] copyArr = Arrays.copyOf(arr, arr.length);</span><br><span class="line">    <span class="keyword">return</span> select(copyArr, <span class="number">0</span>, copyArr.length - <span class="number">1</span>, K - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> begin, <span class="type">int</span> end, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[begin];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> medianOfMedians(arr, begin, end);</span><br><span class="line">    <span class="type">int</span>[] pivotRange = partition(arr, begin, end, pivot);</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= pivotRange[<span class="number">0</span>] &amp;&amp; i &lt;= pivotRange[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; pivotRange[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> select(arr, begin, pivotRange[<span class="number">0</span>] - <span class="number">1</span>, i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> select(arr, pivotRange[<span class="number">1</span>] + <span class="number">1</span>, end, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">medianOfMedians</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> end - begin + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> num % <span class="number">5</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] mArr = <span class="keyword">new</span> <span class="title class_">int</span>[num / <span class="number">5</span> + offset];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mArr.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">beginI</span> <span class="operator">=</span> begin + i * <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">endI</span> <span class="operator">=</span> beginI + <span class="number">4</span>;</span><br><span class="line">        mArr[i] = getMedian(arr, beginI, Math.min(end, endI));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> select(mArr, <span class="number">0</span>, mArr.length - <span class="number">1</span>, mArr.length / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] partition(<span class="type">int</span>[] arr, <span class="type">int</span> begin, <span class="type">int</span> end, <span class="type">int</span> pivotValue) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> begin - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> begin;</span><br><span class="line">    <span class="type">int</span> <span class="variable">big</span> <span class="operator">=</span> end + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != big) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] &lt; pivotValue) &#123;</span><br><span class="line">            swap(arr, ++small, cur++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &gt; pivotValue) &#123;</span><br><span class="line">            swap(arr, cur, --big);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] range = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    range[<span class="number">0</span>] = small + <span class="number">1</span>;</span><br><span class="line">    range[<span class="number">1</span>] = big - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> range;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMedian</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    insertionSort(arr, begin, end);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> end + begin;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (sum / <span class="number">2</span>) + (sum % <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> arr[mid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin + <span class="number">1</span>; i != end + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j != begin; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                swap(arr, j - <span class="number">1</span>, j);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="需要排序的最短子数组长度"><a href="#需要排序的最短子数组长度" class="headerlink" title="需要排序的最短子数组长度"></a>需要排序的最短子数组长度</h2><p>【题目】</p>
<p>给定一个无序数组 arr，求出需要排序的最短子数组长度。<br>例如：arr = [1,5,3,4,2,6,7] 返回 4，因为只有 [5,3,4,2] 需要排序。</p>
<p>【解答】</p>
<p>解决这个问题可以做到时间复杂度为 O(N)、额外空间复杂度为 O(1)。</p>
<p>初始化变量 noMinIndex=-1，从右向左遍历，遍历的过程中记录右侧出现过的数的最小值，记为 min。假设当前数为 arr[i]，如果 arr[i]&gt;min，说明如果要整体有序，min 值必然会挪到 arr[i] 的左边。用 noMinIndex 记录最左边出现这种情况的位置。如果遍历完成后，noMinIndex 依然等于 -1，说明从右到左始终不升序（原数组本来就有序），直接返回 0，即完全不需要排序。</p>
<p>接下来从左向右遍历，遍历的过程中记录左侧出现过的数的最大值，记为 max。假设当前数为 arr[i]，如果 arr[i]&lt;max，说明如果排序，max 值必然会挪到 arr[i] 的右边。用变量 noMaxIndex 记录最右边出现这种情况的位置。</p>
<p>遍历完成后，arr[noMinIndex..noMaxIndex] 是真正需要排序的部分，返回它的长度即可。</p>
<p>具体过程参看如下代码中的 getMinLength 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinLength</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[arr.length - <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">noMinIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">2</span>; i != -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; min) &#123;</span><br><span class="line">            noMinIndex = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            min = Math.min(min, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (noMinIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">noMaxIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i != arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; max) &#123;</span><br><span class="line">            noMaxIndex = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> noMaxIndex - noMinIndex + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在数组中找到出现次数大于-N-K-的数"><a href="#在数组中找到出现次数大于-N-K-的数" class="headerlink" title="在数组中找到出现次数大于 N/K 的数"></a>在数组中找到出现次数大于 N/K 的数</h2><p>【题目】</p>
<p>给定一个整型数组 arr，打印其中出现次数大于一半的数，如果没有这样的数，打印提示信息。</p>
<p>进阶问题：给定一个整型数组 arr，再给定一个整数 K，打印所有出现次数大于 N/K 的数，如果没有这样的数，打印提示信息。</p>
<p>【要求】</p>
<p>原问题要求时间复杂度为 O(N)，额外空间复杂度为 O(1)。进阶问题要求时间复杂度为 O(N×K)，额外空间复杂度为 O(K)。</p>
<p>【解答】</p>
<p>无论是原问题还是进阶问题，都可以用哈希表记录每个数及其出现的次数，但是额外空间复杂度为 O(N)，不符合题目要求。<br>核心思路是：一次在数组中删掉 K 个不同的数，不停地删除，直到剩下的数的种类不足 K 就停止删除，那么，如果一个数在数组中出现的次数大于 N/K，则这个数最后一定会被剩下来。</p>
<p>对于原问题，出现次数大于一半的数最多只会有一个。具体的过程为，一次在数组中删掉两个不同的数，不停地删除，直到剩下的数只有一种，如果一个数出现次数大。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printHalfMajor</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cand</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (times == <span class="number">0</span>) &#123;</span><br><span class="line">            cand = arr[i];</span><br><span class="line">            times = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] == cand) &#123;</span><br><span class="line">            times++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            times--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    times = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == cand) &#123;</span><br><span class="line">            times++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (times &gt; arr.length / <span class="number">2</span>) &#123;</span><br><span class="line">        System.out.println(cand);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;no such number.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>printHalfMajor 方法中第一个 for 循环就是一次在数组中删掉两个不同数的代码实现。我们把变量 cand 叫作候选，times 叫作次数。</p>
<ul>
<li>times==0 时，表示当前没有候选，则把当前数 arr[i] 设成候选，同时把 times 设置成 1。</li>
<li>times!=0 时，表示当前有候选，如果当前的数 arr[i] 与候选一样，就把 times 加 1；如果当前的数 arr[i] 与候选不一样，就把 times 减 1，减到 0 则表示又没有候选了。</li>
</ul>
<p>第一个 for 循环的实质就是我们的核心解题思路，一次在数组中删掉两个不同的数，不停地删除，直到剩下的数只有一种，如果一个数出现次数大于一半，则这个数最后一定会被剩下来，也就是最后的 cand 值。<br>这里请注意一点，一个数出现次数虽然大于一半，它肯定会被剩下来，但这并不表示剩下来的数一定是符合条件的。例如，1，2，1，其中 1 符合出现次数超过了一半，所以 1 肯定会剩下来。再如 1，2，3，其中没有任何一个数出现的次数超过了一半，可 3 最后也剩下来了。所以 printHalfMajor 方法中第二个 for 循环的工作就是检验最后剩下来的那个数（即 cand）是否真的是出现次数大于一半的数。</p>
<p>进阶问题解法核心也是类似的，一次在数组中删掉 K 个不同的数，不停地删除，直到剩下的数的种类不足 K。如果要立 K-1 个候选，然后有 K-1 个 times 统计即可。具体过程如下。<br>遍历到 arr[i] 时，看 arr[i] 是否与已经被选出的某一个候选相同。<br>如果与某一个候选相同，就把属于那个候选的点数统计加 1。<br>如果与所有的候选都不相同，先看当前的候选是否选满了，K-1 就是满，否则就是不满：</p>
<ul>
<li>如果不满，把 arr[i] 作为一个新的候选，属于它的点数初始化为 1。</li>
<li>如果已满，说明此时发现了 K 个不同的数，arr[i] 就是第 K 个。此时把每一个候选各自的点数全部减 1，表示每个候选“付出”一个自己的点数。如果某些候选的点数在减 1 之后等于 0，则还需要把这些候选都删除，候选又变成不满的状态。</li>
</ul>
<p>在遍历过程结束后，再遍历一次 arr，验证被选出来的所有候选有哪些出现次数真的大于 N/K，打印符合条件的候选。具体请参看如下代码中的 printKMajor 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printKMajor</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (K &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;the value of K is invalid.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; cands = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cands.containsKey(arr[i])) &#123;</span><br><span class="line">            cands.put(arr[i], cands.get(arr[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cands.size() == K - <span class="number">1</span>) &#123;</span><br><span class="line">                allCandsMinusOne(cands);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cands.put(arr[i], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; reals = getReals(arr, cands);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasPrint</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;Integer, Integer&gt; set : cands.entrySet()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> set.getKey();</span><br><span class="line">        <span class="keyword">if</span> (reals.get(key) &gt; arr.length / K) &#123;</span><br><span class="line">            hasPrint = <span class="literal">true</span>;</span><br><span class="line">            System.out.print(key + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(hasPrint ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;no such number.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">allCandsMinusOne</span><span class="params">(HashMap&lt;Integer, Integer&gt; map)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; removeList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;Integer, Integer&gt; set : map.entrySet()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> set.getKey();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> set.getValue();</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">1</span>) &#123;</span><br><span class="line">            removeList.add(key);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(key, value - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Integer removeKey : removeList) &#123;</span><br><span class="line">        map.remove(removeKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> HashMap&lt;Integer, Integer&gt; <span class="title function_">getReals</span><span class="params">(<span class="type">int</span>[] arr,</span></span><br><span class="line"><span class="params">        HashMap&lt;Integer, Integer&gt; cands)</span> &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; reals = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curNum</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="keyword">if</span> (cands.containsKey(curNum)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (reals.containsKey(curNum)) &#123;</span><br><span class="line">                reals.put(curNum, reals.get(curNum) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reals.put(curNum, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【扩展】</p>
<p>这种一次删掉 K 个不同的数的思想在面试中通常会变形之后反复出现。例如，下面这道面试真题：有一场投票，投票有效的条件是必须有一个候选人得票数超过半数，但是验票人员不能看到每张选票上选了谁，只能把任意两张选票放到一台机器上看这两张选票是否一样，若一样，则机器给出 true 的提醒，不一样则给出 false 的提醒。如果你作为验票的人员，怎么判断这场投票是有效的？<br>这道题就是原问题的变形，但是“不能看到每张选票上选了谁”的这个限制实际上把用哈希表来解题的可能性完全堵死了。但本文的方法却可以满足题目的要求，因为我们实现的方法只需要对当前数和候选数做比较，而不需要知道每个数的值。</p>
<h2 id="在行列都排好序的矩阵中找指定数"><a href="#在行列都排好序的矩阵中找指定数" class="headerlink" title="在行列都排好序的矩阵中找指定数"></a>在行列都排好序的矩阵中找指定数</h2><p>【题目】</p>
<p>给定一个 N×M 的整型矩阵 matrix 和一个整数 K，matrix 的每一行和每一列都是排好序的。实现一个函数，判断 K 是否在 matrix 中。<br>例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 5</span><br><span class="line">2 3 4 7</span><br><span class="line">4 4 4 8</span><br><span class="line">5 7 7 9</span><br></pre></td></tr></table></figure><br>如果 K 为 7，返回 true；如果 K 为 6，返回 false。</p>
<p>【要求】</p>
<p>时间复杂度为 O(N+M)，额外空间复杂度为 O(1)。</p>
<p>【解答】</p>
<p>符合要求的解法比较巧妙且易于理解。<br>可以用以下步骤解决：</p>
<ol>
<li>从矩阵最右上角的数开始寻找（row=0，col=M-1）。</li>
<li>比较当前数 matrix[row][col] 与 K 的关系：<ul>
<li>如果与 K 相等，说明已找到，直接返回 true。</li>
<li>如果比 K 大，因为矩阵每一列都已排好序，所以在当前数所在的列中，处于当前数下方的数都会比 K 大，则没有必要继续在第 col 列上寻找，令 col=col-1，重复步骤 2。</li>
<li>如果比 K 小，因为矩阵每一行都已排好序，所以在当前数所在的行中，处于当前数左方的数都会比 K 小，则没有必要继续在第 row 行上寻找，令 row=row+1，重复步骤 2。</li>
</ul>
</li>
<li>如果找到越界都没有发现与 K 相等的数，则返回 false。</li>
</ol>
<p>或者，也可以用以下步骤：</p>
<ol>
<li>从矩阵最左下角的数开始寻找（row=N-1，col=0）。</li>
<li>比较当前数 matrix[row][col] 与 K 的关系：<ul>
<li>如果与 K 相等，说明已找到，直接返回 true。</li>
<li>如果比 K 大，因为矩阵每一行都已排好序，所以在当前数所在的行中，处于当前数右方的数都会比 K 大，则没有必要继续在第 row 行上寻找，令 row=row-1，重复步骤 2。</li>
<li>如果比 K 小，因为矩阵每一列都已排好序，所以在当前数所在的列中，处于当前数上方的数都会比 K 小，则没有必要继续在第 col 列上寻找，令 col=col+1，重复步骤 2。</li>
</ul>
</li>
<li>如果找到越界都没有发现与 K 相等的数，则返回 false。</li>
</ol>
<p>具体请参看如下代码中的 isContains 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isContains</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (row &lt; matrix.length &amp;&amp; col &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[row][col] == K) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &gt; K) &#123;</span><br><span class="line">            col--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最长的可整合子数组的长度"><a href="#最长的可整合子数组的长度" class="headerlink" title="最长的可整合子数组的长度"></a>最长的可整合子数组的长度</h2><p>【题目】</p>
<p>先给出可整合数组的定义：如果一个数组在排序之后，每相邻两个数差的绝对值都为 1，则该数组为可整合数组。例如，[5,3,4,6,2] 排序之后为 [2,3,4,5,6]，符合每相邻两个数差的绝对值都为 1，所以这个数组为可整合数组。</p>
<p>给定一个整型数组 arr，请返回其中最大可整合子数组的长度。例如，[5,5,3,2,6,4,3] 的最大可整合子数组为 [5,3,2,6,4]，所以返回 5。</p>
<p>【解答】</p>
<p><strong>方法一：时间复杂度高但容易理解的做法</strong></p>
<p>对 arr 中的每一个子数组 arr[i..j]（0≤i≤j≤N-1），都验证一下是否符合可整合数组的定义，也就是对 arr[i..j] 排序，看是否依次递增且每次递增 1。然后在所有符合可整合数组定义的子数组中，记录最大的那个长度，返回即可。<br>需要注意的是，在考查每一个 arr[i..j] 是否符合可整合数组定义的时候，都得把 arr[i..j] 单独复制成一个新的数组，然后把这个新的数组排序、验证，而不能直接改变 arr 中元素的顺序。所以大体过程如下：</p>
<ol>
<li>依次考查每一个子数组 arr[i..j]（0≤i≤j≤N-1），一共有 O(N²) 个。</li>
<li>对每一个子数组 arr[i..j]，复制成一个新的数组，记为 newArr，把 newArr 排序，然后验证是否符合可整合数组的定义，这一步代价为 O(MlogM)（M 为子数组长度）。</li>
<li>步骤 2 中符合条件的、最大的那个子数组的长度就是结果。</li>
</ol>
<p>具体请参看如下代码中的 getLIL1 方法，时间复杂度为 O(N²)×O(NlogN) -&gt; O(N³logN)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLIL1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isIntegrated(arr, i, j)) &#123;</span><br><span class="line">                len = Math.max(len, j - i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIntegrated</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] newArr = Arrays.copyOfRange(arr, left, right + <span class="number">1</span>); <span class="comment">// O(N)</span></span><br><span class="line">    Arrays.sort(newArr); <span class="comment">// O(N*logN)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; newArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newArr[i - <span class="number">1</span>] != newArr[i] - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法二：时间复杂度为 O(N²) 的做法</strong></p>
<p>第一种方法严格按照题目的意思来验证每一个子数组是否是可整合数组，但是验证可整合数组真的需要如此麻烦吗？有没有更好的方法来加速验证过程？这也是本书提供方法的核心。<br>判断一个数组是否是可整合数组还可以用以下方法：一个数组中如果没有重复元素，并且最大值减去最小值，再加 1 的结果等于元素个数（max-min+1==元素个数），那么这个数组就是可整合数组。比如 [3,2,5,6,4]，max-min+1 = 6-2+1 = 5 == 元素个数，所以这个数组是可整合数组。</p>
<p>这样，验证每一个子数组是否是可整合数组的时间复杂度可以从第一种方法的 O(NlogN) 加速至 O(1)，整个过程的时间复杂度就可加速到 O(N²)。具体请参看如下代码中的 getLIL2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLIL2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;(); <span class="comment">// 判断重复</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        max = Integer.MIN_VALUE;</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(arr[j])) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(arr[j]);</span><br><span class="line">            max = Math.max(max, arr[j]);</span><br><span class="line">            min = Math.min(min, arr[j]);</span><br><span class="line">            <span class="keyword">if</span> (max - min == j - i) &#123; <span class="comment">// 新的检查方式</span></span><br><span class="line">                len = Math.max(len, j - i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不重复打印排序数组中相加和为给定值的所有二元组和三元组"><a href="#不重复打印排序数组中相加和为给定值的所有二元组和三元组" class="headerlink" title="不重复打印排序数组中相加和为给定值的所有二元组和三元组"></a>不重复打印排序数组中相加和为给定值的所有二元组和三元组</h2><p>【题目】</p>
<p>给定排序数组 arr 和整数 k，不重复打印 arr 中所有相加和为 k 的不降序二元组。<br>例如，arr=[-8,-4,-3,0,1,2,4,5,8,9]，k=10，打印结果为：<br>1,9<br>2,8</p>
<p>补充问题：给定排序数组 arr 和整数 k，不重复打印 arr 中所有相加和为 k 的不降序三元组。<br>例如，arr=[-8,-4,-3,0,1,2,4,5,8,9]，k=10，打印结果为：<br>-4,5,9<br>-3,4,9<br>-3,5,8<br>0,1,9<br>0,2,8<br>1,4,5</p>
<p>【解答】</p>
<p>利用排序后数组的特点，打印二元组的过程可以用一个左指针和一个右指针不断向中间压缩的方式实现，具体过程为：</p>
<ol>
<li>设置变量 left=0，right=arr.length-1。</li>
<li>比较 arr[left]+arr[right] 的值 (sum) 与 k 的大小：<ul>
<li>如果 sum 等于 k，打印 “arr[left],arr[right]”，则 left++，right—。</li>
<li>如果 sum 大于 k，right—。</li>
<li>如果 sum 小于 k，left++。</li>
</ul>
</li>
<li>如果 left&lt;right，则一直重复步骤 2，否则过程结束。</li>
</ol>
<p>那么如何保证不重复打印相同的二元组呢？只需在打印时增加一个检查即可，检查 arr[left] 是否与它前一个值 arr[left-1] 相等，如果相等，就不打印。具体解释为：因为整体过程是从两头向中间压缩的过程，如果 arr[left]+arr[right]==k，又有 arr[left]==arr[left-1]，那么之前一定已经打印过这个二元组，此时无须重复打印。比如 arr=[1,1,1,9]，k=10。首先打印 arr[0] 和 arr[3] 的组合，接下来就不再重复打印 1 和 9 这个二元组。</p>
<p>具体过程请参看如下代码中的 printUniquePair 方法，时间复杂度 O(N)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printUniquePair</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[left] + arr[right] &lt; k) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[left] + arr[right] &gt; k) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (left == <span class="number">0</span> || arr[left - <span class="number">1</span>] != arr[left]) &#123;</span><br><span class="line">                System.out.println(arr[left] + <span class="string">&quot;,&quot;</span> + arr[right]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三元组的问题类似于二元组的求解过程。<br>例如：<br>arr=[-8,-4,-3,0,1,2,4,5,8,9]，k=10。</p>
<ul>
<li>当三元组的第一个值为 -8 时，寻找 -8 后面的子数组中所有相加为 18 的不重复二元组。</li>
<li>当三元组的第一个值为 -4 时，寻找 -4 后面的子数组中所有相加为 14 的不重复二元组。</li>
<li>当三元组的第一个值为 -3 时，寻找 -3 后面的子数组中所有相加为 13 的不重复二元组。<br>依此类推。<br>如何不重复打印相同的三元组呢？首先要保证每次寻找过程开始前，选定的三元组中第一个值不重复，其次就是和原问题的打印检查一样，要保证不重复打印二元组。<br>具体请参看如下代码中的 printUniqueTriad 方法，时间复杂度为 O(N²)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printUniqueTriad</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || arr[i] != arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            printRest(arr, i, i + <span class="number">1</span>, arr.length - <span class="number">1</span>, k - arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printRest</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> f, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[l] + arr[r] &lt; k) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[l] + arr[r] &gt; k) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (l == f + <span class="number">1</span> || arr[l - <span class="number">1</span>] != arr[l]) &#123;</span><br><span class="line">                System.out.println(arr[f] + <span class="string">&quot;,&quot;</span> + arr[l] + <span class="string">&quot;,&quot;</span> + arr[r]);</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="未排序正数数组中累加和为给定值的最长子数组长度"><a href="#未排序正数数组中累加和为给定值的最长子数组长度" class="headerlink" title="未排序正数数组中累加和为给定值的最长子数组长度"></a>未排序正数数组中累加和为给定值的最长子数组长度</h2><p>【题目】</p>
<p>给定一个数组 arr，该数组无序，但每个值均为正数，再给定一个正数 k。求 arr 的所有子数组中所有元素相加和为 k 的最长子数组长度。<br>例如，arr=[1,2,1,1,1]，k=3。<br>累加和为 3 的最长子数组为 [1,1,1]，所以结果返回 3。</p>
<p>【解答】</p>
<p>最优解可以做到时间复杂度为 O(N)、额外空间复杂度为 O(1)。首先用两个位置来标记子数组的左右两头，记为 left 和 right，开始时都在数组的最左边 (left=0, right=0)。整体过程如下：</p>
<ol>
<li>开始时变量 left=0，right=0，代表子数组 arr[left..right]。</li>
<li>变量 sum 始终表示子数组 arr[left..right] 的和。开始时 sum=arr[0]，即 arr[0..0] 的和。</li>
<li>变量 len 一直记录累加和为 k 的所有子数组中最大子数组的长度。开始时，len=0。</li>
<li>根据 sum 与 k 的比较结果决定是 left 移动还是 right 移动，具体如下：<ul>
<li>如果 sum==k，说明 arr[left..right] 累加和为 k，如果 arr[left..right] 长度大于 len，则更新 len，此时因为数组中所有的值都为正数，那么所有从 left 位置开始，在 right 之后的位置结束的子数组，即 arr[left..i(i&gt;right)]，累加和一定大于 k。所以，令 left 加 1，这表示我们开始考查以 left 之后的位置开始的子数组，同时令 sum-=arr[left]，sum 此时开始表示 arr[left+1..right] 的累加和。</li>
<li>如果 sum 小于 k，说明 arr[left..right] 还需要加上 right 后面的值，其和才可能达到 k，所以，令 right 加 1，sum+=arr[right]。需要注意的是，right 加 1 后是否越界。</li>
<li>如果 sum 大于 k，说明所有从 left 位置开始，在 right 之后的位置结束的子数组，即 arr[left..i(i&gt;right)]，累加和一定大于 k。所以，令 left 加 1，这表示我们开始考查以 left 之后的位置开始的子数组，同时令 sum-=arr[left]，sum 此时表示 arr[left+1..right] 的累加和。</li>
</ul>
</li>
<li>如果 right&lt;arr.length，重复步骤 4。否则直接返回 len，全部过程结束。</li>
</ol>
<p>具体请参看如下代码中的 getMaxLength 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaxLength</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; arr.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == k) &#123;</span><br><span class="line">            len = Math.max(len, right - left + <span class="number">1</span>);</span><br><span class="line">            sum -= arr[left++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; k) &#123;</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span> (right == arr.length) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += arr[right];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum -= arr[left++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="未排序数组中累加和为给定值的最长子数组系列问题"><a href="#未排序数组中累加和为给定值的最长子数组系列问题" class="headerlink" title="未排序数组中累加和为给定值的最长子数组系列问题"></a>未排序数组中累加和为给定值的最长子数组系列问题</h2><p>【题目】</p>
<p>给定一个无序数组 arr，其中元素可正、可负、可 0。给定一个整数 k，求 arr 所有的子数组中累加和为 k 的最长子数组长度。</p>
<p>补充问题 1：给定一个无序数组 arr，其中元素可正、可负、可 0。求 arr 所有的子数组中正数与负数个数相等的最长子数组长度。</p>
<p>补充问题 2：给定一个无序数组 arr，其中元素只是 1 或 0。求 arr 所有的子数组中 0 和 1 个数相等的最长子数组长度。</p>
<p>【解答】</p>
<p>本书提供的方法可以做到时间复杂度为 O(N)、额外空间复杂度为 O(N)。首先来看原问题。<br>为了说明解法，先定义 s 的概念，s(i) 代表子数组 arr[0..i] 所有元素的累加和。那么子数组 arr<a href="0≤j≤i&lt;arr.length">j..i</a> 的累加和为 s(i)-s(j-1)，因为根据定义，s(i)=arr[0..i] 的累加和等于 arr[0..j-1] 的累加和与 arr[j..i] 的累加和相加，又有 arr[0..j-1] 的累加和为 s(j-1)。所以，arr[j..i] 的累加和为 s(i)-s(j-1)，这个结论是求解这道题的核心。</p>
<p>原问题解法只遍历一次 arr，具体过程为：</p>
<ol>
<li>设置变量 sum=0，表示从 0 位置开始一直加到 i 位置所有元素的和。设置变量 len=0，表示累加和为 k 的最长子数组长度。设置哈希表 map，其中，key 表示从 arr 最左边开始累加的过程中出现过的 sum 值，对应的 value 值则表示 sum 值最早出现的位置。</li>
<li>从左到右开始遍历，遍历的当前元素为 arr[i]。<br>1) 令 sum=sum+arr[i]，即之前所有元素的累加和 s(i)，在 map 中查看是否存在 sum-k。<ul>
<li>如果 sum-k 存在，从 map 中取出 sum-k 对应的 value 值，记为 j，j 代表从左到右不断累加的过程中第一次加出 sum-k 这个累加和的位置。根据之前得出的结论，arr[j+1..i] 的累加和为 s(i)-s(j)，此时 s(i)=sum，又有 s(j)=sum-k，所以 arr[j+1..i] 的累加和为 k。同时因为 map 中只记录每一个累加和最早出现的位置，所以此时的 arr[j+1..i] 是在必须以 arr[i] 结尾的所有子数组中，最长的累加和为 k 的子数组，如果该子数组的长度大于 len，就更新 len。</li>
<li>如果 sum-k 不存在，说明在必须以 arr[i] 结尾的情况下没有累加和为 k 的子数组。<br>2) 检查当前的 sum（即 s(i)）是否在 map 中。如果不存在，说明此时的 sum 值是第一次出现的，就把记录 (sum,i) 加入到 map 中。如果 sum 存在，说明之前已经出现过 sum，map 只记录一个累加和最早出现的位置，所以此时什么记录也不加。</li>
</ul>
</li>
<li>继续遍历下一个元素，直到所有的元素遍历完。</li>
</ol>
<p>大体过程如上，但还有一个很重要的问题需要处理。根据 arr[j+1..i] 的累加和为 s(i)-s(j)，所以，如果从 0 位置开始累加，会导致 j+1≥1。也就是说，所有从 0 位置开始的子数组都没有考虑过。所以，应该从 -1 位置开始累加，也就是在遍历之前先把 (0,-1) 这个记录放进 map，这个记录的意义是如果任何一个数都不加时，累加和为 0。这样，从 0 位置开始的子数组就被我们考虑到了。</p>
<p>具体过程请参看如下代码中的 maxLength 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxLength</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>, -<span class="number">1</span>); <span class="comment">// 重要</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(sum - k)) &#123;</span><br><span class="line">            len = Math.max(i - map.get(sum - k), len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(sum)) &#123;</span><br><span class="line">            map.put(sum, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理解了原问题的解法后，补充问题是可以迅速解决的。<br>第一个补充问题是先把数组 arr 中的正数全部变成 1，负数全部变成 -1，0 不变，然后求累加和为 0 的最长子数组长度即可。<br>第二个补充问题是先把数组 arr 中的 0 全部变成 -1，1 不变，然后求累加和为 0 的最长子数组长度即可。<br>两个补充问题的代码略。</p>
<h2 id="未排序数组中累加和小于或等于给定值的最长子数组长度"><a href="#未排序数组中累加和小于或等于给定值的最长子数组长度" class="headerlink" title="未排序数组中累加和小于或等于给定值的最长子数组长度"></a>未排序数组中累加和小于或等于给定值的最长子数组长度</h2><p>【题目】</p>
<p>给定一个无序数组 arr，其中元素可正、可负、可 0。给定一个整数 k，求 arr 所有的子数组中累加和小于或等于 k 的最长子数组长度。<br>例如：arr=[3,-2,-4,0,6]，k=-2，相加和小于或等于 -2 的最长子数组为 {3,-2,-4,0}，所以结果返回 4。</p>
<p>【要求】</p>
<p>实现出时间复杂度为 O(N) 的方法。</p>
<p>【解答】</p>
<p>时间复杂度为 O(NlogN)，额外空间复杂度为 O(N) 的解法。<br>依次求以数组中每个位置结尾的、累加和小于或等于 k 的最长子数组长度，其中最长的那个子数组的长度就是我们要的结果。为了便于读者理解，我们举一个比较具体的例子。<br>假设处理到位置 30，从位置 0 到位置 30 的累加和为 100（sum[0..30]=100），现在想求以位置 30 结尾的、累加和小于或等于 10 的最长子数组长度。再假设从位置 0 开始累加到位置 10 的时候，累加和第一次大于或等于 90（sum[0..10]≥90），那么可以知道以位置 30 结尾的相加和小于或等于 10 的最长子数组就是 arr[11..30]。也就是说，如果从 0 位置到 j 位置的累加和为 sum[0..j]，此时想求以 j 位置结尾的相加和小于或等于 k 的最长子数组长度。那么只要知道大于或等于 sum[0..j]-k 这个值的累加和最早出现在 j 之前的什么位置就可以，假设那个位置是 i 位置，那么 arr[i+1..j] 就是在 j 位置结尾的相加和小于或等于 k 的最长子数组。</p>
<p>为了很方便地找到大于或等于某一个值的累加和最早出现的位置，可以按照如下方法生成辅助数组 helpArr。</p>
<ol>
<li>生成 arr 每个位置从左到右的累加和数组 sumArr。以 [1,2,-1,5,-2] 为例，生成的 sumArr=[0,1,3,2,7,5]。注意，sumArr 中的第一个数为 0，表示没有任何一个数时的累加和为 0。</li>
<li>生成 sumArr 的左侧最大值数组 helpArr，sumArr={0,1,3,2,7,5} -&gt; helpArr={0,1,3,3,7,7}。为什么原来的 sumArr 数组中的 2 和 5 变为 3 和 7 呢？因为我们只关心大于或等于某一个值的累加和最早出现的位置，而累加和 3 出现在 2 之前，并且大于或等于 3，必然大于 2。所以，当然要保留一个更大的、出现更早的累加和。</li>
<li>helpArr 是 sumArr 每个位置上左侧的最大值数组，那么它当然是有序的。在这样一个有序的数组中，就可以二分查找大于或等于某一个值的累加和最早出现的位置。例如，在 [0,1,3,3,7,7] 中查找大于或等于 4 这个值的位置，就是第一个 7 的位置。</li>
</ol>
<p>以原题中给的例子来说明整个计算过程。<br>arr = [3,-2,-4,0,6]，k = -2。</p>
<ol>
<li>arr=[3,-2,-4,0,6]，求 arr 的累加数数组 sumArr=[0,3,1,-3,-3,3]，进一步得 sumArr 左侧的最大值数组 [0,3,3,3,3,3]。</li>
<li>j=0 时，sum[0..0]=3，所以在 helpArr 中二分查找大于或等于 3-k=3-(-2)=5 这个值第一次出现的位置，结果是没有。可知以位置 0 结尾的所有子数组累加后没有小于或等于 k (即 -2) 的。</li>
<li>j=1 时，sum[0..1]=1，所以在 helpArr 中二分查找大于或等于 1-k=1-(-2)=3 这个值第一次出现的位置，在 helpArr 中的位置是 1，对应的 arr 中的位置是 0。所以，arr[1..1] 是满足条件的最长数组。</li>
<li>j=2 时，sum[0..2]=-3，所以在 helpArr 中二分查找大于或等于 -3-k=-3-(-2)=-1 这个值第一次出现的位置，在 helpArr 中的位置是 0，对应的 arr 中的位置是 -1，表示一个数都不累加的情况。所以 arr[0..2] 是满足条件的最长数组。</li>
<li>j=3 时，sum[0..3]=-3，所以在 helpArr 中二分查找大于或等于 -3-k=-3-(-2)=-1 这个值第一次出现的位置，在 helpArr 中的位置是 0，对应的 arr 中的位置是 -1，表示一个数都不累加的情况。所以 arr[0..3] 是满足条件的最长数组。</li>
<li>j=4 时，sum[0..4]=3，所以在 helpArr 中二分查找大于或等于 3-k=3-(-2)=5 这个值第一次出现的位置，结果是没有。所以，可知以位置 4 结尾的所有子数组累加后没有小于或等于 k (即 -2) 的。<br>全部过程请参看如下代码中的 maxLength 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxLength</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] h = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    h[<span class="number">0</span>] = sum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">        h[i + <span class="number">1</span>] = Math.max(sum, h[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">        pre = getLessIndex(h, sum - k);</span><br><span class="line">        len = pre == -<span class="number">1</span> ? <span class="number">0</span> : i - pre + <span class="number">1</span>;</span><br><span class="line">        res = Math.max(res, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLessIndex</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= num) &#123;</span><br><span class="line">            res = mid;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为 O(N)，额外空间复杂度为 O(N) 的最优解。如果数组 arr 长度为 N，建立两个长度为 N 的数组 minSums[] 和 minSumEnds[]。minSums[i] 表示必须以 arr[i] 开头的所有子数组中，能够得到的最小累加和是多少；minSumEnds[i] 表示必须以 arr[i] 开头的所有子数组中，如果得到了最小累加和，那么这个最小累加和的子数组右边界在哪个位置。从右往左遍历一遍就可以生成 minSums[] 和 minSumEnds[] 这两个数组。以下是一个例子。<br>位置：       0  1  2  3  4  5<br>arr=        {-3, 9, -6, 4, -2, -1}<br>minSums=    {-3, 3, -6, 1, -3, -1}<br>minSumEnds= {0, 2, 2, 5, 5, 5}<br>位置 5。必须以 arr[5] 开头的所有子数组只有 {-1}，能够得到的最小累加和也就是 -1。所以 minSums[5]=-1，这个子数组是以位置 5 作为右边界的，minSumEnds[5]=5。<br>接下来，从右往左求到任何一个位置 i 时，minSums[i+1] 和 minSumEnds[i+1] 一定已经求出。必须以 arr[i] 开头的子数组可以只包含 arr[i]，也可以往右扩，如果往右扩，就一定会包含 arr[i+1]。所以，必须以 arr[i] 开头的子数组最小累加和有以下两种可能性。<br>可能性 1：arr[i]，也就是只包含 arr[i] 的情况。<br>可能性 2：arr[i] + minSums[i+1]，也就是决定往右扩的情况。minSums[i+1] 表示必须以 arr[i+1] 开头的子数组最小累加和，既然往右扩一定包含 arr[i+1]，那么往右扩到什么位置，扩出来的这部分最小累加和是多少，就是 minSums[i+1] 的值。<br>两种可能性谁小，谁就是 minSums[i] 的解，即 minSums[i] = min { 可能性 1, 可能性 2 }。<br>如果 minSums[i] 来自可能性 1，子数组只包含 arr[i]，右边界就是 i，所以 minSumEnds[i] = i。<br>如果 minSums[i] 来自可能性 2，子数组要往右扩，扩到哪里，就是 minSumEnds[i+1] 的值，所以 minSumEnds[i] = minSumEnds[i+1]。<br>以上的判断逻辑还可以按照如下简化：<br>如果 minSums[i+1]&lt;=0，那么 minSums[i] = arr[i] + minSums[i+1]，minSumEnds[i] = minSumEnds[i+1]。<br>如果 minSums[i+1]&gt;0，那么 minSums[i] = arr[i]，minSumEnds[i] = i。<br>接下来用上文举的例子来展示如何利用 minSums[] 和 minSumEnds[] 这两个数组求解累加和小于或等于 0 的最长子数组。<br>先看必须以 0 位置开始的所有子数组。因为 minSums[0] 为 -3，是小于或等于 0 的，又有 minSumEnds[0] 等于 0（右边界），说明 arr[0..0] 是满足累加和小于或等于 0 的。窗口形成了，此时窗口就是 arr[0..0]，把窗口内的累加和记为 sum，此时 sum 等于 -3。那么窗口能继续往右扩吗？窗口右边的下一个位置是 1 位置，minSums[1] 为 3，把这个 3 累加进 sum，sum=-3+3=0，是小于或等于 0 的，又有 minSumEnds[1] 等于 2（新的右边界），说明 arr[0..2] 是满足累加和小于或等于 0 的，窗口扩大了，此时窗口是 arr[0..2]，窗口累加和 sum 等于 0。那么窗口还能继续往右扩吗？窗口右边的下一个位置是 3 位置，minSums[3] 为 1，如果把这个 1 累加进 sum，就不再满足累加和小于或等于 0 了，所以便知道窗口不能向右边界扩了，这是因为根据 minSums 数组的含义，minSums[3] 为 1，本身就代表必须以 arr[3] 开头的所有子数组中，能取得的最小累加和是 1，所以说明往后怎么扩，都不可能再满足累加和小于或等于 0 的条件。窗口最终固定在 arr[0..2]，长度为 3。<br>再看必须以 1 位置开始的所有子数组。之前找到的窗口为 arr[0..2]，窗口累加和 sum=0，让 arr[0] 的数出窗口，也就是把窗口缩小成 arr[1..2]，sum 当然也要减去 arr[0] 的值，就变成了 3。窗口能继续往右扩吗？窗口右边的下一个位置是 3 位置，minSums[3] 为 1，如果把这个 1 累加进 sum，不满足累加和小于或等于 0。所以可以知道，窗口不能向右扩。窗口最终固定在了 arr[1..2]，长度为 2。<br>这里是整个算法最精髓的地方，大家看一下 arr 数组，必须以 arr[1] 开头的所有子数组，根本没有任何一个可以使用累加和小于或等于 0。那么此时窗口固定在 arr[1..2]，这么做有何意义？比如，某一个数组，必须以 34 位置开始的时候，窗口的右边界向右扩到了 100 位置，arr[34..100] 这个窗口是必须以 34 位置开始的所有子数组中累加和小于或等于 0 的最长子数组。那么，如果必须以 35 位置开始的所有子数组中，累加和小于或等于 0 的最长子数组是 arr[35..65]。也就是说，必须以 35 位置开始的所有子数组中，客观上确实往右最多只能扩到 65 的位置，也就是扩不到 100 位置更往右的位置。那么其实我们本来也不需要关心从 35 位置开始到底能扩到哪里。因为既然我们已经找到了 arr[34..100]，为什么要关心一个更短的答案呢？也就是说，每次考查必须以 i 位置开始的所有子数组时，扩出来的窗口（假设为 arr[i..j]）的含义并不是从 i 位置出发累加和小于或等于 k 的最长子数组。真正的含义是，我们根本就不关心比 arr[i..j] 长度更短的答案，只想知道在以 i 位置开始的时候，是否存在把窗口的右边界再往右扩的可能。<br>再看必须以 2 位置开始的所有子数组。之前找到的窗口为 arr[1..2]，窗口累加和 sum=3，让 arr[1] 的数出窗口，也就是把窗口缩小成 arr[2..2]，sum 当然也要减去 arr[1] 的值，就变成了 -6。窗口能继续往右扩吗？窗口右边的下一个位置是 3 位置，minSums[3] 为 1，如果把这个 1 累加进 sum，sum 变成 -5，是小于或等于 0 的，又有 minSumEnds[3] 等于 5（新的右边界）。说明 arr[2..5] 是满足累加和小于或等于 0 的，窗口扩大了，此时窗口是 arr[2..5]，窗口累加和 sum 等于 -5。那么窗口还能继续往右扩吗？不能，已经来到整个数组的最后一个位置了。arr[2..5] 的长度为 4，接下来即便还存在累加和小于或等于 0 的子数组，也不会比 arr[2..5] 更长。<br>整个过程中，最大长度为 4，就是答案。</p>
<p>窗口的左边界依次为 0、1、2…N-1，而窗口的右边界是永远不回跳且只会往更右的。所以时间复杂度为 O(N)。具体过程参见如下 maxLengthAwesome 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxLengthAwesome</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] minSums = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="type">int</span>[] minSumEnds = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    minSums[arr.length - <span class="number">1</span>] = arr[arr.length - <span class="number">1</span>];</span><br><span class="line">    minSumEnds[arr.length - <span class="number">1</span>] = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minSums[i + <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            minSums[i] = arr[i] + minSums[i + <span class="number">1</span>];</span><br><span class="line">            minSumEnds[i] = minSumEnds[i + <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minSums[i] = arr[i];</span><br><span class="line">            minSumEnds[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// i 是窗口的最左位置，end 是窗口最右位置的下一个位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// while 循环结束之后：</span></span><br><span class="line">        <span class="comment">// 1) 如果以 i 开头的情况下，累加和小于或等于 k 的最长子数组是 arr[i..end-1]，</span></span><br><span class="line">        <span class="comment">//    看看这个子数组长度能不能更新 res</span></span><br><span class="line">        <span class="comment">// 2) 如果以 i 开头的情况下，累加和小于或等于 k 的最长子数组比 arr[i..end-1] 短，</span></span><br><span class="line">        <span class="comment">//    不管是否更新 res，都不会影响最终结果</span></span><br><span class="line">        <span class="keyword">while</span> (end &lt; arr.length &amp;&amp; sum + minSums[end] &lt;= k) &#123;</span><br><span class="line">            sum += minSums[end];</span><br><span class="line">            end = minSumEnds[end] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, end - i);</span><br><span class="line">        <span class="keyword">if</span> (end &gt; i) &#123; <span class="comment">// 窗口内还有数</span></span><br><span class="line">            sum -= arr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 窗口内已经没有数了，说明从 i 开头的所有子数组累加和都不可能小于</span></span><br><span class="line">            <span class="comment">// 或等于 k</span></span><br><span class="line">            end = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算数组的小和"><a href="#计算数组的小和" class="headerlink" title="计算数组的小和"></a>计算数组的小和</h2><p>【题目】</p>
<p>数组小和的定义如下：<br>例如，数组 s=[1,3,5,2,4,6]，在 s[0] 的左边小于或等于 s[0] 的数的和为 0；在 s[1] 的左边小于或等于 s[1] 的数的和为 1；在 s[2] 的左边小于或等于 s[2] 的数的和为 1+3=4；在 s[3] 的左边小于或等于 s[3] 的数的和为 1；在 s[4] 的左边小于或等于 s[4] 的数的和为 1+3=4；在 s[5] 的左边小于或等于 s[5] 的数的和为 1+3+5+2+4=15。所以 s 的小和为 0+1+4+1+4+15=25。<br>给定一个数组 s，实现函数返回 s 的小和。</p>
<p>【解答】</p>
<p>用时间复杂度为 O(N²) 的方法比较简单，按照题目例子描述的求小和的方法求解即可，本书不再详述。下面介绍一种时间复杂度为 O(NlogN)、额外空间复杂度为 O(N) 的方法，这是一种在归并排序的过程中，利用组间在进行合并时产生小和的过程。</p>
<ol>
<li>假设左组为 l[]，右组为 r[]，左右两个组的组内都已经有序，现在要利用外排序合并成一个大组，并假设当前外排序是 l[i] 与 r[j] 在进行比较。</li>
<li>如果 l[i]&lt;=r[j]，那么产生小和。假设从 r[j] 往右一直到 r[] 结束，元素的个数为 m，那么产生的小和为 l[i]*m。</li>
<li>如果 l[i]&gt;r[j]，不产生任何小和。</li>
<li>整个归并排序的过程该怎么进行就怎么进行，排序过程没有任何变化，只是利用步骤 1~步骤 3，也就是在组间合并的过程中累加所有产生的小和，总的累加和就是结果。</li>
</ol>
<p>还是以题目的例子来说明计算过程。</p>
<ol>
<li>归并排序的过程中会进行拆分再合并。[1,3,5,2,4,6] 拆分成左组 [1,3,5] 和右组 [2,4,6]，[1,3,5] 再拆分成 [1,3] 和 [5]，[2,4,6] 再拆分成 [2,4] 和 [6]，[1,3] 再拆分成 [1] 和 [3]，[2,4] 再拆分成 [2] 和 [4]。</li>
<li>[1] 与 [3] 合并。1 和 3 比较，左组的数小，右组从 3 开始到最后一共只有 1 个数。所以产生小和为 1×1=1，合并为 [1,3]。</li>
<li>[1,3] 与 [5] 合并。1 和 5 比较，左组的数小，右组从 5 开始到最后一共只有 1 个数。所以产生小和为 1×1=1。同理，3 和 5 比较，产生小和为 3×1=3，合并为 [1,3,5]。</li>
<li>[2] 与 [4] 合并。2 和 4 比较，左组的数小，右组从 4 开始到最后一共只有 1 个数。所以产生小和为 2×1=2，合并为 [2,4]。</li>
<li>[2,4] 与 [6] 合并。与步骤 3 同理，产生小和为 6，合并为 [2,4,6]。</li>
<li>[1,3,5] 与 [2,4,6] 合并。1 和 2 比较，左组的数小，右组从 2 开始到最后一共有 3 个数。所以产生小和为 1×3=3。3 和 2 比较，右组的数小，不产生小和。3 和 4 比较，左组的数小，右组从 4 开始到最后一共有 2 个数。所以产生小和为 3×2=6。5 和 4 比较，右组的数小，不产生小和。5 和 6 比较，左组的数小，右组从 6 开始到最后一共有 1 个数。所以产生小和为 5，合并为 [1,2,3,4,5,6]。</li>
<li>归并过程结束，总的小和为 1+1+3+2+6+3+6+5=27。</li>
</ol>
<p>在归并排序中，尤其是在组与组之间进行外排序合并的过程中，按照如上方式把小和一点一点地“榨”出来，最后收集到所有的小和。具体过程请参看如下代码中的 getSmallSum 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSmallSum</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> func(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>[] s, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> func(s, l, mid) + func(s, mid + <span class="number">1</span>, r) + merge(s, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] s, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] h = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">hi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">smallSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &lt;= s[j]) &#123;</span><br><span class="line">            smallSum += s[i] * (right - j + <span class="number">1</span>);</span><br><span class="line">            h[hi++] = s[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            h[hi++] = s[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; (j &lt; right + <span class="number">1</span>) || (i &lt; mid + <span class="number">1</span>); j++, i++) &#123;</span><br><span class="line">        h[hi++] = i &gt; mid ? s[j] : s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k != h.length; k++) &#123;</span><br><span class="line">        s[left++] = h[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> smallSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自然数数组的排序"><a href="#自然数数组的排序" class="headerlink" title="自然数数组的排序"></a>自然数数组的排序</h2><p>【题目】</p>
<p>给定一个长度为 N 的整型数组 arr，其中有 N 个互不相等的自然数 1~N。请实现 arr 的排序，但是不要把下标 0~N-1 位置上的数通过直接赋值的方式替换成 1~N。</p>
<p>【要求】</p>
<p>时间复杂度为 O(N)，额外空间复杂度为 O(1)。</p>
<p>【解答】</p>
<p>arr 在调整之后应该是下标从 0 到 N-1 的位置上依次放着 1~N，即 arr[index]=index+1。<br>本书提供两种实现方法，先介绍方法一。</p>
<ol>
<li>从左到右遍历 arr，假设当前遍历到 i 位置。</li>
<li>如果 arr[i]==i+1，说明当前的位置不需要调整，继续遍历下一个位置。</li>
<li>如果 arr[i]!=i+1，说明此时 i 位置的数 arr[i] 不应该放在 i 位置上，接下来将进行跳的过程。<br>举例说明，比如 [1,2,5,3,4]，假设遍历到位置 2，也就是 5 这个数。5 应该放在位置 4 上，所以把 5 放进去，数组变成 [1,2,5,3,5]。同时，4 这个数是被 5 替下来的数，应该放在位置 3，所以把 4 放进去，数组变成 [1,2,5,4,5]。同时，3 这个数是被 4 替下来的数，应该放在位置 2。所以把 3 放进去，数组变成 [1,2,3,4,5]。当跳了一圈回到原位置后，会发现此时 arr[i]==i+1，继续遍历下一个位置。<br>方法一的具体过程请参看如下代码中的 sort1 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        tmp = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (arr[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">            next = arr[tmp - <span class="number">1</span>];</span><br><span class="line">            arr[tmp - <span class="number">1</span>] = tmp;</span><br><span class="line">            tmp = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面介绍方法二。</p>
<ol>
<li>从左到右遍历 arr，假设当前遍历到 i 位置。</li>
<li>如果 arr[i]==i+1，说明当前的位置不需要调整，继续遍历下一个位置。</li>
<li>如果 arr[i]!=i+1，说明此时 i 位置的数 arr[i] 不应该放在 i 位置上，接下来将在 i 位置进行交换过程。<br>比如 [1,2,5,3,4]，假设遍历到位置 2，也就是 5 这个数。5 应该放在位置 4 上，所以位置 4 上的数 4 和 5 交换，数组变成 [1,2,4,3,5]。但此时还是 arr[2]!=3，4 这个数应该放在位置 3 上，所以 3 和 4 交换，数组变成 [1,2,3,4,5]。此时 arr[2]==3，遍历下一个位置。<br>方法二的具体过程请参看如下代码中的 sort2 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">            tmp = arr[arr[i] - <span class="number">1</span>];</span><br><span class="line">            arr[arr[i] - <span class="number">1</span>] = arr[i];</span><br><span class="line">            arr[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="奇数下标都是奇数或者偶数下标都是偶数"><a href="#奇数下标都是奇数或者偶数下标都是偶数" class="headerlink" title="奇数下标都是奇数或者偶数下标都是偶数"></a>奇数下标都是奇数或者偶数下标都是偶数</h2><p>【题目】</p>
<p>给定一个长度不小于 2 的数组 arr，实现一个函数调整 arr，要么让所有的偶数下标都是偶数，要么让所有的奇数下标都是奇数。</p>
<p>【要求】</p>
<p>如果 arr 的长度为 N，函数要求时间复杂度为 O(N)、额外空间复杂度为 O(1)。</p>
<p>【解答】</p>
<p>实现方法有很多，本书介绍一种易于实现的方法，步骤如下：</p>
<ol>
<li>设置变量 even，表示目前 arr 最左边的偶数下标，初始时 even=0。</li>
<li>设置变量 odd，表示目前 arr 最左边的奇数下标，初始时 odd=1。</li>
<li>不断检查 arr 的最后一个数，即 arr[N-1]。如果 arr[N-1] 是偶数，交换 arr[N-1] 和 arr[even]，然后令 even=even+2。如果 arr[N-1] 是奇数，交换 arr[N-1] 和 arr[odd]，然后令 odd=odd+2。继续重复步骤 3。</li>
<li>如果 even 或者 odd 大于或等于 N，过程停止。</li>
</ol>
<p>举例说明整个过程。比如 [1,8,3,2,4,6]，当前最后一个数记为 end=6，even=0，odd=1。此时 end=6 为偶数，所以 6 和 arr[even=0] 交换，数组变成 [6,8,3,2,4,1]，even=even+2=2。此时 end=1 为奇数，所以 1 和 arr[odd=1] 交换，数组变成 [6,1,3,2,4,8]，odd=odd+2=3。此时 end=8 为偶数，所以 8 和 arr[even=2] 交换，数组变成 [6,1,8,2,4,3]，even=even+2=4。此时 end=3 为奇数，所以 3 和 arr[odd=3] 交换，数组变成 [6,1,8,3,4,2]，odd=odd+2=5。此时 end=2 为偶数，所以 2 和 arr[odd=4] 交换，数组变成 [6,1,8,3,2,4]，even=even+2=6。此时 even 大于或等于长度 6，说明偶数下标已经都是偶数，过程停止。</p>
<p>再解释得直白一点，最后位置的数是偶数，就向偶数下标发送，最后位置的数是奇数，就向奇数下标发送，如果偶数下标或者奇数下标已经无法向右移动，说明调整结束。调整的全部过程请参看如下代码中的 modify 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">even</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">odd</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (even &lt;= end &amp;&amp; odd &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((arr[end] &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            swap(arr, end, even);</span><br><span class="line">            even += <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(arr, end, odd);</span><br><span class="line">            odd += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="子数组的最大累加和问题"><a href="#子数组的最大累加和问题" class="headerlink" title="子数组的最大累加和问题"></a>子数组的最大累加和问题</h2><p>【题目】</p>
<p>给定一个数组 arr，返回子数组的最大累加和。<br>例如，arr=[1,-2,3,5,-2,6,-1]，所有的子数组中，[3,5,-2,6] 可以累加出最大的和 12，所以返回 12。</p>
<p>【要求】</p>
<p>如果 arr 长度为 N，要求时间复杂度为 O(N)、额外空间复杂度为 O(1)。</p>
<p>【解答】</p>
<p>如果 arr 中没有正数，产生的最大累加和一定是数组中的最大值。<br>如果 arr 中有正数，从左到右遍历 arr，用变量 cur 记录每一步的累加和，遍历到正数 cur 增加，遍历到负数 cur 减少。当 cur<0 时，说明累加到当前数出现了小于 0 的结果，那么累加的这一部分肯定不能作为产生最大累加和的子数组的左边部分，此时令 cur=0，表示重新从下一个数开始累加。当 cur>=0 时，每一次累加都可能是最大的累加和。所以，用另外一个变量 max 全程跟踪记录 cur 出现的最大值即可。<br>举例说明，arr=[1,-2,3,5,-2,6,-1]，开始时，max=极小值，cur=0。<br>遍历到 1，cur=cur+1=1，max 更新成 1。遍历到 -2，cur=cur-2=-1，开始出现负的累加和。所以，说明 [1,-2] 这一部分肯定不会作为产生最大累加和的子数组的左边部分，于是令 cur=0，max 不变。遍历到 3，cur=cur+3=3，max 更新成 3。遍历到 5，cur=cur+5=8，max 更新成 8。遍历到 -2，cur=cur-2=6，虽然累加了一个负数，但是 cur 依然大于 0，说明累加的这一部分（也就是 [3,5,-2]）仍可能作为最大累加和的子数组的左边部分。max 不更新。遍历到 6，cur=cur+6=12，max 更新成 12。遍历到 -1，cur=cur-1=11，max 不更新。最后返回 12。解释得再直白一点，cur 累加成为负数就清零重新累加，max 记录 cur 的最大值即可。<br>求解最大累加和具体过程请参看如下代码中的 maxSum 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSum</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        cur += arr[i];</span><br><span class="line">        max = Math.max(max, cur);</span><br><span class="line">        cur = cur &lt; <span class="number">0</span> ? <span class="number">0</span> : cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="子矩阵的最大累加和问题"><a href="#子矩阵的最大累加和问题" class="headerlink" title="子矩阵的最大累加和问题"></a>子矩阵的最大累加和问题</h2><p>【题目】</p>
<p>给定一个矩阵 matrix，其中的值有正、有负、有 0，返回子矩阵的最大累加和。<br>例如，矩阵 matrix 为：<br>-90 48 78<br>64 -40 64<br>-81 -7 66<br>其中，最大累加和的子矩阵为：<br>48 78<br>-40 64<br>-7 66<br>所以返回累加和 209。<br>例如，matrix 为：<br>-1 -1 -1<br>-1 2 2<br>-1 -1 -1<br>其中，最大累加和的子矩阵为：<br>2 2<br>所以返回累加和 4。</p>
<p>【要求】</p>
<p>如果 arr 长度为 N，要求时间复杂度为 O(N)、额外空间复杂度为 O(1)。</p>
<p>【解答】</p>
<p>在阅读本题的解释之前，请先阅读上一道题“子数组的最大累加和问题”，因为本题的最优解深度利用了上一题的解法。<br>如何求必须含有 2 行元素的子矩阵中的最大累加和？可以把两列的元素累加，然后得到累加数组，接下来求这个累加数组的最大累加和。<br>也就是说，如果一个矩阵一共有 k 行且限定必须含有 k 行元素的情况下，我们只要把矩阵中每一列的 k 个元素累加生成一个累加数组，然后求出这个数组的最大累加和，这个最大累加和就是必须含有 k 行元素的子矩阵中的最大累加和。<br>请读者务必理解以上解释，下面看原问题如何求解。为了方便讲述，我们用题目的第一个例子来展示求解过程，首先考虑只有一行的矩阵 [-90,48,78]，因为只有一行，所以累加数组 arr 就是 [-90,48,78]，这个数组的最大累加和为 126。<br>接下来考虑含有两行的矩阵：<br>-90 48 78<br>64 -40 64<br>这个矩阵的累加数组就是在上一步的累加数组 [-90,48,78] 的基础上，依次在每个位置上加上矩阵最新一行 [64,-40,64] 的结果，即 [-26,8,142]，这个数组的最大累加和为 150。<br>接下来考虑含有三行的矩阵：<br>-90 48 78<br>64 -40 64<br>-81 -7 66<br>这个矩阵的累加数组就是在上一步累加数组 [-26,8,142] 的基础上，依次在每个位置上加上矩阵最新一行 [-81,-7,66] 的结果，即 [-107,1,208]，这个数组的最大累加和为 209。<br>此时，必须从矩阵的第一行元素开始，并往下的所有子矩阵已经查找完毕，接下来从矩阵的第二行开始，继续这样的过程，含有一行矩阵：<br>64 -40 64<br>因为只有一行，所以累加数组就是 [64,-40,64]，这个数组的最大累加和为 88。<br>接下来考虑含有两行的矩阵：<br>64 -40 64<br>-81 -7 66<br>这个矩阵的累加数组就是在上一步累加数组 [64,-40,64] 的基础上，依次在每个位置上加上矩阵最新一行 [-81,-7,66] 的结果，即 [-17,-47,130]，这个数组的最大累加和为 130。<br>此时，必须从矩阵的第二行元素开始，并往下的所有子矩阵已经查找完毕，接下来从矩阵的第三行开始，继续这样的过程，含有一行矩阵：<br>-81 -7 66<br>因为只有一行，所以累加数组就是 [-81,-7,66]，这个数组的最大累加和为 66。<br>全部过程结束，所有的子矩阵都已经考虑到了，结果为以上所有最大累加和中最大的 209。<br>整个过程最关键的地方有两处：</p>
<ul>
<li>用求累加数组的最大累加和的方式得到每一层子矩阵的最大累加和。</li>
<li>每一步的累加数组可以利用前一步求出的累加数组很方便地更新得到。<br>如果矩阵大小为 N×N，以上全部过程的时间复杂度为 O(N³)，具体请参看如下代码中的 maxSum 方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSum</span><span class="params">(<span class="type">int</span>[][] m)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">null</span> || m.length == <span class="number">0</span> || m[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] s = <span class="literal">null</span>; <span class="comment">// 累加数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != m.length; i++) &#123;</span><br><span class="line">        s = <span class="keyword">new</span> <span class="title class_">int</span>[m[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j != m.length; j++) &#123;</span><br><span class="line">            cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k != s.length; k++) &#123;</span><br><span class="line">                s[k] += m[j][k];</span><br><span class="line">                cur += s[k];</span><br><span class="line">                max = Math.max(max, cur);</span><br><span class="line">                cur = cur &lt; <span class="number">0</span> ? <span class="number">0</span> : cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在数组中找到一个局部最小的位置"><a href="#在数组中找到一个局部最小的位置" class="headerlink" title="在数组中找到一个局部最小的位置"></a>在数组中找到一个局部最小的位置</h2><p>【题目】</p>
<p>定义局部最小的概念。arr 长度为 1 时，arr[0] 是局部最小。arr 的长度为 N (N&gt;1) 时，如果 arr[0]&lt;arr[1]，那么 arr[0] 是局部最小；如果 arr[N-1]&lt;arr[N-2]，那么 arr[N-1] 是局部最小；如果 0&lt;i&lt;N-1，既有 arr[i]&lt;arr[i-1]，又有 arr[i]&lt;arr[i+1]，那么 arr[i] 是局部最小。<br>给定无序数组 arr，已知 arr 中任意两个相邻的数都不相等。写一个函数，只需返回 arr 中任意一个局部最小出现的位置即可。</p>
<p>【要求】</p>
<p>如果 arr 长度为 N，要求时间复杂度为 O(N)、额外空间复杂度为 O(1)。</p>
<p>【解答】</p>
<p>本题可以利用二分查找做到时间复杂度为 O(logN)、额外空间复杂度为 O(1)，步骤如下：</p>
<ol>
<li>如果 arr 为空或者长度为 0，返回 -1 表示不存在局部最小。</li>
<li>如果 arr 长度为 1 或者 arr[0]&lt;arr[1]，说明 arr[0] 是局部最小，返回 0。</li>
<li>如果 arr[N-1]&lt;arr[N-2]，说明 arr[N-1] 是局部最小，返回 N-1。</li>
<li>如果 arr 长度大于 2 且 arr 的左右两头都不是局部最小，则令 left=1，right=N-2，然后进入步骤 5 做二分查找。</li>
<li>令 mid=(left+right)/2，然后进行如下判断：<br>1) 如果 arr[mid]&gt;arr[mid-1]，可知在 arr[left..mid-1] 上肯定存在局部最小，令 right=mid-1，重复步骤 5。<br>2) 如果不满足 1)，但 arr[mid]&gt;arr[mid+1]，可知在 arr[mid+1..right] 上肯定存在局部最小，令 left=mid+1，重复步骤 5。<br>3) 如果既不满足 1)，也不满足 2)，那么 arr[mid] 就是局部最小，直接返回 mid。</li>
<li>步骤 5 一直进行二分查找，直到 left==right 时停止，返回 left 即可。</li>
</ol>
<p>如此可见，二分查找并不是数组有序时才能使用，只要你能确定二分两侧的某一侧肯定存在你要找的内容，就可以使用二分查找。具体过程请参看如下的 getLessIndex 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLessIndex</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">1</span> || arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[arr.length - <span class="number">1</span>] &lt; arr[arr.length - <span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; arr[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组中子数组的最大累乘积"><a href="#数组中子数组的最大累乘积" class="headerlink" title="数组中子数组的最大累乘积"></a>数组中子数组的最大累乘积</h2><p>【题目】</p>
<p>给定一个 double 类型的数组 arr，其中的元素可正、可负、可 0，返回子数组累乘的最大乘积。例如，arr=[-2.5, 4, 0, 3, 0.5, 8, -1]，子数组[3, 0.5, 8]累乘可以获得最大的乘积 12，所以返回 12。</p>
<p>【解答】</p>
<p>本题可以做到时间复杂度为 O(N)、额外空间复杂度为 O(1)。所有的子数组都会以某一个位置结束，所以，如果求出以每一个位置结尾的子数组最大的累乘积，在那么多最大累乘积中最大的那个就是最终的结果。也就是说，结果=max{以 arr[0]结尾的所有子数组的最大累乘积，以 arr[1]结尾的所有子数组的最大累乘积……以 arr[arr.length-1]结尾的所有子数组的最大累乘积}。<br>如何快速求出所有以 i 位置结尾（arr[i]）的子数组的最大累乘积呢？假设以 arr[i-1]结尾的最小累乘积为 min，以 arr[i-1]结尾的最大累乘积为 max。那么，以 arr[i]结尾的最大累乘积只有以下三种可能：</p>
<ul>
<li>可能是 max<em>arr[i]。max 既然表示以 arr[i-1]结尾的最大累乘积，那么当然有可能以 arr[i]结尾的最大累乘积是 max</em>arr[i]。例如，[3,4,5]在算到 5 的时候。</li>
<li>可能是 min*arr[i]。min 既然表示以 arr[i-1]结尾的最小累乘积，当然有可能 min 是负数，而如果 arr[i]也是负数，两个负数相乘的结果也可能很大。例如，[-2,3,-4]在算到-4 的时候。</li>
<li>可能仅是 arr[i]的值。以 arr[i]结尾的最大累乘积并不一定非要包含 arr[i]之前的数。例如，[0.1,0.1,100]在算到 100 的时候。</li>
</ul>
<p>这三种可能的值中最大的那个就作为以 i 位置结尾的最大累乘积，最小的作为最小累乘积，然后继续计算以 i+1 位置结尾的时候，如此重复，直到计算结束。<br>具体过程请参看如下代码中的 maxProduct 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">double</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">double</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">double</span> <span class="variable">maxEnd</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">minEnd</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">        maxEnd = max * arr[i];</span><br><span class="line">        minEnd = min * arr[i];</span><br><span class="line">        max = Math.max(Math.max(maxEnd, minEnd), arr[i]);</span><br><span class="line">        min = Math.min(Math.min(maxEnd, minEnd), arr[i]);</span><br><span class="line">        res = Math.max(res, max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="打印-N-个数组整体最大的-Top-K"><a href="#打印-N-个数组整体最大的-Top-K" class="headerlink" title="打印 N 个数组整体最大的 Top K"></a>打印 N 个数组整体最大的 Top K</h2><p>【题目】</p>
<p>有 N 个长度不一的数组，所有的数组都是有序的，请从大到小打印 N 个数组整体最大的前 K 个数。<br>例如，输入含有 N 行元素的二维数组可以代表 N 个一维数组。<br>219,405,538,845,971<br>148,558<br>52,99,348,691<br>再输入整数 k=5，则打印：<br>Top 5: 971,845,691,558,538</p>
<p>【要求】</p>
<ol>
<li>如果所有数组的元素个数小于 K，则从大到小打印所有的数。</li>
<li>要求时间复杂度为 O(KlogN)。</li>
</ol>
<p>【解答】</p>
<p>本题的解法是利用堆结构和堆排序的过程完成的，具体过程如下：</p>
<ol>
<li>构建一个大小为 N 的大根堆 heap，建堆的过程就是把每个数组中的最后一个值（也就是该数组的最大值）依次加入堆里，这个过程是建堆时的调整过程（heapInsert）。</li>
<li>建好堆之后，此时 heap 堆顶的元素是所有数组的最大值中最大的那个，打印堆顶元素。</li>
<li>假设堆顶元素来自 a 数组的 i 位置。那么接下来就把堆顶的前一个数（即 a[i-1]）放在 heap 的头部，也就是用 a[i-1]替换原本的堆顶，然后从堆的头部开始调整堆，使其重新变为大根堆（heapify 过程）。</li>
<li>这样每次都可以得到一个堆顶元素 max，在打印完成后都经历步骤 3 的调整过程。整体打印 k 次，就是从大到小全部的 Top K。</li>
<li>在重复步骤 3 的过程中，如果 max 来自的那个数组（仍假设是 a 数组）已经没有元素。也就是说，max 已经是 a[0]，再往左没有数了。那么就把 heap 中最后一个元素放在 heap 头部的位置，然后把 heap 的大小减 1（heapSize-1），最后依然是从堆的头部开始调整堆，使其重新变为大根堆（堆大小减 1 之后的 heapify 过程）。</li>
<li>直到打印了 k 个数，过程结束。</li>
</ol>
<p>为了知道每一次的 max 来自哪个数组的哪个位置，放在堆里的元素是如下的 HeapNode 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value; <span class="comment">// 值是什么</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> arrNum; <span class="comment">// 来自哪个数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> index; <span class="comment">// 来自数组的哪个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeapNode</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> arrNum, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.arrNum = arrNum;</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个打印过程请参看如下代码中的 printTopK 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printTopK</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> topK)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">heapSize</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    HeapNode[] heap = <span class="keyword">new</span> <span class="title class_">HeapNode</span>[heapSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != heapSize; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> matrix[i].length - <span class="number">1</span>;</span><br><span class="line">        heap[i] = <span class="keyword">new</span> <span class="title class_">HeapNode</span>(matrix[i][index], i, index);</span><br><span class="line">        heapInsert(heap, i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;TOP &quot;</span> + topK + <span class="string">&quot; : &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != topK; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heapSize == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(heap[<span class="number">0</span>].value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (heap[<span class="number">0</span>].index != <span class="number">0</span>) &#123;</span><br><span class="line">            heap[<span class="number">0</span>].value = matrix[heap[<span class="number">0</span>].arrNum][--heap[<span class="number">0</span>].index];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(heap, <span class="number">0</span>, --heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">        heapify(heap, <span class="number">0</span>, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(HeapNode[] heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (index != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (heap[parent].value &lt; heap[index].value) &#123;</span><br><span class="line">            swap(heap, parent, index);</span><br><span class="line">            index = parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(HeapNode[] heap, <span class="type">int</span> index, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> index;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; heapSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap[left].value &gt; heap[index].value) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; heap[right].value &gt; heap[largest].value) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != index) &#123;</span><br><span class="line">            swap(heap, largest, index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index = largest;</span><br><span class="line">        left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        right = index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(HeapNode[] heap, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">    <span class="type">HeapNode</span> <span class="variable">tmp</span> <span class="operator">=</span> heap[index1];</span><br><span class="line">    heap[index1] = heap[index2];</span><br><span class="line">    heap[index2] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="边界都是-1-的最大正方形大小"><a href="#边界都是-1-的最大正方形大小" class="headerlink" title="边界都是 1 的最大正方形大小"></a>边界都是 1 的最大正方形大小</h2><p>【题目】</p>
<p>给定一个 N×N 的矩阵 matrix，在这个矩阵中，只有 0 和 1 两种值，返回边框全是 1 的最大正方形的边长长度。<br>例如：<br>0 1 1 1 1<br>0 1 0 0 1<br>0 1 0 0 1<br>0 1 1 1 1<br>0 1 0 1 1<br>其中，边框全是 1 的最大正方形的大小为 4×4，所以返回 4。</p>
<p>【解答】</p>
<p>先介绍一个比较容易理解的解法。</p>
<ol>
<li>矩阵中一共有 N×N 个位置。O(N²)</li>
<li>对每一个位置都看是否可以成为边长为 N~1 的正方形左上角。比如，对于(0,0)位置，依次检查是否是边长为 5 的正方形左上角，然后检查边长为 4、3 等。O(N)</li>
<li>如何检查一个位置是否可以成为边长为 N 的正方形的左上角呢？遍历这个边长为 N 的正方形边界看是否只由 1 构成，也就是走过 4 个边的长度（4N）。O(N)<br>所以普通方法总的时间复杂度为 O(N²)×O(N)×O(N)=O(N⁴)。</li>
</ol>
<p>本书提供的方法的时间复杂度为 O(N³)，基本过程也是如上三个步骤。但是对于步骤 3，可以把时间复杂度由 O(N)降为 O(1)。具体地说，就是能够在 O(1)的时间内检查一个位置假设为(i,j)，是否可以作为边长为 a（1≤a≤N）的边界全是 1 的正方形左上角。关键是使用预处理技巧，这也是面试经常使用的技巧之一。下面介绍得到预处理矩阵的过程。</p>
<ol>
<li>预处理过程是根据矩阵 matrix 得到两个矩阵 right 和 down。right[i][j]的值表示从位置(i,j)出发向右，有多少个连续的 1。down[i][j]的值表示从位置(i,j)出发向下有多少个连续的 1。</li>
<li>right 和 down 矩阵如何计算？<br>1) 从矩阵的右下角(n-1,n-1)位置开始计算，如果 matrix[n-1][n-1]==1，那么，right[n-1][n-1]=1 且 down[n-1][n-1]=1，否则都等于 0。<br>2) 从右下角开始往上计算，即在 matrix 最后一列上计算，位置就表示为(i,n-1)。对 right 矩阵来说，最后一列的右边没有内容。所以，如果 matrix[i][n-1]==1，则令 right[i][n-1]=1，否则为 0。对 down 矩阵来说，如果 matrix[i][n-1]==1，因为 down[i+1][n-1]表示包括位置(i+1,n-1)在内并且往下有多少个连续的 1。所以，如果位置(i,n-1)是 1，那么，令 down[i][n-1]=down[i+1][n-1]+1；如果 matrix[i][n-1]==0，则令 down[i][n-1]=0。<br>3) 从右下角开始往左计算，即在 matrix 最后一行上计算，位置可以表示为(n-1,j)。对 right 矩阵来说，如果 matrix[n-1][j]==1，因为 right[n-1][j+1]表示包括位置(n-1,j+1)在内右边有多少个连续的 1。所以，如果位置(n-1,j)是 1，则令 right[n-1][j]=right[n-1][j+1]+1；如果 matrix[n-1][j]==0，则令 right[n-1][j]=0。对 down 矩阵来说，最后一列的下边没有内容。所以，如果 matrix[n-1][j]==1，令 down[n-1][j]=1，否则为 0。<br>4) 计算完步骤 1)～步骤 3)之后，剩下的位置都是既有右，也有下，假设位置表示为(i,j)：<br>   如果 matrix[i][j]==1，则令 right[i][j]=right[i][j+1]+1，down[i][j]=down[i+1][j]+1。<br>   如果 matrix[i][j]==0，则令 right[i][j]=0，down[i][j]=0。</li>
</ol>
<p>预处理的具体过程请参看如下代码中的 setBorderMap 方法。<br>得到 right 和 down 矩阵后，如何加速检查过程呢？比如现在想检查一个位置，假设为(i,j)。是否可以作为边长为 a（1≤a≤N）的边界全是 1 的正方形左上角。<br>1) 位置(i,j)的右边和下边连续为 1 的数量必须都大于或等于 a(right[i][j]&gt;=a&amp;&amp;down[i][j]&gt;=a)，否则说明上边界和左边界的 1 不够。<br>2) 位置(i,j)向右跳到位置(i,j+a-1)，这个位置是正方形的右上角，那么这个位置的下边连续为 1 的数量也必须大于或等于 a（down[i][j+a-1]&gt;=a），否则说明右边界的 1 不够。<br>3) 位置(i,j)向下跳到位置(i+a-1,j)，这个位置是正方形的左下角，那么这个位置的右边连续为 1 的数量也必须大于或等于 a（right[i+a-1][j]&gt;=a），否则说明下边界的 1 不够。<br>以上三个条件都满足时，就说明位置(i,j)符合要求，利用 right 和 down 矩阵之后，加速的过程很明显，就不需要遍历边长上的所有值了，只看 4 个点即可。<br>全部过程请参看如下代码中的 getMaxSize 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBorderMap</span><span class="params">(<span class="type">int</span>[][] m, <span class="type">int</span>[][] right, <span class="type">int</span>[][] down)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> m.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> m[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span> (m[r - <span class="number">1</span>][c - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">        right[r - <span class="number">1</span>][c - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        down[r - <span class="number">1</span>][c - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r - <span class="number">2</span>; i != -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m[i][c - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            right[i][c - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            down[i][c - <span class="number">1</span>] = down[i + <span class="number">1</span>][c - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> c - <span class="number">2</span>; i != -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m[r - <span class="number">1</span>][i] == <span class="number">1</span>) &#123;</span><br><span class="line">            right[r - <span class="number">1</span>][i] = right[r - <span class="number">1</span>][i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            down[r - <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r - <span class="number">2</span>; i != -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> c - <span class="number">2</span>; j != -<span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                right[i][j] = right[i][j + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                down[i][j] = down[i + <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaxSize</span><span class="params">(<span class="type">int</span>[][] m)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] right = <span class="keyword">new</span> <span class="title class_">int</span>[m.length][m[<span class="number">0</span>].length];</span><br><span class="line">    <span class="type">int</span>[][] down = <span class="keyword">new</span> <span class="title class_">int</span>[m.length][m[<span class="number">0</span>].length];</span><br><span class="line">    setBorderMap(m, right, down);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Math.min(m.length, m[<span class="number">0</span>].length); size != <span class="number">0</span>; size--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasSizeOfBorder(size, right, down)) &#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasSizeOfBorder</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span>[][] right, <span class="type">int</span>[][] down)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != right.length - size + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j != right[<span class="number">0</span>].length - size + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right[i][j] &gt;= size &amp;&amp; down[i][j] &gt;= size</span><br><span class="line">                    &amp;&amp; right[i + size - <span class="number">1</span>][j] &gt;= size</span><br><span class="line">                    &amp;&amp; down[i][j + size - <span class="number">1</span>] &gt;= size) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不包含本位置值的累乘数组"><a href="#不包含本位置值的累乘数组" class="headerlink" title="不包含本位置值的累乘数组"></a>不包含本位置值的累乘数组</h2><p>【题目】</p>
<p>给定一个整型数组 arr，返回不包含本位置值的累乘数组。<br>例如，arr=[2,3,1,4]，返回[12,8,24,6]，即除自己外，其他位置上的累乘。</p>
<p>【要求】</p>
<ol>
<li>时间复杂度为 O(N)。</li>
<li>除需要返回的结果数组外，额外空间复杂度为 O(1)。<br>进阶问题：对时间和空间复杂度的要求不变，而且不可以使用除法。</li>
</ol>
<p>【解答】</p>
<p>先介绍可以使用除法的实现，结果数组记为 res，所有数的乘积记为 all。如果数组中不含 0，则设置 res[i]=all/arr[i] (0≤i≤n)即可。如果数组中有 1 个 0，对唯一的 arr[i]==0 的位置令 res[i]=all，其他位置上的值都是 0 即可。如果数组中 0 的数量大于 1，那么 res 所有位置上的值都是 0。具体过程请参看如下代码中的 product1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] product1(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">all</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            all *= arr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">            res[i] = all / arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                res[i] = all;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能使用除法的情况下，可以用以下方法实现进阶问题：</p>
<ol>
<li>生成两个长度和 arr 一样的新数组 lr[]和 rl[]。lr[i]表示从左到右的累乘（即 lr[i]=arr[0..i]）的累乘。rl 表示从右到左的累乘（即 rl[i]=arr[i..N-1]）的累乘。</li>
<li>一个位置上除去自己值的累乘，就是自己左边的累乘再乘以自己右边的累乘，即 res[i]=lr[i-1]*rl[i+1]。</li>
<li>最左位置和最右位置的累乘比较特殊，即 res[0]=rl[1]，res[N-1]=lr[N-2]。</li>
</ol>
<p>以上思路虽然可以得到结果 res，但是除 res 之外，又使用了两个额外数组，怎么省掉这两个额外数组呢？可以通过 res 数组复用的方式。也就是说，先把 res 数组作为辅助计算的数组，然后把 res 调整成结果数组返回。具体过程请参看如下代码中的 product2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] product2(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    res[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        res[i] = res[i - <span class="number">1</span>] * arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        res[i] = res[i - <span class="number">1</span>] * tmp;</span><br><span class="line">        tmp *= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    res[<span class="number">0</span>] = tmp;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组的-partition-调整"><a href="#数组的-partition-调整" class="headerlink" title="数组的 partition 调整"></a>数组的 partition 调整</h2><p>【题目】</p>
<p>给定一个有序数组 arr，调整 arr 使得这个数组的左半部分没有重复元素且升序，不用保证右部分是否有序。<br>例如，arr=[1,2,2,2,3,3,4,5,6,6,7,7,8,8,8,9]，调整之后 arr=[1,2,3,4,5,6,7,8,9,…]。</p>
<p>补充问题：给定一个数组 arr，其中只可能含有 0、1、2 三个值，请实现 arr 的排序。<br>另一种问法为：有一个数组，其中只有红球、蓝球和黄球，请实现红球全放在数组的左边，蓝球放在中间，黄球放在右边。<br>另一种问法为：有一个数组，再给定一个值 k，请实现比 k 小的数都放在数组的左边，等于 k 的数都放在数组的中间，比 k 大的数都放在数组的右边。</p>
<p>【要求】</p>
<ol>
<li>所有题目实现的时间复杂度为 O(N)。</li>
<li>所有题目实现的额外空间复杂度为 O(1)。</li>
</ol>
<p>【解答】</p>
<p>先来介绍原问题的解法。</p>
<ol>
<li>生成变量 u，含义是在 arr[0..u]上都是无重复元素且升序的。也就是说，u 是这个区域最后的位置，初始时 u=0，这个区域记为 A。</li>
<li>生成变量 i，利用 i 做从左到右的遍历，在 arr[u+1..i]上是不保证没有重复元素且升序的区域，i 是这个区域最后的位置，初始时 i=1，这个区域记为 B。</li>
<li>i 向右移动（i++）。因为数组整体有序，所以，如果 arr[i]!=arr[u]，说明当前数 arr[i]应该加入到 A 区域里，交换 arr[u+1]和 arr[i]，此时 A 的区域增加一个数（u++）；如果 arr[i]==arr[u]，说明当前数 arr[i]的值之前已经加入 A 区域，此时不用再加入。</li>
<li>重复步骤 3，直到所有的数遍历完。</li>
</ol>
<p>具体请查看如下代码中的 leftUnique 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leftUnique</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i != arr.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i++] != arr[u]) &#123;</span><br><span class="line">            swap(arr, ++u, i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来介绍补充问题的解法。</p>
<ol>
<li>生成变量 left，含义是在 arr[0..left]（左区）上都是 0，left 是这个区域当前最右的位置，初始时 left 为-1。</li>
<li>生成变量 index，利用这个变量做从左到右的遍历，含义是在 arr[left+1..index]（中区）上都是 1，index 是这个区域当前最右的位置，初始时 index 为 0。</li>
<li>生成变量 right，含义是在 arr[right..N-1]（右区）上都是 2，right 是这个区域当前最左的位置，初始时 right 为 N。</li>
<li>index 表示遍历到 arr 的一个位置：<br>1) 如果 arr[index]==1，这个值应该直接加入到中区，index++之后重复步骤 4。<br>2) 如果 arr[index]==0，这个值应该加入到左区，arr[left+1]是中区最左的位置，所以把 arr[index]和 arr[left+1]交换之后，左区就扩大了，index++之后重复步骤 4。<br>3) 如果 arr[index]==2，这个值应该加入到右区，arr[right-1]是右区最左边的左边，但不属于中区，总之，在中区和右区的中间部分。把 arr[index]和 arr[right-1]交换之后，右区就向左扩大了（right—），但是此时 arr[index]上的值未知，所以 index 不变，重复步骤 4。</li>
<li>当 index==right 时，说明中区和右区成功对接，三个区域都划分好后，过程停止。<br>在遍历中的每一步，要么 index 增加，要么 right 减少。如果 index==right，过程就停止，所以时间复杂度就是 O(N)，具体过程请参看如下代码中的 sort 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[index] == <span class="number">0</span>) &#123;</span><br><span class="line">            swap(arr, ++left, index++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[index] == <span class="number">2</span>) &#123;</span><br><span class="line">            swap(arr, index, --right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求最短通路值"><a href="#求最短通路值" class="headerlink" title="求最短通路值"></a>求最短通路值</h2><p>【题目】</p>
<p>用一个整型矩阵 matrix 表示一个网络，1 代表有路，0 代表无路，每一个位置只要不越界，都有上下左右 4 个方向，求从最左上角到最右下角的最短通路值。<br>例如，matrix 为：<br>1 0 1 1 1<br>1 0 1 0 1<br>1 1 1 0 1<br>0 0 0 0 1<br>通路只有一条，由 12 个 1 构成，所以返回 12。</p>
<p>【解答】</p>
<p>使用宽度优先遍历即可，如果矩阵大小为 N×M，本文提供的方法的时间复杂度为 O(N×M)，具体过程如下：</p>
<ol>
<li>开始时生成 map 矩阵，map[i][j]的含义是从(0,0)位置走到(i,j)位置最短的路径值。然后将左上角位置(0,0)的行坐标与列坐标放入行队列 rQ 和列队列 cQ。</li>
<li>不断从队列弹出一个位置(r,c)，然后看这个位置的上下左右四个位置哪些在 matrix 上的值是 1，这些都是能走的位置。</li>
<li>将那些能走的位置设置好各自在 map 中的值，即 map[r][c]+1。同时将这些位置加入 rQ 和 cQ 中，用队列完成宽度优先遍历。</li>
<li>在步骤 3 中，如果一个位置之前走过，就不要重复走，这个逻辑可以根据一个位置在 map 中的值来确定，比如 map[i][j]!=0，就可以知道这个位置之前已经走过。</li>
<li>一直重复步骤 2～步骤 4。直到遇到右下角位置，说明已经找到终点，返回终点在 map 中的值即可，如果 rQ 和 cQ 已经为空都没有遇到终点位置，说明不存在这样一条路径，返回 0。</li>
</ol>
<p>每个位置最多走一遍，所以时间复杂度为 O(N×M)、额外空间复杂度也是 O(N×M)。具体过程请参看如下代码中的 minPathValue 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathValue</span><span class="params">(<span class="type">int</span>[][] m)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">null</span> || m.length == <span class="number">0</span> || m[<span class="number">0</span>].length == <span class="number">0</span> || m[<span class="number">0</span>][<span class="number">0</span>] != <span class="number">1</span></span><br><span class="line">            || m[m.length - <span class="number">1</span>][m[<span class="number">0</span>].length - <span class="number">1</span>] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[m.length][m[<span class="number">0</span>].length];</span><br><span class="line">    map[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    Queue&lt;Integer&gt; rQ = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    Queue&lt;Integer&gt; cQ = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    rQ.add(<span class="number">0</span>);</span><br><span class="line">    cQ.add(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!rQ.isEmpty()) &#123;</span><br><span class="line">        r = rQ.poll();</span><br><span class="line">        c = cQ.poll();</span><br><span class="line">        <span class="keyword">if</span> (r == m.length - <span class="number">1</span> &amp;&amp; c == m[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> map[r][c];</span><br><span class="line">        &#125;</span><br><span class="line">        walkTo(map[r][c], r - <span class="number">1</span>, c, m, map, rQ, cQ); <span class="comment">// 上</span></span><br><span class="line">        walkTo(map[r][c], r + <span class="number">1</span>, c, m, map, rQ, cQ); <span class="comment">// 下</span></span><br><span class="line">        walkTo(map[r][c], r, c - <span class="number">1</span>, m, map, rQ, cQ); <span class="comment">// 左</span></span><br><span class="line">        walkTo(map[r][c], r, c + <span class="number">1</span>, m, map, rQ, cQ); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walkTo</span><span class="params">(<span class="type">int</span> pre, <span class="type">int</span> toR, <span class="type">int</span> toC, <span class="type">int</span>[][] m,</span></span><br><span class="line"><span class="params">        <span class="type">int</span>[][] map, Queue&lt;Integer&gt; rQ, Queue&lt;Integer&gt; cQ)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (toR &lt; <span class="number">0</span> || toR == m.length || toC &lt; <span class="number">0</span> || toC == m[<span class="number">0</span>].length</span><br><span class="line">            || m[toR][toC] != <span class="number">1</span> || map[toR][toC] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    map[toR][toC] = pre + <span class="number">1</span>;</span><br><span class="line">    rQ.add(toR);</span><br><span class="line">    cQ.add(toC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组中未出现的最小正整数"><a href="#数组中未出现的最小正整数" class="headerlink" title="数组中未出现的最小正整数"></a>数组中未出现的最小正整数</h2><p>【题目】</p>
<p>给定一个无序整型数组 arr，找到数组中未出现的最小正整数。</p>
<p>【举例】</p>
<p>arr=[-1,2,3,4]。返回 1。<br>arr=[1,2,3,4]。返回 5。</p>
<p>【解答】</p>
<p>原问题。如果 arr 长度为 N，本题的最优解可以做到时间复杂度为 O(N)，额外空间复杂度为 O(1)。具体过程如下：</p>
<ol>
<li>在遍历 arr 之前先生成两个变量。变量 l 表示遍历到目前为止，数组 arr 已经包含的正整数范围是[1,l]，所以没有开始遍历之前令 l=0，表示 arr 目前没有包含任何正整数。变量 r 表示遍历到目前为止，在后续出现最优状况的情况下，arr 可能包含的正整数范围是[1,r]，所以没有开始遍历之前，令 r=N，因为还没有开始遍历，所以后续出现的最优状况是 arr 包含 1～N 所有的整数。r 同时表示 arr 当前的结束位置。</li>
<li>从左到右遍历 arr，遍历到位置 l，位置 l 的数为 arr[l]。</li>
<li>如果 arr[l]==l+1。没有遍历 arr[l]之前，arr 已经包含的正整数范围是[1,l]，此时出现了 arr[l]=l+1 的情况，所以 arr 包含的正整数范围可以扩到[1,l+1]，即令 l++。然后重复步骤 2。</li>
<li>如果 arr[l]&lt;=l。没有遍历 arr[l]之前，arr 在后续最优的情况下可能包含的正整数范围是[1,r]，已经包含的正整数范围是[1,l]，所以需要[l+1,r]上的数。而此时出现了 arr[l]&lt;=l，说明[l+1,r]范围上的数少了一个，所以 arr 在后续最优的情况下，可能包含的正整数范围缩小了，变为[1,r-1]，此时把 arr 最后位置的数（arr[r-1]）放在位置 l 上，下一步检查这个数，然后令 r—。重复步骤 2。</li>
<li>如果 arr[l]&gt;r，与步骤 4 同理，把 arr 最后位置的数（arr[r-1]）放在位置 l 上，下一步检查这个数，然后令 r—。重复步骤 2。</li>
<li>如果 arr[arr[l]-1]==arr[l]。如果步骤 4 和步骤 5 没中，说明 arr[l]是在[l+1,r]范围上的数，而且这个数应该放在 arr[l]-1 位置上。可是此时发现 arr[l]-1 位置上的数已经是 arr[l]，说明出现了两个 arr[l]，既然在[l+1,r]上出现了重复值，那么[l+1,r]范围上的数又少了一个，所以与步骤 4 和步骤 5 一样，把 arr 最后位置的数（arr[r-1]）放在位置 l 上，下一步检查这个数，然后令 r—。重复步骤 2。</li>
<li>如果步骤 4、步骤 5 和步骤 6 都没中，说明发现了[l+1,r]范围上的数，并且此时并未发现重复。那么 arr[l]应该放到 arr[l]-1 位置上，所以把位置 l 上的数和 arr[l]-1 位置上的数交换，下一步继续遍历 l 位置上的数。重复步骤 2。</li>
<li>最终 l 位置和 r 位置会碰在一起（l==r），arr 已经包含的正整数范围是[1,l]，返回 l+1 即可。<br>具体过程请参看如下代码中的 missNum 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missNum</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[l] == l + <span class="number">1</span>) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[l] &lt;= l || arr[l] &gt; r || arr[arr[l] - <span class="number">1</span>] == arr[l]) &#123;</span><br><span class="line">            arr[l] = arr[--r];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(arr, l, arr[l] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组排序之后相邻数的最大差值"><a href="#数组排序之后相邻数的最大差值" class="headerlink" title="数组排序之后相邻数的最大差值"></a>数组排序之后相邻数的最大差值</h2><p>【题目】</p>
<p>给定一个整型数组 arr，返回排序后相邻两数的最大差值。</p>
<p>【举例】</p>
<p>arr=[9,3,1,10]。如果排序，结果为[1,3,9,10]，9 和 3 的差为最大差值，故返回 6。<br>arr=[5,5,5,5]。返回 0。</p>
<p>【要求】</p>
<p>如果 arr 的长度为 N，请做到时间复杂度为 O(N)。</p>
<p>【解答】</p>
<p>本题如果用排序法实现，其时间复杂度是 O(NlogN)，而如果利用桶排序的思想（不是直接进行桶排序），可以做到时间复杂度为 O(N)，额外空间复杂度为 O(N)。遍历 arr 找到最小值和最大值，分别记为 min 和 max。如果 arr 的长度为 N，那么我们准备 N+1 个桶，把 max 单独放在第 N+1 号桶里。arr 中在[min,max)范围上的数放在 1~N 号桶里，对于 1~N 号桶中的每一个桶来说，负责的区间大小为(max-min)/N。比如长度为 10 的数组 arr 中，最小值为 10，最大值为 110。那么就准备 11 个桶，arr 中等于 110 的数全部放在第 11 号桶里。区间[10,20)的数全部放在 1 号桶里，区间[20,30)的数全部放在 2 号桶里……，区间[100,110)的数全部放在 10 号桶里。那么如果一个数为 num，它应该分配进(num - min) * len / (max - min)号桶里。<br>arr 一共有 N 个数，min 一定会放进 1 号桶里，max 一定会放进最后的桶里。所以，如果把所有的数放入 N+1 个桶中，必然有桶是空的。如果 arr 经过排序，相邻的数有可能此时在同一个桶中，也可能在不同的桶中。在同一个桶中的任何两个数的差值都不会大于区间值，而在空桶左右两个不空的桶里，相邻数的差值肯定大于区间值。所以产生最大差值的两个相邻数肯定来自不同的桶。所以只要计算桶之间数的间距就可以，也就是只用记录每个桶的最大值和最小值，最大差值只可能来自某个非空桶的最小值减去前一个非空桶的最大值。<br>具体过程请参看如下代码中的 maxGap 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxGap</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        min = Math.min(min, nums[i]);</span><br><span class="line">        max = Math.max(max, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (min == max) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span>[] hasNum = <span class="keyword">new</span> <span class="title class_">boolean</span>[len + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[] maxs = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[] mins = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">bid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        bid = bucket(nums[i], len, min, max); <span class="comment">// 算出桶号</span></span><br><span class="line">        mins[bid] = hasNum[bid] ? Math.min(mins[bid], nums[i]) : nums[i];</span><br><span class="line">        maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], nums[i]) : nums[i];</span><br><span class="line">        hasNum[bid] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastMax</span> <span class="operator">=</span> maxs[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasNum[i]) &#123;</span><br><span class="line">            res = Math.max(res, mins[i] - lastMax);</span><br><span class="line">            lastMax = maxs[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 long 类型是为了防止相乘时溢出</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bucket</span><span class="params">(<span class="type">long</span> num, <span class="type">long</span> len, <span class="type">long</span> min, <span class="type">long</span> max)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) ((num - min) * len / (max - min));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="做项目的最大收益问题"><a href="#做项目的最大收益问题" class="headerlink" title="做项目的最大收益问题"></a>做项目的最大收益问题</h2><p>【题目】</p>
<p>给定两个整数 W 和 K，W 代表你拥有的初始资金，K 代表你最多可以做 K 个项目。再给定两个长度为 N 的正数数组 costs[]和 profits[]，代表一共有 N 个项目，costs[i]和 profits[i]分别表示第 i 号项目的启动资金与做完后的利润(注意是利润，如果一个项目启动资金为 10，利润为 4，代表该项目最终的收入为 14)。你不能并行只能串行地做项目，并且手里拥有的资金大于或等于某个项目的启动资金时，你才能做这个项目。该如何选择做项目，能让你最终的收益最大？返回最后能获得的最大资金。</p>
<p>【举例】</p>
<p>W = 3<br>K = 2<br>costs = {5, 4, 1, 2}<br>profits = {3, 5, 3, 2}<br>初始资金为 3，最多做 2 个项目，每个项目的启动资金与利润见 costs 和 profits。最优选择为：先做 2 号项目，做完之后资金增长到 6。然后做 1 号项目，做完之后资金增长到 11。其他的任何选择都不会比这种选择好，所以返回 11。</p>
<p>【要求】</p>
<p>时间复杂度为 O(KlogN)。</p>
<p>【解答】</p>
<p>设计算法的流程如下。</p>
<ol>
<li>定义项目类如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Program</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> cost; <span class="comment">// 项目的花费</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> profit; <span class="comment">// 项目的利润</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Program</span><span class="params">(<span class="type">int</span> cost, <span class="type">int</span> profit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cost = cost;</span><br><span class="line">        <span class="built_in">this</span>.profit = profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>生成小根堆 costMinHeap，可以把具体的 Program 放进 costMinHeap 中，根据 Program 的花费来组织小根堆，花费最小的 Program 放在 costMinHeap 的堆顶。</li>
<li>生成大根堆 profitMaxHeap，可以把具体的 Program 放进 profitMaxHeap 中，根据 Program 的利润来组织大根堆，利润最多的 Program 放在 profitMaxHeap 的堆顶。</li>
<li>根据 costs 和 profits 数组，可以得到所有的 Program，把所有的 Program 放进 costMinHeap。</li>
<li>根据当前的资金 W，来解锁 costMinHeap 中的项目，只要是花费小于或等于 W 的项目，就从 costMinHeap 中弹出，放入 profitMaxHeap。因为 costMinHeap 是小根堆，所以依次弹出 Program，直到 costMinHeap 为空或者剩下项目的花费都大于 W，弹出过程停止。每一个从 costMinHeap 弹出的 Program，都进入 profitMaxHeap。进入步骤 6。</li>
<li>profitMaxHeap 装着所有可以被考虑和被解锁的项目。<br>1) 如果经历了步骤 5 的解锁过程之后，发现 profitMaxHeap 为空，首先说明当前资金 W 并没有解锁出任何项目，其次说明目前已经没有任何项目可以挑选了。直接返回 W。<br>2) 如果经历了步骤 5 的解锁过程之后，发现 profitMaxHeap 不为空。选择位于 profitMaxHeap 堆顶的那个项目完成，记为 ProgramBest。因为在所有可以被考虑的项目中，profitMaxHeap 堆顶的项目一定是获得利润最多的项目。完成 ProgramBest 之后，可以获得 ProgramBest 的利润，所以 W+=ProgramBest.profit。然后重复步骤 5，进行新一轮的解锁。</li>
<li>如果步骤 6 进行的过程中没有返回。那么做完 K 个项目后，返回 W。<br>全部过程请参看如下的 getMaxMoney 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Program</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> cost; <span class="comment">// 项目的花费</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> profit; <span class="comment">// 项目的利润</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Program</span><span class="params">(<span class="type">int</span> cost, <span class="type">int</span> profit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cost = cost;</span><br><span class="line">        <span class="built_in">this</span>.profit = profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义小根堆如何比较大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CostMinComp</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Program&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Program o1, Program o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.cost - o2.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义大根堆如何比较大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProfitMaxComp</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Program&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Program o1, Program o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.profit - o1.profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaxMoney</span><span class="params">(<span class="type">int</span> W, <span class="type">int</span> K, <span class="type">int</span>[] costs, <span class="type">int</span>[] profits)</span> &#123;</span><br><span class="line">    <span class="comment">// 无效参数</span></span><br><span class="line">    <span class="keyword">if</span> (W &lt; <span class="number">1</span> || K &lt; <span class="number">0</span> || costs == <span class="literal">null</span> ||</span><br><span class="line">            profits == <span class="literal">null</span> || costs.length != profits.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> W;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 项目花费小根堆，花费最小的项目在顶部</span></span><br><span class="line">    PriorityQueue&lt;Program&gt; costMinHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">CostMinComp</span>());</span><br><span class="line">    <span class="comment">// 项目利润大根堆，利润最大的项目在顶部</span></span><br><span class="line">    PriorityQueue&lt;Program&gt; profitMaxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ProfitMaxComp</span>());</span><br><span class="line">    <span class="comment">// 所有项目都进项目花费小根堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; costs.length; i++) &#123;</span><br><span class="line">        costMinHeap.add(<span class="keyword">new</span> <span class="title class_">Program</span>(costs[i], profits[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依次做K个项目</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= K; i++) &#123;</span><br><span class="line">        <span class="comment">// 当前资金为w，在项目花费小根堆里所有花费小于或等于w的项目，都可以考虑</span></span><br><span class="line">        <span class="keyword">while</span> (!costMinHeap.isEmpty() &amp;&amp; costMinHeap.peek().cost &lt;= W) &#123;</span><br><span class="line">            <span class="comment">// 把可以考虑的项目都放进项目利润大根堆里</span></span><br><span class="line">            profitMaxHeap.add(costMinHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果此时项目利润大根堆为空，说明可以考虑的项目为空</span></span><br><span class="line">        <span class="comment">// 说明当前资金w已经无法解锁任何项目，直接返回w</span></span><br><span class="line">        <span class="keyword">if</span> (profitMaxHeap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> W;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果还可以做项目，从项目利润大根堆拿出获得利润最多的项目完成</span></span><br><span class="line">        W += profitMaxHeap.poll().profit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> W;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分金条的最小花费"><a href="#分金条的最小花费" class="headerlink" title="分金条的最小花费"></a>分金条的最小花费</h2><p>【题目】</p>
<p>给定一个正数数组 arr，arr 的累加和代表金条的总长度，arr 的每个数代表金条要分成的长度。规定长度为 K 的金条只需分成两块，费用为 K 个铜板。返回把金条分出 arr 中的每个数字需要的最小代价。</p>
<p>【举例】</p>
<p>arr={10,30,20}，金条总长度为 60。<br>如果先分成 40 和 20 两块，将花费 60 个铜板，再把长度为 40 的金条分成 10 和 30 两块，将花费 40 个铜板，总花费为 100 个铜板；如果先分成 10 和 50 两块，将花费 60 个铜板，再把长度为 50 的金条分成 20 和 30 两块，将花费 50 个铜板，总花费为 110 个铜板；如果先分成 30 和 30 两块，将花费 60 个铜板，再把其中一根长度为 30 的金条分成 10 和 20 两块，将花费 30 个铜板，总花费为 90 个铜板。所以返回最低花费为 90。</p>
<p>【要求】</p>
<p>如果 arr 长度为 N，时间复杂度为 O(NlogN)。</p>
<p>【解答】</p>
<p>这道题的原型为哈夫曼编码算法，是用贪心策略求解的，对于贪心策略的证明，有兴趣的读者可以自行了解，本书不再赘述。本题的解题思路非常简单。</p>
<ol>
<li>假设最小代价为 ans，初始时 ans=0。先把 arr 中所有的数字放进一个小根堆。</li>
<li>从小根堆中弹出两个数字，假设为 a 和 b，令 ans=ans+a+b，然后把 a+b 的和放进小根堆。</li>
<li>重复步骤 1，直到小根堆中只剩一个数字过程停止，返回 ans 即可。<br>举个例子，假设 arr={3,9,5,2,4,4}，准备变量 ans 和小根堆 minHeap。</li>
<li>初始时 ans=0，把 arr 中所有的数字放进 minHeap，minHeap 含有数字{3,9,5,2,4,4}，并按照小根堆组织。</li>
<li>minHeap 是小根堆，所以弹出 2 和 3，令 ans=0+5=5，然后把 5 放进 minHeap，minHeap 含有数字{5,9,5,4,4}，并按照小根堆组织。</li>
<li>minHeap 是小根堆，所以弹出 4 和 4，令 ans=5+8=13，然后把 8 放进 minHeap，minHeap 含有数字{8,5,9,5}，并按照小根堆组织。</li>
<li>minHeap 是小根堆，所以弹出 5 和 5，令 ans=13+10=23，然后把 10 放进 minHeap，minHeap 含有数字{10,8,9}，并按照小根堆组织。</li>
<li>minHeap 是小根堆，所以弹出 8 和 9，令 ans=23+17=40，然后把 17 放进 minHeap，minHeap 含有数字{17,10}，并按照小根堆组织。</li>
<li>minHeap 是小根堆，所以弹出 17 和 10，令 ans=40+27=67，然后 27 放进 minHeap，minHeap 含有数字{27}，并按照小根堆组织。</li>
<li>此时小根堆只剩一个数字了，返回 ans=67。</li>
</ol>
<p>上述过程相当于构建了一棵树，这棵树的所有非叶节点值加起来，就是 ans 的最后结果。同时这棵树从上往下看也知道了如果去分割，先把 27 的金条分成 10 和 17，10 分成 5 和 5，17 分成 8 和 9，其中的一个 5 分成 2 和 3，8 分成 4 和 4。<br>一共有 N 个数，总的合并步骤为 O(N)次，每一次合并操作都需要小根堆的压入和弹出操作 O(logN)，所以全部过程为 O(NlogN)。具体实现请看如下的 getMinSplitCost 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinSplitCost</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 优先级队列就是堆结构，而且默认是小根堆结构</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        minHeap.add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (minHeap.size() != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> minHeap.poll() + minHeap.poll();</span><br><span class="line">        ans += sum;</span><br><span class="line">        minHeap.add(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="大楼轮廓问题"><a href="#大楼轮廓问题" class="headerlink" title="大楼轮廓问题"></a>大楼轮廓问题</h2><p>【题目】</p>
<p>给定一个 N×3 的矩阵 matrix，对于每一个长度为 3 的小数组 arr，都表示一个大楼的三个数据。arr[0]表示大楼的左边界，arr[1]表示大楼的右边界，arr[2]表示大楼的高度（一定大于 0）。每座大楼的地基都在 X 轴上，大楼之间可能会有重叠，请返回整体的轮廓线数组。</p>
<p>【举例】</p>
<p>matrix = {<br>    {2, 5, 6},<br>    {1, 7, 4},<br>    {4, 6, 7},<br>    {3, 6, 5},<br>    {10, 13, 2},<br>    {9, 11, 3},<br>    {12, 14, 4},<br>    {10, 12, 5}<br>}</p>
<p>返回的轮廓线数组如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="punctuation">&#123;</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="punctuation">&#123;</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">7</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="punctuation">&#123;</span><span class="number">6</span><span class="punctuation">,</span> <span class="number">7</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="punctuation">&#123;</span><span class="number">9</span><span class="punctuation">,</span> <span class="number">10</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="punctuation">&#123;</span><span class="number">10</span><span class="punctuation">,</span> <span class="number">12</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="punctuation">&#123;</span><span class="number">12</span><span class="punctuation">,</span> <span class="number">14</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>【要求】</p>
<p>时间复杂度为 O(NlogN)。</p>
<p>【解答】</p>
<p>本题需要用到有序表结构（sortedMap 或叫 orderedMap），比如红黑树、AVL 树、size-balance-tree 和跳表等都属于有序表结构。虽然有序表结构的底层实现可能不同，但是基本功能和时间复杂度的指标是一样的。<br>这种表结构是把所有在其中的数据按照 key 的排序来组织，并提供如下操作。<br>1) void put(K key, V value)：将一个（key,value）记录加入到表中，或者将 key 的记录更新成 value。<br>2) V get(K key)：根据给定的 key，查询 value 并返回。<br>3) void remove(K key)：移除 key 的记录。<br>4) boolean containsKey(K key)：询问是否有关于 key 的记录。<br>5) K firstKey()：返回所有键值的排序结果中，最左（最小）的那个。<br>6) K lastKey()：返回所有键值的排序结果中，最右（最大）的那个。<br>7) K floorKey(K key)：如果表中存入过 key，返回 key；否则返回所有键值的排序结果中，key 的前一个。<br>8) K ceilingKey(K key)：如果表中存入过 key，返回 key；否则返回所有键值的排序结果中，key 的后一个。<br>任何一个有序表结构都一定包含这 8 个操作，并且如果其中数据量为 N 的情况下，如上 8 个操作的时间复杂度都为 O(logN)。但本书篇幅有限，讲清楚红黑树、AVL 树、size-balance-tree 和跳表中的任何一个，并且将代码完全列出，都会占用很大篇幅，故不再详述。读者不管使用哪种语言，都一定能在各个语言库中找到现成的结构来使用，这些结构在算法中的地位也很重要，面试过程中也经常出现，但是因为其复杂性，面试官不会关注结构本身，面试官可以把有序表结构当黑盒，会使用这 8 个操作，并且知道每种操作的时间复杂度都为 O(logN)即可。当然有兴趣的读者可以去了解这些结构以及这几个操作都是如何实现的。</p>
<p>每一个大楼数组都可以看作在左边界新加了一个高度，在右边界删掉了一个高度。比如{1, 7, 4}这个大楼，可以看作在 1 这个点新加了一个高度 4，在 7 这个点删除了一个高度 4。所以一个大楼数组可以生成两个描述高度变化的对象。比如{1, 7, 4}这个大楼数组可以生成{1, 加入, 一个高度 4}和{7, 删除, 一个高度 4}这两个描述高度变化的对象。<br>第一步：将所有的大楼数组变成描述高度变化的对象。<br>比如题目中的例子，matrix = {<br>    {2, 5, 6},<br>    {1, 7, 4},<br>    {4, 6, 7},<br>    {3, 6, 5},<br>    {10, 13, 2},<br>    {9, 11, 3},<br>    {12, 14, 4},<br>    {10, 12, 5}<br>}<br>会变成描述高度变化的对象数组如下：<br>{<br>    {2, 加入, 一个高度 6}, {5, 删除, 一个高度 6},<br>    {1, 加入, 一个高度 4}, {7, 删除, 一个高度 4},<br>    {4, 加入, 一个高度 7}, {6, 删除, 一个高度 7},<br>    {3, 加入, 一个高度 5}, {6, 删除, 一个高度 5},<br>    {10, 加入, 一个高度 2}, {13, 删除, 一个高度 2},<br>    {9, 加入, 一个高度 3}, {11, 删除, 一个高度 3},<br>    {12, 加入, 一个高度 4}, {14, 删除, 一个高度 4},<br>    {10, 加入, 一个高度 5}, {12, 删除, 一个高度 5}<br>}</p>
<p>第二步：将描述高度变化的对象数组排序，排序的比较策略如下。</p>
<ol>
<li>第一个维度的值从小到大排序。</li>
<li>如果第一个维度的值相等，看第二个维度的值，“加入”排在前，“删除”排在后。</li>
<li>如果两个对象第一维度和第二维度的值都相等，则认为两个对象相等，谁在前都行。<br>比如上一步的对象数组，排序之后的结果为：<br>{<br> {1, 加入, 一个高度 4},<br> {2, 加入, 一个高度 6},<br> {3, 加入, 一个高度 5},<br> {4, 加入, 一个高度 7},<br> {5, 删除, 一个高度 6},<br> {6, 删除, 一个高度 5},<br> {6, 删除, 一个高度 7},<br> {7, 删除, 一个高度 4},<br> {9, 加入, 一个高度 3},<br> {10, 加入, 一个高度 2},<br> {10, 加入, 一个高度 5},<br> {11, 删除, 一个高度 3},<br> {12, 加入, 一个高度 4},<br> {12, 删除, 一个高度 5},<br> {13, 删除, 一个高度 2},<br> {14, 删除, 一个高度 4}<br>}</li>
</ol>
<p>第三步：按如下操作。<br>1) 准备有序表 mapHeightTimes，key 是一个整数，代表高度，value 是这个高度目前出现的次数。当某个 key 出现的次数为 0，则删掉这条记录。一开始 mapHeight 中没有任何记录。<br>2) 准备有序表 mapXvalueHeight，key 是一个整数，代表 X 轴上的一个位置，value 是这个位置上的最大高度。当某个 key 出现的次数为 0 时，删掉这条记录。一开始 mapXvalueHeight 中没有任何记录。</p>
<p>第四步：根据第二步生成的描述高度变化的数组，对 mapHeightTimes 和 mapXvalueHeight 进行如下操作。<br>{1, 加入, 一个高度 4}。在 mapHeightTimes 中加入{4, 1}，表示高度 4 出现了 1 次（如果某个高度在 mapHeightTimes 中已经有记录，则只用把次数加 1 即可，如果没有记录，所以新加入即可）。此时在 x=1 处，出现所有高度中的最大高度可以通过 mapHeightTimes.lastKey 得到，也就是 4。将{1, 4}记录在 mapXvalueHeight 中，表示在 x=1 处，最大高度是 4。<br>此时，mapHeightTimes 中所有的记录为：<code>&#123;&#123;4, 1&#125;&#125;</code>。<br>此时，mapXvalueHeight 中所有的记录为：<code>&#123;&#123;1, 4&#125;&#125;</code>。<br>{2, 加入, 一个高度 6}。在 mapHeightTimes 中加入{6, 1}，表示高度 6 出现了 1 次。此时在 x=2 处，出现所有高度中的最大高度可以通过 mapHeightTimes.lastKey 得到，也就是 6。将{2, 6}记录在 mapXvalueHeight 中，表示在 x=2 处，最大高度是 6。<br>此时，mapHeightTimes 中所有的记录为：<code>&#123;&#123;4, 1&#125;, &#123;6, 1&#125;&#125;</code>。<br>此时，mapXvalueHeight 中所有的记录为：<code>&#123;&#123;1, 4&#125;, &#123;2, 6&#125;&#125;</code>。<br>{3, 加入, 一个高度 5}。在 mapHeightTimes 中加入{5, 1}，表示高度 5 出现了 1 次。此时在 x=3 处，出现所有高度中的最大高度可以通过 mapHeightTimes.lastKey 得到，依然是 6。将{3, 6}记录在 mapXvalueHeight 中，表示在 x=3 处，最大高度是 6。<br>此时，mapHeightTimes 中所有的记录为：<code>&#123;&#123;4, 1&#125;, &#123;6, 1&#125;, &#123;5, 1&#125;&#125;</code>。<br>此时，mapXvalueHeight 中所有的记录为：<code>&#123;&#123;1, 4&#125;, &#123;2, 6&#125;, &#123;3, 6&#125;&#125;</code>。<br>{4, 加入, 一个高度 7}。在 mapHeightTimes 中加入{7, 1}，表示高度 7 出现了 1 次。此时在 x=4 处，出现所有高度中的最大高度可以通过 mapHeightTimes.lastKey 得到，也就是 7。将{4, 7}记录在 mapXvalueHeight 中，表示在 x=4 处，最大高度是 7。<br>此时，mapHeightTimes 中所有的记录为：<code>&#123;&#123;4, 1&#125;, &#123;6, 1&#125;, &#123;5, 1&#125;, &#123;7, 1&#125;&#125;</code>。<br>此时，mapXvalueHeight 中所有的记录为：<code>&#123;&#123;1, 4&#125;, &#123;2, 6&#125;, &#123;3, 6&#125;, &#123;4, 7&#125;&#125;</code>。<br>{5, 删除, 一个高度 6}。此时在 mapHeightTimes 中高度 6 只出现了 1 次，又是删除操作，所以彻底删掉 key==6 的记录（如果出现次数大于 1 次，则把次数减 1 即可，不需要彻底删除）。此时在 x=5 处，出现所有高度中的最大高度可以通过 mapHeightTimes.lastKey 得到，也就是 7。将{5, 7}记录在 mapXvalueHeight 中，表示在 x=5 处，最大高度是 7。<br>此时，mapHeightTimes 中所有的记录为：<code>&#123;&#123;4, 1&#125;, &#123;5, 1&#125;, &#123;7, 1&#125;&#125;</code>。<br>此时，mapXvalueHeight 中所有的记录为：<code>&#123;&#123;1, 4&#125;, &#123;2, 6&#125;, &#123;3, 6&#125;, &#123;4, 7&#125;, &#123;5, 7&#125;&#125;</code>。<br>{6, 删除, 一个高度 5}。此时在 mapHeightTimes 中高度 5 只出现了 1 次，所以彻底删掉 key==5 的记录。此时在 x=6 处，出现所有高度中的最大高度可以通过 mapHeightTimes.lastKey 得到，也就是 7。将{6, 7}记录在 mapXvalueHeight 中。<br>此时，mapHeightTimes 中所有的记录为：<code>&#123;&#123;4, 1&#125;, &#123;7, 1&#125;&#125;</code>。<br>此时，mapXvalueHeight 中所有的记录为：<code>&#123;&#123;1, 4&#125;, &#123;2, 6&#125;, &#123;3, 6&#125;, &#123;4, 7&#125;, &#123;5, 7&#125;, &#123;6, 7&#125;&#125;</code>。<br>{6, 删除, 一个高度 7}。此时在 mapHeightTimes 中高度 7 只出现了 1 次，所以彻底删掉 key==7 的记录。此时在 x=6 处，出现所有高度中的最大高度可以通过 mapHeightTimes.lastKey 得到，也就是 4。将{6, 4}记录在 mapXvalueHeight 中。<br>此时，mapHeightTimes 中所有的记录为：<code>&#123;&#123;4, 1&#125;&#125;</code>。<br>此时，mapXvalueHeight 中所有的记录为：<code>&#123;&#123;1, 4&#125;, &#123;2, 6&#125;, &#123;3, 6&#125;, &#123;4, 7&#125;, &#123;5, 7&#125;, &#123;6, 4&#125;&#125;</code>。<br>{7, 删除, 一个高度 4}。此时在 mapHeightTimes 中高度 4 只出现了 1 次，所以彻底删掉 key==4 的记录。此时在 x=7 处，mapHeightTimes 已经空了，所以最大高度是 0。将<code>&#123;7, 0&#125;</code>记录在 mapXvalueHeight 中。<br>此时，mapHeightTimes 中所有的记录为：空。<br>此时，mapXvalueHeight 中所有的记录为：<code>&#123;&#123;1, 4&#125;, &#123;2, 6&#125;, &#123;3, 6&#125;, &#123;4, 7&#125;, &#123;5, 7&#125;, &#123;6, 4&#125;, &#123;7, 0&#125;&#125;</code>。<br>{9, 加入, 一个高度 3}，mapHeightTimes 中加入{3, 1}，表示高度 3 出现了 1 次。此时在 x=9 处，出现所有高度中的最大高度可以通过 mapHeightTimes.lastKey 得到，也就是 3。将{9, 3}记录在 mapXvalueHeight 中，表示在 x=9 处，最大高度是 3。<br>此时，mapHeightTimes 中所有的记录为：<code>&#123;&#123;3, 1&#125;&#125;</code>。<br>此时，mapXvalueHeight 中所有的记录为：<code>&#123;&#123;1, 4&#125;, &#123;2, 6&#125;, &#123;3, 6&#125;, &#123;4, 7&#125;, &#123;5, 7&#125;, &#123;6, 4&#125;, &#123;7, 0&#125;, &#123;9, 3&#125;&#125;</code>。<br>{10, 加入, 一个高度 5}，mapHeightTimes 中加入{5, 1}，表示高度 5 出现了 1 次。此时在 x=10 处，出现所有高度中的最大高度可以通过 mapHeightTimes.lastKey 得到，也就是 5。将{10, 5}记录在 mapXvalueHeight 中，表示在 x=10 处，最大高度是 5。<br>此时，mapHeightTimes 中所有的记录为：<code>&#123;&#123;3, 1&#125;, &#123;5, 1&#125;&#125;</code>。<br>此时，mapXvalueHeight 中所有的记录为：<code>&#123;&#123;1, 4&#125;, &#123;2, 6&#125;, &#123;3, 6&#125;, &#123;4, 7&#125;, &#123;5, 7&#125;, &#123;6, 4&#125;, &#123;7, 0&#125;, &#123;9, 3&#125;, &#123;10, 5&#125;&#125;</code>。<br>{10, 加入, 一个高度 2}，mapHeightTimes 中加入{2, 1}，表示高度 2 出现了 1 次。此时在 x=10 处，出现所有高度中的最大高度可以通过 mapHeightTimes.lastKey 得到，也就是 5。将{10, 5}记录在 mapXvalueHeight 中，表示在 x=10 处，最大高度是 5。<br>此时，mapHeightTimes 中所有的记录为：<code>&#123;&#123;3, 1&#125;, &#123;5, 1&#125;, &#123;2, 1&#125;&#125;</code>。<br>此时，mapXvalueHeight 中所有的记录为：<code>&#123;&#123;1, 4&#125;, &#123;2, 6&#125;, &#123;3, 6&#125;, &#123;4, 7&#125;, &#123;5, 7&#125;, &#123;6, 4&#125;, &#123;7, 0&#125;, &#123;9, 3&#125;, &#123;10, 5&#125;&#125;</code>。<br>{11, 删除, 一个高度 3}，此时在 mapHeightTimes 中高度 3 只出现了 1 次，所以彻底删掉 key==3 的记录。此时在 x=11 处，出现所有高度中的最大高度可以通过 mapHeightTimes.lastKey 得到，也就是 5。将{11, 5}记录在 mapXvalueHeight 中，表示在 x=11 处，最大高度是 5。<br>此时，mapHeightTimes 中所有的记录为：<code>&#123;&#123;5, 1&#125;, &#123;2, 1&#125;&#125;</code>。<br>此时，mapXvalueHeight 中所有的记录为：<code>&#123;&#123;1, 4&#125;, &#123;2, 6&#125;, &#123;3, 6&#125;, &#123;4, 7&#125;, &#123;5, 7&#125;, &#123;6, 4&#125;, &#123;7, 0&#125;, &#123;9, 3&#125;, &#123;10, 5&#125;, &#123;11, 5&#125;&#125;</code>。<br>{12, 加入, 一个高度 4}，mapHeightTimes 中加入{4, 1}，表示高度 4 出现了 1 次。此时在 x=12 处，出现所有高度中的最大高度可以通过 mapHeightTimes.lastKey 得到，也就是 5。将{12, 5}记录在 mapXvalueHeight 中，表示在 x=12 处，最大高度是 5。<br>此时，mapHeightTimes 中所有的记录为：<code>&#123;&#123;5, 1&#125;, &#123;2, 1&#125;, &#123;4, 1&#125;&#125;</code>。<br>此时，mapXvalueHeight 中所有的记录为：<code>&#123;&#123;1, 4&#125;, &#123;2, 6&#125;, &#123;3, 6&#125;, &#123;4, 7&#125;, &#123;5, 7&#125;, &#123;6, 4&#125;, &#123;7, 0&#125;, &#123;9, 3&#125;, &#123;10, 5&#125;, &#123;11, 5&#125;, &#123;12, 5&#125;&#125;</code>。<br>{12, 删除, 一个高度 5}，此时在 mapHeightTimes 中高度 5 只出现了 1 次，所以彻底删掉 key==5 的记录。此时在 x=12 处，出现所有高度中的最大高度可以通过 mapHeightTimes.lastKey 得到，也就是 4。将{12, 4}记录在 mapXvalueHeight 中，表示在 x=12 处，最大高度是 4。<br>此时，mapHeightTimes 中所有的记录为：<code>&#123;&#123;2, 1&#125;, &#123;4, 1&#125;&#125;</code>。<br>此时，mapXvalueHeight 中所有的记录为：<code>&#123;&#123;1, 4&#125;, &#123;2, 6&#125;, &#123;3, 6&#125;, &#123;4, 7&#125;, &#123;5, 7&#125;, &#123;6, 4&#125;, &#123;7, 0&#125;, &#123;9, 3&#125;, &#123;10, 5&#125;, &#123;11, 5&#125;, &#123;12, 4&#125;&#125;</code>。<br>{13, 删除, 一个高度 2}，此时在 mapHeightTimes 中高度 2 只出现了 1 次，所以彻底删掉 key==2 的记录。此时在 x=13 处，出现所有高度中的最大高度可以通过 mapHeightTimes.lastKey 得到，也就是 4。将{13, 4}记录在 mapXvalueHeight 中，表示在 x=13 处，最大高度是 4。<br>此时，mapHeightTimes 中所有的记录为：<code>&#123;&#123;4, 1&#125;&#125;</code>。<br>此时，mapXvalueHeight 中所有的记录为：<code>&#123;&#123;1, 4&#125;, &#123;2, 6&#125;, &#123;3, 6&#125;, &#123;4, 7&#125;, &#123;5, 7&#125;, &#123;6, 4&#125;, &#123;7, 0&#125;, &#123;9, 3&#125;, &#123;10, 5&#125;, &#123;11, 5&#125;, &#123;12, 4&#125;, &#123;13, 4&#125;&#125;</code>。<br>{14, 删除, 一个高度 4}，此时在 mapHeightTimes 中高度 4 只出现了 1 次，所以彻底删掉 key==4 的记录。此时在 x=14 处，mapHeightTimes 已经为空，所以最大高度是 0，将{14, 0}记录在 mapXvalueHeight 中，表示在 x=14 处，最大高度是 0。<br>此时，mapHeightTimes 中所有的记录为：空。<br>此时，mapXvalueHeight 中所有的记录为：<code>&#123;&#123;1, 4&#125;, &#123;2, 6&#125;, &#123;3, 6&#125;, &#123;4, 7&#125;, &#123;5, 7&#125;, &#123;6, 4&#125;, &#123;7, 0&#125;, &#123;9, 3&#125;, &#123;10, 5&#125;, &#123;11, 5&#125;, &#123;12, 4&#125;, &#123;13, 4&#125;, &#123;14, 0&#125;&#125;</code>。</p>
<p>第五步：根据第四步生成的 mapXvalueHeight 表，生成所有的轮廓线。mapXvalueHeight 表其实统计了在 x 轴上出现的每个点在所有的操作都做完之后，得到的最大高度。轮廓线的产生其实只和每个点最终的最大高度变化有关。下面展示如何根据 mapXvalueHeight 表，生成轮廓线结果数组 res。<br>{1, 4}。轮廓线开始产生，开始位置为 1，高度为 4。结束位置待定，目前的最大高度为 4。res = <code>&#123;&#123;1, 待定, 4&#125;&#125;</code>。<br>{2, 6}。之前的最大高度为 4，现在最大高度变为 6。所以之前结束位置特定的轮廓线，此时可以确定结束位置为 2。同时新的轮廓线开始产生，开始位置为 2，高度为 6，结束位置待定。目前的最大高度为 6。res = <code>&#123;&#123;1, 2, 4&#125;, &#123;2, 待定, 6&#125;&#125;</code>。<br>{3, 6}。之前的最大高度为 6，现在最大高度仍是 6。所以不产生任何信息。<br>{4, 7}。之前的最大高度为 6，现在最大高度变为 7。所以之前结束位置特定的轮廓线，此时可以确定结束位置为 4。同时新的轮廓线开始产生，开始位置为 4，高度为 7，结束位置待定。目前的最大高度为 7。res = <code>&#123;&#123;1, 2, 4&#125;, &#123;2, 4, 6&#125;, &#123;4, 待定, 7&#125;&#125;</code>。<br>{5, 7}。之前的最大高度为 7，现在最大高度仍是 7。所以不产生任何信息。<br>{6, 4}。之前的最大高度为 7，现在最大高度变为 4。所以之前结束位置特定的轮廓线，此时可以确定结束位置为 6。同时新的轮廓线开始产生，开始位置为 6，高度为 4，结束位置待定。目前的最大高度为 4。res = <code>&#123;&#123;1, 2, 4&#125;, &#123;2, 4, 6&#125;, &#123;4, 6, 7&#125;, &#123;6, 待定, 4&#125;&#125;</code>。<br>{7, 0}。之前的最大高度为 4，现在最大高度变为 0。所以之前结束位置特定的轮廓线，此时可以确定结束位置为 7。根据题目描述，大楼的高度一定大于 0，如果某个位置的最大高度为 0，一定没有高楼，所以没有新的轮廓线开始产生。res = <code>&#123;&#123;1, 2, 4&#125;, &#123;2, 4, 6&#125;, &#123;4, 6, 7&#125;, &#123;6, 7, 4&#125;&#125;</code>。<br>{9, 3}。轮廓线开始产生，开始位置为 9，高度为 3。结束位置待定，目前的最大高度为 3。res = <code>&#123;&#123;1, 2, 4&#125;, &#123;2, 4, 6&#125;, &#123;4, 6, 7&#125;, &#123;6, 7, 4&#125;, &#123;9, 待定, 3&#125;&#125;</code>。<br>{10, 5}。之前的最大高度为 3，现在最大高度变为 5。所以之前结束位置特定的轮廓线，此时可以确定结束位置为 10。同时新的轮廓线开始产生，开始位置为 10，高度为 5，结束位置待定，目前的最大高度为 5。res = <code>&#123;&#123;1, 2, 4&#125;, &#123;2, 4, 6&#125;, &#123;4, 6, 7&#125;, &#123;6, 7, 4&#125;, &#123;9, 10, 3&#125;, &#123;10, 待定, 5&#125;&#125;</code>。<br>{11, 5}。之前的最大高度为 5，现在最大高度仍是 5。所以不产生任何信息。<br>{12, 4}。之前的最大高度为 5，现在最大高度变为 4。所以之前结束位置特定的轮廓线，此时可以确定结束位置为 12。同时新的轮廓线开始产生，开始位置为 12，高度为 4，结束位置待定，目前的最大高度为 4。res = <code>&#123;&#123;1, 2, 4&#125;, &#123;2, 4, 6&#125;, &#123;4, 6, 7&#125;, &#123;6, 7, 4&#125;, &#123;9, 10, 3&#125;, &#123;10, 12, 5&#125;, &#123;12, 待定, 4&#125;&#125;</code>。<br>{13, 4}。之前的最大高度为 4，现在最大高度仍是 4。所以不产生任何信息。<br>{14, 0}。之前的最大高度为 4，现在最大高度变为 0。所以之前结束位置特定的轮廓线，此时可以确定结束位置为 14。根据题目描述，大楼的高度一定大于 0，如果某个位置的最大高度为 0，一定没有高楼，所以没有新的轮廓线开始产生。res = <code>&#123;&#123;1, 2, 4&#125;, &#123;2, 4, 6&#125;, &#123;4, 6, 7&#125;, &#123;6, 7, 4&#125;, &#123;9, 10, 3&#125;, &#123;10, 12, 5&#125;, &#123;12, 14, 4&#125;&#125;</code>。<br>最后返回 res 即可。全部流程代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 描述高度变化的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x; <span class="comment">// x 轴上的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> isAdd; <span class="comment">// true 为加入，false 为删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> h; <span class="comment">// 高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> x, <span class="type">boolean</span> isAdd, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.isAdd = isAdd;</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序的比较策略</span></span><br><span class="line"><span class="comment">// 1. 第一个维度的值从小到大</span></span><br><span class="line"><span class="comment">// 2. 如果第一个维度的值相等，看第二个维度的值，“加入”排在前，“删除”排在后</span></span><br><span class="line"><span class="comment">// 3. 如果两个对象第一维度和第二维度的值都相等，则认为两个对象相等，谁在前都行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NodeComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Node&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Node o1, Node o2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o1.x != o2.x) &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.x - o2.x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o1.isAdd != o2.isAdd) &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.isAdd ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全部流程的主方法</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">buildingOutline</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    Node[] nodes = <span class="keyword">new</span> <span class="title class_">Node</span>[matrix.length * <span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 每一个大楼轮廓数组产生两个描述高度变化的对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        nodes[i * <span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Node</span>(matrix[i][<span class="number">0</span>], <span class="literal">true</span>, matrix[i][<span class="number">2</span>]);</span><br><span class="line">        nodes[i * <span class="number">2</span> + <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Node</span>(matrix[i][<span class="number">1</span>], <span class="literal">false</span>, matrix[i][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把描述高度变化的对象数组按照规定的排序策略排序</span></span><br><span class="line">    Arrays.sort(nodes, <span class="keyword">new</span> <span class="title class_">NodeComparator</span>());</span><br><span class="line">    <span class="comment">// TreeMap 就是 Java 中的红黑树结构，直接当作有序表来使用</span></span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; mapHeightTimes = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; mapXvalueHeight = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes[i].isAdd) &#123; <span class="comment">// 如果当前是加入操作</span></span><br><span class="line">            <span class="comment">// 没有出现的高度直接新加记录</span></span><br><span class="line">            <span class="keyword">if</span> (!mapHeightTimes.containsKey(nodes[i].h)) &#123;</span><br><span class="line">                mapHeightTimes.put(nodes[i].h, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 之前出现的高度，次数加 1 即可</span></span><br><span class="line">                mapHeightTimes.put(nodes[i].h,</span><br><span class="line">                        mapHeightTimes.get(nodes[i].h) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果当前是删除操作</span></span><br><span class="line">            <span class="comment">// 如果当前的高度出现次数为 1，直接删除记录</span></span><br><span class="line">            <span class="keyword">if</span> (mapHeightTimes.get(nodes[i].h) == <span class="number">1</span>) &#123;</span><br><span class="line">                mapHeightTimes.remove(nodes[i].h);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果当前的高度出现次数大于 1，次数减 1 即可</span></span><br><span class="line">                mapHeightTimes.put(nodes[i].h,</span><br><span class="line">                        mapHeightTimes.get(nodes[i].h) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据 mapHeightTimes 中的最大高度，设置 mapXvalueHeight 表</span></span><br><span class="line">        <span class="keyword">if</span> (mapHeightTimes.isEmpty()) &#123; <span class="comment">// 如果 mapHeightTimes 为空，说明最大高度为 0</span></span><br><span class="line">            mapXvalueHeight.put(nodes[i].x, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果 mapHeightTimes 不空，mapHeightTimes.lastKey()是最大高度</span></span><br><span class="line">            mapXvalueHeight.put(nodes[i].x, mapHeightTimes.lastKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// res 为结果数组，每一个 List&lt;Integer&gt;代表一个轮廓线，</span></span><br><span class="line">    <span class="comment">// 有开始位置、结束位置和高度，一共三个信息</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 一个新轮廓线的开始位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 之前的最大高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">preHeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 根据 mapXvalueHeight 生成 res 数组</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : mapXvalueHeight.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 当前位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curX</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="comment">// 当前最大高度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curMaxHeight</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (preHeight != curMaxHeight) &#123; <span class="comment">// 之前最大高度和当前最大高度不一样时</span></span><br><span class="line">            <span class="keyword">if</span> (preHeight != <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(start, curX, preHeight)));</span><br><span class="line">            &#125;</span><br><span class="line">            start = curX;</span><br><span class="line">            preHeight = curMaxHeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="加油站良好出发点问题"><a href="#加油站良好出发点问题" class="headerlink" title="加油站良好出发点问题"></a>加油站良好出发点问题</h2><p><strong>题目</strong></p>
<p>N 个加油站组成一个环形，给定两个长度都是 N 的非负数组 oil 和 dis (N&gt;1)，oil[i]代表第 i 个加油站存的油可以跑多少千米，dis[i]代表第 i 个加油站到环中下一个加油站相隔多少千米。<br>假设你有一辆油箱足够大的车，初始时车里没有油。如果车从第 i 个加油站出发，最终可以回到这个加油站，那么第 i 个加油站就算良好出发点，否则就不算。请返回长度为 N 的 boolean 型数组 res，res[i]代表第 i 个加油站是不是良好出发点。</p>
<p><strong>要求</strong></p>
<p>如果 oil 和 dis 长度为 N，时间复杂度达到 O(N)，额外空间复杂度 O(1)，返回的 boolean 类型数组不算额外空间。</p>
<p><strong>解答</strong></p>
<p>每个位置用遍历的方式确定是不是良好出发点肯定可以实现，但是这种方法的时间复杂度为 O(N^2)。最优解可以做到时间复杂度达到 O(N)，额外空间复杂度为 O(1)。<br>首先可以把数据经过简单处理，oil[i]-dis[i] 可以表示从 i 位置走到下一个位置，但是还没有加下一个位置的油量之前剩余的油量。<br>changeDisArrayGetInit 方法调用之后，dis[i]就变成了原来的 oil[i]-dis[i]值，我们把新的 dis 数组认为是“纯能数组”，并且该函数会返回一个纯能值大于或等于 0 的位置，我们把这个点叫做环的 init 点，只要是纯能值大于或等于 0 的位置都可以作为 init 点，选择哪一个都行。<br>下面的过程是依次考查 init 点以及从 init 点顺时针方向遇到的每一个点是否是良好出发点。同时这个过程的时间复杂度为 O(N)。<br>前提：init 点存在。如果 init 点不存在，说明所有的加油站纯能值都小于 0，那么必然所有点都不是良好出发点，直接返回结果即可。在满足前提的情况下，进入步骤一。<br>步骤一：扩充连通区。<br>连通区表示为[start,end)，这里使用[)符号并不是指数学上值的范围是左闭右开，而是说车在初始时是从 start 位置出发的，沿着逆时针行进，可以达到 end 位置的前一个位置。need 值为从 start 位置顺时针扩充连通区的要求，rest 值为从 end 位置逆时针扩充连通区的资源。在查看每一个点是否是良好出发点的过程中，通过 need 值和 rest 值的变化来扩充连通区。</p>
<p>我们从 init 位置开始顺时针考查每一个点是否是良好开始点，如果我们在标记星号的位置时发现星号位置是良好开始点。假设从星号继续顺时针遇到的 init 之前的每一个点，记为 X。因为从星号出发可以转一圈，所以 X 只要能达到星号位置，X 一定可以转一圈。<br>至此，已经穷举了所有的可能性。考查每一个点的过程中，连通区都可能会扩大，但是一旦扩到整个环，或者考查节点来到连通区，后续的过程都将没有连通区的扩大过程。也就是说，连通区扩大的整体时间复杂度为 O(N)，依次考查每一个点的整体时间复杂度为 O(N)，所以全部过程的时间复杂度为 O(N)。具体请看如下代码的 stations 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span>[] stations(<span class="type">int</span>[] dis, <span class="type">int</span>[] oil) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dis == <span class="literal">null</span> || oil == <span class="literal">null</span> || dis.length &lt; <span class="number">2</span> || dis.length != oil.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">init</span> <span class="operator">=</span> changeDisArrayGetInit(dis, oil);</span><br><span class="line">    <span class="keyword">return</span> init == -<span class="number">1</span> ? <span class="keyword">new</span> <span class="title class_">boolean</span>[dis.length] : enlargeArea(dis, init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">changeDisArrayGetInit</span><span class="params">(<span class="type">int</span>[] dis, <span class="type">int</span>[] oil)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">init</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class="line">        dis[i] = oil[i] - dis[i];</span><br><span class="line">        <span class="keyword">if</span> (dis[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            init = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span>[] enlargeArea(<span class="type">int</span>[] dis, <span class="type">int</span> init) &#123;</span><br><span class="line">    <span class="type">boolean</span>[] res = <span class="keyword">new</span> <span class="title class_">boolean</span>[dis.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> init;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nextIndex(init, dis.length);</span><br><span class="line">    <span class="type">int</span> <span class="variable">need</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 当前来到的 start 已经在连通区域中，可以确定后续的开始点一定无法转完一圈</span></span><br><span class="line">        <span class="keyword">if</span> (start != init &amp;&amp; start == lastIndex(end, dis.length)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前来到的 start 不在连通区域中，就扩充连通区域</span></span><br><span class="line">        <span class="keyword">if</span> (dis[start] &lt; need) &#123; <span class="comment">// 从当前 start 出发，无法到达 initial 点</span></span><br><span class="line">            need -= dis[start];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如 start 可以到达 initial 点，扩充连通区域的结束点</span></span><br><span class="line">            rest += dis[start] - need;</span><br><span class="line">            need = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (rest &gt;= <span class="number">0</span> &amp;&amp; end != start) &#123;</span><br><span class="line">                rest += dis[end];</span><br><span class="line">                end = nextIndex(end, dis.length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果连通区域已经覆盖整个环，当前的 start 是良好出发点，进入 2 阶段</span></span><br><span class="line">            <span class="keyword">if</span> (rest &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                res[start] = <span class="literal">true</span>;</span><br><span class="line">                connectGood(dis, lastIndex(start, dis.length), init, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        start = lastIndex(start, dis.length);</span><br><span class="line">    &#125; <span class="keyword">while</span> (start != init);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已知 start 的 next 方向上有一个良好出发点</span></span><br><span class="line"><span class="comment">// start 如果可以达到这个良好出发点，那么从 start 出发一定可以转一圈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connectGood</span><span class="params">(<span class="type">int</span>[] dis, <span class="type">int</span> start, <span class="type">int</span> init, <span class="type">boolean</span>[] res)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">need</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start != init) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dis[start] &lt; need) &#123;</span><br><span class="line">            need -= dis[start];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[start] = <span class="literal">true</span>;</span><br><span class="line">            need = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start = lastIndex(start, dis.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> index == <span class="number">0</span> ? (size - <span class="number">1</span>) : index - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> index == size - <span class="number">1</span> ? <span class="number">0</span> : (index + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="容器盛水问题"><a href="#容器盛水问题" class="headerlink" title="容器盛水问题"></a>容器盛水问题</h2><p><strong>题目</strong></p>
<p>给定一个数组 arr，已知其中所有的值都是非负的，将这个数组看作一个容器，请返回容器能装多少水。<br>例如，arr = {3,1,2,5,2,4}，可以装下 5 格水。<br>arr = {4,5,1,3,2}，可以装下 2 格水。</p>
<p><strong>要求</strong></p>
<p>如果 arr 长度为 N，时间复杂度达到 O(N)，额外空间复杂度 O(1)。</p>
<p><strong>解答</strong></p>
<p>面对这道题，很多面试者会去尝试寻找波峰和波谷，但这种方式编程难度不小，而且存在波谷失效的情况。<br>一个简洁的标准是：如果现在来到 i 位置，只单独考虑 i 位置的上方能有几格水。<br>i 位置上方水的数量 = <code>max&#123; min(i左侧的最大值, i右侧的最大值) - arr[i], 0 &#125;</code><br>如果我们依次求出数组中每一个位置上方的水，都累加起来就是答案。</p>
<p><strong>解法一：暴力遍历</strong></p>
<p>最简洁也是最暴力的解法，对每个位置都遍历求左右最大值。<br>时间复杂度为 O(N^2)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWater1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 0 位置和 n-1 位置上方一定没有水，所以不尝试</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历求 i 位置的左侧最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; i; l++) &#123;</span><br><span class="line">            leftMax = Math.max(arr[l], leftMax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历求 i 位置的右侧最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i + <span class="number">1</span>; r &lt; arr.length; r++) &#123;</span><br><span class="line">            rightMax = Math.max(arr[r], rightMax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i 位置上方的水量累加到结果中</span></span><br><span class="line">        res += Math.max(Math.min(leftMax, rightMax) - arr[i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法二：预处理数组</strong></p>
<p><code>getWater1</code> 方法的时间复杂度为 O(N^2)，因为求 i 位置两侧最大值是通过遍历的方式。可以用预处理数组的方式把遍历的代价省下来。<br>生成和 arr 等长的两个数组 <code>leftMaxs</code> 和 <code>rightMaxs</code>。</p>
<ul>
<li><code>leftMaxs[i]</code> 的含义是 <code>arr[0..i]</code> 的最大值。</li>
<li><code>rightMaxs[i]</code> 的含义是 <code>arr[i..N-1]</code> 的最大值。</li>
</ul>
<p>生成这两个数组的时间复杂度为 O(N)。之后对于任何一个 i 位置，左侧的最大值就是 <code>leftMaxs[i-1]</code>，右侧的最大值就是 <code>rightMaxs[i+1]</code>。<br>整体时间复杂度 O(N)，额外空间复杂度 O(N)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWater2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] leftMaxs = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    leftMaxs[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        leftMaxs[i] = Math.max(leftMaxs[i - <span class="number">1</span>], arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] rightMaxs = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    rightMaxs[arr.length - <span class="number">1</span>] = arr[arr.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        rightMaxs[i] = Math.max(rightMaxs[i + <span class="number">1</span>], arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        res += Math.max(Math.min(leftMaxs[i - <span class="number">1</span>], rightMaxs[i + <span class="number">1</span>]) - arr[i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法三：双指针最优解</strong></p>
<p><code>getWater2</code> 方法时间复杂度是 O(N)，但使用了额外的数组。最优解可以做到时间复杂度 O(N)，额外空间复杂度 O(1)。<br>设置左右两个指针，记为 L 和 R，还有两个变量 leftMax 和 rightMax。<br>初始时 L 指向 <code>arr[1]</code> 的位置，R 指向 <code>arr[N-2]</code> 的位置。<code>leftMax = arr[0]</code>，<code>rightMax = arr[N-1]</code>。<br>求解每一步让 L 向右移动或者 R 向左移动，leftMax 表示 <code>arr[0..L-1]</code> 中的最大值，rightMax 表示 <code>arr[R+1..N-1]</code> 中的最大值。</p>
<ol>
<li>如果 <code>leftMax &lt;= rightMax</code>，此时可以求出 L 位置上方的水量。因为 rightMax 是 <code>arr[R+1..N-1]</code> 的最大值，而 L 的右侧还有一个未遍历的区域，所以 L 右侧最大值一定不会小于 rightMax。此时瓶颈在于 leftMax。<br>L 位置上方的水量 = <code>max&#123;leftMax - arr[L], 0&#125;</code>。<br>然后更新 leftMax (<code>leftMax = max&#123;leftMax, arr[L++]&#125;</code>)。</li>
<li>如果 <code>leftMax &gt; rightMax</code>，此时可以求出 R 位置上方的水量。解释同理，R 左侧最大值一定不会小于 leftMax，瓶颈在于 rightMax。<br>R 位置上方的水量 = <code>max&#123;rightMax - arr[R], 0&#125;</code>。<br>然后更新 rightMax (<code>rightMax = max&#123;rightMax, arr[R--]&#125;</code>)。</li>
<li>每一步都会求出 L 或者 R 一个位置的水量，累加起来，当 L 和 R 相遇之后一旦错过 (L &gt; R)，过程就结束。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWater3</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> arr[arr.length - <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> arr.length - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftMax &lt;= rightMax) &#123;</span><br><span class="line">            res += Math.max(<span class="number">0</span>, leftMax - arr[L]);</span><br><span class="line">            leftMax = Math.max(leftMax, arr[L++]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += Math.max(<span class="number">0</span>, rightMax - arr[R]);</span><br><span class="line">            rightMax = Math.max(rightMax, arr[R--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="其他题目"><a href="#其他题目" class="headerlink" title="其他题目"></a>其他题目</h1><h2 id="从-5-随机到-7-随机及其扩展"><a href="#从-5-随机到-7-随机及其扩展" class="headerlink" title="从 5 随机到 7 随机及其扩展"></a>从 5 随机到 7 随机及其扩展</h2><p>【题目】</p>
<p>给定一个等概率随机产生 1~5 的随机函数 rand1To5 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand1To5</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) (Math.random() * <span class="number">5</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，不能使用任何额外的随机机制，请用 rand1To5 实现等概率随机产生 1~7 的随机函数 rand1To7。</p>
<p>补充问题：给定一个以 p 概率产生 0，以 1-p 概率产生 1 的随机函数 rand01p 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand01p</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 可随意改变 p</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0.83</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.random() &lt; p ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，不能使用任何额外的随机机制，请用 rand01p 实现等概率随机产生 1~6 的随机函数 rand1To6。</p>
<p>进阶问题：给定一个等概率随机产生 1~m 的随机函数 rand1ToM 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand1ToM</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) (Math.random() * m) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，不能使用任何额外的随机机制。有两个输入参数，分别为 m 和 n，请用 rand1ToM(m) 实现等概率随机产生 1~n 的随机函数 rand1ToN。</p>
<p>【解答】</p>
<p>先解决原问题，具体步骤如下：</p>
<ol>
<li>rand1To5() 等概率随机产生 1, 2, 3, 4, 5。</li>
<li>rand1To5() - 1 等概率随机产生 0, 1, 2, 3, 4。</li>
<li>(rand1To5() - 1) * 5 等概率随机产生 0, 5, 10, 15, 20。</li>
<li>(rand1To5() - 1) * 5 + (rand1To5() - 1) 等概率随机产生 0, 1, 2, 3, …, 23, 24。注意，这两个 rand1To5() 是指独立的两次调用，请不要简化。这是“插空儿”的过程。</li>
<li>如果步骤 4 产生的结果大于 20，则重复进行步骤 4，直到产生的结果在 0~20 之间。同时可以轻易知道出现 21~24 的概率会平均分配到 0~20 上。这是“筛”过程。</li>
<li>步骤 5 会等概率随机产生 0~20，所以步骤 5 的结果再进行 %7 操作，就会等概率地随机产生 0~6。</li>
<li>步骤 6 的结果再加 1，就会等概率地随机产生 1~7。</li>
</ol>
<p>具体请参看如下代码中的 rand1To7 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand1To5</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) (Math.random() * <span class="number">5</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand1To7</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        num = (rand1To5() - <span class="number">1</span>) * <span class="number">5</span> + rand1To5() - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (num &gt; <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">7</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是补充问题。虽然 rand01p 方法以 p 的概率产生 0，以 1-p 的概率产生 1，但是 rand01p 产生 01 和 10 的概率却都是 p(1-p)，可以利用这一点来实现等概率随机产生 0 和 1 的函数。具体过程请参看如下代码中的 rand01 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand01p</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 可随意改变 p</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0.83</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.random() &lt; p ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand01</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        num = rand01p();</span><br><span class="line">    &#125; <span class="keyword">while</span> (num == rand01p());</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了等概率随机产生 0 和 1 的函数后，再按照如下步骤生成等概率随机产生 1~6 的函数：</p>
<ol>
<li>rand01() 方法可以等概率随机产生 0 和 1。</li>
<li>rand01() * 2 等概率随机产生 0 和 2。</li>
<li>rand01() * 2 + rand01() 等概率随机产生 0, 1, 2, 3。注意，这两个 rand01() 是指独立的两次调用，请不要简化。这是“插空儿”的过程。<br>步骤 3 已经实现了等概率随机产生 0~3 的函数，具体请参看如下代码中的 rand0To3 方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand0To3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rand01() * <span class="number">2</span> + rand01();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>rand0To3() * 4 + rand0To3() 等概率随机产生 0, 1, 2, …, 14, 15。注意，这两个 rand0To3() 是指独立的两次调用，请不要简化。这还是“插空儿”的过程。</li>
<li>如果步骤 4 产生的结果大于 11，则重复进行步骤 4，直到产生的结果在 0~11 之间。那么可以知道出现 12~15 的概率会平均分配到 0~11 上。这是“筛”过程。</li>
<li>因为步骤 5 的结果是等概率随机产生 0~11，所以用第 5 步的结果再进行 %6 操作，就会等概率随机产生 0~5。</li>
<li>第 6 步的结果再加 1，就会等概率随机产生 1~6。</li>
</ol>
<p>具体请参看如下代码中的 rand1To6 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand1To6</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        num = rand0To3() * <span class="number">4</span> + rand0To3();</span><br><span class="line">    &#125; <span class="keyword">while</span> (num &gt; <span class="number">11</span>);</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">6</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是进阶问题。如果读者真正理解了“插空儿”过程和“筛”过程，就可以知道，只要给定某个区间上的等概率随机函数，就可以实现任意区间上的随机函数。所以，如果 m &gt;= n，直接进入如上所述的“筛”过程；如果 m &lt; n，先进入如上所述的“插空儿”过程，直到产生比 n 的范围还大的随机范围后，再进入“筛”过程。具体地说，是调用 k 次 rand1ToM(m)，生成 k 位的 m 进制数，并且产生的范围要大于或等于 n。比如随机 5 到随机 7 的问题，首先生成 0~24 范围的数，其实就是 0~(5^2-1) 范围的数。在把范围扩到大于或等于 n 的级别之后，如果真实生成的数大于或等于 n，就忽略，也就是“筛”过程。只留下小于或等于 n 的数，那么在 0~n-1 上就可以做到均匀分布。具体请参看如下代码中的 rand1ToN 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand1ToM</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) (Math.random() * m) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand1ToN</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nMSys = getMSysNum(n - <span class="number">1</span>, m);</span><br><span class="line">    <span class="type">int</span>[] randNum = getRanMSysNumLessN(nMSys, m);</span><br><span class="line">    <span class="keyword">return</span> getNumFromMSysNum(randNum, m) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 value 转成 m 进制数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getMSysNum(<span class="type">int</span> value, <span class="type">int</span> m) &#123;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> res.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (value != <span class="number">0</span>) &#123;</span><br><span class="line">        res[index--] = value % m;</span><br><span class="line">        value = value / m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等概率随机产生一个 0~nMSys 范围的数，只不过是用 m 进制数表达的</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getRanMSysNumLessN(<span class="type">int</span>[] nMSys, <span class="type">int</span> m) &#123;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nMSys.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (nMSys[start] == <span class="number">0</span>) &#123;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> start;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">lastEqual</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (index != nMSys.length) &#123;</span><br><span class="line">        res[index] = rand1ToM(m) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (lastEqual) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[index] &gt; nMSys[index]) &#123;</span><br><span class="line">                index = start;</span><br><span class="line">                lastEqual = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lastEqual = res[index] == nMSys[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 m 进制数转换成十进制数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumFromMSysNum</span><span class="params">(<span class="type">int</span>[] mSysNum, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != mSysNum.length; i++) &#123;</span><br><span class="line">        res = res * m + mSysNum[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一行代码求两个数的最大公约数"><a href="#一行代码求两个数的最大公约数" class="headerlink" title="一行代码求两个数的最大公约数"></a>一行代码求两个数的最大公约数</h2><p>【题目】</p>
<p>给定两个不等于 0 的整数 M 和 N，求 M 和 N 的最大公约数。</p>
<p>【解答】</p>
<p>一个很简单求两个数最大公约数的算法是欧几里得在其《几何原本》中提出的欧几里得算法，又称为辗转相除法。<br>具体做法：如果 q 和 r 分别是 m 除以 n 的商及余数，即 m=nq+r，那么 m 和 n 的最大公约数等于 n 和 r 的最大公约数。详细证明略。<br>具体请参看如下代码中的 gcd 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? m : gcd(n, m % n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有关阶乘的两个问题"><a href="#有关阶乘的两个问题" class="headerlink" title="有关阶乘的两个问题"></a>有关阶乘的两个问题</h2><p>【题目】</p>
<p>给定一个非负整数 N，返回 N! 结果的末尾为 0 的数量。<br>例如：3!=6, 结果的末尾没有 0, 则返回 0。5!=120, 结果的末尾有 1 个 0, 返回 1。1000000000!, 结果的末尾有 249999998 个 0, 返回 249999998。</p>
<p>进阶问题：给定一个非负整数 N，如果用二进制数表达 N! 的结果，返回最低位的 1 在哪个位置上，认为最右的位置为位置 0。<br>例如：1!=1, 最低位的 1 在 0 位置上。2!=2, 最低位的 1 在 1 位置上。1000000000!, 最低位的 1 在 999999987 位置上。</p>
<p>【解答】</p>
<p>无论是原问题还是进阶问题，通过算出真实的阶乘结果后再处理的方法无疑是不合适的，因为阶乘的结果通常很大，非常容易溢出，而且会增加计算的复杂性。</p>
<p>先来介绍原问题的一个普通解法。对原问题来说，N! 结果的末尾有多少个 0 的问题可以转换为 1, 2, 3, …, N-1, N 的序列中一共有多少个因子 5。这是因为进行 1×2×3×…×N 操作的过程中，因子 2 的数目比因子 5 的数目多，所以不管有多少个因子 5，都有足够的因子 2 与其相乘得到 10。所以只要找出 1~N 所有的数中一共有多少个因子 5 就可以。具体参看如下代码中的 zeroNum1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">zeroNum1</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>; i &lt; num + <span class="number">1</span>; i = i + <span class="number">5</span>) &#123;</span><br><span class="line">        cur = i;</span><br><span class="line">        <span class="keyword">while</span> (cur % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            cur /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上方法的效率并不高，对每一个数 i 来说，处理的代价是 logi (以 5 为底)，一共有 O(N) 个数。所以时间复杂度为 O(NlogN)。</p>
<p>现在介绍原问题的最优解。我们把 1~N 的数列出来，1, 2, 3, 4, 5, 6, 7, 8, 9, 10…, 15…, 20…, 25…, 30…, 35…, 40…, 45…, 50…, 75…, 100…, 125…<br>读者观察上面的数就会发现：若每 5 个数含有 0 个因子 5 的数 (1, 2, 3, 4, 5) 组成一组，这一组中的第 5 个数就含有 5^1 的因子 (5)。若每 5 个含有 1 个因子 5 的数 (5, 10, 15, 20, 25) 组成一组，这一组中的第 5 个数就含有 5^2 的因子 (25)。若每 5 个含有 2 个因子 5 的数 (25, 50, 75, 100, 125) 组成一组，这一组中的第 5 个数就含有 5^3 的因子 (125)。若每 5 个含有 i 个因子 5 的数组成一组，这一组中的第 5 个数就含有 5^(i+1) 的因子……</p>
<p>所以，如果把 N! 的结果中因子 5 的总个数记为 Z，就可以得到如下关系：<br>Z = N/5 + N/(5^2) + N/(5^3) + … + N/(5^i)  (i 一直增长，直到 5^i &gt; N)<br>用上文的例子来理解就是，1~N 中有 N/5 个数，每个数都能贡献一个 5；然后 1~N 中有 N/(5^2) 个数，这每个数又都能贡献一个 5…… 具体请参看如下代码中的 zeroNum2 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">zeroNum2</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">        res += num / <span class="number">5</span>;</span><br><span class="line">        num /= <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果一共有 N 个数，最优解的时间复杂度为 O(logN)，以 5 为底。</p>
<p>进阶问题。本书提供两种方法，先来介绍解法一。与原问题的解法类似，最低位的 1 在哪个位置上，完全取决于 1~N 的数中因子 2 有多少个，因为只要出现一个因子 2，最低位的 1 就会向左位移一位。所以，如果把 N! 的结果中因子 2 的总个数记为 Z，我们就可以得到如下关系 Z = N/2 + N/4 + N/8 + … + N/(2^i) (i 一直增长，直到 2^i &gt; N)。具体请参看如下代码中的 rightOne1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rightOne1</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        res += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来介绍解法二。如果把 N! 的结果中因子 2 的总个数记为 Z，把 N 的二进制数表达式中 1 的个数记为 m，还存在如下一个关系 Z = N - m，也就是可以证明 N/2 + N/4 + N/8 + … = N - m。注意，这里的 / 不是数学上的除法，而是计算科学中的除法，即结果要向下取整。首先，如果一个整数 K 正好为 2 的某次方 (K=2^i)，那么求和公式 K/2+K/4+K/8+…+1，也就是在 K=2^i 时，计算科学中的除法和数学上的除法等效。所以根据等比数列求和公式 S=(末项×公比-首项)/(公比-1)，可以得到 K/2+K/4+K/8+… = K-1。<br>如果在 N 的二进制表达中有 m 个 1，那么 N 可以表达为：N=K1+K2+K3+…+Km，其中所有的 K 都等于 2 的某次方。例如，N=10110 时，N=10000+100+10。于是有 N/2+N/4+… = (K1+K2+K3+…+Km)/2+(K1+K2+K3+…+Km)/4+… = K1/2+K1/4+K1/8+…+1 + K2/2+K2/4+…+1 + … + Km/2+Km/4+…+1。<br>K1, K2, …, Km 都等于 2 的某次方。所以等式右边 = K1-1+K2-1+K3-1+…+Km-1 = (K1+…+Km)-m = N-m。至此，Z=N-m 证明完毕。具体过程请参看如下代码中的 rightOne2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rightOne2</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ones</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> num;</span><br><span class="line">    <span class="keyword">while</span> (tmp != <span class="number">0</span>) &#123;</span><br><span class="line">        ones += (tmp &amp; <span class="number">1</span>) != <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        tmp &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num - ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断一个点是否在矩形内部"><a href="#判断一个点是否在矩形内部" class="headerlink" title="判断一个点是否在矩形内部"></a>判断一个点是否在矩形内部</h2><p>【题目】</p>
<p>在二维坐标系中，所有的值都是 double 类型，那么一个矩形可以由 4 个点来代表，(x1, y1) 为最左的点、(x2, y2) 为最上的点、(x3, y3) 为最下的点、(x4, y4) 为最右的点。给定 4 个点代表的矩形，再给定一个点 (x, y)，判断 (x, y) 是否在矩形中。</p>
<p>【解答】</p>
<p>本题的解法有很多种，本书提供的方法先解决如果矩形的边不是平行于 x 轴就是平行于 y 轴的情况下，该如何判断点 (x, y) 是否在其中，具体请参看如下代码中的 isInside 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInside</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x4, <span class="type">double</span> y4, <span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= x1) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= x4) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= y1) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y &lt;= y4) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况是比较简单的，因为矩形的边不是平行于 x 轴就是平行于 y 轴，所以判断该点是否完全在矩形的左侧、右侧、上侧或下侧，如果都不是，就一定在其中。如果矩形的边不平行于坐标轴呢？也非常简单，就是高中数学的知识，通过坐标变换把矩形转成平行的情况，在旋转时所有的点跟着转动就可以。旋转完成后，再用上面的方式进行判断。具体请参看如下代码中的 isInside 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInside</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2,</span></span><br><span class="line"><span class="params">        <span class="type">double</span> x3, <span class="type">double</span> y3, <span class="type">double</span> x4, <span class="type">double</span> y4, <span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (y1 == y2) &#123;</span><br><span class="line">        <span class="keyword">return</span> isInside(x1, y1, x4, y4, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> <span class="variable">l</span> <span class="operator">=</span> Math.abs(y4 - y3);</span><br><span class="line">    <span class="type">double</span> <span class="variable">k</span> <span class="operator">=</span> Math.abs(x4 - x3);</span><br><span class="line">    <span class="type">double</span> <span class="variable">s</span> <span class="operator">=</span> Math.sqrt(k * k + l * l);</span><br><span class="line">    <span class="type">double</span> <span class="variable">sin</span> <span class="operator">=</span> l / s;</span><br><span class="line">    <span class="type">double</span> <span class="variable">cos</span> <span class="operator">=</span> k / s;</span><br><span class="line">    <span class="type">double</span> <span class="variable">x1R</span> <span class="operator">=</span> cos * x1 + sin * y1;</span><br><span class="line">    <span class="type">double</span> <span class="variable">y1R</span> <span class="operator">=</span> -x1 * sin + y1 * cos;</span><br><span class="line">    <span class="type">double</span> <span class="variable">x4R</span> <span class="operator">=</span> cos * x4 + sin * y4;</span><br><span class="line">    <span class="type">double</span> <span class="variable">y4R</span> <span class="operator">=</span> -x4 * sin + y4 * cos;</span><br><span class="line">    <span class="type">double</span> <span class="variable">xR</span> <span class="operator">=</span> cos * x + sin * y;</span><br><span class="line">    <span class="type">double</span> <span class="variable">yR</span> <span class="operator">=</span> -x * sin + y * cos;</span><br><span class="line">    <span class="keyword">return</span> isInside(x1R, y1R, x4R, y4R, xR, yR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断一个点是否在三角形内部"><a href="#判断一个点是否在三角形内部" class="headerlink" title="判断一个点是否在三角形内部"></a>判断一个点是否在三角形内部</h2><p>【题目】</p>
<p>在二维坐标系中，所有的值都是 double 类型，那么一个三角形可以由 3 个点来代表，给定 3 个点代表的三角形，再给定一个点 (x,y)，判断 (x,y) 是否在三角形中。</p>
<p>【解答】</p>
<p>本书提供两种解法，第一种解法是从面积的角度来解决这道题，第二种解法是从向量的角度来解决。解法一在逻辑上没有问题，但是没有解法二好，下面会给出详细的解释。</p>
<p>先来介绍解法一，如果点 O 在三角形 ABC 内部，那么，有面积 ABC=面积 ABO+面积 BCO+面积 CAO。如果点 O 在三角形 ABC 外部，那么，有面积 ABC&lt;面积 ABO+面积 BCO+面积 CAO。既告知了这样一种评判标准，实现代码就变得很简单了。首先实现求两个点 (x1,y1) 和 (x2,y2) 之间距离的函数，具体请参看如下代码中的 getSideLength 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSideLength</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> Math.abs(x1 - x2);</span><br><span class="line">    <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> Math.abs(y1 - y2);</span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(a * a + b * b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了如上函数后，就可以求出一条边的边长。下面根据边长来求三角形的面积，用海伦公式来求解三角形面积是非常合适的，具体请参看如下代码中的 getArea 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2,</span></span><br><span class="line"><span class="params">        <span class="type">double</span> x3, <span class="type">double</span> y3)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">side1Len</span> <span class="operator">=</span> getSideLength(x1, y1, x2, y2);</span><br><span class="line">    <span class="type">double</span> <span class="variable">side2Len</span> <span class="operator">=</span> getSideLength(x1, y1, x3, y3);</span><br><span class="line">    <span class="type">double</span> <span class="variable">side3Len</span> <span class="operator">=</span> getSideLength(x2, y2, x3, y3);</span><br><span class="line">    <span class="type">double</span> <span class="variable">p</span> <span class="operator">=</span> (side1Len + side2Len + side3Len) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.sqrt((p - side1Len) * (p - side2Len) * (p - side3Len) * p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就可以根据我们的标准来求解，具体请参看如下代码中的 isInside1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInside1</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2,</span></span><br><span class="line"><span class="params">        <span class="type">double</span> x3, <span class="type">double</span> y3, <span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">area1</span> <span class="operator">=</span> getArea(x1, y1, x2, y2, x, y);</span><br><span class="line">    <span class="type">double</span> <span class="variable">area2</span> <span class="operator">=</span> getArea(x1, y1, x3, y3, x, y);</span><br><span class="line">    <span class="type">double</span> <span class="variable">area3</span> <span class="operator">=</span> getArea(x2, y2, x3, y3, x, y);</span><br><span class="line">    <span class="type">double</span> <span class="variable">allArea</span> <span class="operator">=</span> getArea(x1, y1, x2, y2, x3, y3);</span><br><span class="line">    <span class="keyword">return</span> area1 + area2 + area3 &lt;= allArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然解法一的逻辑是正确的，但 double 类型的值在计算时会出现一定程度的偏差。所以经常会发生明明 O 点在三角形内，但是面积却对不准的情况出现，最后导致判断出错。所以解法一并不推荐。</p>
<p>解法二使用了和解法一完全不同的标准，而且几乎不会受精度损耗的影响。如果点 O 在三角形 ABC 内部，除面积上的关系外，还有其他关系存在。<br>如果点 O 在三角形 ABC 中，那么从三角形的一点出发，逆时针走过所有边的过程中，点 O 始终都在走过边的左侧。比如，O 都在 AB、BC 和 CA 的左侧。如果点 O 在三角形 ABC 外部，则不满足这个关系。</p>
<p>新的标准有了，接下来解决一个棘手的问题。我们知道作为参数传入的三个点的坐标代表一个三角形，可是这三个点依次的顺序不一定是逆时针的。比如，如果参数的顺序为 A 坐标、B 坐标和 C 坐标，那就没问题，因为这是逆时针的。但如果参数的顺序为 C 坐标、B 坐标和 A 坐标，就有问题，因为这是顺时针的。作为程序的实现者，要求用户按你规定的顺序传入三角形的三个点坐标，这显然是不合适的。所以需要自己来解决这个问题。假设得到的坐标依次为点 1、点 2、点 3。顺序可能是顺时针，也可能是逆时针。<br>如果点 2 在 1-&gt;3 边的右边，此时按照点 1、点 2 和点 3 的顺序没有问题，这个顺序本来就是逆时针的。但如果点 2 在 1-&gt;3 边的左边，那么按照点 1、点 2 和点 3 的顺序就有问题，因为这个顺序是顺时针的，所以应该按照点 1、点 3 和点 2 的顺序。</p>
<p>如何判断一个点在一条有向边的左边还是右边？这利用几何上向量积（叉积）的求解公式即可。如果有向边 1-&gt;2 叉乘有向边 1-&gt;3 的结果为正，说明 2 在有向边 1-&gt;3 的左边；如果有向边 1-&gt;2 叉乘有向边 1-&gt;3 的结果为负，说明 2 在有向边 1-&gt;3 的右边。<br>具体过程请参看如下代码中的 crossProduct 方法，该方法描述了向量 (x1,y1) 叉乘向量 (x2,y2)，两个向量的开始点都是原点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">crossProduct</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x1 * y2 - x2 * y1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们已经解释了解法二的所有细节，全部过程请参看如下代码中的 isInside2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInside2</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2,</span></span><br><span class="line"><span class="params">        <span class="type">double</span> x3, <span class="type">double</span> y3, <span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果三角形的点不是逆时针输入，改变一下顺序</span></span><br><span class="line">    <span class="keyword">if</span> (crossProduct(x3 - x1, y3 - y1, x2 - x1, y2 - y1) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">tmpx</span> <span class="operator">=</span> x2;</span><br><span class="line">        <span class="type">double</span> <span class="variable">tmpy</span> <span class="operator">=</span> y2;</span><br><span class="line">        x2 = x3;</span><br><span class="line">        y2 = y3;</span><br><span class="line">        x3 = tmpx;</span><br><span class="line">        y3 = tmpy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (crossProduct(x2 - x1, y2 - y1, x - x1, y - y1) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (crossProduct(x3 - x2, y3 - y2, x - x2, y - y2) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (crossProduct(x1 - x3, y1 - y3, x - x3, y - y3) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="折纸问题"><a href="#折纸问题" class="headerlink" title="折纸问题"></a>折纸问题</h2><p>【题目】</p>
<p>请把一张纸条竖着放在桌子上，然后从纸条的下边向上方对折 1 次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折 2 次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。给定一个输入参数 N，代表纸条都从下边向上方连续对折 N 次，请从上到下打印所有折痕的方向。<br>例如：N=1 时，打印：<br>down<br>N=2 时，打印：<br>down<br>down<br>up</p>
<p>【解答】</p>
<p>对折第 1 次产生的折痕：        下<br>对折第 2 次产生的折痕：    上      下<br>对折第 3 次产生的折痕：  上  下  上  下<br>对折第 4 次产生的折痕：上 下 上 下 上 下 上 下</p>
<p>根据上述关系可以总结出：</p>
<ul>
<li>产生第 i+1 次折痕的过程，就是在对折 i 次产生的每一条折痕的左右两侧，依次插入上折痕和下折痕的过程。</li>
<li>所有折痕的结构是一棵满二叉树，在这棵满二叉树中，头节点为下折痕，每一棵左子树的头节点为上折痕，每一棵右子树的头节点为下折痕。</li>
<li>从上到下打印所有折痕方向的过程，就是二叉树的先右、再中、最后左的中序遍历。</li>
</ul>
<p>具体过程请参看如下代码中的 printAllFolds 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printAllFolds</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">    printProcess(<span class="number">1</span>, N, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printProcess</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> N, <span class="type">boolean</span> down)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; N) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printProcess(i + <span class="number">1</span>, N, <span class="literal">true</span>);</span><br><span class="line">    System.out.println(down ? <span class="string">&quot;down &quot;</span> : <span class="string">&quot;up &quot;</span>);</span><br><span class="line">    printProcess(i + <span class="number">1</span>, N, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>纸条连续对折 n 次之后一定会产生 2^n - 1 条折痕，所以要打印所有的节点，不管用什么方法，其时间复杂度肯定都是 O(2^n)，因为解的空间本身就有这么大，但是本书提供的方法的额外空间复杂度为 O(n)，也就是这棵满二叉树的高度，额外空间主要用来维持递归函数的运行，也就是函数栈的大小。</p>
<h2 id="能否完美地拼成矩形"><a href="#能否完美地拼成矩形" class="headerlink" title="能否完美地拼成矩形"></a>能否完美地拼成矩形</h2><p>【题目】</p>
<p>每条边不是平行于 X 轴就是平行于 Y 轴的矩形，可以用左下角点和右上角点来表示。比如 {1,2,3,4}，表示的图形如图 9-6 所示。</p>
<p>给定一个 N 行 4 列的二维数组 matrix，表示 N 个每条边不是平行于 X 轴就是平行于 Y 轴的矩形。想知道所有的矩形能否组成一个大的完美矩形。完美矩形是指拼出的整体图案是矩形，既不缺任何块儿，也没有重合的部分。</p>
<p>【举例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回 false。如果画出这四个矩形，会发现拼出的图案缺少 {2,3,3,4} 这一块儿。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">matrix = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回 false。拼出的图案缺少 {3,1,4,2}，并且 {3,2,4,3} 是重合区域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">matrix = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回 true。拼出的图案是一整块儿矩形，既不缺任何块儿，也没有重合的部分。</p>
<p>【解答】</p>
<p>标准一：面积要能对上。遍历每一个矩形的过程中，记录 X 轴方向上出现的最左位置和最右位置，并分别记为 mostLeft 和 mostRight；记录 Y 轴方向上出现的最下位置和最上位置，并分别记为 mostDown 和 mostUp。<br>mostLeft、mostRight、mostDown、mostUp 这四个值可以定位一个大矩形，面积为 (mostRight-mostLeft)*(mostUp-mostDown)。那么拼出完美矩形的标准之一是：每一个小矩形的面积累加起来必须等于大矩形的面积。但这是不够的，比如题目中的例子二，虽然每一个小矩形的面积累加起来等于大矩形的面积，但其实缺少 {3,1,4,2} 这一块，这一块的面积正好被多出来的 {3,2,4,3} 区域补上了而已。</p>
<p>标准二：除大矩形的四个顶点只出现 1 次之外，其他任何小矩形的顶点都必须出现偶数次。<br>只要同时满足标准一和标准二，一定可以拼出完美的矩形，有一个不满足都一定拼不出完美的矩形。证明略。具体过程请看如下的 isRectangleCover 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRectangleCover</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mostLeft</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mostRight</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mostDown</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mostUp</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] rect : matrix) &#123;</span><br><span class="line">        mostLeft = Math.min(rect[<span class="number">0</span>], mostLeft);</span><br><span class="line">        mostDown = Math.min(rect[<span class="number">1</span>], mostDown);</span><br><span class="line">        mostRight = Math.max(rect[<span class="number">2</span>], mostRight);</span><br><span class="line">        mostUp = Math.max(rect[<span class="number">3</span>], mostUp);</span><br><span class="line">        area += (rect[<span class="number">2</span>] - rect[<span class="number">0</span>]) * (rect[<span class="number">3</span>] - rect[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">String</span> <span class="variable">leftDown</span> <span class="operator">=</span> rect[<span class="number">0</span>] + <span class="string">&quot;_&quot;</span> + rect[<span class="number">1</span>];</span><br><span class="line">        <span class="type">String</span> <span class="variable">leftUp</span> <span class="operator">=</span> rect[<span class="number">0</span>] + <span class="string">&quot;_&quot;</span> + rect[<span class="number">3</span>];</span><br><span class="line">        <span class="type">String</span> <span class="variable">rightDown</span> <span class="operator">=</span> rect[<span class="number">2</span>] + <span class="string">&quot;_&quot;</span> + rect[<span class="number">1</span>];</span><br><span class="line">        <span class="type">String</span> <span class="variable">rightUp</span> <span class="operator">=</span> rect[<span class="number">2</span>] + <span class="string">&quot;_&quot;</span> + rect[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">if</span> (!set.add(leftDown)) set.remove(leftDown);</span><br><span class="line">        <span class="keyword">if</span> (!set.add(leftUp)) set.remove(leftUp);</span><br><span class="line">        <span class="keyword">if</span> (!set.add(rightUp)) set.remove(rightUp);</span><br><span class="line">        <span class="keyword">if</span> (!set.add(rightDown)) set.remove(rightDown);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!set.contains(mostLeft + <span class="string">&quot;_&quot;</span> + mostDown)</span><br><span class="line">            || !set.contains(mostLeft + <span class="string">&quot;_&quot;</span> + mostUp)</span><br><span class="line">            || !set.contains(mostRight + <span class="string">&quot;_&quot;</span> + mostDown)</span><br><span class="line">            || !set.contains(mostRight + <span class="string">&quot;_&quot;</span> + mostUp)</span><br><span class="line">            || set.size() != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area == (mostRight - mostLeft) * (mostUp - mostDown);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="蓄水池算法"><a href="#蓄水池算法" class="headerlink" title="蓄水池算法"></a>蓄水池算法</h2><p>【题目】</p>
<p>有一台机器按自然数序列的方式吐出球（1 号球，2 号球，3 号球，……），你有一个袋子，袋子最多只能装下 K 个球，并且除袋子以外，你没有更多的空间。设计一种选择方式，使得当机器吐出第 N 号球的时候（N&gt;K），袋子中的球数是 K 个，同时可以保证从 1 号球到 N 号球中的每一个被选进袋子的概率都是 K/N。举一个更具体的例子，有一个只能装下 10 个球的袋子，当吐出 100 个球时，袋子里有 10 个球，并且 1~100 号中的每一个球被选中的概率都是 10/100。然后继续吐球，当吐出 1000 个球时，袋子里有 10 个球，并且 1~1000 号中的每一个球被选中的概率都是 10/1000。继续吐球，当吐出 i 个球时，袋子里有 10 个球，并且 1~i 号中的每一个球被选中的概率都是 10/i，即吐球的同时，已经吐出的球被选中的概率也动态地变化。</p>
<p>【解答】</p>
<p>这道题的核心解法就是蓄水池算法，我们先说这个算法的过程，然后再证明。</p>
<ol>
<li>处理 1~k 号球时，直接放进袋子里。</li>
<li>处理第 i 号球时（i&gt;k），以 k/i 的概率决定是否将第 i 号球放进袋子。如果不决定将第 i 号球放进袋子，直接扔掉第 i 号球。如果决定将第 i 号球放进袋子，那么就从袋子里的 k 个球中随机扔掉一个，然后把第 i 号球放入袋子。</li>
<li>处理第 i+1 号球时重复步骤 1 或步骤 2。</li>
</ol>
<p>过程非常简单，但为什么这个过程就能保证从 1 号球到 n 号球中的每一个被选进袋子的概率都是 k/n 呢？以下是证明过程。<br>假设第 i 号球被选中（1&lt;=i&lt;=k），那么在选第 k+1 号球之前，第 i 号球留在袋子中的概率是 1。<br>在选第 k+1 号球时，在什么情况下第 i 号球会被淘汰呢？只有决定将第 k+1 号球放进袋子，同时在袋子中的第 i 号球被随机选中并决定扔掉时，第 i 号球才会被淘汰。也就是说，第 i 号球会被淘汰的概率是 (k/(k+1))×(1/k)=1/(k+1)，所以第 i 号球留下来的概率就是 1-(1/(k+1))=k/(k+1)，这也是 1 号球到第 k+1 号球的过程中，第 i 号球留下来的概率。<br>在选第 k+2 号球时，什么情况下第 i 号球会被淘汰？只有决定将第 k+2 号球放进袋子，同时在袋子中的第 i 号球被随机选中并决定扔掉时，第 i 号球才会被淘汰。也就是说，第 i 号球会被淘汰的概率是 (k/(k+2))×(1/k)=1/(k+2)，则第 i 号球留下来的概率就是 1-(1/(k+2)) = (k+1)/(k+2)，那么从 1 号球到第 k+2 号球的过程中，第 i 号球留在袋子中的概率是 k/(k+1)×(k+1)/(k+2)。<br>在选第 k+3 号球时，……。那么从 1 号球到第 k+3 号球的过程中，第 i 号球留在袋子中的概率是 k/(k+1)×(k+1)/(k+2)×(k+2)/(k+3)。<br>依此类推，在选第 N 号球时，从 1 号球到第 N 号球的全部过程中，第 i 号球最终留在袋子中的概率是 k/(k+1)×(k+1)/(k+2)×(k+2)/(k+3)×(k+3)/(k+4)×…×(N-1)/N=k/N。</p>
<p>假设第 i 号球被选中（k&lt;i&lt;=k），那么在选第 i 号球时，第 i 号球被选进袋子的概率是 k/i。<br>在选第 i+1 号球时，在什么情况下第 i 号球会被淘汰？只有决定将第 i+1 号球放进袋子，同时在袋子中的第 i 号球被随机选中并决定扔掉时，第 i 号球才会被淘汰。也就是说，第 i 号球会被淘汰的概率是 (k/(i+1)) × (1/k) = 1/(i+1)。那么第 i 号球留下来的概率就是 1 - 1/(i+1) = i/(i+1)，从 i 号球被选中到第 i+1 号球的过程中，第 i 号球留在袋子中的概率是 (k/i) × (i/(i+1))。<br>在选第 i+2 号球时，从 i 号球被选中到第 i+2 号球的过程中，第 i 号球留在袋子中的概率是 (k/i) × (i/(i+1)) × ((i+1)/(i+2))。<br>依此类推，在选第 N 号球时，从 i 号球被选中到第 N 号球的过程中，第 i 号球最终留在袋子中的概率是 (k/i) × (i/(i+1)) × ((i+1)/(i+2)) ×… × (N-1)/N = k/N。</p>
<p>综上所述，按照步骤 1~步骤 3 操作，当吐出球数为 N 时，每一个球被选进袋子的概率都是 k/N。具体过程请参看如下代码中的 getKNumsRand 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单的随机函数，决定一件事情做还是不做</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand</span><span class="params">(<span class="type">int</span> max)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) (Math.random() * max) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getKNumsRand(<span class="type">int</span> k, <span class="type">int</span> max) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max &lt; <span class="number">1</span> || k &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[Math.min(k, max)];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != res.length; i++) &#123;</span><br><span class="line">        res[i] = i + <span class="number">1</span>; <span class="comment">// 前 k 个数直接进袋子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>; i &lt; max + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rand(i) &lt;= k) &#123; <span class="comment">// 决定 i 进不进袋子</span></span><br><span class="line">            res[rand(k) - <span class="number">1</span>] = i; <span class="comment">// i 随机替换掉袋子中的一个</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="设计有-setAll-功能的哈希表"><a href="#设计有-setAll-功能的哈希表" class="headerlink" title="设计有 setAll 功能的哈希表"></a>设计有 setAll 功能的哈希表</h2><p>【题目】</p>
<p>哈希表常见的三个操作是 put、get 和 containsKey，而且这三个操作的时间复杂度为 O(1)。<br>现在想加一个 setAll 功能，就是把所有记录的 value 都设成统一的值。请设计并实现这种有 setAll 功能的哈希表，并且 put、get、containsKey 和 setAll 四个操作的时间复杂度都为 O(1)。</p>
<p>【解答】</p>
<p>加入一个时间戳结构，一切问题就变得非常简单了，具体步骤如下：</p>
<ol>
<li>把每一个记录都加上一个时间，标记每条记录是何时建立的。</li>
<li>设置一个 setAll 记录也加上一个时间，标记 setAll 记录建立的时间。</li>
<li>查询记录时，如果某条记录的时间早于 setAll 记录的时间，说明 setAll 是最新数据，返回 setAll 记录的值。如果某条记录的时间晚于 setAll 记录的时间，说明记录的值是最新数组，返回该条记录的值。</li>
</ol>
<p>具体请参看如下的 MyHashMap 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyValue</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyValue</span><span class="params">(V value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.time = time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;K, MyValue&lt;V&gt;&gt; baseMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> time;</span><br><span class="line">    <span class="keyword">private</span> MyValue&lt;V&gt; setAll;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.baseMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;K, MyValue&lt;V&gt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.time = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.setAll = <span class="keyword">new</span> <span class="title class_">MyValue</span>&lt;V&gt;(<span class="literal">null</span>, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.baseMap.containsKey(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.baseMap.put(key, <span class="keyword">new</span> <span class="title class_">MyValue</span>&lt;V&gt;(value, <span class="built_in">this</span>.time++));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAll</span><span class="params">(V value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setAll = <span class="keyword">new</span> <span class="title class_">MyValue</span>&lt;V&gt;(value, <span class="built_in">this</span>.time++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.baseMap.get(key).getTime() &gt; <span class="built_in">this</span>.setAll.getTime()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.baseMap.get(key).getValue();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.setAll.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最大的-leftMax-与-rightMax-之差的绝对值"><a href="#最大的-leftMax-与-rightMax-之差的绝对值" class="headerlink" title="最大的 leftMax 与 rightMax 之差的绝对值"></a>最大的 leftMax 与 rightMax 之差的绝对值</h2><p>【题目】</p>
<p>给定一个长度为 N (N&gt;1) 的整型数组 arr，可以划分成左右两个部分，左部分为 arr[0..K]，右部分为 arr[K+1..N-1]，K 可以取值的范围是 [0,N-2]。求这么多划分方案中，左部分中的最大值减去右部分最大值的绝对值中，最大是多少？<br>例如：[2,7,3,1,1]，当左部分为 [2,7]，右部分为 [3,1,1] 时，左部分中的最大值减去右部分的最大值的绝对值为 4。当左部分为 [2,7,3]，右部分为 [1,1] 时，左部分中的最大值减去右部分最大值的绝对值为 6。还有很多划分方案，但最终返回 6。</p>
<p>【解答】</p>
<p>方法一：时间复杂度为 O(N^2)，额外空间复杂度为 O(1)。这是最笨的方法，在数组的每个位置 i 都做一次这种划分，找到 arr[0..i] 的最大值 maxLeft，找到 arr[i+1..N-1] 的最大值 maxRight，然后计算两个值相减的绝对值。每次划分都这样求一次，自然可以得到最大的相减的绝对值。具体请参看如下代码中的 maxABS1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxABS1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLeft</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxRight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        maxLeft = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j != i + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            maxLeft = Math.max(arr[j], maxLeft);</span><br><span class="line">        &#125;</span><br><span class="line">        maxRight = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j != arr.length; j++) &#123;</span><br><span class="line">            maxRight = Math.max(arr[j], maxRight);</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(Math.abs(maxLeft - maxRight), res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：时间复杂度为 O(N)，额外空间复杂度为 O(N)。使用预处理数组的方法，先从左到右遍历一次生成 lArr，lArr[i] 表示 arr[0..i] 中的最大值。再从右到左遍历一次生成 rArr，rArr[i] 表示 arr[i..N-1] 中的最大值。最后一次遍历看哪种划分的情况下可以得到两部分最大的相减的绝对值，因为预处理数组已经保存了所有划分的 max 值，所以过程得到了加速。具体请参看如下代码中的 maxABS2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxABS2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] lArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="type">int</span>[] rArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    lArr[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    rArr[arr.length - <span class="number">1</span>] = arr[arr.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        lArr[i] = Math.max(lArr[i - <span class="number">1</span>], arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">2</span>; i &gt; -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        rArr[i] = Math.max(rArr[i + <span class="number">1</span>], arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        max = Math.max(max, Math.abs(lArr[i] - rArr[i + <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法三：最优解，时间复杂度为 O(N)，额外空间复杂度为 O(1)。先求整个 arr 的最大值 max，因为 max 是全局最大值，所以不管怎么划分，max 要么会成为左部分的最大值，要么会成为右部分的最大值。如果 max 作为左部分的最大值，接下来只要让右部分的最大值尽量小就可以。右部分的最大值怎么尽量小呢？右部分只含有 arr[N-1] 的时候就是尽量小的时候。同理，如果 max 作为右部分的最大值，只要让左部分的最大值尽量小就可以，左部分只含有 arr[0] 的时候就是尽量小的时候。所以整个求解过程会变得异常简单。具体请参看如下代码中的 maxABS3 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxABS3</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        max = Math.max(arr[i], max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max - Math.min(arr[<span class="number">0</span>], arr[arr.length - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="设计-LRU-缓存结构"><a href="#设计-LRU-缓存结构" class="headerlink" title="设计 LRU 缓存结构"></a>设计 LRU 缓存结构</h2><p>【题目】</p>
<p>设计 LRU 缓存结构，该结构在构造时确定大小，假设大小为 K，并有如下两个功能。</p>
<ul>
<li>set(key,value)：将记录 (key,value) 插入该结构。</li>
<li>get(key)：返回 key 对应的 value 值。</li>
</ul>
<p>【要求】</p>
<ol>
<li>set 和 get 方法的时间复杂度为 O(1)。</li>
<li>某个 key 的 set 或 get 操作一旦发生，认为这个 key 的记录成了最常使用的。</li>
<li>当缓存的大小超过 K 时，移除最不经常使用的记录，即 set 或 get 最久远的。</li>
</ol>
<p>【举例】</p>
<p>假设缓存结构的实例是 cache，大小为 3，并依次发生如下行为：</p>
<ol>
<li>cache.set(“A”,1)。最常使用的记录为(“A”,1)。</li>
<li>cache.set(“B”,2)。最常使用的记录为(“B”,2)，(“A”,1)变为最不常使用的。</li>
<li>cache.set(“C”,3)。最常使用的记录为(“C”,3)，(“A”,1)还是最不常使用的。</li>
<li>cache.get(“A”)。最常使用的记录为(“A”,1)，(“B”,2)变为最不常使用的。</li>
<li>cache.set(“D”,4)。大小超过了 3，所以移除此时最不常使用的记录(“B”,2)，加入记录(“D”,4)，并且为最常使用的记录，然后(“C”,2)变为最不常使用的记录。</li>
</ol>
<p>【解答】</p>
<p>这种缓存结构可以由双端队列与哈希表相结合的方式实现。首先实现一个基本的双向链表节点的结构，请参看如下代码中的 Node 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> V value;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;V&gt; last;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(V value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据双向链表节点结构 Node，实现一种双向链表结构 NodeDoubleLinkedList，在该结构中优先级最低的节点是 head (头)，优先级最高的节点是 tail (尾)。这个结构有以下三种操作。</p>
<ul>
<li>当加入一个节点时，将新加入的节点放在这个链表的尾部，并将这个节点设置为新的尾部，参见如下代码中的 addNode 方法。</li>
<li>对这个结构中的任意节点，都可以分离出来并放到整个链表的尾部，参见如下代码中的 moveNodeToTail 方法。</li>
<li>移除 head 节点并返回这个节点，然后将 head 设置成老 head 节点的下一个，参见如下代码中的 removeHead 方法。</li>
</ul>
<p>NodeDoubleLinkedList 结构全部实现如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NodeDoubleLinkedList</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;V&gt; head;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NodeDoubleLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.tail = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Node&lt;V&gt; newNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newNode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.head = newNode;</span><br><span class="line">            <span class="built_in">this</span>.tail = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.tail.next = newNode;</span><br><span class="line">            newNode.last = <span class="built_in">this</span>.tail;</span><br><span class="line">            <span class="built_in">this</span>.tail = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveNodeToTail</span><span class="params">(Node&lt;V&gt; node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.tail == node) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.head == node) &#123;</span><br><span class="line">            <span class="built_in">this</span>.head = node.next;</span><br><span class="line">            <span class="built_in">this</span>.head.last = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.last.next = node.next;</span><br><span class="line">            node.next.last = node.last;</span><br><span class="line">        &#125;</span><br><span class="line">        node.last = <span class="built_in">this</span>.tail;</span><br><span class="line">        node.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.tail.next = node;</span><br><span class="line">        <span class="built_in">this</span>.tail = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node&lt;V&gt; <span class="title function_">removeHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;V&gt; res = <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="built_in">this</span>.tail) &#123;</span><br><span class="line">            <span class="built_in">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.tail = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.head = res.next;</span><br><span class="line">            res.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.head.last = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后实现最终的 LRU 缓存结构。如何把记录之间按照“访问经常度”来排序，就是上文提到的 NodeDoubleLinkedList 结构。一旦加入新的记录，就把该记录加到 NodeDoubleLinkedList 的尾部 (addNode)。一旦获得 (get) 或设置 (set) 一个记录的 key，就将这个 key 对应的 node 在 NodeDoubleLinkedList 中调整到尾部 (moveNodeToTail)。一旦 cache 满了，就删除“最不常使用”的记录，也就是移除 NodeDoubleLinkedList 的当前头部 (removeHead)。<br>为了能让每一个 key 都能找到在 NodeDoubleLinkedList 所对应的节点，同时让每一个 node 都能找到各自的 key，我们还需要两个 map 分别记录 key 到 node 的映射，以及 node 到 key 的映射，就是如下 MyCache 结构中的 keyNodeMap 和 nodeKeyMap。具体实现请参看如下代码中的 MyCache 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCache</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;K, Node&lt;V&gt;&gt; keyNodeMap;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Node&lt;V&gt;, K&gt; nodeKeyMap;</span><br><span class="line">    <span class="keyword">private</span> NodeDoubleLinkedList&lt;V&gt; nodeList;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;should be more than 0.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.keyNodeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;K, Node&lt;V&gt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.nodeKeyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node&lt;V&gt;, K&gt;();</span><br><span class="line">        <span class="built_in">this</span>.nodeList = <span class="keyword">new</span> <span class="title class_">NodeDoubleLinkedList</span>&lt;V&gt;();</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.keyNodeMap.containsKey(key)) &#123;</span><br><span class="line">            Node&lt;V&gt; res = <span class="built_in">this</span>.keyNodeMap.get(key);</span><br><span class="line">            <span class="built_in">this</span>.nodeList.moveNodeToTail(res);</span><br><span class="line">            <span class="keyword">return</span> res.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.keyNodeMap.containsKey(key)) &#123;</span><br><span class="line">            Node&lt;V&gt; node = <span class="built_in">this</span>.keyNodeMap.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">            <span class="built_in">this</span>.nodeList.moveNodeToTail(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;V&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;V&gt;(value);</span><br><span class="line">            <span class="built_in">this</span>.keyNodeMap.put(key, newNode);</span><br><span class="line">            <span class="built_in">this</span>.nodeKeyMap.put(newNode, key);</span><br><span class="line">            <span class="built_in">this</span>.nodeList.addNode(newNode);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.keyNodeMap.size() == <span class="built_in">this</span>.capacity + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.removeMostUnusedCache();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeMostUnusedCache</span><span class="params">()</span> &#123;</span><br><span class="line">        Node&lt;V&gt; removeNode = <span class="built_in">this</span>.nodeList.removeHead();</span><br><span class="line">        <span class="type">K</span> <span class="variable">removeKey</span> <span class="operator">=</span> <span class="built_in">this</span>.nodeKeyMap.get(removeNode);</span><br><span class="line">        <span class="built_in">this</span>.nodeKeyMap.remove(removeNode);</span><br><span class="line">        <span class="built_in">this</span>.keyNodeMap.remove(removeKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LFU-缓存结构设计"><a href="#LFU-缓存结构设计" class="headerlink" title="LFU 缓存结构设计"></a>LFU 缓存结构设计</h2><p>【题目】</p>
<p>一个缓存结构需要实现如下功能。</p>
<ul>
<li>void set(int key, int value): 加入或修改 key 对应的 value。</li>
<li>int get(int key): 查询 key 对应的 value 值。</li>
</ul>
<p>但是缓存中最多放 K 条记录，如果新的第 K+1 条记录要加入，就需要根据策略删掉一条记录，然后才能把新记录加入。这个策略为：在缓存结构的 K 条记录中，哪一个 key 从进入缓存结构的时刻开始，被调用 set 或 get 的次数最少，就删掉这个 key 的记录；如果调用次数最少的 key 有多个，上次调用发生最早的 key 被删除。<br>这就是 LFU 缓存替换算法。实现这个结构，K 作为参数给出。</p>
<p>【要求】</p>
<p>set 和 get 方法的时间复杂度为 O(1)。</p>
<p>【解答】</p>
<p>整体结构设计成发生 set 和 get 操作次数一样的 key，都放在一个双向链表里（桶）。对于不同的操作次数，分别设置桶，然后桶和桶之间按照操作次数从小到大串起来，桶和桶之间也看作是一个双向链表。<br>当某一个 key 发生 set 和 get 时，来到 key 所在的位置，把 key 从原来的桶中去掉，也就是 key 的上一个节点和下一个节点之间直接相连。然后把 key 扔到次数+1 之后的桶中，如果没有次数+1 的桶就新建，保证桶之间依然是双向链表的链接；如果已经有次数+1 的桶，就把 key 放在这个桶的头部。如果 key 原来所在的桶中只有 key 这一个记录，就删掉原来的桶，保证桶之间依然是双向链表的链接。</p>
<p>直观感觉本题并不难，就是桶和桶之间是双向链表，桶内部的节点之间也是双向链表，当一个节点发生了 set 或 get 操作，就从自己的桶里出来，然后进入到次数+1 的下一个桶中。难点在于实现代码时，需要维系桶之间、节点之间始终是双向链表这个关系。当你的记录已经达到 K 条，又有新的节点进来时，就需要删掉一个节点，删除最左边的桶的尾节点即可。删除节点的操作同样需要维持桶之间、节点之间始终是双向链表这个关系。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点的数据结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Integer key;</span><br><span class="line">    <span class="keyword">public</span> Integer value;</span><br><span class="line">    <span class="keyword">public</span> Integer times; <span class="comment">// 这个节点发生 get 或者 set 的次数总和</span></span><br><span class="line">    <span class="keyword">public</span> Node up; <span class="comment">// 节点之间是双向链表，所以有一个上节点</span></span><br><span class="line">    <span class="keyword">public</span> Node down;<span class="comment">// 节点之间是双向链表，所以有一个下节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value, <span class="type">int</span> times)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.times = times;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 桶结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NodeList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node head; <span class="comment">// 桶的头节点</span></span><br><span class="line">    <span class="keyword">public</span> Node tail; <span class="comment">// 桶的尾节点</span></span><br><span class="line">    <span class="keyword">public</span> NodeList last; <span class="comment">// 桶之间是双向链表，所以有前一个桶</span></span><br><span class="line">    <span class="keyword">public</span> NodeList next; <span class="comment">// 桶之间是双向链表，所以有后一个桶</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NodeList</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        head = node;</span><br><span class="line">        tail = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把一个新的节点加入这个桶，新的节点都放在顶端变成新的头部</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNodeFromHead</span><span class="params">(Node newHead)</span> &#123;</span><br><span class="line">        newHead.down = head;</span><br><span class="line">        head.up = newHead;</span><br><span class="line">        head = newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断这个桶是不是空的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除 node 节点并保证 node 的上下环境重新连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">            head = <span class="literal">null</span>;</span><br><span class="line">            tail = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == head) &#123;</span><br><span class="line">                head = node.down;</span><br><span class="line">                head.up = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == tail) &#123;</span><br><span class="line">                tail = node.up;</span><br><span class="line">                tail.down = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.up.down = node.down;</span><br><span class="line">                node.down.up = node.up;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node.up = <span class="literal">null</span>;</span><br><span class="line">        node.down = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总的缓存结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity; <span class="comment">// 缓存的大小限制，即 K</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size; <span class="comment">// 缓存目前有多少个节点</span></span><br><span class="line">    <span class="comment">// 表示 key(Integer) 由哪个节点 (Node) 代表</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; records;</span><br><span class="line">    <span class="comment">// 表示节点 (Node) 在哪个桶 (NodeList) 里</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Node, NodeList&gt; heads;</span><br><span class="line">    <span class="keyword">private</span> NodeList headList; <span class="comment">// 整个结构中位于最左的桶</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LFUCache</span><span class="params">(<span class="type">int</span> K)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = K;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.records = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.heads = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        headList = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// removeNodeList：刚刚减少了一个节点的桶</span></span><br><span class="line">    <span class="comment">// 这个函数的功能是，判断刚刚减少了一个节点的桶是否已经为空</span></span><br><span class="line">    <span class="comment">// 1) 如果不空，什么也不做</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 2) 如果空了，removeNodeList 还是整个缓存结构最左的桶 (headList)。</span></span><br><span class="line">    <span class="comment">// 删掉这个桶的同时也要让最左的桶变成 removeNodeList 的下一个。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 3) 如果空了，removeNodeList 不是整个缓存结构最左的桶 (headList)。</span></span><br><span class="line">    <span class="comment">// 把这个桶删除，并保证上一个桶和下一个桶之间还是双向链表的连接方式</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 函数的返回值表示刚刚减少了一个节点的桶是否已经为空，空则返回 true；不空则返回 false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">modifyHeadList</span><span class="params">(NodeList removeNodeList)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (removeNodeList.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (headList == removeNodeList) &#123;</span><br><span class="line">                headList = removeNodeList.next;</span><br><span class="line">                <span class="keyword">if</span> (headList != <span class="literal">null</span>) &#123;</span><br><span class="line">                    headList.last = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                removeNodeList.last.next = removeNodeList.next;</span><br><span class="line">                <span class="keyword">if</span> (removeNodeList.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                    removeNodeList.next.last = removeNodeList.last;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数的功能</span></span><br><span class="line">    <span class="comment">// node 这个节点的次数+1 了，这个节点原来在 oldNodeList 里。</span></span><br><span class="line">    <span class="comment">// 把 node 从 oldNodeList 删除，然后放到次数+1 的桶中</span></span><br><span class="line">    <span class="comment">// 整个过程既要保证桶之间仍然是双向链表，也要保证节点之间仍然是双向链表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(Node node, NodeList oldNodeList)</span> &#123;</span><br><span class="line">        oldNodeList.deleteNode(node);</span><br><span class="line">        <span class="comment">// preList 表示次数+1 的桶的前一个桶是谁</span></span><br><span class="line">        <span class="comment">// 如果 oldNodeList 删掉 node 之后还有节点，</span></span><br><span class="line">        <span class="comment">// oldNodeList 就是次数+1 的桶的前一个桶；</span></span><br><span class="line">        <span class="comment">// 如果 oldNodeList 删掉 node 之后空了，oldNodeList 是需要删除的，</span></span><br><span class="line">        <span class="comment">// 所以次数+1 的桶的前一个桶是 oldNodeList 的前一个</span></span><br><span class="line">        <span class="type">NodeList</span> <span class="variable">preList</span> <span class="operator">=</span> modifyHeadList(oldNodeList) ? oldNodeList.last</span><br><span class="line">                : oldNodeList;</span><br><span class="line">        <span class="comment">// nextList 表示次数+1 的桶的后一个桶是谁</span></span><br><span class="line">        <span class="type">NodeList</span> <span class="variable">nextList</span> <span class="operator">=</span> oldNodeList.next;</span><br><span class="line">        <span class="keyword">if</span> (nextList == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">NodeList</span> <span class="variable">newList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeList</span>(node);</span><br><span class="line">            <span class="keyword">if</span> (preList != <span class="literal">null</span>) &#123;</span><br><span class="line">                preList.next = newList;</span><br><span class="line">            &#125;</span><br><span class="line">            newList.last = preList;</span><br><span class="line">            <span class="keyword">if</span> (headList == <span class="literal">null</span>) &#123;</span><br><span class="line">                headList = newList;</span><br><span class="line">            &#125;</span><br><span class="line">            heads.put(node, newList);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextList.head.times.equals(node.times)) &#123;</span><br><span class="line">                nextList.addNodeFromHead(node);</span><br><span class="line">                heads.put(node, nextList);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">NodeList</span> <span class="variable">newList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeList</span>(node);</span><br><span class="line">                <span class="keyword">if</span> (preList != <span class="literal">null</span>) &#123;</span><br><span class="line">                    preList.next = newList;</span><br><span class="line">                &#125;</span><br><span class="line">                newList.last = preList;</span><br><span class="line">                newList.next = nextList;</span><br><span class="line">                nextList.last = newList;</span><br><span class="line">                <span class="keyword">if</span> (headList == nextList) &#123;</span><br><span class="line">                    headList = newList;</span><br><span class="line">                &#125;</span><br><span class="line">                heads.put(node, newList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (records.containsKey(key)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> records.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">            node.times++;</span><br><span class="line">            <span class="type">NodeList</span> <span class="variable">curNodeList</span> <span class="operator">=</span> heads.get(node);</span><br><span class="line">            move(node, curNodeList);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> headList.tail;</span><br><span class="line">                headList.deleteNode(node);</span><br><span class="line">                modifyHeadList(headList);</span><br><span class="line">                records.remove(node.key);</span><br><span class="line">                heads.remove(node);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (headList == <span class="literal">null</span>) &#123;</span><br><span class="line">                headList = <span class="keyword">new</span> <span class="title class_">NodeList</span>(node);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (headList.head.times.equals(node.times)) &#123;</span><br><span class="line">                    headList.addNodeFromHead(node);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">NodeList</span> <span class="variable">newList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeList</span>(node);</span><br><span class="line">                    newList.next = headList;</span><br><span class="line">                    headList.last = newList;</span><br><span class="line">                    headList = newList;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            records.put(key, node);</span><br><span class="line">            heads.put(node, headList);</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!records.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> records.get(key);</span><br><span class="line">        node.times++;</span><br><span class="line">        <span class="type">NodeList</span> <span class="variable">curNodeList</span> <span class="operator">=</span> heads.get(node);</span><br><span class="line">        move(node, curNodeList);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="设计-RandomPool-结构"><a href="#设计-RandomPool-结构" class="headerlink" title="设计 RandomPool 结构"></a>设计 RandomPool 结构</h2><p>【题目】</p>
<p>设计一种结构，在该结构中有如下三个功能。</p>
<ul>
<li>insert(key): 将某个 key 加入到该结构，做到不重复加入。</li>
<li>delete(key): 将原本在结构中的某个 key 移除。</li>
<li>getRandom(): 等概率随机返回结构中的任何一个 key。</li>
</ul>
<p>【要求】</p>
<p>Insert、delete 和 getRandom 方法的时间复杂度都是 O(1)。</p>
<p>【解答】</p>
<p>这种结构假设叫 Pool，具体实现如下：</p>
<ol>
<li>包含两个哈希表 keyIndexMap 和 indexKeyMap。</li>
<li>keyIndexMap 用来记录 key 到 index 的对应关系。</li>
<li>indexKeyMap 用来记录 index 到 key 的对应关系。</li>
<li>包含一个整数 size，用来记录目前 Pool 的大小，初始时 size 为 0。</li>
<li>执行 insert(newKey) 操作时，将 (newKey,size) 放入 keyIndexMap，将 (size,newKey) 放入 indexKeyMap，然后把 size 加 1，即每次执行 insert 操作之后 size 自增。</li>
<li>执行 delete(deleteKey) 操作时（关键步骤），假设 Pool 最新加入的 key 记为 lastKey，lastKey 对应的 index 信息记为 lastIndex。要删除的 key 为 deleteKey，对应的 index 信息记为 deleteIndex。那么先把 lastKey 的 index 信息换成 deleteKey，即在 keyIndexMap 中把记录 (lastKey,lastIndex) 变为 (lastKey,deleteIndex)，并在 indexKeyMap 中把记录 (deleteIndex,deleteKey) 变为 (deleteIndex,lastKey)。然后在 keyIndexMap 中删除记录 (deleteKey,deleteIndex)，并在 indexKeyMap 中把记录 (lastIndex,lastKey) 删除。最后 size 减 1。这么做相当于把 lastKey 放到了 deleteKey 的位置上，保证记录的 index 还是连续的。</li>
<li>进行 getRandom 操作时，根据当前的 size 随机得到一个 index，步骤 6 可保证 index 在范围 [0~size-1] 上，都对应着有效的 key，然后把 index 对应的 key 返回即可。</li>
</ol>
<p>具体请参看如下代码中的 Pool 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pool</span>&lt;K&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;K, Integer&gt; keyIndexMap;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, K&gt; indexKeyMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.keyIndexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;K, Integer&gt;();</span><br><span class="line">        <span class="built_in">this</span>.indexKeyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, K&gt;();</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.keyIndexMap.containsKey(key)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.keyIndexMap.put(key, <span class="built_in">this</span>.size);</span><br><span class="line">            <span class="built_in">this</span>.indexKeyMap.put(<span class="built_in">this</span>.size++, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.keyIndexMap.containsKey(key)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">deleteIndex</span> <span class="operator">=</span> <span class="built_in">this</span>.keyIndexMap.get(key);</span><br><span class="line">            <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> --<span class="built_in">this</span>.size;</span><br><span class="line">            <span class="type">K</span> <span class="variable">lastKey</span> <span class="operator">=</span> <span class="built_in">this</span>.indexKeyMap.get(lastIndex);</span><br><span class="line">            <span class="built_in">this</span>.keyIndexMap.put(lastKey, deleteIndex);</span><br><span class="line">            <span class="built_in">this</span>.indexKeyMap.put(deleteIndex, lastKey);</span><br><span class="line">            <span class="built_in">this</span>.keyIndexMap.remove(key);</span><br><span class="line">            <span class="built_in">this</span>.indexKeyMap.remove(lastIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * <span class="built_in">this</span>.size);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.indexKeyMap.get(randomIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并查集的实现"><a href="#并查集的实现" class="headerlink" title="并查集的实现"></a>并查集的实现</h2><p>【题目】</p>
<p>给定一个没有重复值的整型数组 arr，初始时认为 arr 中每一个数各自都是一个单独的集合。请设计一种叫 UnionFind 的结构，并提供以下两个操作。<br>1) boolean isSameSet(int a, int b): 查询 a 和 b 这两个数是否属于一个集合。<br>2) void union(int a, int b): 把 a 所在的集合与 b 所在的集合合并在一起，原本两个集合各自的元素以后都算作同一个集合。</p>
<p>【要求】</p>
<p>如果调用 isSameSet 和 union 的总次数逼近或超过 O(N)，请做到单次调用 isSameSet 或 union 方法的平均时间复杂度为 O(1)。</p>
<p>【解答】</p>
<p>符合题目功能和要求的结构就是并查集结构。并查集结构由 Bernard A. Galler 和 Michael J. Fischer 在 1964 年发明，但证明时间复杂度的过程却持续了数年之久，直到 1989 才彻底证明完毕。有兴趣的读者请阅读《算法导论》一书了解整个证明过程。本书由于篇幅所限，不再详述证明过程，这里只重点介绍并查集的结构和各种操作的细节，并实现针对二叉树结构的并查集，这是一种经常使用的高级数据结构。</p>
<p>并查集由一群集合构成，最开始时所有元素各自单独构成一个集合。比如，有一批元素 arr = {a,b,c,d,e}，开始时并查集里有 5 个小集合，a 单独构成的集合、b 单独构成的集合……e 单独构成的集合。也就是说，并查集先经历初始化的过程。那么并查集中的单个集合是什么结构呢？如果集合中只有一个元素，记为节点 a 时，如图 9-9 所示。</p>
<p>当集合中只有一个元素时，这个元素的 father 为自己，也就意味着这个集合的代表节点，因为它唯一的元素。实现记录节点 father 信息的方式有很多，本书使用哈希表来保存所有并查集中所有集合的所有元素的 father 信息，记为 fatherMap。比如，对于这个集合，在 fatherMap 中肯定有一条记录为 (节点 a(key), 节点 a(value))，表示 key 节点 father 为 value 节点。每个元素都有 father 的信息，还有另一个信息叫 rank，只有—个集合的代表节点才会有这个信息，rank 为代表节点所在集合的秩，具体含义是这个集合一共有多少元素。集合中只有一个元素时，这个元素也就是代表节点，其 rank 初始化为 1。所有代表节点的 rank 信息保存在 rankMap 中。<br>当一个集合有多个节点时，下层节点的 father 为上层节点，最上层的节点 father 指向自己，最上层的节点叫这个集合的代表节点，如图 9-10 所示。</p>
<p>在并查集中，若要查一个节点属于哪个集合，就是在查这个节点所在集合的代表节点是什么，一个节点通过 father 信息逐渐找到最上面的节点，这个节点的 father 是自己，代表整个集合。比如图 9-10 中，任何一个节点最终都找到节点 a。比如节点 g。如果另外一个节点假设为 z，找到的代表节点不是节点 a，那么可以肯定节点 g 和节点 z 不在一个集合中。通过一个节点找到所在集合代表节点的过程叫作 findFather 过程。findFather 最终会返回代表节点，但过程并不仅是单纯的查找过程，还会把整个查找路径压缩。比如，执行 findFather(g)，通过 father 逐渐向上，找到最上层节点 a 之后，会把从 a 到 g 这条路径上所有节点的 father 都设置为 a，则集合变成图 9-11 所示的样子。</p>
<p>经过路径压缩之后，路径上每个节点下次再找代表节点的时候都只需经过一次移动过程。这也是整个并查集结构设计中最重要的优化。<br>前面已经展示了并查集中的集合如何初始化，如何根据某一个节点查找所在集合的代表元素以及如何做路径压缩的过程，接下来介绍集合如何合并。首先，两个集合进行合并操作时，参数并不是两个集合，而是并查集中任意两个节点，记为 a 和 b。所以集合的合并更准确的说法是，根据 a 找到 a 所在集合的代表节点是 findFather(a)，记为 aF，根据 b 找到 b 所在集合的代表节点是 findFather(b)，记为 bF，然后用如下策略决定由哪个代表节点作为合并后大集合的代表节点。合并过程如图 9-12、图 9-13 所示。</p>
<ol>
<li>如果 aF==bF，说明 a 和 b 本身就在一个集合里，不用合并。</li>
<li>如果 aF!=bF，因为 aF 和 bF 是各自集合的代表节点，所以可以在 rankMap 中查询到 aF 的 rank 值，记为 aFrank，bF 的 rank 值记为 bFrank。根据 rank 的含义，rank 就是一个集合的节点个数。<br> 1) 如果 aFrank<bFrank，那么把 aF 的 father 设为 bF，这么做的含义是 aF 所在的集合节点数较少，所以放在了 bF 所在的集合里，同时更新 bFrank += aFrank，因为 aF 所在的集合已合并，同时删除 aF 的 rank 信息，因为 aF 不再是任何集合的代表节点。
 2) 如果 aFrank>bFrank，就把 bF 的 father 设为 aF。同时更新 aFrank += bFrank，并删除 bF 的 rank 信息，因为 bF 不再是任何集合的代表节点。<br> 3) 如果 aFrank==bFrank 那么 aF 和 bF 谁做大集合的代表都可以，但不要忘记更新 rankMap。</li>
</ol>
<p>并查集所有的代码见如下的 UnionFindSet 类实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Element</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Element</span><span class="params">(V value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFindSet</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;V, Element&lt;V&gt;&gt; elementMap;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Element&lt;V&gt;, Element&lt;V&gt;&gt; fatherMap;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Element&lt;V&gt;, Integer&gt; rankMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFindSet</span><span class="params">(List&lt;V&gt; list)</span> &#123;</span><br><span class="line">        elementMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        fatherMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        rankMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (V value : list) &#123;</span><br><span class="line">            Element&lt;V&gt; element = <span class="keyword">new</span> <span class="title class_">Element</span>&lt;V&gt;(value);</span><br><span class="line">            elementMap.put(value, element);</span><br><span class="line">            fatherMap.put(element, element);</span><br><span class="line">            rankMap.put(element, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Element&lt;V&gt; <span class="title function_">findHead</span><span class="params">(Element&lt;V&gt; element)</span> &#123;</span><br><span class="line">        Stack&lt;Element&lt;V&gt;&gt; path = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (element != fatherMap.get(element)) &#123;</span><br><span class="line">            path.push(element);</span><br><span class="line">            element = fatherMap.get(element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!path.isEmpty()) &#123;</span><br><span class="line">            fatherMap.put(path.pop(), element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameSet</span><span class="params">(V a, V b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementMap.containsKey(a) &amp;&amp; elementMap.containsKey(b)) &#123;</span><br><span class="line">            <span class="keyword">return</span> findHead(elementMap.get(a)) == findHead(elementMap.get(b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(V a, V b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementMap.containsKey(a) &amp;&amp; elementMap.containsKey(b)) &#123;</span><br><span class="line">            Element&lt;V&gt; aF = findHead(elementMap.get(a));</span><br><span class="line">            Element&lt;V&gt; bF = findHead(elementMap.get(b));</span><br><span class="line">            <span class="keyword">if</span> (aF != bF) &#123;</span><br><span class="line">                Element&lt;V&gt; big = rankMap.get(aF) &gt;= rankMap.get(bF) ? aF : bF;</span><br><span class="line">                Element&lt;V&gt; small = big == aF ? bF : aF;</span><br><span class="line">                fatherMap.put(small, big);</span><br><span class="line">                rankMap.put(big, rankMap.get(aF) + rankMap.get(bF));</span><br><span class="line">                rankMap.remove(small);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调整-0-x-区间上的数出现的概率"><a href="#调整-0-x-区间上的数出现的概率" class="headerlink" title="调整[0,x)区间上的数出现的概率"></a>调整<code>[0,x)</code>区间上的数出现的概率</h2><p>【题目】</p>
<p>假设函数 Math.random() 等概率随机返回一个在 [0,1) 范围上的数，那么我们知道，在 [0,x) 区间上的数出现的概率为 x (0&lt;x≤1)。给定一个大于 0 的整数 k，并且可以使用 Math.random() 函数，请实现一个函数依然返回在 [0,1) 范围上的数，但是在 [0,x) 区间上的数出现的概率为 x^k (0&lt;x≤1)。</p>
<p>【解答】</p>
<p>实现在区间 [0,x) 上的数返回的概率是 x^2，只调用 2 次 Math.random()，返回最大的那个数即可。即如下代码中的 randXPower2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">randXPower2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.max(Math.random(), Math.random());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释起来也很简单，如果 randXPower2 要想返回在 [0,x) 区间上的数，两次调用 Math.random() 的返回值都必须落在 [0,x) 区间上，否则会返回大于 x 的数，所以概率为 x^2。</p>
<p>同理，想让区间 [0,x) 上的数返回的概率是 x^k，只调用 k 次 Math.random()，返回最大的那个数即可。具体请参看如下代码中的 randXPowerK 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">randXPowerK</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != k; i++) &#123;</span><br><span class="line">        res = Math.max(res, Math.random());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="路径数组变为统计数组"><a href="#路径数组变为统计数组" class="headerlink" title="路径数组变为统计数组"></a>路径数组变为统计数组</h2><p>【题目】</p>
<p>给定一个路径数组 paths，表示一张图。paths[i]==j 代表城市 i 连向城市 j，如果 paths[i]==i，则表示 i 城市是首都，一张图里只会有一个首都且图中除首都指向自己之外不会有环。例如，paths=[9,1,4,9,0,4,8,9,0,1]，代表的图如图 9-14 所示。</p>
<p>由数组表示的图可以知道，城市 1 是首都，所以距离为 0，离首都距离为 1 的城市只有城市 9，首都距离为 2 的城市有城市 0、3 和 7，离首都距离为 3 的城市有城市 4 和 8，离首都距离为 4 的城市有城市 2、5 和 6。所以距离为 0 的城市有 1 座，距离为 1 的城市有 1 座，距离为 2 的城市有 3 座，距离为 3 的城市有 2 座，距离为 4 的城市有 3 座。那么统计数组 nums=[1,1,3,2,3,0,0,0,0,0]，nums[i]==j 代表距离为 i 的城市有 j 座。要求实现一个 void 类型的函数，输入一个路径数组 paths，直接在原数组上调整，使之变为 nums 数组，即 paths=[9,1,4,9,0,4,8,9,0,1] 经过这个函数处理后变成 [1,1,3,2,3,0,0,0,0,0]。</p>
<p>【要求】</p>
<p>如果 paths 长度为 N，请达到时间复杂度为 O(N)，额外空间复杂度为 O(1)。</p>
<p>【解答】</p>
<p>本题完全考查代码实现技巧，怎么在一个数组上不停地折腾且不出错是非常锻炼边界处理能力的。本书提供的解法分为两步，第一步是将 paths 数组转换为距离数组。以题目中的例子来说，paths=[9,1,4,9,0,4,8,9,0,1] 转换为 [-2,0,-4,-2,-3,-4,-4,-2,-3,-1]。转换后的 paths[i]==j 代表城市 i 距离首都的距离为 j 的绝对值。至于为什么距离数组中的值要设置为负数，在以下过程中会说明。转换成距离数组的过程如下：</p>
<ol>
<li>从左到右遍历 paths，先遍历位置 0。<br>paths[0]==9，首先令 paths[0]=-1，因为城市 0 指向城市 9，所以跳到城市 9。<br>跳到城市 9 之后，paths[9]==1，说明城市 9 下一步应该跳到城市 1，因为城市 9 是由城市 0 跳过来的，所以先令 paths[9]=0，然后跳到城市 1。<br>跳到城市 1 之后，此时 paths[1]==1，说明城市 1 是首都，停止向首都跳的过程。城市 1 是由城市 9 跳过来的，所以跳回城市 9。<br>根据之前的设置 (paths[9]==0)，我们可以知道城市 9 下一步应该跳回城市 0，在跳回之前先设置 paths[9]==-1，表示城市 9 距离为 1，然后跳回城市 0。<br>根据之前的设置 (paths[0]==-1)，我们知道城市 0 是整个过程的发起城市，所以不需要再回跳，设置 paths[0]=-2，表示城市 0 距离为 2。<br>以上在跳向首都的过程中，paths 数组有一个路径反指的过程，这是为了保证找到首都之后，能够完全跳回来。在跳回来的过程中，设置好这一路所跳城市的距离即可，此时 paths=[-2,1,4,9,0,4,8,9,0,-1]。</li>
<li>遍历到位置 1，此时 paths[1]==1，说明城市 1 是首都，令一个单独的变量 cap=1，然后不再做任何操作。</li>
<li>遍历到位置 2，paths[2]==4，先令 paths[2]=-1，因为城市 2 指向城市 4，跳到城市 4。<br>跳到城市 4 之后，paths[4]==0，说明城市 4 下一步应该跳到城市 0，因为城市 4 是由城市 2 跳过来的，所以先令 paths[4]=2，然后跳到城市 0。<br>跳到城市 0 之后，发现 paths[0]==-2，此时将距离设置为负数的作用就显现出来了，是负数标记着这是一个之前已经计算过与首都的距离的值，而不是下一跳的城市，所以向前跳的过程停止，开始跳回城市 4。<br>跳回到城市 4 之后，根据之前的设置 (paths[4]==2)，可以知道城市 4 下一步应该跳回城市 2。但先设置 paths[4]=-3，因为城市 4 跳到城市 0 之后发现 paths[0] 已经等于 -2，所以自己距离首都的距离应该再远一步，然后跳回城市 2。<br>跳回到城市 2 之后，根据之前的设置 (paths[2]==-1)，我们知道城市 2 是整个过程的发起城市，所以不需要再回跳，设置 paths[2]=-4，表示城市 2 距离为 4，此时 paths=[-2,1,-4,9,-3,4,8,9,0,-1]。</li>
<li>遍历到位置 3，paths[3]==9，先令 paths[3]=-1，因为城市 3 指向城市 9，跳到城市 9。<br>跳到城市 9 之后，发现 paths[9]==-1，说明城市 9 之前已经计算过与首都的距离，所以向前跳的过程停止，开始跳回城市 3。<br>跳回到城市 3 之后，根据之前的设置 (paths[3]==-1)，知道城市 3 是整个过程的发起城市，所以不需要再回跳，设置 paths[3]=-2 (因为之前 paths[9]==-1)。所以此时 paths=[-2,1,-4,-2,-3,4,8,9,0,-1]</li>
<li>遍历到位置 4，发现 paths[4]==-3，说明之前计算过城市 4 的值，直接继续下一步。</li>
<li>遍历到位置 5，paths[5]==4，首先令 paths[5]=-1，因为城市 5 指向城市 4，跳到城市 4。<br>跳到城市 4 之后，发现 paths[4]==-3，说明城市 4 之前已经计算过与首都的距离，所以向前跳的过程停止，跳回城市 5。<br>跳回到城市 5 之后，根据之前的设置 (paths[5]==-1)，我们知道城市 5 是整个过程的发起城市，所以不需要再回跳，设置 paths[5]=-4，此时 paths=[-2,1,-4,-2,-3,-4,8,9,0,-1]。</li>
<li>遍历到位置 6，paths[6]==8，先令 paths[6]=-1，因为城市 6 指向城市 8，跳到城市 8。<br>跳到城市 8 之后，发现 paths[8]==0，说明城市 8 下一步应该跳到城市 0，因为城市 8 是由城市 6 跳过来的，所以先令 paths[8]=6，然后跳到城市 0。<br>跳到城市 0 之后，发现 paths[0]==-2，说明城市 0 计算过了，向前跳停止，跳回城市 8。<br>跳回城市 8 之后，根据之前的设置 (paths[8]==6)，知道城市 8 下一步应该跳回城市 6，依然与步骤 1 的情况一样，通过之前 paths 数组的反指找到回去的路径。先设置 paths[8]=-3，然后跳回城市 6。<br>跳回城市 6 之后，根据之前的设置 (paths[6]==-1)，我们知道城市 6 是整个过程的发起城市，所以不需要再回跳，设置 paths[6]=-4，此时 paths=[-2,1,-4,-2,-3,-4,-4,9,-3,-1]。</li>
<li>遍历到位置 7，paths[7]==9，先令 paths[7]=-1，因为城市 7 指向城市 9，跳到城市 9。<br>跳到城市 9 之后，发现 paths[9]==-1，说明城市 9 之前已经计算过与首都的距离，所以向前跳的过程停止，跳回城市 7。<br>跳回到城市 7 之后，根据之前的设置 (paths[7]==-1)，我们知道城市 7 是整个过程的发起城市，所以不需要再回跳，设置 paths[7]=-2 (因为之前 paths[9]==-1)，此时 paths=[-2,1,-4,-2,-3,-4,-4,-2,-3,-1]</li>
<li>位置 8 和位置 9 都已经是负数，所以可知之前已经计算过，不用调整，遍历结束。</li>
<li>根据步骤 2 的 cap 变量，可知首都是城市 1，所以单独设置 paths[1]=0，此时 paths=[-2,0,-4,-2,-3,-4,-4,-2,-3,-1]。</li>
</ol>
<p>paths 数组转换为距离数组的详细过程请参看如下代码中的 pathsToDistans 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pathsToDistans</span><span class="params">(<span class="type">int</span>[] paths)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != paths.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (paths[i] == i) &#123;</span><br><span class="line">            cap = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (paths[i] &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curI</span> <span class="operator">=</span> paths[i];</span><br><span class="line">            paths[i] = -<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">preI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (paths[curI] != curI) &#123;</span><br><span class="line">                <span class="keyword">if</span> (paths[curI] &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">nextI</span> <span class="operator">=</span> paths[curI];</span><br><span class="line">                    paths[curI] = preI;</span><br><span class="line">                    preI = curI;</span><br><span class="line">                    curI = nextI;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> paths[curI] == curI ? <span class="number">0</span> : paths[curI];</span><br><span class="line">            <span class="keyword">while</span> (paths[preI] != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">lastPreI</span> <span class="operator">=</span> paths[preI];</span><br><span class="line">                paths[preI] = --value;</span><br><span class="line">                curI = preI;</span><br><span class="line">                preI = lastPreI;</span><br><span class="line">            &#125;</span><br><span class="line">            paths[preI] = --value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    paths[cap] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>paths 变成了距离数组，数组中的距离值都用负数表示，接下来进行第二步，将 paths 转换为最终想要的统计数组的过程，即 paths=[-2,0,-4,-2,-3,-4,-4,-2,-3,-1] 需要变为 [1,1,3,2,3,0,0,0,0,0]。转换过程如下：</p>
<ol>
<li>从左到右遍历 paths，遍历到位置 0，paths[0]==-2，说明距离为 2 的城市发现了 1 座。先把 paths[0] 设置为 0，表示 paths[0] 的值已经不表示城市 0 与首都的距离，表示以后可以用来统计距离为 0 的城市数量。<br>因为距离为 2 的城市发现了 1 座，所以应该设置 paths[2]=1，说明此时 paths[2] 开始表示距离 2 的城市数量，而不再是城市 2 与首都的距离。<br>在设置 paths[2] 时发现 paths[2]==-4，说明 paths[2] 在改变它的意义之前，还代表城市 2 与首都的距离为 4，所以先设置 paths[2]=1，然后设置 paths[4] 的值，因为距离 4 的城市又发现了 1 座。<br>在设置 paths[4] 时发现 paths[4]==-3，依然说明 paths[4] 在改变它的意义之前，还代表城市 4 与首都的距离为 3，所以先设置 paths[4]=1，然后设置 paths[3] 的值，因为距离 3 的城市又发现了 1 座。<br>在设置 paths[3] 时发现 paths[3]==-2，依然说明 paths[3] 在改变它的意义之前，还代表城市 3 与首都的距离为 2，所以先设置 paths[3]=1，然后设置 paths[2] 的值，因为距离 2 的城市又发现了 1 座。<br>此时 paths={0,0,1,1,1,-4,-4,-2,-3,-1}，所以在设置 paths[2] 时发现 paths[2]==1，值已经是正数，说明 paths[2] 的意义已经不代表城市 2 与首都的距离，而完全是距离为 2 的城市数量统计，所以直接令 paths[2]++，跳的过程停止，此时 paths=[0,0,2,1,1,-4,-4,-2,-3,-1]。</li>
<li>遍历到位置 1，paths[1]==0，如果是正值，可以直接忽略，因为意义已经变成城市数量统计。这里值为 0，我们也忽略，因为一张图上距离为 0 的城市只有首都，所以等全部过程完毕后单独设置距离为 0 的城市数量。</li>
<li>位置 2~位置 4 上值已经是正数，一律忽略。</li>
<li>遍历到位置 5，paths[5]==-4，说明距离为 4 的城市发现了 1 座。先把 paths[5] 设置为 0，表示 paths[5] 的值已经不表示城市 5 与首都的距离，表示以后可以用来统计距离为 5 的城市数量。此时发现 paths[4]==1，说明不需要跳，直接进行 paths[4]++ 操作，过程停止。此时 paths=[0,0,2,1,2,0,-4,-2,-3,-1]。</li>
<li>遍历位置 6~位置 8，过程与步骤 4 基本相同，处理后 paths=[0,1,3,2,3,0,0,0,0,0]。</li>
<li>单独设置 paths[0]=1，因为距离为 0 的城市只有首都。<br>此时可以说明为什么生成距离数组的时候要把值都弄成负数，因为可以标记状态来让转换成统计数组的过程变得更加顺利。距离数组转换为统计数组的过程请参看如下代码中的 distansToNums 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">distansToNums</span><span class="params">(<span class="type">int</span>[] disArr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != disArr.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> disArr[i];</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            disArr[i] = <span class="number">0</span>; <span class="comment">// 重要</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                index = -index;</span><br><span class="line">                <span class="keyword">if</span> (disArr[index] &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                    disArr[index]++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">nextIndex</span> <span class="operator">=</span> disArr[index];</span><br><span class="line">                    disArr[index] = <span class="number">1</span>;</span><br><span class="line">                    index = nextIndex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    disArr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>paths 转成距离数组的过程中，每一个城市只经历跳出去和跳回来两个过程，距离数组转成统计数组的过程也是如此。所以时间复杂度为 O(N)，整个过程没有使用额外的数据结构，只使用了有限几个变量，所以额外空间复杂度为 O(1)。全部过程请参看如下代码中的 pathsToNums 方法，这也是主方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pathsToNums</span><span class="params">(<span class="type">int</span>[] paths)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (paths == <span class="literal">null</span> || paths.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// citiesPath -&gt; distancesArray</span></span><br><span class="line">    pathsToDistans(paths);</span><br><span class="line">    <span class="comment">// distancesArray -&gt; numArray</span></span><br><span class="line">    distansToNums(paths);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="正数数组的最小不可组成和"><a href="#正数数组的最小不可组成和" class="headerlink" title="正数数组的最小不可组成和"></a>正数数组的最小不可组成和</h2><p>【题目】<br>给定一个正数数组 arr，其中所有的值都为整数，以下是最小不可组成和的概念：</p>
<ul>
<li>把 arr 每个子集内的所有元素加起来会出现很多值，其中最小的记为 min，最大的记为 max。</li>
<li>在区间[min,max]上，如果有的数不可以被 arr 某一个子集相加得到，那么其中最小的那个数是 arr 的最小不可组成和。</li>
<li>在区间[min,max]上，如果所有的数都可以被 arr 的某一个子集相加得到，那么 max+1 是 arr 的最小不可组成和。<br>请写函数返回正数数组 arr 的最小不可组成和。</li>
</ul>
<p>【举例】<br>arr=[3,2,5]。子集{2}相加产生 2 为 min，子集{3,2,5}相加产生 10 为 max。在区间[2,10]上，4、6 和 9 不能被任何子集相加得到，其中 4 是 arr 的最小不可组成和。<br>arr=[1,2,4]。子集{1}相加产生 1 为 min，子集{1,2,4}相加产生 7 为 max。在区间[1,7]上，任何数都可以被子集相加得到，所以 8 是 arr 的最小不可组成和。</p>
<p>进阶问题：如果已知正数数组 arr 中肯定有 1 这个数，是否能更快地得到最小不可组成和？</p>
<p>【解答】<br>解法一：暴力递归的方法。即收集每一个子集的累加和，存到一个哈希表里，然后从 min 开始递增检查，看哪个正数不在哈希表中，第一个不在哈希表中的正数就是结果。具体请参见如下代码中的 unformedSum1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">unformedSum1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">    process(arr, <span class="number">0</span>, <span class="number">0</span>, set); <span class="comment">// 收集所有子集的和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> min + <span class="number">1</span>; i != Integer.MIN_VALUE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!set.contains(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> sum, HashSet&lt;Integer&gt; set)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == arr.length) &#123;</span><br><span class="line">        set.add(sum);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    process(arr, i + <span class="number">1</span>, sum, set); <span class="comment">// 不包含当前数arr[i]的情况</span></span><br><span class="line">    process(arr, i + <span class="number">1</span>, sum + arr[i], set); <span class="comment">// 包含当前数arr[i]的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 arr 长度为 N，那么子集的个数为 O(2^N)，所以暴力递归方法的时间复杂度为 O(2^N)，收集子集和的过程中，递归函数 process 最多有 N 层，所以额外空间复杂度为 O(N)。</p>
<p>解法二：动态规划的方法。假设 arr 所有数的累加和为 sum。那么 arr 子集的累加和必然都在 [0,sum] 区间上。于是生成长度为 sum+1 的 boolean 型数组 dp[]，dp[j] 如果为 true，则表示 j 这个累加和能够被 arr 的子集相加得到。如果为 false，则表示不能。如果 arr[0..i] 范围上的数组成的所有子集可以累加出 k，那么 arr[0..i+1] 范围上的数组成的所有子集则必然可以累加出 k+arr[i+1]。具体过程请参看如下代码中的 unformedSum2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">unformedSum2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[sum + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> sum; j &gt;= arr[i]; j--) &#123;</span><br><span class="line">            dp[j] = dp[j - arr[i]] ? <span class="literal">true</span> : dp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> min; i != dp.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dp[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新 dp[] 时，从 arr[0..i] 的子集和状态更新到 arr[0..i+1] 的子集和状态的过程中，0~sum 的累加和都要看是否能被加出来。所以每次更新的时间复杂度为 O(sum)。子集和状态从 arr[0] 的范围增长到 arr[0..N-1]，所以更新的次数为 N。所以解法二的时间复杂度为 O(N*sum)。额外空间就是 dp[] 的长度，即额外空间复杂度为 O(N)。</p>
<p>进阶问题。如果正数数组 arr 中肯定有 1 这个数，求最小不可组成和的过程可以得到很好的优化，优化后可以做到时间复杂度为 O(NlogN)，额外空间复杂度为 O(1)。具体过程为：</p>
<ol>
<li>把 arr 排序，排序之后则必有 arr[0]==1。</li>
<li>从左往右计算每个位置 i 的 range (0&lt;=i&lt;N)。range 代表当计算到 arr[i] 时，[1,range] 区间内的所有正数都可以被 arr[0..i-1] 的某一个子集相加出来。初始时，arr[0]==1，range=0。</li>
<li>如果 arr[i]&gt;range+1。因为 arr 是有序的，所以 arr[i] 往后的数都不会出现 range+1。直接返回 range+1。如果 arr[i]&lt;=range+1。说明 [1,range+arr[i]] 区间上的所有正数都可以被 arr[0..i] 的某一个子集相加出来。所以令 range+=arr[i]，继续计算下一个位置。</li>
<li>如果所有的位置都没有出现 arr[i]&gt;range+1 的情况，直接返回 range+1。<br>步骤 1 的时间复杂度为 O(NlogN)，步骤 2~步骤 4 的时间复杂度为 O(N)。所以整个过程的时间复杂度为 O(NlogN)。额外空间复杂度为 O(1)。</li>
</ol>
<p>举例说明一下，arr=[3,8,1,2]。排序后为 [1,2,3,8]。计算开始前 range=0。<br>计算到 1 时，range 更新成 1，表示 [1,1] 区间上的正数都可以被 arr[0] 的某个子集加出来。<br>计算到 2 时，range 更新成 3，表示 [1,3] 区间上的正数都可以被 arr[0..1] 的某个子集加出来。<br>计算到 3 时，range 更新成 6，表示 [1,6] 区间上的正数都可以被 arr[0..2] 的某个子集加出来。<br>计算到 8 时，第一次出现 8&gt;range+1。此时可知 7 这个数永远不可能得到，直接返回 7。<br>具体过程请参看如下代码中的 unformedSum3 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">unformedSum3</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(arr); <span class="comment">// 把 arr 排序</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">range</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; range + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> range + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            range += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> range + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="累加出整个范围所有的数最少还需几个数"><a href="#累加出整个范围所有的数最少还需几个数" class="headerlink" title="累加出整个范围所有的数最少还需几个数"></a>累加出整个范围所有的数最少还需几个数</h2><p>【题目】<br>给定一个有序的正数数组 arr 和一个正数 range，如果可以自由选择 arr 中的数字，想累加得到 1~range 范围上所有的数，返回 arr 最少还缺几个数。</p>
<p>【举例】<br>arr = {1, 2, 3, 7}, range = 15<br>想累加得到 1~15 范围上所有的数，arr 还缺 14 这个数，所以返回 1。</p>
<p>arr = {1, 5, 7}, range = 15<br>想累加得到 1~15 范围上所有的数，arr 还缺 2 和 4，所以返回 2。</p>
<p>【解答】<br>如果没有 arr 数组，我们看看想累加得到 1~range 范围上所有的数，最少需要几个数。首先缺 1，在有了 1 之后，就可以得到 1~1 范围上的所有数；然后缺 2，有了 2 之后，就可以得到 1~3 范围上的所有数；接下来缺 4，有了 4 之后，就可以得到 1~7 范围上的所有数；接下来缺 8，有了 8 之后，就可以得到 1~15 范围上的所有数……也就是说，如果已经搞定了 1~touch 范围上的所有数，下一个缺的数就是 touch+1，有了 touch+1 之后，就可以搞定 1~touch+touch+1 范围上的所有数。随着 touch 的扩大，最终会达到或超过 range，这样就知道最少需要几个数了。举几个例子，range=15，根据上文的方法，需要 1、2、4、8 四个数；range=67，需要 1、2、4、8、16、32、64 七个数。可以看出，在没有 arr 数组的情况下，如上流程的时间复杂度为 O(log range)。</p>
<p>如果拥有一个有序的正数数组 arr，会加速上文介绍的方法。举个例子，arr={3,17,21,78}, range=67，在从左往右遍历 arr 的过程中进行如下操作：</p>
<ol>
<li>设置变量 touch，表示当前已经搞定了 1~touch 范围上的数。初始时令 touch=0，表示哪个范围也搞不定。</li>
<li>遍历到 arr[0]值为 3，当前目标为先搞定 1~2 范围上的所有数。目前 touch 为 0，所以缺 1，有了 1 之后，可以搞定 1~1 范围；然后缺 2，有了 2 之后就可以搞定 1~3 范围，完成目标。已经搞定的范围是 1~3，当前拥有的数字为 3，所以可以搞定 1~6 范围，即 touch=6。</li>
<li>遍历到 arr[1]值为 17，当前目标为先搞定 1~16 范围上的所有数。目前 touch 为 6，所以缺 7，有了 7 之后就可以搞定 1~13 范围；然后缺 14，有了 14 之后就可以搞定 1~27 范围，完成了目标。已经搞定的范围是 1~27，当前拥有的数字为 17，所以可以搞定 1~44 范围，即 touch=44。</li>
<li>遍历到 arr[2]值为 21，当前目标为先搞定 1~20 范围上的所有数，直接完成目标。已经搞定的范围是 1~44，当前拥有的数字为 21，所以可以搞定 1~65 范围，即 touch=65。</li>
<li>遍历到 arr[3]值为 78，当前目标为先搞定 1~77 范围上的所有数。目前 touch 为 65，所以缺 66，有了 66 之后可以搞定 1~131 范围，发现这时已经满足 1~67 的总目标。如上过程中，缺的数字是 1、2、7、14、66，所以返回 5。</li>
</ol>
<p>在遍历 arr 的过程中，任何时候只要 touch 达到或超过了 range，直接返回缺的数字个数；如果遍历完 arr 之后，touch 依然没有达到 range，那么最后的目标就是搞定 1~range 范围，即依次增大 touch 使之达到或超过 range 即可。整个过程中因为有 arr 所含数字的帮助，时间复杂度不会比 O(log range)高，全部过程请看如下的 minNeeds 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNeeds</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> range)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">needs</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">touch</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[i] &gt; touch + <span class="number">1</span>) &#123;</span><br><span class="line">            touch += touch + <span class="number">1</span>;</span><br><span class="line">            needs++;</span><br><span class="line">            <span class="keyword">if</span> (touch &gt;= range) &#123;</span><br><span class="line">                <span class="keyword">return</span> needs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        touch += arr[i];</span><br><span class="line">        <span class="keyword">if</span> (touch &gt;= range) &#123;</span><br><span class="line">            <span class="keyword">return</span> needs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (range &gt;= touch + <span class="number">1</span>) &#123;</span><br><span class="line">        touch += touch + <span class="number">1</span>;</span><br><span class="line">        needs++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> needs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一种字符串和数字的对应关系"><a href="#一种字符串和数字的对应关系" class="headerlink" title="一种字符串和数字的对应关系"></a>一种字符串和数字的对应关系</h2><p>【题目】<br>一个 char 类型的数组 chs，其中所有的字符都不同。<br>例如，chs=[‘A’, ‘B’, ‘C’, … ‘Z’]，则字符串与整数的对应关系如下：<br>A, B… Z, AA, AB…AZ, BA, BB…ZZ, AAA… ZZZ,    AAAA…<br>1, 2…26, 27, 28… 52, 53, 54…702, 703…18278, 18279…<br>例如，chs=[‘A’, ‘B’, ‘C’]，则字符串与整数的对应关系如下：<br>A, B, C, AA, AB…CC, AAA…CCC, AAAA…<br>1, 2, 3, 4, 5…12, 13…39, 40…<br>给定一个数组 chs，实现根据对应关系完成字符串与整数相互转换的两个函数。</p>
<p>【解答】<br>面试者在分析本题时，往往会将字符串与数字的对应关系与 K 进制数联系起来，K 指 chs 的长度，比如，第一个例子中 chs 的长度为 26。最终会发现用 K 进制数是不能实现的。下面解释一下本题的对应关系与 K 进制数不同的地方。<br>K 进制数是每一个位置上的值只能在[0,K-1]之间取值。例如，十进制数的 72，高位为 7，低位为 2。十进制数的 72 转换成三进制数的表达为“2200”，也就是 72=27x2+9x2+3x0+1x0。但是本题描述的对应方式却不是这样，我们暂时把题目描述的对应方式叫作 K 伪进制数，K 伪进制数是每一个位置上的值只能在[1,K]之间取值。以 chs=[‘A’,’B’,’C’]举例，即 3 伪进制数。如果把十进制数的 72 用这个 chs 的 3 伪进制数表示，是“BABC”，也就是 72=27x2+9x1+3x2+1x3。也就是说对 K 进制数来讲，每个位（如：27、9、3、1）上的值是可以取 0 的，但如果位上的值不为 0，也在[1,K-1]范围上。而对 K 伪进制数来讲，每个位上的值绝对不能取 0，而是必须在[1,K]之间。所以用 K 进制数的思路不能实现本题的对应关系。</p>
<p>下面解释一下本书提供的解法，先从数字如何得到字符串。还是以 chs=[‘A’,’B’,’C’]举例，以下是十进制数的 72 得到表达它的字符串的过程。</p>
<ol>
<li>chs 的长度为 3，所以这是一个 3 伪进制数，从低位到高位依次为 1, 3, 9, 27, 81…。</li>
<li>从 1 开始减，72 减去 1，剩下 71；71 减去 3，剩下 68；68 减去 9，剩下 59；59 减去 27，剩下 32；32 减去 81 时，发现不够减，此时就知道想要表达十进制数的 72，只需使用 3 伪进制数的前 4 位，也就是 27, 9, 3, 1，而不必扩到第 5 位的 81。换句话说，既然 K 伪进制数中每个位上的值都不能为 0，就从低位到高位把每个位置上的值都先减去 1 遍，看这个数到底需要前几位。</li>
<li>步骤 2 剩下的数是 32，同时前四位的值已经使用了 1 次，即 72 - 32 = 40 = 27x1 + 9x1 + 3x1 + 1x1 = “AAAA”。接下来看剩下的 32 最多可以用几个 27？最多用 1 个 (32/27=1)，再算上之前的一个 27，一共 2 个 27 (B)。32%27 的结果是 5，这表示让 32 减去尽量多的 27 而剩下来的数。然后看 5 最多可以用几个 9，一个也用不了，再算上之前的一个 9，一共要 1 个 9(A)。5%9=5，接下来看 5 最多可以用几个 3，1 个，再算上之前的一个 3，一共要 2 个 3 (B)。5%3=2，最后看 2 最多可以用几个 1，2 个，算上之前的一个 1，一共 3 个 1 (C)。所以结果是”BABC”。</li>
</ol>
<p>上文所描述的 K 伪进制数虽然和 K 进制数不同，但是把十进制数转换成 K 伪进制数的过程却和把十进制数转换成 K 进制数的过程相似。具体说来，步骤 2 中是从低位到高位看一个数 N 最多用几个 K 伪进制数的位，时间复杂度为 O(logN)（以 K 为底），步骤 3 是从高位到低位反着回去看每个位上的值最多是多少，时间复杂度也是 O(logN)（以 K 为底），K 为 chs 的长度。所以以上过程的时间复杂度为 O(logN)（以 chs 的长度为底）。<br>数字到字符串的全部过程请参看如下代码中的 getString 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getString</span><span class="params">(<span class="type">char</span>[] chs, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (chs == <span class="literal">null</span> || chs.length == <span class="number">0</span> || n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> chs.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= cur) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        n -= cur;</span><br><span class="line">        cur *= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] res = <span class="keyword">new</span> <span class="title class_">char</span>[len];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nCur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        cur /= base;</span><br><span class="line">        nCur = n / cur;</span><br><span class="line">        res[index++] = getKthCharAtChs(chs, nCur + <span class="number">1</span>);</span><br><span class="line">        n %= cur;</span><br><span class="line">    &#125; <span class="keyword">while</span> (index != res.length);</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getKthCharAtChs</span><span class="params">(<span class="type">char</span>[] chs, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">1</span> || k &gt; chs.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> chs[k - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来介绍如何通过字符串得到对应的数字。其实如果理解了 K 伪进制数的含义，算出字符串对应的数字就十分容易了。例如，chs=[‘A’,’B’,’C’]，字符串是”ABBA”，可以知道这个字符串的含义是 27 有 1 个，9 有 2 个，3 有 2 个，1 有 1 个。所以对应的数字是 52。具体过程请参看如下代码中的 getNum 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">(<span class="type">char</span>[] chs, String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (chs == <span class="literal">null</span> || chs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] strc = str.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> chs.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> strc.length - <span class="number">1</span>; i != -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        res += getNthFromChar(chs, strc[i]) * cur;</span><br><span class="line">        cur *= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNthFromChar</span><span class="params">(<span class="type">char</span>[] chs, <span class="type">char</span> ch)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != chs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chs[i] == ch) &#123;</span><br><span class="line">            res = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-到-n-中-1-出现的次数"><a href="#1-到-n-中-1-出现的次数" class="headerlink" title="1 到 n 中 1 出现的次数"></a>1 到 n 中 1 出现的次数</h2><p>【题目】<br>给定一个整数 n，返回从 1 到 n 的数字中 1 出现的个数。<br>例如：<br>n=5，1~n 为 1, 2, 3, 4, 5。那么 1 出现了 1 次，所以返回 1。<br>n=11，1~n 为 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11。那么 1 出现的次数为 1(出现 1 次)，10(出现 1 次)，11(有两个 1，所以出现了 2 次)，所以返回 4。</p>
<p>【解答】<br>方法一：容易理解但是复杂度较高的方法，即逐一考查 1~n 的每一个数里有多少个 1。具体请参看如下代码中的 solution1 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution1</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i != num + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        count += get1Nums(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get1Nums</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">10</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>十进制整数 N 有 logN 位（以 10 为底），所以考查一个整数含有多少个 1 的代价是 O(logN)，一共需要考查 N 个数，所以方法一的时间复杂度为 O(NlogN)（以 10 为底）。</p>
<p>方法二：不再依次考查每一个数，而是分析 1 出现的规律。<br>先看 n，如果只有 1 位的情况，因为 1~9 的数中，1 只出现 1 次，所以，如果 n 只有 1 位时，返回 1。接下来以 n=114 为例来介绍方法二。先不看 1~14 之间出现了多少个 1，而是先求出 15~114 的数之间一共出现了多少个 1。15~114 之间，哪些数百位上能出现 1 呢？毫无疑问，100~114 这些数百位上才有 1，所以百位上的 1 出现的次数为 15 个，即 114%100+1。15~114 之间，哪些数十位上有 1 呢？110, 111, 112, 113, 114, 15, 16, 17, 18, 19。这些数的十位上才有 1，一共 10 个。15~114 之间，哪些数个位上有 1 呢？101, 111, 21, 31, 41, 51, 61, 71, 81, 91。这些数的个位上才有 1，一共 10 个。<br>所以，观察发现如下规律：</p>
<ol>
<li>若十位上固定是 1，个位从 0 变到 9 都是可以的。</li>
<li>若个位上固定是 1，十位从 0 变到 9 都是可以的。</li>
<li>无非就是最高位取值跟着变化，使构成的数落在 15~114 区间上即可。<br>所以，15~114 之间的数在十位和个位上 1 的数量为 10+10=20=1x2x10，即 (最高位的数字) x (除去最高位后剩下的位数) x (某一位固定是 1 的情况下，剩下的 1 位数都可以从 0 到 9 自由变化，所以是 10 的 1 次方)。这样就求出了 15~114 之间 1 的个数，然后 1~14 的数字上出现 1 的个数可以按照如上方式递归求解。</li>
</ol>
<p>再举一例，n=21345。先不看 1~1345 之间出现了多少个 1，而是先求出 1346~21345 的数之间一共出现了多少个 1。1346~21345 之间，哪些数万位上能出现 1 呢？毫无疑问，10000~19999 这些数百位上都有 1，所以百位上的 1 出现的次数为 10000 个。与上一例不同的是，上一例 n 的最高位是 1，而这里大于 1。如果像上例那样最高位的数字等于 1，那么最高位上 1 的数量=除去最高位后剩下的数+1。而如果像本例那样最高位的数字大于 1，那么最高位上 1 的数量=10000=10^(k-1) (k 为 n 的位数，本例中 k 为 5)。1346~21345 之间，哪些数千位上有 1 呢？在 1346~11345 范围上，若千位上固定是 1，百位、十位和个位可自由从 0~9 变换，10^3 个，在 11346~21345 范围上，若千位上固定是 1，百位、十位、个位可自由从 0~9 变换，10^3 个，所以有 2x10^3 个千位上是 1。哪些数百位上有 1 呢？在 1346~11345 范围上，若百位上固定是 1，千位、十位、个位可自由从 0~9 变换，10^3 个，在 11346~21345 范围上，若百位上固定是 1，千位、十位、个位可自由从 0~9 变换，10^3 个，所以有 2x10^3 个百位上是 1。十位和个位也是一样的情况，所以千位、百位、十位、个位是 1 的总数量= 2x4x10^3，即 (最高位的数字) x (除去最高位后剩下的位数) x (某一位固定是 1 的情况下，剩下的 3 位数都可以从 0 到 9 自由变化，所以是 10^3)。这样就求出了 1346~21345 之间 1 的个数，然后 1~1345 的数字上出现 1 的个数可以按照如上方式递归求解。<br>具体过程请参看如下代码中的 solution2 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution2</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> getLenOfNum(num);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp1</span> <span class="operator">=</span> powerBaseOf10(len - <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> num / tmp1;</span><br><span class="line">    <span class="type">int</span> <span class="variable">firstOneNum</span> <span class="operator">=</span> first == <span class="number">1</span> ? num % tmp1 + <span class="number">1</span> : tmp1;</span><br><span class="line">    <span class="type">int</span> <span class="variable">otherOneNum</span> <span class="operator">=</span> first * (len - <span class="number">1</span>) * (tmp1 / <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> firstOneNum + otherOneNum + solution2(num % tmp1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLenOfNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">powerBaseOf10</span><span class="params">(<span class="type">int</span> base)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) Math.pow(<span class="number">10</span>, base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仅通过分析如上代码就可以知道，n 一共有多少位，递归函数最多就会被调用多少次，即 logN 次。在递归函数内部 getLenOfNum 方法和 powerBaseOf10 方法的复杂度分别为 O(logN) 和 O(log(logN))。求一个数的 A 次方的问题在系统内部实现的复杂度为 O(logA)，A 为 N 的位数 (A=logN)，所以 powerBaseOf10 方法的时间复杂度为 O(log(logN))。所以方法二的总时间复杂度为 O(logN x logN)。</p>
<h2 id="从-N-个数中等概率打印-M-个数"><a href="#从-N-个数中等概率打印-M-个数" class="headerlink" title="从 N 个数中等概率打印 M 个数"></a>从 N 个数中等概率打印 M 个数</h2><p>【题目】<br>给定一个长度为 N 且没有重复元素的数组 arr 和一个整数 n，实现函数等概率随机打印 arr 中的 M 个数。</p>
<p>【要求】</p>
<ol>
<li>相同的数不要重复打印。</li>
<li>时间复杂度为 O(M)，额外空间复杂度为 O(1)。</li>
<li>可以改变 arr 数组。</li>
</ol>
<p>【解答】<br>如果没有空间复杂度的限制，可以用哈希表标记一个数之前是否被打印过，就可以做到不重复打印。解法的关键点是利用要求 3 改变数组 arr。打印过程如下：</p>
<ol>
<li>在[0,N-1]中随机得到一个位置 a，然后打印 arr[a]。</li>
<li>把 arr[a]和 arr[N-1]交换。</li>
<li>在[0,N-2]中随机得到一个位置 b，然后打印 arr[b]，因为打印过的 arr[a]已被换到了 N-1 位置，所以这次打印不可能再次出现。</li>
<li>把 arr[b]和 arr[N-2]交换。</li>
<li>在[0,N-3]中随机得到一个位置 c，然后打印 arr[c]，因为打印过的 arr[a]和 arr[b]已被换到了 N-1 位置和 N-2 位置，所以这次打印都不可能再出现。</li>
<li>依此类推，直到打印 M 个数。</li>
</ol>
<p>总之，就是把随机选出来的数打印出来，然后将打印的数交换到范围中的最后位置，再把范围缩小，使得被打印的数下次不可能再被选中，直到打印结束。很多有关等概率随机的面试题都是用这种与最后一个位置交换的解法，希望这种小技巧能引起读者重视。具体过程请参看如下代码中的 printRandM 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printRandM</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || m &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m = Math.min(arr.length, m);</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; m) &#123;</span><br><span class="line">        i = (<span class="type">int</span>) (Math.random() * (arr.length - count));</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">        swap(arr, arr.length - count++ - <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断一个数是否是回文数"><a href="#判断一个数是否是回文数" class="headerlink" title="判断一个数是否是回文数"></a>判断一个数是否是回文数</h2><p>【题目】<br>定义回文数的概念如下：</p>
<ul>
<li>如果一个非负数左右完全对应，则该数是回文数，例如：121，22 等。</li>
<li>如果一个负数的绝对值左右完全对应，也是回文数，例如：-121，-22 等。<br>给定一个 32 位整数 num，判断 num 是否是回文数。</li>
</ul>
<p>【解答】<br>本题的实现方法当然有很多种，本书介绍一种仅用一个整型变量就可以实现的方法，步骤如下：</p>
<ol>
<li>假设判断的数字为非负数 n，先生成变量 help，开始时 help=1。</li>
<li>用 help 不停地乘以 10，直到变得与 num 的位数一样。例如：num 等于 123321 时，help 就是 100000。num 如果是 131，help 就是 100。总之，让 help 与 num 的位数一样。</li>
<li>num/help 的结果就是最高位的数字，num%10 就是最低位的数字，比较这两个数字，不相同则直接返回 false。相同则令 num=(num%help)/10，即 num 变成除去最高位和最低位两个数字之后的值。令 help/=100，即让 help 变得继续和新的 num 位数一样。</li>
<li>如果 num==0，表示所有的数字都已经对应判断完，返回 true，否则重复步骤 3。<br>上述方法就是让 num 每次剥掉最左和最右两个数，然后逐渐完成所有对应的判断。需要注意的是，如上方法只适用于非负数的判断，如果 n 为负数，则先把 n 变成其绝对值，然后用上面的方法进行判断。同时还需注意，32 位整数中的最小值为-2147483648，它是转不成相应的绝对值的，可这个数很明显不是回文数。所以，如果 n 为-2147483648，直接返回 false。具体过程请参看如下代码中的 isPalindrome 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == Integer.MIN_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n = Math.abs(n);</span><br><span class="line">    <span class="type">int</span> <span class="variable">help</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n / help &gt;= <span class="number">10</span>) &#123; <span class="comment">// 防止 help 溢出</span></span><br><span class="line">        help *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n / help != n % <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n = (n % help) / <span class="number">10</span>;</span><br><span class="line">        help /= <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在有序旋转数组中找到最小值"><a href="#在有序旋转数组中找到最小值" class="headerlink" title="在有序旋转数组中找到最小值"></a>在有序旋转数组中找到最小值</h2><p>【题目】<br>有序数组 arr 可能经过一次旋转处理，也可能没有，且 arr 可能存在重复的数。例如，有序数组[1,2,3,4,5,6,7]，可以旋转处理成[4,5,6,7,1,2,3]等。给定一个可能旋转过的有序数组 arr，返回 arr 中的最小值。</p>
<p>【解答】<br>为了方便描述，我们把没经过旋转前有序数组 arr 最左边的数在经过旋转之后所处的位置叫作“断点”。例如，题目例子里的数组，旋转后断点在 1 所处的位置，也就是位置 4。如果没有经过旋转处理，断点在位置 0。那么只要找到断点，就找到了最小值。</p>
<p>本书提供的方式做到了尽可能多地利用二分查找，但是最差情况下仍无法避免 O(N)的时间复杂度。我们假设目前想在 arr[low..high]范围上找到这个范围的最小值（那么初始时 low==0, high==arr.length-1)，以下是具体过程：</p>
<ol>
<li>如果 arr[low]&lt;arr[high]，说明 arr[low..high]上没有旋转，断点就是 arr[low]，返回 arr[low]即可。</li>
<li>令 mid=(low+high)/2，mid 即 arr[low..high]中间的位置。<br>1) 如果 arr[low]&gt;arr[mid]，说明断点一定在 arr[low..mid]上，则令 high=mid，然后回到步骤 1。<br>2) 如果 arr[mid]&gt;arr[high]，说明断点一定在 arr[mid..high]上，令 low=mid，然后回到步骤 1。</li>
<li>如果步骤 1 和步骤 2 的逻辑都没有命中，说明什么呢？步骤 1 没有命中说明 arr[low]&gt;=arr[high]，步骤 2 的 1) 没有命中说明 arr[low]&lt;=arr[mid]，步骤 2 的 2) 没有命中说明 arr[mid]&lt;=arr[high]。此时只有一种情况，也就是 arr[low]==arr[mid]==arr[high]。面对这种情况根本无法判断断点的位置在哪里，很多书籍在面对这种情况时都选择直接遍历 arr[low..high]的方法找出断点。但其实还是可以继续为二分创造条件，生成变量 i，初始时令 i=low，开始向右遍历 arr(i++)，那么会有以下三种情况：<ul>
<li>情况 1：遍历到某个位置时发现 arr[low]&gt;arr[i]，那么 arr[i]就是断点处的值，因为在 arr 中发现的降序必然是断点，所以直接返回 arr[i]。</li>
<li>情况 2：遍历到某个位置时发现 arr[low]<arr[i]，说明 arr[i]>arr[mid]，那么说明断点在 arr[i..mid]上。此时又可以开始二分，令 high=mid，重新回到步骤 1。</li>
<li>情况 3：如果 i==mid 都没有出现情况 1 和情况 2，说明从 arr 的 low 位置到 mid 位置，值全部都一样。那么断点只可能在 arr[mid..high]上，所以令 low=mid，进行后续的二分过程，重新回到步骤 1。</li>
</ul>
</li>
</ol>
<p>全部过程请参看如下代码中的 getMin 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (low == high - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[low] &lt; arr[high]) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[low];</span><br><span class="line">        &#125;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[low] &gt; arr[mid]) &#123;</span><br><span class="line">            high = mid;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; arr[high]) &#123;</span><br><span class="line">            low = mid;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; mid) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[low] == arr[mid]) &#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[low] &lt; arr[mid]) &#123;</span><br><span class="line">                <span class="keyword">return</span> arr[low];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(arr[low], arr[high]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在有序旋转数组中找到一个数"><a href="#在有序旋转数组中找到一个数" class="headerlink" title="在有序旋转数组中找到一个数"></a>在有序旋转数组中找到一个数</h2><p>【题目】<br>有序数组 arr 可能经过一次旋转处理，也可能没有，且 arr 可能存在重复的数。例如，有序数组[1,2,3,4,5,6,7]，可以旋转处理成[4,5,6,7,1,2,3]等。给定一个可能旋转过的有序数组 arr，再给定一个数 num，返回 arr 中是否含有 num。</p>
<p>【解答】<br>为了方便描述，我们把没经过旋转前有序数组 arr 最左边的数在经过旋转之后所处的位置叫作断点。例如，题目例子里的数组，旋转后断点在 1 所处的位置，也就是位置 4。如果一个数组没有经过旋转处理，断点在位置 0。<br>本书提供的方式做到了尽可能多地利用二分查找，但是最差情况下仍无法避免 O(N)的时间复杂度，以下是具体过程：</p>
<ol>
<li>用 low 和 high 变量表示 arr 上的一个范围，每次判断 num 是否在 arr[low..high]上，初始时，low=0，high=arr.length-1，然后进入步骤 2。</li>
<li>如果 low&gt;high，直接进入步骤 5，否则令变量 mid=(low+high)/2，也就是二分的位置。如果 arr[mid]==num，直接返回 true，否则进入步骤 3。</li>
<li>此时 arr[mid]!=num。如果发现 arr[low]、arr[mid]、arr[high]三个值不都相等，直接进入步骤 4。如果发现三个值都相等，此时根本无法知道断点的位置在 mid 的哪一侧。例如：7(low)…7(mid)…7(high)，举一个极端的例子，如果这个数组中只有一个值为 num 的数，其他的数都是 7，那么 num 除了不在 low、mid、high 这三个位置，剩下的位置都是可能的，即 num 既可能在 mid 的左边，也可能在右边。所以进行如下处理：<br>1) 只要 arr[low]等于 arr[mid]，就让 low 不断地向右移动 (low++)，如果在 low 移到 mid 的期间，都没有发现 arr[low]和 arr[mid]不等的情况，说明 num 只可能在 mid 的右侧，因为左侧全部遍历过了，此时令 low=mid+1，high 不变，进入步骤 2。<br>2) 只要 arr[low]等于 arr[mid]，就让 low 不断地向右移动 (low++)，如果移动期间一旦发现 arr[low]和 arr[mid]不等，说明在此时的 arr[low(递增后的)..mid..right]上是可以判断出断点位置的，则进入步骤 4。</li>
<li>此时 arr[mid]!=num，并且 arr[low]、arr[mid]、arr[high]三个值不都相等，那么是一定可以二分的，具体判断如下：<br>如果 arr[low]!=arr[mid]，如何判断断点位置呢？分以下两种情况。<br>情况一：arr[mid]&gt;arr[low]，断点一定在 mid 的右侧，此时 arr[low..mid]上有序。<br>1) 如果 num&gt;=arr[low]&amp;&amp;num<arr[mid]，说明 num 只需要在 arr[low..mid]上寻找。这是因为，如果 num==arr[low]&&num<arr[mid]。很显然，在 arr[low..mid]上能找到 num。如果 num>arr[low]&amp;&amp;num<arr[mid]，则说明断点在右侧，假设断点在 mid 和 high 之间的 break 位置上，那么 arr[mid..break-1]上的值都大于或等于 arr[mid]，也都大于 num，arr[break..high]上的值都小于或等于 arr[low]，也都小于 num，所以整个 mid 的右侧都没有 num。综上所述，num 只需要在 arr[low..mid]上寻找，令 high=mid-1，进入步骤 2。
2) 若不满足条件 1)，说明要么 num<arr[low]，此时整个 arr[low..mid]上都大于 num。要么 num>arr[mid]，此时整个 arr[low..mid]上都小于 num。无论是哪种，num 都只可能出现在 mid 的右侧，所以令 low=mid+1，进入步骤 2。<br>情况二：不满足情况一则断点一定在 mid 位置或在 mid 左侧，不管哪一种，arr[mid..high]都一定是有序的。<br>1) 如果 num&gt;arr[mid]&amp;&amp;num&lt;=arr[high]与情况一的条件 1) 相同的分析方式，令 low=mid+1，进入步骤 2。<br>2) 若不满足条件 1)，与情况一的条件 2) 相同的分析方式，令 high=mid-1，进入步骤 2。<br>如果 arr[mid]!=arr[high]，如何判断断点的位置呢？和 arr[low]!=arr[mid]时一样的分析方式，这里不再详述。</li>
<li>如果 low 在 high 的右边 (low&gt;high)，说明 arr 中没有 num，返回 false。<br>全部过程请参看如下代码中的 isContains 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isContains</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[low] == arr[mid] &amp;&amp; arr[mid] == arr[high]) &#123;</span><br><span class="line">            <span class="keyword">while</span> (low != mid &amp;&amp; arr[low] == arr[mid]) &#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (low == mid) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[low] != arr[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; arr[low]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &gt;= arr[low] &amp;&amp; num &lt; arr[mid]) &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; arr[mid] &amp;&amp; num &lt;= arr[high]) &#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &lt; arr[high]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; arr[mid] &amp;&amp; num &lt;= arr[high]) &#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &gt;= arr[low] &amp;&amp; num &lt; arr[mid]) &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数字的英文表达和中文表达"><a href="#数字的英文表达和中文表达" class="headerlink" title="数字的英文表达和中文表达"></a>数字的英文表达和中文表达</h2><p>【题目】<br>给定一个 32 位整数 num，写两个函数分别返回 num 的英文与中文表达字符串。</p>
<p>【举例】</p>
<ul>
<li>num=319<ul>
<li>英文: Three Hundred Nineteen</li>
<li>中文: 三百一十九</li>
</ul>
</li>
<li>num=1014<ul>
<li>英文: One Thousand, Fourteen</li>
<li>中文: 一千零十四</li>
</ul>
</li>
<li>num=-2147483648<ul>
<li>英文: Negative, Two Billion, One Hundred Forty Seven Million, Four Hundred Eighty Three Thousand, Six Hundred Forty Eight</li>
<li>中文: 负二十一亿四千七百四十八万三千六百四十八</li>
</ul>
</li>
<li>num=0<ul>
<li>英文: Zero</li>
<li>中文: 零</li>
</ul>
</li>
</ul>
<p>【解答】<br>本题的重点是考查面试者分析业务场景并实际解决问题的能力。本题实现的方式当然是多种多样的，本书提供的方法仅是作者的实现，希望读者也能写出自己的实现。</p>
<h3 id="1-英文表达的实现"><a href="#1-英文表达的实现" class="headerlink" title="1. 英文表达的实现"></a>1. 英文表达的实现</h3><p>英文的表达是以三个数为单位成一组的，所以先解决数字 1~999 的表达问题。<br>首先看数字 1~19 的表达问题。<br>然后利用 num1To99 函数来解决数字 1~99 的表达问题。<br>有以上两个函数，再解决数字 1~999。<br>最后可以解决最终的问题，需要注意如下几种特殊情况：</p>
<ul>
<li>num 为 0 的情况要单独处理。</li>
<li>num 为负的情况，一律以处理其绝对值的方式来得到表达字符串，然后加上 “Negative, “ 的前缀，所以 num 为 Integer.MIN_VALUE 时，也是特殊情况。</li>
<li>把 32 位整数分解成十亿组、百万组、千组、1~999 组。对每个组的表达利用 num1To999 方法，再把组与组之间各自的表达字符串连接起来即可。</li>
</ul>
<h3 id="2-中文表达的实现"><a href="#2-中文表达的实现" class="headerlink" title="2. 中文表达的实现"></a>2. 中文表达的实现</h3><p>与英文表达的处理过程类似，都是由小范围的数向大范围的数扩张的过程，这个过程有不同的处理细节。<br>首先解决数字 1~9 的中文表达问题。<br>利用 num1To9 方法，我们来看看数字 1~99 如何表达。其中有一个得注意的细节，16 的表达是十六，116 的表达是一百一十六，1016 的表达可以是一千零十六，也可以是一千零一十六。这个细节说明，对 10~19 来说，如果其前一位（也就是百位）有数字，则表达该是一十~一十九。如果百位上没数字，则表达应一律规定为十~十九。<br>利用 num1To9 与 num1To99 方法后，接下来解决数字 1~999 的表达。<br>然后是数字 1~9999 的表达问题。<br>接下来是数字 1~99999999 的表达问题。<br>最后是中文表达的主方法。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberExpression</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================= 英文表达 =================</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getNumEngExp</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Zero&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            res = <span class="string">&quot;Negative, &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num == Integer.MIN_VALUE) &#123;</span><br><span class="line">            res += <span class="string">&quot;Two Billion, &quot;</span>;</span><br><span class="line">            num %= -<span class="number">2000000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num = Math.abs(num);</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">1000000000</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">highIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        String[] names = &#123; <span class="string">&quot;Billion &quot;</span>, <span class="string">&quot;Million &quot;</span>, <span class="string">&quot;Thousand &quot;</span>, <span class="string">&quot;&quot;</span> &#125;;</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> num / high;</span><br><span class="line">            num %= high;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="number">0</span>) &#123;</span><br><span class="line">                res += num1To999(cur);</span><br><span class="line">                res += names[highIndex] + (num == <span class="number">0</span> ? <span class="string">&quot; &quot;</span> : <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            high /= <span class="number">1000</span>;</span><br><span class="line">            highIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">num1To19</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1</span> || num &gt; <span class="number">19</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] names = &#123; <span class="string">&quot;One &quot;</span>, <span class="string">&quot;Two &quot;</span>, <span class="string">&quot;Three &quot;</span>, <span class="string">&quot;Four &quot;</span>, <span class="string">&quot;Five &quot;</span>, <span class="string">&quot;Six &quot;</span>,</span><br><span class="line">            <span class="string">&quot;Seven &quot;</span>, <span class="string">&quot;Eight &quot;</span>, <span class="string">&quot;Nine &quot;</span>, <span class="string">&quot;Ten &quot;</span>, <span class="string">&quot;Eleven &quot;</span>, <span class="string">&quot;Twelve &quot;</span>,</span><br><span class="line">            <span class="string">&quot;Thirteen &quot;</span>, <span class="string">&quot;Fourteen &quot;</span>, <span class="string">&quot;Fifteen &quot;</span>, <span class="string">&quot;Sixteen &quot;</span>, <span class="string">&quot;Seventeen &quot;</span>,</span><br><span class="line">            <span class="string">&quot;Eighteen &quot;</span>, <span class="string">&quot;Nineteen &quot;</span> &#125;;</span><br><span class="line">        <span class="keyword">return</span> names[num - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">num1To99</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1</span> || num &gt; <span class="number">99</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> num1To19(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> num / <span class="number">10</span>;</span><br><span class="line">        String[] tyNames = &#123; <span class="string">&quot;Twenty &quot;</span>, <span class="string">&quot;Thirty &quot;</span>, <span class="string">&quot;Forty &quot;</span>, <span class="string">&quot;Fifty &quot;</span>,</span><br><span class="line">            <span class="string">&quot;Sixty &quot;</span>, <span class="string">&quot;Seventy &quot;</span>, <span class="string">&quot;Eighty &quot;</span>, <span class="string">&quot;Ninety &quot;</span> &#125;;</span><br><span class="line">        <span class="keyword">return</span> tyNames[high - <span class="number">2</span>] + num1To19(num % <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">num1To999</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1</span> || num &gt; <span class="number">999</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> num1To99(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> num / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> num1To19(high) + <span class="string">&quot;Hundred &quot;</span> + num1To99(num % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================= 中文表达 =================</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getNumChiExp</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;零&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> num &lt; <span class="number">0</span> ? <span class="string">&quot;负&quot;</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">yi</span> <span class="operator">=</span> Math.abs(num / <span class="number">100000000</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> Math.abs(num % <span class="number">100000000</span>);</span><br><span class="line">        <span class="keyword">if</span> (yi == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res + num1To99999999(rest);</span><br><span class="line">        &#125;</span><br><span class="line">        res += num1To9999(yi) + <span class="string">&quot;亿&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rest &lt; <span class="number">10000000</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> res + <span class="string">&quot;零&quot;</span> + num1To99999999(rest);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> res + num1To99999999(rest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 ~ 99999999 (万级别)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">num1To99999999</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1</span> || num &gt; <span class="number">99999999</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">wan</span> <span class="operator">=</span> num / <span class="number">10000</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> num % <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">if</span> (wan == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> num1To9999(rest);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> num1To9999(wan) + <span class="string">&quot;万&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rest &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> res + <span class="string">&quot;零&quot;</span> + num1To999(rest);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> res + num1To9999(rest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">num1To9</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1</span> || num &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] names = &#123; <span class="string">&quot;一&quot;</span>, <span class="string">&quot;二&quot;</span>, <span class="string">&quot;三&quot;</span>, <span class="string">&quot;四&quot;</span>, <span class="string">&quot;五&quot;</span>, <span class="string">&quot;六&quot;</span>, <span class="string">&quot;七&quot;</span>, <span class="string">&quot;八&quot;</span>, <span class="string">&quot;九&quot;</span> &#125;;</span><br><span class="line">        <span class="keyword">return</span> names[num - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">num1To99</span><span class="params">(<span class="type">int</span> num, <span class="type">boolean</span> hasBai)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1</span> || num &gt; <span class="number">99</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> num1To9(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">shi</span> <span class="operator">=</span> num / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (shi == <span class="number">1</span> &amp;&amp; (!hasBai)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;十&quot;</span> + num1To9(num % <span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> num1To9(shi) + <span class="string">&quot;十&quot;</span> + num1To9(num % <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">num1To999</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1</span> || num &gt; <span class="number">999</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> num1To99(num, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> num1To9(num / <span class="number">100</span>) + <span class="string">&quot;百&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> num % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rest &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            res += num1To99(rest, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += <span class="string">&quot;零&quot;</span> + num1To9(rest);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">num1To9999</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1</span> || num &gt; <span class="number">9999</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> num1To999(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> num1To9(num / <span class="number">1000</span>) + <span class="string">&quot;千&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> num % <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rest &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">            res += num1To999(rest);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += <span class="string">&quot;零&quot;</span> + num1To99(rest, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分糖果问题"><a href="#分糖果问题" class="headerlink" title="分糖果问题"></a>分糖果问题</h2><p>【题目】<br>一群孩子做游戏，现在请你根据游戏得分来发糖果，要求如下：</p>
<ol>
<li>每个孩子不管得分多少，起码分到 1 个糖果。</li>
<li>任意两个相邻的孩子之间，得分较多的孩子必须拿多一些的糖果。<br>给定一个数组 arr 代表得分数组，请返回最少需要多少糖果。<br>例如：arr=[1,2,2]，糖果分配为[1,2,1]，即可满足要求且数量最少，所以返回 4。</li>
</ol>
<p>进阶问题：原题目中的两个规则不变，再加一条规则：</p>
<ol>
<li>任意两个相邻的孩子之间如果得分一样，糖果数必须相同。<br>给定一个数组 arr 代表得分数组，返回最少需要多少糖果。<br>例如：arr=[1,2,2]，糖果分配为[1,2,2]，即可满足要求且数量最少，所以返回 5。</li>
</ol>
<p>【要求】<br>arr 长度为 N，原题与进阶题都要求时间复杂度为 O(N)，额外空间复杂度为 O(1)。</p>
<p>【解答】<br>原问题。先引入爬坡和下坡的概念，从左到右依次考虑每个孩子，如果一个孩子的右邻居比他大，那么爬坡过程开始。如果一直单调递增，就一直爬坡，否则爬坡结束，下坡开始。如果一直单调递减，就一直下坡，直到遇到一个孩子的右邻居大于或等于他，则下坡结束。爬坡中的路径叫左坡，下坡中的路径叫右坡。<br>比如[1,2,3,2,1]，左坡为[1,2,3]，右坡为[3,2,1]。比如[1,2,2,1]，第一个左坡为[1,2]，第一个右坡为[2]（只含有第一个 2），第二个左坡为[2]（只含有第二个 2），第二个右坡为[2,1]。比如[1,2,3,1,2]，第一个左坡[1,2,3]，第一个右坡为[3,1]，第二个左坡为[1,2]，第二个右坡为[2]。<br>定义了爬坡过程和下坡过程之后，大家可以看到，arr 数组可以被分解成很多对左坡和右坡，利用左坡和右坡来看糖果如何分。假设有一对左坡和右坡，分别为[1,4,5,9]和[9,3,2]。对左坡来说，从左到右分的糖果应该为[1,2,3,4]，对右坡来说，从左到右分的糖果应该为[3,2,1]。但这两种分配方式对 9 这个坡顶的分配是不同的，怎么决定呢？看左坡和右坡的坡度哪个更大，坡度是指坡中除去相同的数字之后（也就是纯升序或纯降序）的序列长度。而根据我们定义的爬坡和下坡过程，左坡和右坡中都不可能有重复数字，所以坡度就是各自的序列长度。[1,2,3,4]坡度为 4，[3,2,1]坡度为 3。如果左坡的坡度更大，坡顶就按左坡的分配，如果右坡的坡度更大，就按右坡的分配，所以最终分配为[1,2,3,4,2,1]。<br>成对的左坡和右坡都按照这种处理方式，从左到右处理得分数组 arr，统计总体的糖果数即可。具体过程请参看如下代码中的 candy1 方法。</p>
<p>进阶问题。针对进阶问题所加的新规则，需要对爬坡和下坡的过程进行修改。从左到右依次考虑每个孩子，如果一个孩子的右邻居大于或等于他，那么爬坡过程开始，如果一直不降序，就一直爬坡，否则爬坡结束，下坡开始。如果一直不升序，就一直下坡，直到遇到一个孩子的右邻居大于他，则下坡结束。爬坡中的路径叫左坡，下坡中的路径叫右坡。比如，[1,2,3,2,1]，左坡为[1,2,3]，右坡为[3,2,1]。再如，[1,2,2,1]，左坡为[1,2,2]，右坡为[2,1]。<br>依然是利用左坡和右坡来决定糖果如何分配，还是举例说明整个分配过程。比如，[0,1,2,3,3,3,2,2,2,2,2,1,1]，左坡为[0,1,2,3,3,3]，右坡为[3,2,2,2,2,2,1,1]。对左坡来说，从左到右分的糖果应该为[1,2,3,4,4,4]，对右坡来说，从左到右分的糖果应该为[3,2,2,2,2,2,1,1]。所以左坡和右坡的分配方案对整个坡顶的分配其实是矛盾的。注意，在这种情况下，其实坡顶为 3 个元素，即[3,3,3]。根据新的规则，相邻的且得分相等的孩子拿的糖果数要一样。所以坡顶究竟按谁的来呢？同样是根据左坡和右坡的坡度决定，左坡[0,1,2,3,3,3]的坡度为 4，右坡[3,2,2,2,2,2,1,1]的坡度为 3，坡顶分的糖果数同样按照坡度大的来决定。所以总的分配方案为[1,2,3,4,4,4,2,2,2,2,2,1,1]。也就是说，坡顶的所有小朋友都根据坡度大的一方决定。具体过程请参看如下代码中的 candy2 方法。</p>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CandyProblem</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================= 原问题 =================</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">candy1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> nextMinIndex1(arr, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> rightCands(arr, <span class="number">0</span>, index++);</span><br><span class="line">        <span class="type">int</span> <span class="variable">lbase</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rcands</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rbase</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index != arr.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[index] &gt; arr[index - <span class="number">1</span>]) &#123;</span><br><span class="line">                res += ++lbase;</span><br><span class="line">                index++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[index] &lt; arr[index - <span class="number">1</span>]) &#123;</span><br><span class="line">                next = nextMinIndex1(arr, index - <span class="number">1</span>);</span><br><span class="line">                rcands = rightCands(arr, index - <span class="number">1</span>, next++);</span><br><span class="line">                rbase = next - index + <span class="number">1</span>;</span><br><span class="line">                res += rcands + (rbase &gt; lbase ? -lbase : -rbase);</span><br><span class="line">                lbase = <span class="number">1</span>;</span><br><span class="line">                index = next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += <span class="number">1</span>;</span><br><span class="line">                lbase = <span class="number">1</span>;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextMinIndex1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i != arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rightCands</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> right - left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n + n * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================= 进阶问题 =================</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">candy2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> nextMinIndex2(arr, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span>[] data = rightCandsAndBase(arr, <span class="number">0</span>, index++);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> data[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">lbase</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">same</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index != arr.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[index] &gt; arr[index - <span class="number">1</span>]) &#123;</span><br><span class="line">                res += ++lbase;</span><br><span class="line">                same = <span class="number">1</span>;</span><br><span class="line">                index++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[index] &lt; arr[index - <span class="number">1</span>]) &#123;</span><br><span class="line">                next = nextMinIndex2(arr, index - <span class="number">1</span>);</span><br><span class="line">                data = rightCandsAndBase(arr, index - <span class="number">1</span>, next++);</span><br><span class="line">                <span class="keyword">if</span> (data[<span class="number">1</span>] &lt;= lbase) &#123;</span><br><span class="line">                    res += data[<span class="number">0</span>] - data[<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += -lbase * same + data[<span class="number">0</span>] - data[<span class="number">1</span>] + data[<span class="number">1</span>] * same;</span><br><span class="line">                &#125;</span><br><span class="line">                index = next;</span><br><span class="line">                lbase = <span class="number">1</span>;</span><br><span class="line">                same = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += lbase;</span><br><span class="line">                same++;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextMinIndex2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i != arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] rightCandsAndBase(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cands</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right - <span class="number">1</span>; i &gt;= left; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                cands += base;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cands += ++base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; cands, base &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一种消息接收并打印的结构设计"><a href="#一种消息接收并打印的结构设计" class="headerlink" title="一种消息接收并打印的结构设计"></a>一种消息接收并打印的结构设计</h2><p>【题目】<br>消息流吐出 2，一种结构接收而不打印 2，因为 1 还没出现。<br>消息流吐出 1，一种结构接收 1，并且打印：1, 2。<br>消息流吐出 4，一种结构接收而不打印 4，因为 3 还没出现。<br>消息流吐出 5，一种结构接收而不打印 5，因为 3 还没出现。<br>消息流吐出 7，一种结构接收而不打印 7，因为 3 还没出现。<br>消息流吐出 3，一种结构接收 3，并且打印：3, 4, 5。<br>消息流吐出 9，一种结构接收而不打印 9，因为 6 还没出现。<br>消息流吐出 8，一种结构接收而不打印 8，因为 6 还没出现。<br>消息流吐出 6，一种结构接收 6，并且打印：6, 7, 8, 9。<br>已知一个消息流会不断地吐出整数 1~N，但不一定按照顺序吐出。如果上次打印的数为 i，那么当 i+1 出现时，请打印 i+1 及其之后接收过的并且连续的所有数，直到 1~N 全部接收并打印完，请设计这种接收并打印的结构。</p>
<p>【要求】<br>消息流最终会吐出全部的 1~N，当然最终也会打印完所有的 1~N，要求接收和打印 1~N 的整个过程，时间复杂度为 O(N)。</p>
<p>【解答】<br>本题的设计方法有很多，本书提供一种设计实现供读者参考。结构假设叫 MessageBox，先以一个与题目不同的例子来简单说明过程。</p>
<ol>
<li>消息流吐出 2，MessageBox 接收并生成连续区间{2}，此时不打印，因为 1 没出现。</li>
<li>消息流吐出 1，MessageBox 接收并生成连续区间{1}，发现可以与{2}连在一起，所以连成整个连续区间{1,2}。此时 1 出现了，所以打印 1, 2，打印后删除连续区间{1,2}。</li>
<li>消息流吐出 4，MessageBox 接收并生成连续区间{4}。</li>
<li>消息流吐出 5，MessageBox 接收并生成连续区间{5}，发现可以与{4}连在一起，所以连成整个连续区间{4,5}。</li>
<li>消息流吐出 7，MessageBox 接收并生成连续区间{7}，此时 MessageBox 中有两个连续区间，分别为{4,5}和{7}。但 3 还没出现，所以不打印。</li>
<li>消息流吐出 9，MessageBox 接收并生成连续区间{9}，此时 MessageBox 中有三个连续区间，分别为{4,5}、{7}和{9}。但 3 还没出现，所以不打印。</li>
<li>消息流吐出 8，MessageBox 接收并生成连续区间{8}，此时发现{8}的出现可以把{7}和{9}连在一起，所以连成整个连续区间{7,8,9}。此时 MessageBox 中有两个连续区间，分别为{4,5}和{7,8,9}。但 3 还没出现，所以不打印。</li>
<li>消息流吐出 6，MessageBox 接收并生成连续区间{6}，此时发现{6}的出现可以把{4,5}和{7,8,9}连在一起，所以连成整个连续区间{4,5,6,7,8,9}。但 3 还没出现，所以不打印。</li>
<li>消息流吐出 3，MessageBox 接收并生成连续区间{3}，发现可以与{4,5,6,7,8,9}连在一起，所以连成整个连续区间{3,4,5,6,7,8,9}。此时 3 出现了，所以打印 3,4,5,6,7,8,9。打印后删除连续区间{3,4,5,6,7,8,9}，整个过程结束。</li>
</ol>
<p>分析如上过程可以知道，如果达到整个过程，其时间复杂度为 O(N)，我们需要设计好的连续区间结构，并且在一个数出现时，还要方便地将这个数上下有关的连续区间连接在一起。下面就介绍 MessageBox 结构的具体设计细节。</p>
<ol>
<li>当接收一个数 num 时，先根据 num 生成一个单链表节点的实例，单链表结构记为 Node。</li>
<li>连续结构就是一个单链表结构，但这还是不够的，为了可以快速合并，MessageBox 中还有三个重要的部分：headMap、tailMap 和 lastPrint。headMap 是一个哈希表，key 为整型，表示一个连续区间开始的数，value 为 Node 类型，表示根据 key 这个数生成的节点，也是连续区间的第一个节点。tailMap 也是一个哈希表，key 为整型，表示一个连续区间结束的数，value 为 Node 类型，表示根据 key 这个数生成的节点，也是连续区间的最后一个节点。比如连续区间{4,5,6,7,8,9}，假设节点值为 4 的节点记为 start，节点值为 9 的节点记为 end，从 start 到 end 是一条单链表，上面有节点值从 4 到 9 的所有节点，而且在 headMap 中还有记录(4,start)，在 tailMap 中还有记录(9,end)。lastPrint 表示上次打印的是什么数。</li>
<li>接收 num 之后，假设根据 num 生成的单链表节点实例为 cur。现在的 num 可以自己成为一个连续区间，即在 headMap 中加上记录(num,cur)，在 tailMap 中也加上记录(num,cur)。然后依次进行如下处理：<ol>
<li>在 tailMap 中查询是否有 key==num-1 的记录。如果有，说明存在一个连续区间以 num-1 结尾，记为连续区间 A，那么 A 可以和 num 自己的连续区间合并。假设 A 最后的数 num-1 对应的节点为 end，那么令 end.next=cur，表示 A 的单向链表在最后加上了一个节点 cur。然后在 tailMap 中删除记录(num-1,end)，因为以 num-1 结尾的连续区间已经不存在，大的连续区间是以 num 结尾的。最后在 headMap 中删除记录(num,cur)，因为以 num 开始的连续区间已经不存在，大的连续区间的头是合并前连续区间 A 的头。如果没有 key==num-1 的记录，则什么也不用做。</li>
<li>在 headMap 中查询是否有 key==num+1 的记录。如果有，说明存在一个连续区间以 num+1 开始，记为连续区间 B，那么 B 可以和以 num 结尾的连续区间合并。假设 B 开始的数 num+1 对应的节点为 start，那么令 cur.next=start，表示以 num 结尾的连续区间的链表合和 B 的链表合并。然后在 headMap 中删除记录(num+1,start)，因为以 num+1 开始的连续区间已经不存在。最后在 tailMap 中删除记录(num,cur)，因为以 num 结束的连续区间也已经不存在。如果没有 key==num+1 的记录，则什么也不用做。<br>整个步骤 3 就是做一件事情，看 num 上下的连续区域有没有因为自己的出现可以进行合并，能合并的全部都合并在一起。</li>
</ol>
</li>
<li>加入 num 之后，能不能打印。如果能打印，把打印的连续区域一律删除。<br>如上过程中，连续区域的合并全是 O(1)的时间复杂度，因为都是简单的哈希表查询操作或者是把某个节点的 next 指针赋值而已。整体过程的时间复杂度为 O(N)。</li>
</ol>
<h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageBox</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> num;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.num = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; headMap;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; tailMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> lastPrint;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageBox</span><span class="params">()</span> &#123;</span><br><span class="line">        headMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Node&gt;();</span><br><span class="line">        tailMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Node&gt;();</span><br><span class="line">        lastPrint = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(num);</span><br><span class="line">        headMap.put(num, cur);</span><br><span class="line">        tailMap.put(num, cur);</span><br><span class="line">        <span class="keyword">if</span> (tailMap.containsKey(num - <span class="number">1</span>)) &#123;</span><br><span class="line">            tailMap.get(num - <span class="number">1</span>).next = cur;</span><br><span class="line">            tailMap.remove(num - <span class="number">1</span>);</span><br><span class="line">            headMap.remove(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (headMap.containsKey(num + <span class="number">1</span>)) &#123;</span><br><span class="line">            cur.next = headMap.get(num + <span class="number">1</span>);</span><br><span class="line">            tailMap.remove(num);</span><br><span class="line">            headMap.remove(num + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (headMap.containsKey(lastPrint + <span class="number">1</span>)) &#123;</span><br><span class="line">            print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> headMap.get(++lastPrint);</span><br><span class="line">        headMap.remove(lastPrint);</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(node.num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            node = node.next;</span><br><span class="line">            lastPrint++;</span><br><span class="line">        &#125;</span><br><span class="line">        tailMap.remove(--lastPrint);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="随时找到数据流的中位数"><a href="#随时找到数据流的中位数" class="headerlink" title="随时找到数据流的中位数"></a>随时找到数据流的中位数</h2><p>【题目】<br>有一个源源不断地吐出整数的数据流，假设你有足够的空间来保存吐出的数。请设计一个名叫 MedianHolder 的结构，MedianHolder 可以随时取得之前吐出所有数的中位数。</p>
<p>【要求】</p>
<ol>
<li>如果 MedianHolder 已经保存了吐出的 N 个数，那么将一个新数加入到 MedianHolder 的过程，其时间复杂度是 O(logN)。</li>
<li>取得已经吐出的 N 个数整体的中位数的过程，时间复杂度为 O(1)。</li>
</ol>
<p>【解答】<br>本书设计的 MedianHolder 中有两个堆，一个是主要大根堆，另一个是小根堆。想做到大根堆中含有接收的所有数中较小的一半，并且按大根堆的方式组织起来，那么这个堆的堆顶就是较小一半的数中最大的那个。小根堆中含有接收的所有数中较大的一半，并且按小根堆的方式组织起来，那么这个堆的堆顶就是较大一半的数中最小的那个。<br>具体流程如下：</p>
<ol>
<li>第一个出现的数直接进入大根堆。</li>
<li>以后对每一个新出现的数 cur，判断 cur 是否小于或等于大根堆的堆顶。如果是，cur 进入大根堆；如果不是，cur 进入小根堆。</li>
<li>每一个数加入完成后，判断大根堆和小根堆的大小。如果个数较多的堆比个数较少的堆拥有的数的个数超过 1，从个数较多的堆中弹出堆顶，放入另一个堆。</li>
<li>任何时候想得到所有数字的中位数，一定可以由两个堆的堆顶得到。</li>
</ol>
<p>下面举例说明，大根堆记为 maxheap，小根堆记为 minheap，初始时都为空。假设依次吐出的数字为：5、3、6、7。</p>
<ul>
<li>当得到 5 时，直接进大根堆。maxheap={5}，minheap={}。</li>
<li>当得到 3 时，发现 3 小于或等于大根堆的堆顶 5，所以进入大根堆。maxheap={5,3}，minheap={}，此时发现大根堆的大小为 2，小根堆为 0，超过了 1。所以大根堆堆顶弹出，进入小根堆。maxheap={3}，minheap={5}。</li>
<li>当得到 6 时，发现 6 大于大根堆的堆顶 3，所以进入小根堆。maxheap={3}，minheap={5,6}。此时小根堆含有数字较多，但是和大根堆的个数相比没有超过 1，所以不调整。</li>
<li>当得到 7 时，发现 7 大于大根堆的堆顶 3，所以进入小根堆。maxheap={3}，minheap={5,6,7}。此时发现小根堆的大小为 3，大根堆为 1，超过了 1。所以小根堆堆顶弹出，进入大根堆。maxheap={5,3}，minheap={6,7}。</li>
</ul>
<p>你会发现每次新加的数进入具体的一个堆，经过调整之后，大根堆中含有接收的所有数中较小的一半，小根堆中含有接收的所有数中较大的一半。这样，通过两个堆的堆顶，我们总可以得到所有数的中位数。取得中位数的操作时间复杂度为 O(1)，同时根据堆的性质，不管是大根堆还是小根堆，往其中加一个新的数，以及调整堆的代价都是 O(logN)，符合题目的要求。具体实现请看如下的 MedianHolder 类。</p>
<h3 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MedianHolder</span> &#123;</span><br><span class="line">    <span class="comment">// 生成小根堆的比较器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinHeapComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Integer&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1 - o2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成大根堆的比较器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxHeapComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Integer&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PriorityQueue 结构就是堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianHolder</span><span class="params">()</span> &#123;</span><br><span class="line">        maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">MaxHeapComparator</span>());</span><br><span class="line">        minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">MinHeapComparator</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNumber</span><span class="params">(Integer num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.isEmpty() || num &lt;= maxHeap.peek()) &#123;</span><br><span class="line">            maxHeap.add(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minHeap.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        modifyTwoHeaps();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() == minHeap.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> (maxHeap.peek() + minHeap.peek()) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> maxHeap.size() &gt; minHeap.size() ? maxHeap.peek() : minHeap.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">modifyTwoHeaps</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() == minHeap.size() + <span class="number">2</span>) &#123;</span><br><span class="line">            minHeap.add(maxHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minHeap.size() == maxHeap.size() + <span class="number">2</span>) &#123;</span><br><span class="line">            maxHeap.add(minHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在两个长度相等的排序数组中找到上中位数"><a href="#在两个长度相等的排序数组中找到上中位数" class="headerlink" title="在两个长度相等的排序数组中找到上中位数"></a>在两个长度相等的排序数组中找到上中位数</h2><p>【题目】<br>给定两个有序数组 arr1 和 arr2，已知两个数组的长度都为 N，求两个数组中所有数的上中位数。</p>
<p>【举例】<br>arr1=[1,2,3,4], arr2=[3,4,5,6]<br>总共有 8 个数，那么上中位数是第 4 小的数，所以返回 3。<br>arr1=[0,1,2], arr2=[3,4,5]<br>总共有 6 个数，那么上中位数是第 3 小的数，所以返回 2。</p>
<p>【要求】<br>时间复杂度为 O(logN)，额外空间复杂度为 O(1)。</p>
<p>【解答】<br>根据时间复杂度的要求可知，应该利用二分查找的方式寻找上中位数，具体过程为：</p>
<ol>
<li>重新定义一下问题，现在在 arr1[start1..end1] 与 arr2[start2..end2]上寻找这两段数组共同的上中位数，并且这两段的长度应该相等（end1-start1==end2-start2）。</li>
<li>初始时 start1=0, end1=N-1, 即 arr1[start1..end1]代表 arr1 的全部。start2=0, end2=N-1, 即 arr2[start2..end2]代表 arr2 的全部。</li>
<li>如果 start1==end1，那么也有 start2==end2，寻找的过程中始终保证两段长度一致。这种情况下说明每一段都只有一个元素，这时元素总个数是 2 个，上中位数为较小的那个，则应该直接返回 min{arr1[start1], arr2[start2]}。</li>
<li>如果 start1!=end1，此时说明两段数组的长度都大于 1，则令 mid1=(start1+end1)/2，代表 arr1[start1..end1]的中间位置。令 mid2=(start2+end2)/2，代表 arr2[start2..end2]的中间位置。那么具体情况有如下三种。<ul>
<li>情况一：如果 arr1[mid1]==arr2[mid2]。为了方便理解，举两个例子说明这种情况。<br>  1) arr1 和 arr2 的长度为奇数的例子。arr1 的长度为 5，{1, 2, 3, 4, 5}依次表示 arr1 的第 1 个数，第 2 个数……第 5 个数。注意，这个数字表示 arr1 第几个数的意思，并不代表值。arr2 长度为 5，{1’, 2’, 3’, 4’, 5’}依次表示 arr2 的第 1 个数，第 2 个数……第 5 个数。注意，这个数字表示 arr2 的第几个数的意思，并不代表值。如果 arr1 的第 3 个数等于 arr2 的第 3 个数（3==3’），那么对这两个数来说，在 arr1 中把 1 和 2 压在底下，在 arr2 中把 1’ 和 2’ 压在底下。所以这两个数的值就是上中位数，直接返回 arr1[mid1]即可（当然也是 arr2[mid2]）。<br>  2) arr1 和 arr2 的长度为偶数的例子。arr1 的长度为 4，{1, 2, 3, 4}的含义同上。arr2 的长度为 4，{1’, 2’, 3’, 4’}的含义同上。如果 arr1 的第 2 个数等于 arr2 的第 2 个数（2==2’），那么对这两个数来说，在 arr1 中把 1 压在底下，在 arr2 中把 1’ 压在底下。所以这两个数的值就是上中位数，直接返回 arr1[mid1]即可（当然也是 arr2[mid2]）。<br>  综上所述，情况一中，如果 arr1[mid1]==arr2[mid2]，直接返回 arr1[mid1]。</li>
<li>情况二：如果 arr1[mid1]&gt;arr2[mid2]。为了方便理解，仍然举两个例子说明。<br>  1) arr1 和 arr2 的长度为奇数的例子。arr1 长度为 5，{1, 2, 3, 4, 5}的含义同上。arr2 长度为 5，{1’, 2’, 3’, 4’, 5’}的含义同上。如果 arr1 的第 3 个数大于 arr2 的第 3 个数（3&gt;3’），对 4 来说，它可能是第 5 个数吗？不可能。因为在 arr1 中，4 把三个数压在底下，同时又有（3&gt;3’），所以 4 在 arr2 中又起码把三个数压在底下，所以 4 最好情况下是第 7 个数。那么对 5 来说，则更不可能。对 2’来说，它可能是第 5 个数吗？不可能。因为在 arr2 中，2’只压了一个数，同时又有（3&gt;3’&gt;=2’），所以 2’在 arr1 中最多只能把两个数压在底下，2’最好情况下是第 4 个数。那么对 1’来说，则更不可能。现在我们看一下，{1, 2, 3}和{3’, 4’, 5’}这两段共同的上中位数，也就是这 6 个数中第 3 小的数记为 a，代表什么？a 在{1, 2, 3}和{3’, 4’, 5’}这两段中，会把两个数压在下面，同时也会把原来 arr2 中的 1’和 2’压在下面。那么 a 正好就是{1, 2, 3, 4, 5}和{1’, 2’, 3’, 4’, 5’}整体第 5 小的数，也就是想求的结果。所以只要求{1, 2, 3}和{3’, 4’, 5’}的上中位数即可，即令 end1=mid1，start2=mid2，然后重复步骤 3。<br>  2) arr1 和 arr2 的长度为偶数的例子。arr1 长度为 4，{1, 2, 3, 4}的含义同上。arr2 长度为 4，{1’, 2’, 3’, 4’}的含义同上。如果 arr1 的第 2 个数大于 arr2 的第 2 个数（2&gt;2’），对 3 来说，它可能是第 4 个数吗？不可能，因为它起码把四个数压在底下，最好情况也是第 5 个数，则 4 更不可能。对 2’来说，它可能是第 4 个数吗？也不可能，因为它最多只把两个数压在底下，最好情况也仅是第 3 个数，则 1’更不可能。现在我们看一下，{1, 2}和{3’, 4’}这两段共同的上中位数，也就是这 4 个数中第 2 小的数记为 b，代表什么？b 在{1, 2}和{3’, 4’}这两段中，会把一个数压在下面，同时也会把原来 arr2 中的 1’和 2’压在下面。那么 b 正好就是{1, 2, 3, 4}和{1’, 2’, 3’, 4’}整体第 4 小的数，也就是想求的结果。所以只要求{1, 2}和{3’, 4’}的上中位数即可，即令 end1=mid1，start2=mid2+1，然后重复步骤 3。<br>  综上所述，情况二中，无论怎样，在 arr1 和 arr2 的范围上都可以二分。</li>
<li>情况三：如果 arr1[mid1]&lt;arr2[mid2]。分析方式类似情况二，这里不再详细解释，肯定可以二分。arr1 和 arr2 如果长度为奇数，令 start1=mid1，end2=mid2，然后重复步骤 3。arr1 和 arr2 如果长度为偶数，令 start1=mid1+1，end2=mid2，然后重复步骤 3。<br>具体过程请参看如下代码中的 getUpMedian 方法。</li>
</ul>
</li>
</ol>
<h3 id="完整代码-4"><a href="#完整代码-4" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UpMedian</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getUpMedian</span><span class="params">(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr1 == <span class="literal">null</span> || arr2 == <span class="literal">null</span> || arr1.length != arr2.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Your arr is invalid!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end1</span> <span class="operator">=</span> arr1.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end2</span> <span class="operator">=</span> arr2.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (start1 &lt; end1) &#123;</span><br><span class="line">            mid1 = (start1 + end1) / <span class="number">2</span>;</span><br><span class="line">            mid2 = (start2 + end2) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 元素个数为奇数，则 offset 为 0；元素个数为偶数，则 offset 为 1</span></span><br><span class="line">            offset = ((end1 - start1 + <span class="number">1</span>) &amp; <span class="number">1</span>) ^ <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr1[mid1] &gt; arr2[mid2]) &#123;</span><br><span class="line">                end1 = mid1;</span><br><span class="line">                start2 = mid2 + offset;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr1[mid1] &lt; arr2[mid2]) &#123;</span><br><span class="line">                start1 = mid1 + offset;</span><br><span class="line">                end2 = mid2;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> arr1[mid1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(arr1[start1], arr2[start2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在两个排序数组中找到第-k-小的数"><a href="#在两个排序数组中找到第-k-小的数" class="headerlink" title="在两个排序数组中找到第 k 小的数"></a>在两个排序数组中找到第 k 小的数</h2><p>【题目】<br>给定两个有序数组 arr1 和 arr2，再给定一个整数 k，返回所有的数中第 K 小的数。</p>
<p>【举例】<br>arr1=[1,2,3,4,5], arr2=[3,4,5], k=1。<br>1 是所有数中第 1 小的数，所以返回 1。<br>arr1=[1,2,3], arr2=[3,4,5,6], k=4。<br>3 是所有数中第 4 小的数，所以返回 3。</p>
<p>【要求】<br>如果 arr1 的长度为 N，arr2 的长度为 M，时间复杂度请达到 O(log(min{M,N}))，额外空间复杂度为 O(1)。</p>
<p>【解答】<br>在了解本题的解法之前，请读者先阅读“在两个长度相等的排序数组中找到上中位数”这个问题的解答。本题也深度利用了这个问题解法。以下的 getUpMedian 方法就是上中位数这个问题的代码，在 a1[s1..e1]和 a2[s2..e2]两段长度相等的范围上找上中位数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getUpMedian</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span> s1, <span class="type">int</span> e1, <span class="type">int</span>[] a2, <span class="type">int</span> s2, <span class="type">int</span> e2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s1 &lt; e1) &#123;</span><br><span class="line">        mid1 = (s1 + e1) / <span class="number">2</span>;</span><br><span class="line">        mid2 = (s2 + e2) / <span class="number">2</span>;</span><br><span class="line">        offset = ((e1 - s1 + <span class="number">1</span>) &amp; <span class="number">1</span>) ^ <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a1[mid1] &gt; a2[mid2]) &#123;</span><br><span class="line">            e1 = mid1;</span><br><span class="line">            s2 = mid2 + offset;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a1[mid1] &lt; a2[mid2]) &#123;</span><br><span class="line">            s1 = mid1 + offset;</span><br><span class="line">            e2 = mid2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a1[mid1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(a1[s1], a2[s2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面开始求解本题，为了方便理解，我们用举例说明的方式。长度较短的数组为 shortArr，长度记为 lenS；长度较长的数组为 longArr，长度记为 lenL。假设 shortArr 长度为 10，{1, 2, 3, …, 10}依次表示 shortArr 的第 1 个数，第 2 个数……第 10 个数。注意，这个数字表示 shortArr 的第几个数的意思，并不代表值。假设 longArr 长度为 27，{1’,2’,…,27’}依次表示 longArr 的第 1 个数，第 2 个数……第 27 个数。注意，这个数字表示 longArr 的第几个数的意思，并不代表值。下面是找到整体第 k 个最小的数的过程。</p>
<ul>
<li>情况 1：如果 k<1 或者 k>lenS+lenL，那么 k 值是无效的。</li>
<li>情况 2：如果 k&lt;=lenS，那么在 shortArr 中选前 k 个数，在 longArr 中也选前 k 个数，这两段数组中的上中位数就是整体第 k 个最小的数。比如 k=5 时，那么{1…5}和{1’…5’}这两段数组整体的上中位数就是整体第 5 小的数。</li>
<li>情况 3：如果 k&gt;lenL。举一个具体的例子，一共有 37 个数，求第 33 个最小的数（33&gt;lenL==27）就是这种情况。在{1…10}中，5 不可能成为第 33 个最小的数，因为即便是 5 比 27’还要大。也就是说，即使 5 在 longArr 中把 27 个数全压在下面，5 在 shortArr 中也只把 4 个数压在下面，所以 5 最好的情况就是第 32 个最小的数。那么{1…4}就更不可能，所以{1…5}一律不可能。6 可能是吗？可能。6 如果大于 27’，那么它就是第 33 个最小的数，直接返回，否则它也不是。同理，在{1’…27’}中，{1’…22’}绝不可能是第 33 个最小的数。23’如果大于 10，那么 23’就是第 33 个最小的数，直接返回，否则 23’也不是。如果发现 6 和 23’有一个满足条件，就可以直接返回，否则可以知道{1…6}和{1’…23’}这一共 29 个数都是不可能的，那么{7…10}和{24’…27’}这两段数组整体的上中位数，即这 8 个数里的第 4 小数，就是整体第 33 个最小的数。</li>
<li>情况 4：如果不是情况 1、情况 2 和情况 3，说明 lenS&lt;k&lt;=lenL。举一个具体的例子，求第 17 个最小的数（10&lt;17&lt;=27）就是这种情况。在{1…10}中，任何数都有可能是第 17 个最小的数。在{1’…27’}中，6’不可能是第 17 个最小的数，因为即使 6’在 shortArr 中把 10 个数全压在下面，6’在 longArr 中也只把 5 个数压在下面，6’最好的情况就是第 16 个最小的数，所以{1’…6’}一律不可能。在{1’…27’}中，18’也不可能是第 17 个最小的数，18’最好的情况也只能做第 18 个最小的数，所以{18’…27’}一律不可能。只剩下{7’…17’}，7’可能是吗？可能。7’如果大于 10，那么 7’就是第 17 个最小的数，直接返回，否则 7’也是不可能的，这时{1’…7’}这一共 7 个数都是不可能的，那么{1…10}和{8’…17’}这两段数组整体的上中位数，即这 20 个数里第 10 小的数，就是整体第 17 个最小的数。</li>
</ul>
<p>不管是以上 4 种情况的哪一种，在求 arr1 和 arr2 长度相等的两个范围的上中位数时，范围最多也只是 shortArr 数组的长度，所以时间复杂度为 O(log(min{M,N}))。具体过程请参看如下代码中的 findKthNum 方法。</p>
<h3 id="完整代码-5"><a href="#完整代码-5" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KthNumberInSortedArrays</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findKthNum</span><span class="params">(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2, <span class="type">int</span> kth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr1 == <span class="literal">null</span> || arr2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Your arr is invalid!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (kth &lt; <span class="number">1</span> || kth &gt; arr1.length + arr2.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;K is invalid!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] longs = arr1.length &gt;= arr2.length ? arr1 : arr2;</span><br><span class="line">        <span class="type">int</span>[] shorts = arr1.length &lt; arr2.length ? arr1 : arr2;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> longs.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> shorts.length;</span><br><span class="line">        <span class="keyword">if</span> (kth &lt;= s) &#123;</span><br><span class="line">            <span class="keyword">return</span> getUpMedian(shorts, <span class="number">0</span>, kth - <span class="number">1</span>, longs, <span class="number">0</span>, kth - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (kth &gt; l) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shorts[kth - l - <span class="number">1</span>] &gt;= longs[l - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> shorts[kth - l - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (longs[kth - s - <span class="number">1</span>] &gt;= shorts[s - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> longs[kth - s - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> getUpMedian(shorts, kth - l, s - <span class="number">1</span>, longs, kth - s, l - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (longs[kth - s - <span class="number">1</span>] &gt;= shorts[s - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> longs[kth - s - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getUpMedian(shorts, <span class="number">0</span>, s - <span class="number">1</span>, longs, kth - s, kth - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getUpMedian</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span> s1, <span class="type">int</span> e1, <span class="type">int</span>[] a2, <span class="type">int</span> s2, <span class="type">int</span> e2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s1 &lt; e1) &#123;</span><br><span class="line">            mid1 = (s1 + e1) / <span class="number">2</span>;</span><br><span class="line">            mid2 = (s2 + e2) / <span class="number">2</span>;</span><br><span class="line">            offset = ((e1 - s1 + <span class="number">1</span>) &amp; <span class="number">1</span>) ^ <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a1[mid1] &gt; a2[mid2]) &#123;</span><br><span class="line">                e1 = mid1;</span><br><span class="line">                s2 = mid2 + offset;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a1[mid1] &lt; a2[mid2]) &#123;</span><br><span class="line">                s1 = mid1 + offset;</span><br><span class="line">                e2 = mid2;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a1[mid1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(a1[s1], a2[s2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两个有序数组间相加和的-Top-k-问题"><a href="#两个有序数组间相加和的-Top-k-问题" class="headerlink" title="两个有序数组间相加和的 Top k 问题"></a>两个有序数组间相加和的 Top k 问题</h2><p>【题目】<br>给定两个有序数组 arr1 和 arr2，再给定一个整数 k，返回来自 arr1 和 arr2 的两个数相加和最大的前 k 个，两个数必须分别来自两个数组。</p>
<p>【举例】<br>arr1=[1,2,3,4,5], arr2=[3,5,7,9,11], k=4。<br>返回数组[16,15,14,14]。</p>
<p>【要求】<br>时间复杂度达到 O(klogk)。</p>
<p>【解答】<br>哪两个分别来自两个排序数组的数相加和最大？自然是 arr1 的最后一个数和 arr2 的最后一个数。假设 arr1 长度为 N，arr2 长度为 M。<br>既然 arr2[M-1]+arr1[N-1]无疑是所有和中最大的，那么先把这个和放到大根堆里。然后从堆中弹出一个堆顶，此时这个堆顶肯定是 (M-1,N-1) 位置的和，即 arr2[M-1]+arr1[N-1]。接下来把两个位置的和再放进堆里，分别是 (M-2,N-1) 和 (M-1,N-2)，因为除 (M-1,N-1) 位置的和之外，其他任何位置的和都不会比 (M-2,N-1) 和 (M-1,N-2) 位置的和更大。每放入一个位置的和，都经过堆的调整 (heapInsert 调整)。当再从堆中弹出一个堆顶时，此时的堆顶必然是堆中最大的和，假设是 (i,j) 位置的和。弹出之后再把堆调整成大根堆，即把堆中最后一个元素放到堆顶的位置进行从上到下的 heapify 调整，调整之后再依次把 (i,j-1) 和 (i-1,j) 位置的和放入到堆中。也就是说，每次从堆中拿出一个位置和，然后把该位置和的左位置和上位置放入堆里。每次弹出的位置和就是从大到小排列的我们想得到的 Top k。这个过程再次总结如下：</p>
<ol>
<li>初始时把位置 (M-1,N-1) 放入堆中，因为这个位置代表的相加和就是最大的相加和。</li>
<li>此时堆顶为 (M-1,N-1)，把这个位置代表的相加和 (arr2[M-1]+arr1[N-1]) 收集起来，然后把堆尾放到堆顶的位置，再经历堆的调整 (heapify)，最后把 (M-2,N-1) 和 (M-1,N-2) 放入堆中，并根据代表的相加和来重新调整堆 (heapInsert)。</li>
<li>每次堆顶都会有一个位置记为 (i,j)，把这个位置代表的相加和 (arr2[i]+arr1[j]) 收集起来，然后把堆尾放到堆顶的位置，再经历堆的调整 (heapify)。最后把这个位置上的 (i-1,j) 和左边的 (i,j-1) 放入堆中，并根据代表的相加和调整堆 (heapInsert)。</li>
<li>直到收集的个数为 k，整个过程结束。<br>堆的大小为 k，每次堆的调整为 O(logk)级别，并且一共收集 k 个数，所以时间复杂度为 O(klogk)。需要注意的是，要利用哈希表来防止同一个位置重复进堆的情况。<br>全部过程请参看如下代码中的 topKSum 方法。</li>
</ol>
<h3 id="完整代码-6"><a href="#完整代码-6" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopKSum</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放入大根堆中的结构</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> index1; <span class="comment">// arr1 中的位置</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> index2; <span class="comment">// arr2 中的位置</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> value; <span class="comment">// arr1[index1] + arr2[index2]的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> i1, <span class="type">int</span> i2, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">            index1 = i1;</span><br><span class="line">            index2 = i2;</span><br><span class="line">            value = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成大根堆的比较器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MaxHeapComp</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Node&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Node o1, Node o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o2.value - o1.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] topKSum(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2, <span class="type">int</span> topK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr1 == <span class="literal">null</span> || arr2 == <span class="literal">null</span> || topK &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        topK = Math.min(topK, arr1.length * arr2.length);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[topK];</span><br><span class="line">        <span class="type">int</span> <span class="variable">resIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;Node&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MaxHeapComp</span>());</span><br><span class="line">        HashSet&lt;String&gt; positionSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> arr1.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> arr2.length - <span class="number">1</span>;</span><br><span class="line">        maxHeap.add(<span class="keyword">new</span> <span class="title class_">Node</span>(i1, i2, arr1[i1] + arr2[i2]));</span><br><span class="line">        positionSet.add(i1 + <span class="string">&quot;_&quot;</span> + i2);</span><br><span class="line">        <span class="keyword">while</span> (resIndex != topK) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">curNode</span> <span class="operator">=</span> maxHeap.poll();</span><br><span class="line">            res[resIndex++] = curNode.value;</span><br><span class="line">            i1 = curNode.index1;</span><br><span class="line">            i2 = curNode.index2;</span><br><span class="line">            <span class="keyword">if</span> (i1 - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !positionSet.contains((i1 - <span class="number">1</span>) + <span class="string">&quot;_&quot;</span> + i2)) &#123;</span><br><span class="line">                positionSet.add((i1 - <span class="number">1</span>) + <span class="string">&quot;_&quot;</span> + i2);</span><br><span class="line">                maxHeap.add(<span class="keyword">new</span> <span class="title class_">Node</span>(i1 - <span class="number">1</span>, i2, arr1[i1 - <span class="number">1</span>] + arr2[i2]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i2 - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !positionSet.contains(i1 + <span class="string">&quot;_&quot;</span> + (i2 - <span class="number">1</span>))) &#123;</span><br><span class="line">                positionSet.add(i1 + <span class="string">&quot;_&quot;</span> + (i2 - <span class="number">1</span>));</span><br><span class="line">                maxHeap.add(<span class="keyword">new</span> <span class="title class_">Node</span>(i1, i2 - <span class="number">1</span>, arr1[i1] + arr2[i2 - <span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="出现次数的-Top-k-问题"><a href="#出现次数的-Top-k-问题" class="headerlink" title="出现次数的 Top k 问题"></a>出现次数的 Top k 问题</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定 String 类型的数组 strArr，再给定整数 k，请严格按照排名顺序打印出现次数前 k 名的字符串。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>strArr=[“1”,”2”,”3”,”4”]，k=2<br>No.1: 1, times: 1<br>No.2: 2, times: 1<br>这种情况下，所有的字符串都出现一样多，随便打印任何两个字符串都可以。</p>
<p>strArr=[“1”,”1”,”2”,”3”]，k=2<br>输出：<br>No.1: 1, times: 2<br>No.2: 2, times: 1<br>或者输出：<br>No.1: 1, times: 2<br>No.2: 3, times: 1</p>
<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>如果 strArr 长度为 N，时间复杂度请达到 O(Nlogk)。</p>
<h3 id="进阶问题"><a href="#进阶问题" class="headerlink" title="进阶问题"></a>进阶问题</h3><p>设计并实现 TopKRecord 结构，可以不断地向其中加入字符串，并且可以根据字符串出现的情况随时打印加入次数最多的前 k 个字符串，具体为：</p>
<ol>
<li>k 在 TopKRecord 实例生成时指定，并且不再变化（k 是构造函数的参数）。</li>
<li>含有 add(String str)方法，即向 TopKRecord 中加入字符串。</li>
<li>含有 printTopK()方法，即打印加入次数最多的前 k 个字符串，打印有哪些字符串和对应的次数即可，不要求严格按排名顺序打印。</li>
</ol>
<p><strong>举例</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TopKRecord</span> <span class="variable">record</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopKRecord</span>(<span class="number">2</span>); <span class="comment">// 打印 Top 2 的结构</span></span><br><span class="line">record.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">record.printTopK();</span><br><span class="line"><span class="comment">// 此时打印：</span></span><br><span class="line"><span class="comment">// TOP: </span></span><br><span class="line"><span class="comment">//  Str: A Times: 1</span></span><br><span class="line"></span><br><span class="line">record.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">record.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">record.printTopK();</span><br><span class="line"><span class="comment">// 此时打印：</span></span><br><span class="line"><span class="comment">//  TOP: </span></span><br><span class="line"><span class="comment">//  Str: A Times: 1</span></span><br><span class="line"><span class="comment">//  Str: B Times: 2</span></span><br><span class="line"><span class="comment">// 或者打印</span></span><br><span class="line"><span class="comment">//  TOP: </span></span><br><span class="line"><span class="comment">//  Str: B Times: 2</span></span><br><span class="line"><span class="comment">//  Str: A Times: 1</span></span><br><span class="line"></span><br><span class="line">record.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">record.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">record.printTopK();</span><br><span class="line"><span class="comment">// 此时打印：</span></span><br><span class="line"><span class="comment">//  TOP: </span></span><br><span class="line"><span class="comment">//  Str: B Times: 2</span></span><br><span class="line"><span class="comment">//  Str: C Times: 2</span></span><br><span class="line"><span class="comment">// 或者打印</span></span><br><span class="line"><span class="comment">//  TOP: </span></span><br><span class="line"><span class="comment">//  Str: C Times: 2</span></span><br><span class="line"><span class="comment">//   Str: B Times: 2</span></span><br></pre></td></tr></table></figure></p>
<p><strong>要求</strong></p>
<ol>
<li>在任何时候，add 方法的时间复杂度不超过 O(logk)。</li>
<li>在任何时候，printTopK 方法的时间复杂度不超过 O(k)。</li>
</ol>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="原问题"><a href="#原问题" class="headerlink" title="原问题"></a>原问题</h4><p>首先遍历 strArr 并统计字符串的词频。<br>用哈希表的每条信息可以生成 Node 类的实例。<br>哈希表中有多少信息，就建立多少 Node 类的实例，并且依次放入堆中，具体过程为：</p>
<ol>
<li>建立一个大小为 k 的小根堆，这个堆放入的是 Node 类的实例。</li>
<li>遍历哈希表的每条记录，假设一条记录为（s,t），s 表示一种字符串，s 的词频为 t，则生成 Node 类的实例，记为（str,times）。<ul>
<li>如果小根堆没有满，就直接将（str,times）加入堆，然后进行建堆调整（heapInsert 调整），堆中 Node 类实例之间都以词频（times）来进行比较，词频越小，位置越往上。</li>
<li>如果小根堆已满，说明此时小根堆已经选出 k 个最高词频的字符串，那么整个小根堆的堆顶自然代表已经选出的 k 个最高词频的字符串中，词频最低的那个。堆顶的元素记为（headStr,minTimes）。如果 minTimes &lt; times，说明字符串 str 有资格进入当前 k 个最高词频字符串的范围。而 headStr 应该被移出这个范围，所以把当前的堆顶（headStr,minTimes）替换成（str,times），然后从堆顶的位置进行堆的调整（heapify）。如果 minTimes &gt;= times，说明字符串 str 没有资格进入当前 k 个最高词频字符串的范围。</li>
</ul>
</li>
<li>遍历完 strArr 之后，小根堆里就是所有字符串中 k 个最高词频的字符串，但要求严格按排名打印，所以还需要根据词频从大到小完成 k 个元素间的排序。</li>
</ol>
<p><strong>复杂度分析</strong>：<br>遍历 strArr 建立哈希表的过程为 O(N)。哈希表中记录的条数最多为 N 条，每一条记录进堆时，堆的调整时间复杂度为 O(logk)，所以根据记录更新小根堆的过程为 O(Nlogk)。k 条记录排序的时间复杂度为 O(klogk)。所以总的时间复杂度为 O(N)+O(Nlogk)+O(klogk)，即 O(Nlogk)。</p>
<p><strong>代码实现</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopKStrings</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> String str;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> times;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(String s, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">            str = s;</span><br><span class="line">            times = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printTopKAndRank</span><span class="params">(String[] arr, <span class="type">int</span> topK)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || topK &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">        <span class="comment">// 生成哈希表(字符串词频)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(cur)) &#123;</span><br><span class="line">                map.put(cur, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(cur, map.get(cur) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Node[] heap = <span class="keyword">new</span> <span class="title class_">Node</span>[topK];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历哈希表，决定每条信息是否进堆</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(str, times);</span><br><span class="line">            <span class="keyword">if</span> (index != topK) &#123;</span><br><span class="line">                heap[index] = node;</span><br><span class="line">                heapInsert(heap, index++);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (heap[<span class="number">0</span>].times &lt; node.times) &#123;</span><br><span class="line">                    heap[<span class="number">0</span>] = node;</span><br><span class="line">                    heapify(heap, <span class="number">0</span>, topK);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把小根堆的所有元素按词频从大到小排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index - <span class="number">1</span>; i != <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(heap, <span class="number">0</span>, i);</span><br><span class="line">            heapify(heap, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 严格按照排名打印 k 条记录</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != heap.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heap[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;No.&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">                System.out.print(heap[i].str + <span class="string">&quot;, times: &quot;</span>);</span><br><span class="line">                System.out.println(heap[i].times);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(Node[] heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (index != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (heap[index].times &lt; heap[parent].times) &#123;</span><br><span class="line">                swap(heap, parent, index);</span><br><span class="line">                index = parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(Node[] heap, <span class="type">int</span> index, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">smallest</span> <span class="operator">=</span> index;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; heapSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heap[left].times &lt; heap[index].times) &#123;</span><br><span class="line">                smallest = left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; heap[right].times &lt; heap[smallest].times) &#123;</span><br><span class="line">                smallest = right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (smallest != index) &#123;</span><br><span class="line">                swap(heap, smallest, index);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index = smallest;</span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            right = index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Node[] heap, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> heap[index1];</span><br><span class="line">        heap[index1] = heap[index2];</span><br><span class="line">        heap[index2] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="进阶问题-1"><a href="#进阶问题-1" class="headerlink" title="进阶问题"></a>进阶问题</h4><p>原问题是已经存在不再变化的字符串数组，所以可以一次性统计词频哈希表，然后建小根堆。进阶问题中，每个字符串词频可能会随时增加，这个过程一直是动态的。<br>如果每次 <code>printTopK</code> 都重新建堆，复杂度为 O(Nlogk)，不达标。</p>
<p><strong>TopKRecord 结构设计</strong>：</p>
<ol>
<li><strong>heap</strong>：小根堆，装的是 Node 类的实例（字符串及其词频）。堆里装的是所有加入过的字符串中词频最高的 Top k。大小在初始化时确定为 k。</li>
<li><strong>index</strong>：整型变量，表示如果新的 Node 实例想加入到 heap，该放在 heap 的哪个位置（堆目前的实际大小）。</li>
<li><strong>strNodeMap</strong>：哈希表，key 为字符串，value 为 Node 类型。表示加入的某种字符串及其对应的 Node 实例。</li>
<li><strong>nodeIndexMap</strong>：哈希表，key 为 Node 类型，value 为整型。表示 key 这个 Node 实例在 heap 上的位置。如果不在 heap 上，为 -1。</li>
</ol>
<p><strong>关键逻辑</strong>：</p>
<ul>
<li><code>strNodeMap</code> 记录字符串的 Node 信息。</li>
<li><code>nodeIndexMap</code> 记录 Node 在堆中的位置，用于快速定位和调整。</li>
<li><strong>add 方法</strong>：<ol>
<li>更新 <code>strNodeMap</code> 中的词频。</li>
<li>检查该 Node 是否在堆中（通过 <code>nodeIndexMap</code>）。<ul>
<li><strong>在堆中</strong>：词频增加，可能需要向下调整 (<code>heapify</code>)。</li>
<li><strong>不在堆中</strong>：<ul>
<li>如果堆未满：放入堆底，向上调整 (<code>heapInsert</code>)。</li>
<li>如果堆已满：比较词频与堆顶。如果大于堆顶，替换堆顶并向下调整 (<code>heapify</code>)。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><strong>注意</strong>：堆中元素的任何交换都要同步更新 <code>nodeIndexMap</code>。</li>
</ul>
<p><strong>复杂度</strong>：</p>
<ul>
<li><code>add</code>: O(logk)</li>
<li><code>printTopK</code>: O(k)</li>
</ul>
<p><strong>代码实现</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopKRecord</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> String str;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> times;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(String s, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">            str = s;</span><br><span class="line">            times = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node[] heap;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Node&gt; strNodeMap;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Node, Integer&gt; nodeIndexMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TopKRecord</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        heap = <span class="keyword">new</span> <span class="title class_">Node</span>[size];</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        strNodeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Node&gt;();</span><br><span class="line">        nodeIndexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">curNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!strNodeMap.containsKey(str)) &#123;</span><br><span class="line">            curNode = <span class="keyword">new</span> <span class="title class_">Node</span>(str, <span class="number">1</span>);</span><br><span class="line">            strNodeMap.put(str, curNode);</span><br><span class="line">            nodeIndexMap.put(curNode, -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curNode = strNodeMap.get(str);</span><br><span class="line">            curNode.times++;</span><br><span class="line">            preIndex = nodeIndexMap.get(curNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (preIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index == heap.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (heap[<span class="number">0</span>].times &lt; curNode.times) &#123;</span><br><span class="line">                    nodeIndexMap.put(heap[<span class="number">0</span>], -<span class="number">1</span>);</span><br><span class="line">                    nodeIndexMap.put(curNode, <span class="number">0</span>);</span><br><span class="line">                    heap[<span class="number">0</span>] = curNode;</span><br><span class="line">                    heapify(<span class="number">0</span>, index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nodeIndexMap.put(curNode, index);</span><br><span class="line">                heap[index] = curNode;</span><br><span class="line">                heapInsert(index++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            heapify(preIndex, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printTopK</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TOP: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != heap.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heap[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;Str: &quot;</span> + heap[i].str);</span><br><span class="line">            System.out.println(<span class="string">&quot; Times: &quot;</span> + heap[i].times);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (index != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (heap[index].times &lt; heap[parent].times) &#123;</span><br><span class="line">                swap(parent, index);</span><br><span class="line">                index = parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">smallest</span> <span class="operator">=</span> index;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; heapSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heap[l].times &lt; heap[index].times) &#123;</span><br><span class="line">                smallest = l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; heap[r].times &lt; heap[smallest].times) &#123;</span><br><span class="line">                smallest = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (smallest != index) &#123;</span><br><span class="line">                swap(smallest, index);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index = smallest;</span><br><span class="line">            l = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            r = index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        nodeIndexMap.put(heap[index1], index2);</span><br><span class="line">        nodeIndexMap.put(heap[index2], index1);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> heap[index1];</span><br><span class="line">        heap[index1] = heap[index2];</span><br><span class="line">        heap[index2] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Manacher-算法"><a href="#Manacher-算法" class="headerlink" title="Manacher 算法"></a>Manacher 算法</h2><p>【题目】<br>给定一个字符串 <code>str</code>，返回 <code>str</code> 中最长回文子串的长度。</p>
<p>【进阶题目】<br>给定一个字符串 <code>str</code>，想通过添加字符的方式使得 <code>str</code> 整体都变成回文字符串，但要求只能在 <code>str</code> 的末尾添加字符，请返回在 <code>str</code> 后面添加的最短字符串。</p>
<p>【示例】</p>
<ul>
<li><code>str=&quot;123&quot;</code>，其中的最长回文子串为”1”、”2”或者”3”，所以返回1。</li>
<li><code>str=&quot;abc1234321ab&quot;</code>，其中的最长回文子串为”1234321”，所以返回7。</li>
<li>进阶：<code>str=&quot;12&quot;</code>，在末尾添加”1”之后，str变为”121”，是回文串。返回”1”。</li>
</ul>
<p>【要求】<br>如果 <code>str</code> 的长度为 $N$，解决原问题和进阶问题的时间复杂度都达到 $O(N)$。</p>
<p>【解析】<br>Manacher 算法可以在 $O(N)$ 的时间复杂度内解决最长回文子串问题。<br>核心是利用之前计算过的回文半径，加速当前位置的回文半径计算。</p>
<p><strong>1. 预处理</strong><br>解决奇偶回文判断不一致的问题。在字符串开头、结尾和中间插入特殊字符 <code>#</code>。<br>例如 <code>str=&quot;bcbaa&quot;</code>，处理后为 <code>&quot;#b#c#b#a#a#&quot;</code>。这样无论是奇回文还是偶回文，都变成了奇回文（以某个字符或 <code>#</code> 为中心）。</p>
<p><strong>2. 核心概念</strong></p>
<ul>
<li><code>pArr</code>：回文半径数组。<code>pArr[i]</code> 表示以 <code>i</code> 为中心的最长回文半径长度。</li>
<li><code>pR</code>：所有已求出的回文半径中，右边界到达的最右位置的<strong>下一个位置</strong>（即最右回文边界）。初始为 -1。</li>
<li><code>index</code>：取得 <code>pR</code> 时对应的回文中心位置。</li>
</ul>
<p><strong>3. 算法流程</strong><br>从左到右遍历处理后的字符串，计算每个位置 <code>i</code> 的 <code>pArr[i]</code>：</p>
<ol>
<li><strong>情况一</strong>：<code>i</code> 在 <code>pR</code> 外部（<code>i &gt;= pR</code>）。无法利用之前的加速，直接暴力向外扩展。</li>
<li><strong>情况二</strong>：<code>i</code> 在 <code>pR</code> 内部（<code>i &lt; pR</code>）。找到 <code>i</code> 关于 <code>index</code> 的对称点 <code>i&#39;</code> (<code>i&#39; = 2 * index - i</code>)。<ul>
<li><strong>子情况 2.a</strong>：<code>i&#39;</code> 的回文区域完全在 <code>index</code> 的回文区域内部。此时 <code>pArr[i] = pArr[i&#39;]</code>。</li>
<li><strong>子情况 2.b</strong>：<code>i&#39;</code> 的回文区域有一部分跑到了 <code>index</code> 的回文区域外部（左侧超出）。此时 <code>pArr[i]</code> 受到 <code>pR</code> 的限制，<code>pArr[i] = pR - i</code>。</li>
<li><strong>子情况 2.c</strong>：<code>i&#39;</code> 的回文区域左边界正好和 <code>index</code> 的回文区域左边界重合。此时 <code>pArr[i]</code> 至少是 <code>pR - i</code>，需要从 <code>pR</code> 位置开始继续向外尝试扩展。</li>
</ul>
</li>
</ol>
<p>代码实现中，可以将上述情况合并为一行代码初始化 <code>pArr[i]</code>，然后统一进行扩展检查。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manacher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span>[] manacherString(String str) &#123;</span><br><span class="line">        <span class="type">char</span>[] charArr = str.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] res = <span class="keyword">new</span> <span class="title class_">char</span>[str.length() * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != res.length; i++) &#123;</span><br><span class="line">            res[i] = (i &amp; <span class="number">1</span>) == <span class="number">0</span> ? <span class="string">&#x27;#&#x27;</span> : charArr[index++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxLcpsLength</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] charArr = manacherString(str);</span><br><span class="line">        <span class="type">int</span>[] pArr = <span class="keyword">new</span> <span class="title class_">int</span>[charArr.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pR</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != charArr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 核心优化：</span></span><br><span class="line">            <span class="comment">// pR &gt; i 说明 i 在有效回文覆盖范围内</span></span><br><span class="line">            <span class="comment">// 2 * index - i 是 i 关于 index 的对称点 i&#x27;</span></span><br><span class="line">            <span class="comment">// Math.min(pArr[2 * index - i], pR - i) 对应了三种情况的最小保底半径</span></span><br><span class="line">            pArr[i] = pR &gt; i ? Math.min(pArr[<span class="number">2</span> * index - i], pR - i) : <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 尝试向外扩展</span></span><br><span class="line">            <span class="keyword">while</span> (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (charArr[i + pArr[i]] == charArr[i - pArr[i]]) &#123;</span><br><span class="line">                    pArr[i]++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新 pR 和 index</span></span><br><span class="line">            <span class="keyword">if</span> (i + pArr[i] &gt; pR) &#123;</span><br><span class="line">                pR = i + pArr[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, pArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 半径减 1 即为原串长度</span></span><br><span class="line">        <span class="keyword">return</span> max - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进阶问题：在末尾添加最少字符使整个字符串变为回文</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">shortestEnd</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] charArr = manacherString(str);</span><br><span class="line">        <span class="type">int</span>[] pArr = <span class="keyword">new</span> <span class="title class_">int</span>[charArr.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pR</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxContainsEnd</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != charArr.length; i++) &#123;</span><br><span class="line">            pArr[i] = pR &gt; i ? Math.min(pArr[<span class="number">2</span> * index - i], pR - i) : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (charArr[i + pArr[i]] == charArr[i - pArr[i]]) &#123;</span><br><span class="line">                    pArr[i]++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i + pArr[i] &gt; pR) &#123;</span><br><span class="line">                pR = i + pArr[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 关键点：一旦右边界扩展到了数组末尾，说明找到了包含最后一个字符的最长回文</span></span><br><span class="line">            <span class="keyword">if</span> (pR == charArr.length) &#123;</span><br><span class="line">                maxContainsEnd = pArr[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// maxContainsEnd - 1 是包含最后一个字符的最长回文子串长度</span></span><br><span class="line">        <span class="comment">// 需要添加的部分是：原字符串长度 - 最长回文后缀长度，即剩余前缀的逆序</span></span><br><span class="line">        <span class="type">char</span>[] res = <span class="keyword">new</span> <span class="title class_">char</span>[str.length() - maxContainsEnd + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[res.length - <span class="number">1</span> - i] = charArr[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><p>【题目】<br>给定两个字符串 str 和 match，长度分别为 N 和 M。实现一个算法，如果字符串 str 中含有子串 match，则返回 match 在 str 中的开始位置，不含有则返回 -1。</p>
<p>【举例】<br>str=”acbc”, match=”bc”, 返回 2。<br>str=”acbc”, match=”bcc”, 返回 -1。</p>
<p>【要求】<br>如果 match 的长度大于 str 的长度 (M&gt;N)，str 必然不会含有 match，可直接返回 -1。但如果 N≥M，要求算法复杂度为 O(N)。</p>
<p>【解答】<br>本文是想重点介绍一下 KMP 算法，该算法是由 Donald Knuth、Vaughan Pratt 和 James H. Morris 于 1977 年联合发明的。在介绍 KMP 算法之前，我们先看普通解法怎么做。<br>最普通的解法是从左到右遍历 str 的每一个字符，然后看如果以当前字符作为第一个字符出发是否匹配 match。普通解法的时间复杂度较高，为 O(N×M)。普通解法之所以复杂度这么高，是因为每次遍历到一个字符时，检查工作相当于从无开始，之前的遍历检查不能优化当前的遍历检查。</p>
<p>下面介绍 KMP 算法是如何快速解决字符串匹配问题的。</p>
<ol>
<li>生成 match 字符串的 nextArr 数组，这个数组的长度与 match 字符串的长度一样，nextArr[i] 的含义是在 match[i] 之前的字符串 match[0..i-1] 中，必须以 match[i-1] 结尾的后缀子串（不能包含 match[0]）与必须以 match[0] 开头的前缀子串（不能包含 match[i-1]）最大匹配长度是多少，这个长度就是 nextArr[i] 的值。</li>
<li>假设从 str[i] 字符出发时，匹配到 j 位置的字符发现与 match 中的字符不一致。也就是说，str[i] 与 match[0] 一样，并且从这个位置开始一直可以匹配，即 str[i..j-1] 与 match[0..j-i-1] 一样，直到发现 str[j] != match[j-i]。<br>因为现在已经有了 match 字符串的 nextArr 数组，nextArr[j-i] 的值表示 match[0..j-i-1] 这一段字符串前缀与后缀的最长匹配。<br>那么下一次的匹配检查不再像普通解法那样退回到 str[i+1] 重新开始与 match[0] 的匹配过程，而是直接让 str[j] 与 match[k] 进行匹配检查 (k = nextArr[j-i])。<br>在 str 中要匹配的位置仍是 j，而不进行退回。对 match 来说，相当于向右滑动，让 match[k] 滑动到与 str[j] 在同一个位置上，然后进行后续的匹配检查。</li>
</ol>
<p>最后需要解释如何快速得到 match 字符串的 nextArr 数组。</p>
<ol>
<li>因为是左右依次求解 nextArr，所以在求解 nextArr[i] 时，nextArr[0..i-1] 的值都已经求出。假设 match[i] 字符为 A 字符，match[i-1] 为 B 字符。<br>通过 nextArr[i-1] 的值可知 B 字符之前的字符串的最长前缀与后缀匹配区域。</li>
<li>如果字符 C (前缀的下一个字符) 与字符 B 相等，那么 A 字符之前的字符串的最长前缀与后缀匹配区域就可以确定，即 nextArr[i] = nextArr[i-1] + 1。</li>
<li>如果字符 C 与字符 B 不相等，就看字符 C 之前的前缀和后缀匹配情况，假设字符 C 是第 cn 个字符 (match[cn])，那么 nextArr[cn] 就是其最长前缀和后缀匹配的长度。<br>如果不等，继续往前跳到字符 D，之后的过程与跳到字符 C 类似，一直进行这样的跳过程，跳的每一步都会有一个新的字符和 B 比较，只要有相等的情况，nextArr[i] 的值就能确定。</li>
<li>如果向前跳到最左位置 (即 match[0] 的位置)，此时 nextArr[0] == -1，说明字符 A 之前的字符串不存在前缀和后缀匹配的情况，则令 nextArr[i] = 0。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndexOf</span><span class="params">(String s, String m)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || m == <span class="literal">null</span> || m.length() &lt; <span class="number">1</span> || s.length() &lt; m.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] ss = s.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] ms = m.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">si</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] next = getNextArray(ms);</span><br><span class="line">    <span class="keyword">while</span> (si &lt; ss.length &amp;&amp; mi &lt; ms.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ss[si] == ms[mi]) &#123;</span><br><span class="line">            si++;</span><br><span class="line">            mi++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next[mi] == -<span class="number">1</span>) &#123;</span><br><span class="line">            si++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mi = next[mi];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mi == ms.length ? si - mi : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getNextArray(<span class="type">char</span>[] ms) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ms.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; -<span class="number">1</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[ms.length];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cn</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos &lt; next.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ms[pos - <span class="number">1</span>] == ms[cn]) &#123;</span><br><span class="line">            next[pos++] = ++cn;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cn = next[cn];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next[pos++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度分析：<br>整个 KMP 算法的复杂度为 O(M) (求解 nextArr 数组的过程) + O(N) (匹配的过程)，因为有 N≥M，所以时间复杂度为 O(N)。</p>
<h2 id="丢棋子问题"><a href="#丢棋子问题" class="headerlink" title="丢棋子问题"></a>丢棋子问题</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>一座大楼有 0~N 层，地面算作第 0 层，最高的一层为第 N 层。已知棋子从第 0 层掉落肯定不会摔碎，从第 i 层掉落可能会摔碎，也可能不会摔碎（1≤i≤N）。给定整数 N 作为楼层数，再给定整数 K 作为棋子数，返回如果想找到棋子不会摔碎的最高层数，即使在最差的情况下扔的最少次数。一次只能扔一个棋子。</p>
<h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>N=10，K=1。<br>返回 10。因为只有 1 棵棋子，所以不得不从第 1 层开始一直试到第 10 层，在最差的情况下，即第 10 层是不会摔坏的最高层，最少也要扔 10 次。</p>
<p>N=3，K=2。<br>返回 2。先在 2 层扔 1 棵棋子，如果碎了，试第 1 层，如果没碎，试第 3 层。</p>
<p>N=105，K=2。<br>返回 14。<br>第一个棋子先在 14 层扔，碎了则用仅存的一个棋子试 1～13。<br>若没碎，第一个棋子继续在 27 层扔，碎了则用仅存的一个棋子试 15～26。<br>若没碎，第一个棋子继续在 39 层扔，碎了则用仅存的一个棋子试 28～38。<br>若没碎，第一个棋子继续在 50 层扔，碎了则用仅存的一个棋子试 40～49。<br>若没碎，第一个棋子继续在 60 层扔，碎了则用仅存的一个棋子试 51～59。<br>若没碎，第一个棋子继续在 69 层扔，碎了则用仅存的一个棋子试 61～68。<br>若没碎，第一个棋子继续在 77 层扔，碎了则用仅存的一个棋子试 70～76。<br>若没碎，第一个棋子继续在 84 层扔，碎了则用仅存的一个棋子试 78～83。<br>若没碎，第一个棋子继续在 90 层扔，碎了则用仅存的一个棋子试 85～89。<br>若没碎，第一个棋子继续在 95 层扔，碎了则用仅存的一个棋子试 91～94。<br>若没碎，第一个棋子继续在 99 层扔，碎了则用仅存的一个棋子试 96～98。<br>若没碎，第一个棋子继续在 102 层扔，碎了则用仅存的一个棋子试 100、101。<br>若没碎，第一个棋子继续在 104 层扔，碎了则用仅存的一个棋子试 103。<br>若没碎，第一个棋子继续在 105 层扔，若到这一步还没碎，那么 105 便是结果。</p>
<h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><h4 id="方法一：暴力递归"><a href="#方法一：暴力递归" class="headerlink" title="方法一：暴力递归"></a>方法一：暴力递归</h4><p>假设 P(N,K)的返回值是 N 层楼有 K 个棋子在最差情况下扔的最少次数。</p>
<ol>
<li>如果 N==0，也就是楼层只有第 0 层，则不用试，肯定不碎，即 P(0,K)=0。</li>
<li>如果 K==1，也就是楼层有 N 层，但只有 1 个棋子了，这时只能从第 1 层开始试，一直试到第 N 层，即 P(N,1)=N。</li>
<li>对一般情况（N&gt;0，K&gt;1），我们需要考虑第 1 个棋子从哪层楼开始扔一次，如果第 1 个棋子从第 i 层开始扔，有以下两种情况：<br>1) 碎了。那么可以知道，没有必要去试第 i 层以上的楼层，接下来的问题就变成了还剩下 i-1 层楼，还剩下 K-1 个棋子，所以总步数为 1+P(i-1,K-1)。<br>2) 没碎。那么可以知道，没有必要去试第 i 层以下的楼层，接下来的问题就变成了还剩下 N-i 层楼，仍有 K 个棋子，所以总步数为 1+P(N-i,K)。</li>
</ol>
<p>根据题意，在 1)和 2)中哪个是最差的情况，最后的取值就应该来自哪个，所以最后取值为 max{ P(i-1,K-1), P(N-i,K) } + 1。<br>那么 i 可以选择哪些值呢？从 1 到 N 都可以选择，应该选择最终步数最少的那种情况。<br>所以，P(N,K)=min{max{P(i-1,K-1),P(N-i,K)}(1&lt;=i&lt;=N)}+1。</p>
<p>方法一为暴力递归的方法，如果楼数为 N，将尝试 N 种可能。在下一步的递归中，楼数最多为 N-1，将尝试 N-1 种可能，所以时间复杂度为 O(N!)，这个时间复杂度非常高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution1</span><span class="params">(<span class="type">int</span> nLevel, <span class="type">int</span> kChess)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nLevel &lt; <span class="number">1</span> || kChess &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Process1(nLevel, kChess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Process1</span><span class="params">(<span class="type">int</span> nLevel, <span class="type">int</span> kChess)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nLevel == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kChess == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nLevel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i != nLevel + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        min = Math.min(min,</span><br><span class="line">                Math.max(Process1(i - <span class="number">1</span>, kChess - <span class="number">1</span>),</span><br><span class="line">                        Process1(nLevel - i, kChess)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h4><p>通过研究如上递归函数我们发现，P(N,K)过程依赖 P(0..N-1,K-1)和 P(0..N-1,K)。所以，若把所有递归过程的返回值看作是一个二维数组，可以用动态规划的方式优化整个递归过程，从而减少递归重复计算。<br>dp[0][K] = 0，dp[N][1] = N，dp[N][K] = min{max{dp[i-1][K-1], dp[N-i][K]} (1&lt;= i&lt;=N) } +1</p>
<p>求每个位置（a,b）（即 P(a,b)）的过程中，需要枚举 P(0..a-1,b)和 P(0..a-1,b-1)，所以每个位置枚举过程的时间复杂度为 O(N)。递归过程即 P(i,j)，i 从 0 到 N，j 从 0 到 K，所以用一张 N×K 的二维表可以表示所有递归过程的返回值，即一共有 O(N×K)个位置。所以方法二整体的时间复杂度为 O(N^2 ×K)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution2</span><span class="params">(<span class="type">int</span> nLevel, <span class="type">int</span> kChess)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nLevel &lt; <span class="number">1</span> || kChess &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kChess == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nLevel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nLevel + <span class="number">1</span>][kChess + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i != dp.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i != dp.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j != dp[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k != i + <span class="number">1</span>; k++) &#123;</span><br><span class="line">                min = Math.min(min,</span><br><span class="line">                        Math.max(dp[k - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - k][j]));</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = min + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nLevel][kChess];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法三：空间压缩"><a href="#方法三：空间压缩" class="headerlink" title="方法三：空间压缩"></a>方法三：空间压缩</h4><p>把方法二的额外空间复杂度从使用 N×K 的矩阵减少为 2 个长度为 N 的数组。分析动态规划的过程发现，dp[N][K]只需要它左边的数据 dp[0..N-1][K-1]和它上面一排的数据 dp[0..N-1][K]。那么在动态规划计算时，就可以用两个数组不停地复用的方式实现，而并不是真的需要申请整个二维数组的空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution3</span><span class="params">(<span class="type">int</span> nLevel, <span class="type">int</span> kChess)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nLevel &lt; <span class="number">1</span> || kChess &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kChess == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nLevel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] preArr = <span class="keyword">new</span> <span class="title class_">int</span>[nLevel + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[] curArr = <span class="keyword">new</span> <span class="title class_">int</span>[nLevel + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i != curArr.length; i++) &#123;</span><br><span class="line">        curArr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i != kChess; i++) &#123;</span><br><span class="line">        <span class="type">int</span>[] tmp = preArr;</span><br><span class="line">        preArr = curArr;</span><br><span class="line">        curArr = tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j != curArr.length; j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k != j + <span class="number">1</span>; k++) &#123;</span><br><span class="line">                min = Math.min(min, Math.max(preArr[k - <span class="number">1</span>], curArr[j - k]));</span><br><span class="line">            &#125;</span><br><span class="line">            curArr[j] = min + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curArr[curArr.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法四：四边形不等式优化"><a href="#方法四：四边形不等式优化" class="headerlink" title="方法四：四边形不等式优化"></a>方法四：四边形不等式优化</h4><p>方法二和方法三的时间复杂度为 O(N^2 ×K)，还是很高。但我们注意到，求解动态规划表中的值时，有枚举过程，此时往往可以用“四边形不等式”及其相关猜想来进行优化。</p>
<ol>
<li>如果已经求出了 k+1 个棋子在解决 n 层楼时的最少步骤（dp[n][k+1]），那么如果在这个尝试过程中发现，第 1 个棋子扔在 m 层楼的这种尝试最终得到了最优解，则在求 k 个棋子在解决 n 层楼时（dp[n][k]），第 1 个棋子不需要去尝试 m 层以上的楼。</li>
<li>如果已经求出了 k 个棋子在解决 n 层楼时的最少步骤（dp[n][k]），那么如果在这个尝试过程中发现，第 1 个棋子扔在第 m 层楼的这种尝试最终得到了最优解。则在求 k 个棋子在解决第 n+1 层楼时（dp[n+1][k]），不需要去尝试第 m 层以下的楼。</li>
</ol>
<p>动态规划表中的两个参数分别为棋子数和楼层数，楼层数增加之后，第 1 个棋子尝试楼层的下限是可以确定的。棋子数变少之后，第 1 个棋子尝试楼层的上限也是可以确定的。这样就省去了很多无效的枚举过程。<br>时间复杂度可以从 O(N^2 ×K)降到 O(N^2)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution4</span><span class="params">(<span class="type">int</span> nLevel, <span class="type">int</span> kChess)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nLevel &lt; <span class="number">1</span> || kChess &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kChess == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nLevel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nLevel + <span class="number">1</span>][kChess + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i != dp.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] cands = <span class="keyword">new</span> <span class="title class_">int</span>[kChess + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i != dp[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">        dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        cands[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; nLevel + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> kChess; j &gt; <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minEnum</span> <span class="operator">=</span> cands[j];</span><br><span class="line">            <span class="type">int</span> <span class="variable">maxEnum</span> <span class="operator">=</span> j == kChess ? i / <span class="number">2</span> + <span class="number">1</span> : cands[j + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> minEnum; k &lt; maxEnum + <span class="number">1</span>; k++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> Math.max(dp[k - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - k][j]);</span><br><span class="line">                <span class="keyword">if</span> (cur &lt;= min) &#123;</span><br><span class="line">                    min = cur;</span><br><span class="line">                    cands[j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = min + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nLevel][kChess];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法五：最优解"><a href="#方法五：最优解" class="headerlink" title="方法五：最优解"></a>方法五：最优解</h4><p>最优解比以上各种方法都要快。首先我们换个角度来看这个问题，以上各种方法解决的问题是 N 层楼有 K 个棋子最少扔多少次。现在反过来看 K 个棋子如果可以扔 M 次，最多可以解决多少层楼这个问题。根据上文实现的函数可以生成下表，在这个表中记为 map，map[i][j] 的意义为 i 个棋子扔 j 次最多搞定的楼层数。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  次数-&gt; 1  2  3  4   5   6   7   8    9    10</span><br><span class="line">棋子数</span><br><span class="line">  ↓</span><br><span class="line">  1     1  2  3  4   5   6   7   8    9    10</span><br><span class="line">  2     1  3  6  10  15  21  28  36   45   55</span><br><span class="line">  3     1  3  7  14  25  41  63  92   129  175</span><br><span class="line">  4     1  3  7  15  30  56  98  162  255  385</span><br><span class="line">  5     1  3  7  15  31  62  119 218  381  637</span><br></pre></td></tr></table></figure>
<p>通过研究 map 表我们发现，第一横排的值从左到右依次为 1，2，3，…，第一纵列都为 0，除此之外的其他位置（i,j）都有 map[i][j]==map[i][j-1]+map[i-1][j-1]+1。<br>如何理解这个公式呢？假设 i 个棋子扔 j 次最多搞定 m 层楼，“搞定最多”说明每次扔的位置都是最优的且棋子肯定够用的情况，假设第 1 个棋子扔在 a 层楼是最优的尝试。</p>
<ol>
<li>如果第 1 个棋子已碎，那就向下，看 i-1 个棋子扔 j-1 次最多搞定多少层楼。</li>
<li>如果第 1 个棋子没碎，那就向上，看 i 个棋子扔 j-1 次最多搞定多少层楼。</li>
<li>a 层楼本身也是被搞定的 1 层。<br>1、2、3 的总楼层数就是 i 个棋子扔 j 次最多搞定的楼层数。</li>
</ol>
<p>同时我们知道 N 层楼完全用二分的方式扔 logN+1 次就可以确定哪层楼是会碎的最低楼层。所以当棋子数（k）大于 logN+1 时，我们就可以直接返回 logN+1。<br>如果棋子数为 K、楼层数为 N，最终的结果为 M 次，那么最优解的时间复杂度为 O(K×M)，在棋子数大于 logN+1 时，时间复杂度为 O(logN)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution5</span><span class="params">(<span class="type">int</span> nLevel, <span class="type">int</span> kChess)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nLevel &lt; <span class="number">1</span> || kChess &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">bsTimes</span> <span class="operator">=</span> log2N(nLevel) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (kChess &gt;= bsTimes) &#123;</span><br><span class="line">        <span class="keyword">return</span> bsTimes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[kChess];</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">previous</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> dp[i];</span><br><span class="line">            dp[i] = dp[i] + previous + <span class="number">1</span>;</span><br><span class="line">            previous = tmp;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt;= nLevel) &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">log2N</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="画匠问题"><a href="#画匠问题" class="headerlink" title="画匠问题"></a>画匠问题</h2><p><strong>题目</strong><br>给定一个整型数组 arr，数组中的每个值都为正数，表示完成一幅画作需要的时间，再给定一个整数 num，表示画匠的数量，每个画匠只能画连在一起的画作。所有的画家并行工作，请返回完成所有的画作需要的最少时间。</p>
<p><strong>举例</strong><br>arr=[3,1,4]，num=2。<br>最好的分配方式为第一个画匠画 3 和 1，所需时间为 4。第二个画匠画 4，所需时间为 4。<br>因为并行工作，所以最少时间为 4。如果分配方式为第一个画匠画 3，所需时间为 3。第二个画匠画 1 和 4，所需的时间为 5。那么最少时间为 5，显然没有第一种分配方式好。所以返回 4。</p>
<p>arr=[1,1,1,4,3]，num=3。<br>最好的分配方式为第一个画匠画前三个 1，所需时间为 3。第二个画匠画 4，所需时间为 4。第三个画匠画 3，所需时间为 3。返回 4。</p>
<p><strong>解答</strong></p>
<p><strong>方法一：动态规划</strong></p>
<p>如果只有 1 个画匠，那么对这个画匠来说，arr[0..j]上的画作最少时间就是 arr[0..j]的累加和。<br>如果有 2 个画匠，对他们来说，画完 arr[0..j]上的画作有如下方案：<br>方案 1：画匠 1 负责 arr[0]，画匠 2 负责 arr[1..j]，时间为 max{sum[0],sum[1..j]}。<br>方案 2：画匠 1 负责 arr[0..1]，画匠 2 负责 arr[2..j]，时间为 max{sum[0..1],sum[2..j]}。<br>……<br>方案 k：画匠 1 负责 arr[0..k]，画匠 2 负责 arr[k+1..j]，时间为 max{sum[0..k],sum[k+1..j]}。<br>方案 j：画匠 1 负责 arr[0..j-1]，画匠 2 负责 arr[j]。时间为 max{sum[0..j-1],sum[j]}。</p>
<p>每一种方案其实都是一种划分，把 arr[0..j]分成两部分，第一部分由画匠 1 来负责，第二部分由画匠 2 来负责，两部分的累加和哪个大，哪个就是这种方案所需的时间。最后选所需时间最小的方案，就是答案。</p>
<p>当画匠数量为 i（i&gt;2）时，假设 dp[i][j]的值代表 i 个画匠搞定 arr[0..j]这些画所需的最少时间。那么有如下方案：<br>方案 1：画匠 1~i-1 负责 arr[0]，画匠 i 负责 arr[1..j] -&gt; max{dp[i-1][0],sum[1..j]}。<br>方案 2：画匠 1~i-1 负责 arr[0..1]，画匠 i 负责 arr[2..j] -&gt; max{dp[i-1][1],sum[2..j]}。<br>……<br>方案 k：画匠 1~i-1 负责 arr[0..k]，画匠 i 负责 arr[k+1..j] -&gt; max{dp[i-1][k],sum[k+1..j]}。<br>方案 j：画匠 1~i-1 负责 arr[0..j-1]，画匠 i 负责 arr[j] -&gt; max{dp[i-1][j-1] , sum[j]}。</p>
<p>哪种方案所需的时间最少，dp[i][j]的值就是该种方案所需的时间，即<br>dp[i][j] = min { max { dp[i-1][k] , sum[k+1..j] } (0&lt;=k&lt;j) }</p>
<p>此方法使用动态规划常见的空间优化技巧。因为 dp[i][j]的值仅依赖 dp[i-1][…]的值。所以我们不必生成规模为 Num×N 大小的矩阵，仅用一个长度为 N 的数组结构滚动更新、不断复用即可。</p>
<p>画匠数目为 num，画作数量为 N，所以一共是 num×N 个位置需要计算。每个位置都需要枚举所有的方案来找出最好的方案，所以方法一的时间复杂度为 O(N^2 * num)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] sumArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    sumArr[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    map[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sumArr.length; i++) &#123;</span><br><span class="line">        sumArr[i] = sumArr[i - <span class="number">1</span>] + arr[i];</span><br><span class="line">        map[i] = sumArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> map.length - <span class="number">1</span>; j &gt; i - <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i - <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> Math.max(map[k], sumArr[j] - sumArr[k]);</span><br><span class="line">                min = Math.min(min, cur);</span><br><span class="line">            &#125;</span><br><span class="line">            map[j] = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map[arr.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法二：四边形不等式优化</strong></p>
<p>动态规划用四边形不等式优化后的解法。计算动态规划的每个值都需要枚举，自然想到用“四边形不等式”及其相关猜想来做枚举优化。具体地说，假设计算 dp[i-1][j]时，在最好的划分方案中，第 i-1 个画匠负责 arr[l..j]的画作。在计算 dp[i][j+1]时，在最好的划分方案中，第 i 个画匠负责 arr[m..j+1]的画作。在计算 dp[i][j]时，假设最好的划分方案是让第 i 个画匠负责 arr[k..j]，那么 k 的范围一定是[l,m]，而不可能在这个范围之外。</p>
<p>利用四边形不等式对枚举过程的优化可以将时间复杂度从 O(N^2 * num)降至 O(N^2)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] sumArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    sumArr[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    map[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sumArr.length; i++) &#123;</span><br><span class="line">        sumArr[i] = sumArr[i - <span class="number">1</span>] + arr[i];</span><br><span class="line">        map[i] = sumArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] cands = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> map.length - <span class="number">1</span>; j &gt; i - <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minPar</span> <span class="operator">=</span> cands[j];</span><br><span class="line">            <span class="type">int</span> <span class="variable">maxPar</span> <span class="operator">=</span> j == map.length - <span class="number">1</span> ? j : cands[j + <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> minPar; k &lt; maxPar + <span class="number">1</span>; k++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> Math.max(map[k], sumArr[j] - sumArr[k]);</span><br><span class="line">                <span class="keyword">if</span> (cur &lt;= min) &#123;</span><br><span class="line">                    min = cur;</span><br><span class="line">                    cands[j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map[j] = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map[arr.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法三：二分答案（最优解）</strong></p>
<p>本题最优解反而是三种方法中最好理解的，先来重新思考这样一个问题，arr 数组中的值依然表示完成一幅画作需要的时间，但是规定每个画匠画画的时间不能多于 limit，那么要几个画匠才够呢？<br>这个问题的实现非常简单，从左到右遍历 arr 的过程中做累加，一旦累加超过 limit，则认为当前的画（arr[i]）必须分给下一个画匠，那么就让累加和清零，并从 arr[i]开始重新累加。遍历的过程中如果发现有某一幅画的时间大于 limit，说明即使是单独分配一个画匠只画这一幅画，也不能满足每个画匠所需时间小于或等于 limit 这个要求。遇到这种情况就直接返回系统最大值，表示无论分多少个画匠，limit 都满足不了。</p>
<p>理解了上面的小问题后，画匠问题最优解的思路就很好理解了——利用二分法。通过调整 limit 的大小，看看需要的画匠数目是大于画匠总数还是少于画匠总数，然后决定是将答案往上调整还是往下调整，那么 limit 的范围一开始为[0,arr 所有值的累加和]，然后不断二分，即可缩小范围，最终确定 limit 到底是多少。</p>
<p>假设 arr 所有值的累加和为 S，那么二分的次数为 logS，每次调用 getNeedNum 方法，然后进行二分，getNeedNum 方法的时间复杂度为 O(N)。所以 solution3 的时间复杂度为 O(N*logS)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution3</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; num) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            maxSum += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (minSum != maxSum - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (minSum + maxSum) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (getNeedNum(arr, mid) &gt; num) &#123;</span><br><span class="line">                minSum = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxSum = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNeedNum</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> lim)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">stepSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; lim) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        stepSum += arr[i];</span><br><span class="line">        <span class="keyword">if</span> (stepSum &gt; lim) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            stepSum = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="邮局选址问题"><a href="#邮局选址问题" class="headerlink" title="邮局选址问题"></a>邮局选址问题</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>一条直线上有居民点，邮局只能建在居民点上。给定一个有序整型数组 arr，每个值表示居民点的一维坐标，再给定一个正数 num，表示邮局数量。选择 num 个居民点建立 num 个邮局，使所有的居民点到邮局的总距离最短，返回最短的总距离。</p>
<h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><p>arr=[1,2,3,4,5,1000]，num=2。<br>第一个邮局建立在 3 位置，第二个邮局建立在 1000 位置。那么 1 位置到邮局的距离为 2，2 位置到邮局距离为 1，3 位置到邮局的距离为 0，4 位置到邮局的距离为 1，5 位置到邮局的距离为 2，1000 位置到邮局的距离为 0。这种方案下的总距离为 6，其他任何方案的总距离都不会比该方案的总距离更短，所以返回 6。</p>
<h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><strong>思路</strong></p>
<p>首先解决一个问题，如果在 <code>arr[i..j]</code>（0≤i≤j&lt;N）区域上只能建一个邮局，并且这个区域上的居民点都前往这个邮局，要让 <code>arr[i..j]</code> 上所有的居民点到邮局的总距离最短，这个邮局应该建在哪里？</p>
<ul>
<li>如果 <code>arr[i..j]</code> 上有奇数个民居点，邮局建在中点位置会使总距离最短；</li>
<li>如果 <code>arr[i..j]</code> 上有偶数个民居点，此时认为中点有两个，邮局建在哪个中点上都行，都会使总距离最短。</li>
</ul>
<p>根据这种思路，我们先生成一个规模为 N×N 的矩阵 w，<code>w[i][j]</code>（0≤i≤j&lt;N）的值代表如果在 <code>arr[i..j]</code>（0≤i≤j&lt;N）区域上只建一个邮局，这一区间上的总距离为多少。</p>
<p><strong>求 w 矩阵的过程</strong></p>
<p>更快速的求法是利用递推：<code>w[i][j] = w[i][j-1] + arr[j] - arr[(i+j)/2]</code>。<br>解释一下这是为什么：</p>
<ul>
<li>如果 <code>arr[i..j-1]</code> 上有奇数个点，那么中点是 <code>arr[(i+j-1)/2]</code>，加上 <code>arr[j]</code> 之后，<code>arr[i..j]</code> 有偶数个点，第一个中点是 <code>arr[(i+j)/2]</code>。在这种情况下，<code>(i+j-1)/2</code> 和 <code>(i+j)/2</code> 其实是同一个位置。</li>
<li>如果 <code>arr[i..j-1]</code> 上有偶数个点，中点有两个，无论选在哪一个，<code>w[i][j-1]</code> 的值都是一样的。加上 <code>arr[j]</code> 之后，<code>arr[i..j]</code> 有奇数个点，中点是 <code>arr[(i+j)/2]</code>。在这种情况下，<code>arr[i..j-1]</code> 上的第二个中点和 <code>arr[i..j]</code> 上唯一的中点其实是同一个位置。</li>
</ul>
<p>所以 <code>w[i][j]</code> 比 <code>w[i][j-1]</code> 多出来的距离就是 <code>arr[j]</code> 到 <code>arr[(i+j)/2]</code> 的距离。</p>
<p><strong>动态规划过程</strong></p>
<p><code>dp[a][b]</code> 的值代表如果在 <code>arr[0..b]</code> 上建设 <code>a+1</code> 个邮局，总距离最少是多少。</p>
<ol>
<li><code>dp[0][0..N-1]</code> 上的所有值可以直接赋值为 <code>w[0][b]</code>。</li>
<li>当 <code>arr[0..b]</code> 上可以建设不止 1 个邮局时，即 <code>dp[a][b]</code> (a&gt;0) 时，枚举所有的划分方案：<br><code>dp[a][b] = min &#123; dp[a - 1][k] + w[k + 1][b] &#125;</code> (0 &lt;= k &lt; b)。</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistances1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || num &lt; <span class="number">1</span> || arr.length &lt; num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] w = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length + <span class="number">1</span>][arr.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            w[i][j] = w[i][j - <span class="number">1</span>] + arr[j] - arr[(i + j) / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[num][arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j != arr.length; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = w[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt;= j; k++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][k] + w[k + <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[num - <span class="number">1</span>][arr.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度</strong><br>方法一总的时间复杂度为 O(N^2 * num)。</p>
<h4 id="方法二：四边形不等式优化"><a href="#方法二：四边形不等式优化" class="headerlink" title="方法二：四边形不等式优化"></a>方法二：四边形不等式优化</h4><p><strong>思路</strong></p>
<p>用四边形不等式优化动态规划的枚举过程，使整个过程的时间复杂度降低至 O(N^2)。<br>在方法一中求解 <code>dp[a][b]</code> 的时候，几乎枚举了所有的 <code>dp[a-1][0..b]</code>，但这个枚举过程其实是可以得到加速的。</p>
<ol>
<li>当邮局为 <code>a-1</code> 个，区间为 <code>arr[0..b]</code> 时，如果在其最优划分方案中发现，邮局 <code>1~a-2</code> 负责 <code>arr[0..l]</code>，邮局 <code>a-1</code> 负责 <code>arr[l+1..b]</code>。</li>
<li>当邮局为 <code>a</code> 个，区间为 <code>arr[0..b+1]</code> 时，如果在其最优划分方案中发现，邮局 <code>1~a-1</code> 负责 <code>arr[0..m]</code>，邮局 <code>a</code> 负责 <code>arr[m+1..b+1]</code>。</li>
</ol>
<p>那么当邮局为 <code>a</code> 个，区间为 <code>arr[0..b]</code> 时，如果想得到最优方案，只需在 <code>dp[a-1][b]</code> 的最优尝试位置 <code>l</code> 和 <code>dp[a][b+1]</code> 的最优尝试位置 <code>m</code> 之间进行枚举，其他位置一概不用再试。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistances2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || num &lt; <span class="number">1</span> || arr.length &lt; num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] w = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length + <span class="number">1</span>][arr.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            w[i][j] = w[i][j - <span class="number">1</span>] + arr[j] - arr[(i + j) / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[num][arr.length];</span><br><span class="line">    <span class="type">int</span>[][] s = <span class="keyword">new</span> <span class="title class_">int</span>[num][arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j != arr.length; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = w[<span class="number">0</span>][j];</span><br><span class="line">        s[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minK</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxK</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            minK = s[i - <span class="number">1</span>][j];</span><br><span class="line">            maxK = j == arr.length - <span class="number">1</span> ? arr.length - <span class="number">1</span> : s[i][j + <span class="number">1</span>];</span><br><span class="line">            dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> minK; k &lt;= maxK; k++) &#123;</span><br><span class="line">                cur = dp[i - <span class="number">1</span>][k] + w[k + <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (cur &lt;= dp[i][j]) &#123;</span><br><span class="line">                    dp[i][j] = cur;</span><br><span class="line">                    s[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[num - <span class="number">1</span>][arr.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://njmxye.de5.net">楠寻njmxye</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://njmxye.de5.net/2026/01/18/%E7%AE%97%E6%B3%95/">https://njmxye.de5.net/2026/01/18/%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://njmxye.de5.net" target="_blank">楠 寻 の 小 窝</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2026/01/17/%E6%A5%A0%E5%AF%BB%E7%9C%BC%E4%B8%AD%E7%9A%84%E7%94%B7%E9%A2%91/" title="楠寻眼中的男频"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">楠寻眼中的男频</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">楠寻njmxye</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/1289795105"><i class="fab fa-bilibili"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/njmxye" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://njmxye.de5.net/njmxye.github.io.apk" target="_blank" title="Apks"><i class="fas fa-download" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">带我走吧，我没法适应人类的生活，像个小孩一样，好痛苦，好想死。派一个人，收走我吧，我快撑不住了，我不再抱任何的希望了。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">1.</span> <span class="toc-text">栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%9C%89-getMin-%E5%8A%9F%E8%83%BD%E7%9A%84%E6%A0%88"><span class="toc-number">1.1.</span> <span class="toc-text">设计一个有 getMin 功能的栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B1%E4%B8%A4%E4%B8%AA%E6%A0%88%E7%BB%84%E6%88%90%E7%9A%84%E9%98%9F%E5%88%97"><span class="toc-number">1.2.</span> <span class="toc-text">由两个栈组成的队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BB%85%E7%94%A8%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88%E6%93%8D%E4%BD%9C%E9%80%86%E5%BA%8F%E4%B8%80%E4%B8%AA%E6%A0%88"><span class="toc-number">1.3.</span> <span class="toc-text">如何仅用递归函数和栈操作逆序一个栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8C%AB%E7%8B%97%E9%98%9F%E5%88%97"><span class="toc-number">1.4.</span> <span class="toc-text">猫狗队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%88%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.</span> <span class="toc-text">用一个栈实现另一个栈的排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%A0%88%E6%9D%A5%E6%B1%82%E8%A7%A3%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text">用栈来求解汉诺塔问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%E6%95%B0%E7%BB%84"><span class="toc-number">1.7.</span> <span class="toc-text">生成窗口最大值数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88%E7%BB%93%E6%9E%84"><span class="toc-number">1.8.</span> <span class="toc-text">单调栈结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.9.</span> <span class="toc-text">求最大子矩阵的大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%80%BC%E5%87%8F%E5%8E%BB%E6%9C%80%E5%B0%8F%E5%80%BC%E5%B0%8F%E4%BA%8E%E6%88%96%E7%AD%89%E4%BA%8E-num-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E9%87%8F"><span class="toc-number">1.10.</span> <span class="toc-text">最大值减去最小值小于或等于 num 的子数组数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E7%9A%84%E5%B1%B1%E5%B3%B0%E5%AF%B9%E6%95%B0%E9%87%8F"><span class="toc-number">1.11.</span> <span class="toc-text">可见的山峰对数量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">链表问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%AC%E5%85%B1%E9%83%A8%E5%88%86"><span class="toc-number">2.1.</span> <span class="toc-text">打印两个有序链表的公共部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E5%92%8C%E5%8F%8C%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%AC-K-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">2.2.</span> <span class="toc-text">在单链表和双链表中删除倒数第 K 个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9%E5%92%8C-a-b-%E5%A4%84%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">2.3.</span> <span class="toc-text">删除链表的中间节点和 a&#x2F;b 处的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%8D%95%E5%90%91%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">2.4.</span> <span class="toc-text">反转单向和双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%83%A8%E5%88%86%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">2.5.</span> <span class="toc-text">反转部分单向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.</span> <span class="toc-text">环形单链表的约瑟夫问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84"><span class="toc-number">2.7.</span> <span class="toc-text">判断一个链表是否为回文结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E6%8C%89%E6%9F%90%E5%80%BC%E5%88%92%E5%88%86%E6%88%90%E5%B7%A6%E8%BE%B9%E5%B0%8F%E3%80%81%E4%B8%AD%E9%97%B4%E7%9B%B8%E7%AD%89%E3%80%81%E5%8F%B3%E8%BE%B9%E5%A4%A7%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.8.</span> <span class="toc-text">将单向链表按某值划分成左边小、中间相等、右边大的形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%90%AB%E6%9C%89%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E8%8A%82%E7%82%B9%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-number">2.9.</span> <span class="toc-text">复制含有随机指针节点的链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E7%94%9F%E6%88%90%E7%9B%B8%E5%8A%A0%E9%93%BE%E8%A1%A8"><span class="toc-number">2.10.</span> <span class="toc-text">两个单链表生成相加链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-number">2.11.</span> <span class="toc-text">两个单链表相交的一系列问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%8F-K-%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E9%80%86%E5%BA%8F"><span class="toc-number">2.12.</span> <span class="toc-text">将单链表的每 K 个节点之间逆序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%97%A0%E5%BA%8F%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%BC%E9%87%8D%E5%A4%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">2.13.</span> <span class="toc-text">删除无序单链表中值重复出现的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E5%80%BC%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">2.14.</span> <span class="toc-text">在单链表中删除指定值的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E6%88%90%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">2.15.</span> <span class="toc-text">将搜索二叉树转换成双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">2.16.</span> <span class="toc-text">单链表的选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%A7%8D%E6%80%AA%E5%BC%82%E7%9A%84%E8%8A%82%E7%82%B9%E5%88%A0%E9%99%A4%E6%96%B9%E5%BC%8F"><span class="toc-number">2.17.</span> <span class="toc-text">一种怪异的节点删除方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E6%9C%89%E5%BA%8F%E7%9A%84%E7%8E%AF%E5%BD%A2%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E8%8A%82%E7%82%B9"><span class="toc-number">2.18.</span> <span class="toc-text">向有序的环形单链表中插入新节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">2.19.</span> <span class="toc-text">合并两个有序的单链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E5%B7%A6%E5%8F%B3%E5%8D%8A%E5%8C%BA%E7%9A%84%E6%96%B9%E5%BC%8F%E9%87%8D%E6%96%B0%E7%BB%84%E5%90%88%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">2.20.</span> <span class="toc-text">按照左右半区的方式重新组合单链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">二叉树问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%88%AB%E7%94%A8%E9%80%92%E5%BD%92%E5%92%8C%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.1.</span> <span class="toc-text">分别用递归和非递归方式实现二叉树先序、中序和后序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BE%B9%E7%95%8C%E8%8A%82%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">打印二叉树的边界节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BE%83%E4%B8%BA%E7%9B%B4%E8%A7%82%E5%9C%B0%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.3.</span> <span class="toc-text">如何较为直观地打印二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">3.4.</span> <span class="toc-text">二叉树的序列化和反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A5%9E%E7%BA%A7%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text">遍历二叉树的神级方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E6%8C%87%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6"><span class="toc-number">3.6.</span> <span class="toc-text">在二叉树中找到累加和为指定值的最长路径长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E5%AD%90%E6%A0%91"><span class="toc-number">3.7.</span> <span class="toc-text">找到二叉树中的最大搜索二叉子树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%A6%E5%90%88%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%9C%80%E5%A4%A7%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84"><span class="toc-number">3.8.</span> <span class="toc-text">找到二叉树中符合搜索二叉树条件的最大拓扑结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%B8%8E-ZigZag-%E6%89%93%E5%8D%B0"><span class="toc-number">3.9.</span> <span class="toc-text">二叉树的按层打印与 ZigZag 打印</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">3.10.</span> <span class="toc-text">调整搜索二叉树中两个错误的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD-t1-%E6%A0%91%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB-t2-%E6%A0%91%E5%85%A8%E9%83%A8%E7%9A%84%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84"><span class="toc-number">3.11.</span> <span class="toc-text">判断 t1 树是否包含 t2 树全部的拓扑结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD-t1-%E6%A0%91%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E4%B8%8E-t2-%E6%A0%91%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84%E5%AE%8C%E5%85%A8%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%90%E6%A0%91"><span class="toc-number">3.12.</span> <span class="toc-text">判断 t1 树中是否有与 t2 树拓扑结构完全相同的子树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.13.</span> <span class="toc-text">判断二叉树是否为平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E5%90%8E%E5%BA%8F%E6%95%B0%E7%BB%84%E9%87%8D%E5%BB%BA%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.14.</span> <span class="toc-text">根据后序数组重建搜索二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.15.</span> <span class="toc-text">判断一棵二叉树是否为搜索二叉树和完全二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%94%9F%E6%88%90%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.16.</span> <span class="toc-text">通过有序数组生成平衡搜索二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9"><span class="toc-number">3.17.</span> <span class="toc-text">在二叉树中找到一个节点的后继节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">3.18.</span> <span class="toc-text">在二叉树中找到两个节点的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tarjan-%E7%AE%97%E6%B3%95%E4%B8%8E%E5%B9%B6%E6%9F%A5%E9%9B%86%E8%A7%A3%E5%86%B3%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E9%97%B4%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E7%9A%84%E6%89%B9%E9%87%8F%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98"><span class="toc-number">3.19.</span> <span class="toc-text">Tarjan 算法与并查集解决二叉树节点间最近公共祖先的批量查询问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98"><span class="toc-number">3.20.</span> <span class="toc-text">二叉树节点间的最大距离问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BE%E5%AF%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BF%AB%E4%B9%90%E5%80%BC"><span class="toc-number">3.21.</span> <span class="toc-text">派对的最大快乐值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%85%88%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E6%95%B0%E7%BB%84%E7%94%9F%E6%88%90%E5%90%8E%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">3.22.</span> <span class="toc-text">通过先序和中序数组生成后序数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%92%8C%E7%94%9F%E6%88%90%E6%89%80%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.23.</span> <span class="toc-text">统计和生成所有不同的二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0"><span class="toc-number">3.24.</span> <span class="toc-text">统计完全二叉树的节点数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">4.</span> <span class="toc-text">递归和动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E9%97%AE%E9%A2%98%E7%9A%84%E9%80%92%E5%BD%92%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">4.1.</span> <span class="toc-text">斐波那契数列问题的递归和动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">4.2.</span> <span class="toc-text">矩阵的最小路径和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%A2%E9%92%B1%E7%9A%84%E6%9C%80%E5%B0%91%E8%B4%A7%E5%B8%81%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">换钱的最少货币数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BE%BE%E5%88%B0%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%96%B9%E6%B3%95%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">机器人达到指定位置方法数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%A2%E9%92%B1%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B0"><span class="toc-number">4.5.</span> <span class="toc-text">换钱的方法数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E6%B0%94%E7%90%83%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0"><span class="toc-number">4.6.</span> <span class="toc-text">打气球的最大分数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">4.7.</span> <span class="toc-text">最长递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-O-N-2"><span class="toc-number">4.7.1.</span> <span class="toc-text">方法一：时间复杂度 O(N^2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-O-N-logN"><span class="toc-number">4.7.2.</span> <span class="toc-text">方法二：时间复杂度 O(N*logN)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%B0%81%E5%B5%8C%E5%A5%97%E9%97%AE%E9%A2%98"><span class="toc-number">4.8.</span> <span class="toc-text">信封嵌套问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98"><span class="toc-number">4.9.</span> <span class="toc-text">汉诺塔问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-number">4.10.</span> <span class="toc-text">最长公共子序列问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98"><span class="toc-number">4.11.</span> <span class="toc-text">最长公共子串问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E5%92%8C%E4%B8%BA-0-%E7%9A%84%E6%9C%80%E5%A4%9A%E5%88%92%E5%88%86"><span class="toc-number">4.12.</span> <span class="toc-text">子数组异或和为 0 的最多划分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%BC%96%E8%BE%91%E4%BB%A3%E4%BB%B7"><span class="toc-number">4.13.</span> <span class="toc-text">最小编辑代价</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BA%A4%E9%94%99%E7%BB%84%E6%88%90"><span class="toc-number">4.14.</span> <span class="toc-text">字符串的交错组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BE%99%E4%B8%8E%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F%E9%97%AE%E9%A2%98"><span class="toc-number">4.15.</span> <span class="toc-text">龙与地下城游戏问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E7%9A%84%E7%A7%8D%E6%95%B0"><span class="toc-number">4.16.</span> <span class="toc-text">数字字符串转换为字母组合的种数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BE%97%E5%88%B0%E6%9C%9F%E6%9C%9B%E7%BB%93%E6%9E%9C%E7%9A%84%E7%BB%84%E6%88%90%E7%A7%8D%E6%95%B0"><span class="toc-number">4.17.</span> <span class="toc-text">表达式得到期望结果的组成种数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E6%88%90%E4%B8%80%E6%9D%A1%E7%BA%BF%E7%9A%84%E7%BA%B8%E7%89%8C%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98"><span class="toc-number">4.18.</span> <span class="toc-text">排成一条线的纸牌博弈问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-number">4.19.</span> <span class="toc-text">跳跃游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-number">4.20.</span> <span class="toc-text">数组中的最长连续序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#N-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="toc-number">4.21.</span> <span class="toc-text">N 皇后问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">字符串问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%8F%98%E5%BD%A2%E8%AF%8D"><span class="toc-number">5.1.</span> <span class="toc-text">判断两个字符串是否互为变形词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E6%97%8B%E8%BD%AC%E8%AF%8D"><span class="toc-number">5.2.</span> <span class="toc-text">判断两个字符串是否互为旋转词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E6%95%B4%E6%95%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%88%90%E6%95%B4%E6%95%B0%E5%80%BC"><span class="toc-number">5.3.</span> <span class="toc-text">将整数字符串转成整数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.4.</span> <span class="toc-text">字符串的统计字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%AD%E6%98%AF%E5%90%A6%E6%89%80%E6%9C%89%E7%9A%84%E5%AD%97%E7%AC%A6%E9%83%BD%E5%8F%AA%E5%87%BA%E7%8E%B0%E8%BF%87%E4%B8%80%E6%AC%A1"><span class="toc-number">5.5.</span> <span class="toc-text">判断字符数组中是否所有的字符都只出现过一次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%9C%89%E5%BA%8F%E4%BD%86%E5%90%AB%E6%9C%89%E7%A9%BA%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.6.</span> <span class="toc-text">在有序但含有空的数组中查找字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%B0%83%E6%95%B4%E4%B8%8E%E6%9B%BF%E6%8D%A2"><span class="toc-number">5.7.</span> <span class="toc-text">字符串的调整与替换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.8.</span> <span class="toc-text">翻转字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E6%B4%97%E7%89%8C%E9%97%AE%E9%A2%98"><span class="toc-number">5.9.</span> <span class="toc-text">完美洗牌问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%A4%9A%E4%BD%99%E5%AD%97%E7%AC%A6%E5%BE%97%E5%88%B0%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.10.</span> <span class="toc-text">删除多余字符得到字典序最小的字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB"><span class="toc-number">5.11.</span> <span class="toc-text">数组中两个字符串的最小距离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.12.</span> <span class="toc-text">字符串的转换路径问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%9C%80%E5%B0%91%E5%AD%97%E7%AC%A6%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B4%E4%BD%93%E9%83%BD%E6%98%AF%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.13.</span> <span class="toc-text">添加最少字符使字符串整体都是回文字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7%E5%92%8C%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E9%95%BF%E5%BA%A6"><span class="toc-number">5.14.</span> <span class="toc-text">括号字符串的有效性和最长有效长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B1%82%E5%80%BC"><span class="toc-number">5.15.</span> <span class="toc-text">公式字符串求值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-%E5%B7%A6%E8%BE%B9%E5%BF%85%E6%9C%89-1-%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E9%87%8F"><span class="toc-number">5.16.</span> <span class="toc-text">0 左边必有 1 的二进制字符串数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%BC%E6%8E%A5%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A7%E7%94%9F%E5%AD%97%E5%85%B8%E9%A1%BA%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E5%A4%A7%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.17.</span> <span class="toc-text">拼接所有字符串产生字典顺序最小的大写字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E5%AD%90%E4%B8%B2"><span class="toc-number">5.18.</span> <span class="toc-text">找到字符串的最长无重复字符子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9A%84%E6%96%B0%E7%B1%BB%E5%9E%8B%E5%AD%97%E7%AC%A6"><span class="toc-number">5.19.</span> <span class="toc-text">找到指定的新类型字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%8B%E5%8F%98%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98"><span class="toc-number">5.20.</span> <span class="toc-text">旋变字符串问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%8C%85%E5%90%AB%E5%AD%90%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">5.21.</span> <span class="toc-text">最小包含子串的长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E6%9C%80%E5%B0%91%E5%88%86%E5%89%B2%E6%95%B0"><span class="toc-number">5.22.</span> <span class="toc-text">回文最少分割数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-number">5.23.</span> <span class="toc-text">字符串匹配问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%88%E5%89%8D%E7%BC%80%E6%A0%91%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.24.</span> <span class="toc-text">字典树（前缀树）的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C"><span class="toc-number">5.25.</span> <span class="toc-text">子数组的最大异或和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E7%A9%BA%E9%97%B4%E9%99%90%E5%88%B6"><span class="toc-number">6.</span> <span class="toc-text">大数据和空间限制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">6.1.</span> <span class="toc-text">认识布隆过滤器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E7%94%A8-2GB-%E5%86%85%E5%AD%98%E5%9C%A8-20-%E4%BA%BF%E4%B8%AA%E6%95%B4%E6%95%B0%E4%B8%AD%E6%89%BE%E5%88%B0%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E6%95%B0"><span class="toc-number">6.2.</span> <span class="toc-text">只用 2GB 内存在 20 亿个整数中找到出现次数最多的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-%E4%BA%BF%E4%B8%AA%E9%9D%9E%E8%B4%9F%E6%95%B4%E6%95%B0%E4%B8%AD%E6%89%BE%E5%88%B0%E6%9C%AA%E5%87%BA%E7%8E%B0%E7%9A%84%E6%95%B0"><span class="toc-number">6.3.</span> <span class="toc-text">40 亿个非负整数中找到未出现的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BE%E5%88%B0-100-%E4%BA%BF%E4%B8%AA-URL-%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84-URL-%E5%8F%8A%E6%90%9C%E7%B4%A2%E8%AF%8D%E6%B1%87%E7%9A%84-Top-K-%E9%97%AE%E9%A2%98"><span class="toc-number">6.4.</span> <span class="toc-text">找到 100 亿个 URL 中重复的 URL 及搜索词汇的 Top K 问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-%E4%BA%BF%E4%B8%AA%E9%9D%9E%E8%B4%9F%E6%95%B4%E6%95%B0%E4%B8%AD%E6%89%BE%E5%88%B0%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1%E7%9A%84%E6%95%B0%E5%92%8C%E6%89%80%E6%9C%89%E6%95%B0%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">6.5.</span> <span class="toc-text">40 亿个非负整数中找到出现两次的数和所有数的中位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">6.6.</span> <span class="toc-text">一致性哈希算法的基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B2%9B%E9%97%AE%E9%A2%98"><span class="toc-number">6.7.</span> <span class="toc-text">岛问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">7.</span> <span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E7%94%A8%E9%A2%9D%E5%A4%96%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E5%80%BC"><span class="toc-number">7.1.</span> <span class="toc-text">不用额外变量交换两个整数的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E7%94%A8%E5%81%9A%E4%BB%BB%E4%BD%95%E6%AF%94%E8%BE%83%E5%88%A4%E6%96%AD%E6%89%BE%E5%87%BA%E4%B8%A4%E4%B8%AA%E6%95%B0%E4%B8%AD%E8%BE%83%E5%A4%A7%E7%9A%84%E6%95%B0"><span class="toc-number">7.2.</span> <span class="toc-text">不用做任何比较判断找出两个数中较大的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B8%8D%E7%94%A8%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E6%95%B4%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97"><span class="toc-number">7.3.</span> <span class="toc-text">只用位运算不用算术运算实现整数的加减乘除运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E8%A1%A8%E8%BE%BE%E4%B8%AD%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA-1"><span class="toc-number">7.4.</span> <span class="toc-text">整数的二进制数表达中有多少个 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%85%B6%E4%BB%96%E6%95%B0%E9%83%BD%E5%87%BA%E7%8E%B0%E5%81%B6%E6%95%B0%E6%AC%A1%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%88%B0%E5%87%BA%E7%8E%B0%E5%A5%87%E6%95%B0%E6%AC%A1%E7%9A%84%E6%95%B0"><span class="toc-number">7.5.</span> <span class="toc-text">在其他数都出现偶数次的数组中找到出现奇数次的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%85%B6%E4%BB%96%E6%95%B0%E9%83%BD%E5%87%BA%E7%8E%B0-k-%E6%AC%A1%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%88%B0%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0"><span class="toc-number">7.6.</span> <span class="toc-text">在其他数都出现 k 次的数组中找到只出现一次的数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5%E9%97%AE%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">数组和矩阵问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E5%9C%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="toc-number">8.1.</span> <span class="toc-text">转圈打印矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9F%A9%E9%98%B5%E9%A1%BA%E6%97%B6%E9%92%88%E8%BD%AC%E5%8A%A8-90%C2%B0"><span class="toc-number">8.2.</span> <span class="toc-text">将正方形矩阵顺时针转动 90°</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C%E4%B9%8B%E2%80%9D%E5%AD%97%E5%BD%A2%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="toc-number">8.3.</span> <span class="toc-text">“之”字形打印矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0"><span class="toc-number">8.4.</span> <span class="toc-text">找到无序数组中最小的 k 个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%8E%92%E5%BA%8F%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6"><span class="toc-number">8.5.</span> <span class="toc-text">需要排序的最短子数组长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%88%B0%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%A4%A7%E4%BA%8E-N-K-%E7%9A%84%E6%95%B0"><span class="toc-number">8.6.</span> <span class="toc-text">在数组中找到出现次数大于 N&#x2F;K 的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E8%A1%8C%E5%88%97%E9%83%BD%E6%8E%92%E5%A5%BD%E5%BA%8F%E7%9A%84%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%89%BE%E6%8C%87%E5%AE%9A%E6%95%B0"><span class="toc-number">8.7.</span> <span class="toc-text">在行列都排好序的矩阵中找指定数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E7%9A%84%E5%8F%AF%E6%95%B4%E5%90%88%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">8.8.</span> <span class="toc-text">最长的可整合子数组的长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E9%87%8D%E5%A4%8D%E6%89%93%E5%8D%B0%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9B%B8%E5%8A%A0%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E6%89%80%E6%9C%89%E4%BA%8C%E5%85%83%E7%BB%84%E5%92%8C%E4%B8%89%E5%85%83%E7%BB%84"><span class="toc-number">8.9.</span> <span class="toc-text">不重复打印排序数组中相加和为给定值的所有二元组和三元组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%AD%A3%E6%95%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6"><span class="toc-number">8.10.</span> <span class="toc-text">未排序正数数组中累加和为给定值的最长子数组长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-number">8.11.</span> <span class="toc-text">未排序数组中累加和为给定值的最长子数组系列问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%B4%AF%E5%8A%A0%E5%92%8C%E5%B0%8F%E4%BA%8E%E6%88%96%E7%AD%89%E4%BA%8E%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6"><span class="toc-number">8.12.</span> <span class="toc-text">未排序数组中累加和小于或等于给定值的最长子数组长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%95%B0%E7%BB%84%E7%9A%84%E5%B0%8F%E5%92%8C"><span class="toc-number">8.13.</span> <span class="toc-text">计算数组的小和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E7%84%B6%E6%95%B0%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-number">8.14.</span> <span class="toc-text">自然数数组的排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%87%E6%95%B0%E4%B8%8B%E6%A0%87%E9%83%BD%E6%98%AF%E5%A5%87%E6%95%B0%E6%88%96%E8%80%85%E5%81%B6%E6%95%B0%E4%B8%8B%E6%A0%87%E9%83%BD%E6%98%AF%E5%81%B6%E6%95%B0"><span class="toc-number">8.15.</span> <span class="toc-text">奇数下标都是奇数或者偶数下标都是偶数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E5%8A%A0%E5%92%8C%E9%97%AE%E9%A2%98"><span class="toc-number">8.16.</span> <span class="toc-text">子数组的最大累加和问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E5%8A%A0%E5%92%8C%E9%97%AE%E9%A2%98"><span class="toc-number">8.17.</span> <span class="toc-text">子矩阵的最大累加和问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E5%B1%80%E9%83%A8%E6%9C%80%E5%B0%8F%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">8.18.</span> <span class="toc-text">在数组中找到一个局部最小的位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E4%B9%98%E7%A7%AF"><span class="toc-number">8.19.</span> <span class="toc-text">数组中子数组的最大累乘积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8D%B0-N-%E4%B8%AA%E6%95%B0%E7%BB%84%E6%95%B4%E4%BD%93%E6%9C%80%E5%A4%A7%E7%9A%84-Top-K"><span class="toc-number">8.20.</span> <span class="toc-text">打印 N 个数组整体最大的 Top K</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E9%83%BD%E6%98%AF-1-%E7%9A%84%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%A4%A7%E5%B0%8F"><span class="toc-number">8.21.</span> <span class="toc-text">边界都是 1 的最大正方形大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%8C%85%E5%90%AB%E6%9C%AC%E4%BD%8D%E7%BD%AE%E5%80%BC%E7%9A%84%E7%B4%AF%E4%B9%98%E6%95%B0%E7%BB%84"><span class="toc-number">8.22.</span> <span class="toc-text">不包含本位置值的累乘数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84-partition-%E8%B0%83%E6%95%B4"><span class="toc-number">8.23.</span> <span class="toc-text">数组的 partition 调整</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82%E6%9C%80%E7%9F%AD%E9%80%9A%E8%B7%AF%E5%80%BC"><span class="toc-number">8.24.</span> <span class="toc-text">求最短通路值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%AA%E5%87%BA%E7%8E%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0"><span class="toc-number">8.25.</span> <span class="toc-text">数组中未出现的最小正整数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%90%8E%E7%9B%B8%E9%82%BB%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC"><span class="toc-number">8.26.</span> <span class="toc-text">数组排序之后相邻数的最大差值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%9A%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9C%80%E5%A4%A7%E6%94%B6%E7%9B%8A%E9%97%AE%E9%A2%98"><span class="toc-number">8.27.</span> <span class="toc-text">做项目的最大收益问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%87%91%E6%9D%A1%E7%9A%84%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9"><span class="toc-number">8.28.</span> <span class="toc-text">分金条的最小花费</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E6%A5%BC%E8%BD%AE%E5%BB%93%E9%97%AE%E9%A2%98"><span class="toc-number">8.29.</span> <span class="toc-text">大楼轮廓问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E6%B2%B9%E7%AB%99%E8%89%AF%E5%A5%BD%E5%87%BA%E5%8F%91%E7%82%B9%E9%97%AE%E9%A2%98"><span class="toc-number">8.30.</span> <span class="toc-text">加油站良好出发点问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9B%9B%E6%B0%B4%E9%97%AE%E9%A2%98"><span class="toc-number">8.31.</span> <span class="toc-text">容器盛水问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%A2%98%E7%9B%AE"><span class="toc-number">9.</span> <span class="toc-text">其他题目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-5-%E9%9A%8F%E6%9C%BA%E5%88%B0-7-%E9%9A%8F%E6%9C%BA%E5%8F%8A%E5%85%B6%E6%89%A9%E5%B1%95"><span class="toc-number">9.1.</span> <span class="toc-text">从 5 随机到 7 随机及其扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0"><span class="toc-number">9.2.</span> <span class="toc-text">一行代码求两个数的最大公约数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%85%B3%E9%98%B6%E4%B9%98%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">9.3.</span> <span class="toc-text">有关阶乘的两个问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E7%9F%A9%E5%BD%A2%E5%86%85%E9%83%A8"><span class="toc-number">9.4.</span> <span class="toc-text">判断一个点是否在矩形内部</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E4%B8%89%E8%A7%92%E5%BD%A2%E5%86%85%E9%83%A8"><span class="toc-number">9.5.</span> <span class="toc-text">判断一个点是否在三角形内部</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%98%E7%BA%B8%E9%97%AE%E9%A2%98"><span class="toc-number">9.6.</span> <span class="toc-text">折纸问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%BD%E5%90%A6%E5%AE%8C%E7%BE%8E%E5%9C%B0%E6%8B%BC%E6%88%90%E7%9F%A9%E5%BD%A2"><span class="toc-number">9.7.</span> <span class="toc-text">能否完美地拼成矩形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%93%84%E6%B0%B4%E6%B1%A0%E7%AE%97%E6%B3%95"><span class="toc-number">9.8.</span> <span class="toc-text">蓄水池算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%9C%89-setAll-%E5%8A%9F%E8%83%BD%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">9.9.</span> <span class="toc-text">设计有 setAll 功能的哈希表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E7%9A%84-leftMax-%E4%B8%8E-rightMax-%E4%B9%8B%E5%B7%AE%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%80%BC"><span class="toc-number">9.10.</span> <span class="toc-text">最大的 leftMax 与 rightMax 之差的绝对值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1-LRU-%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">9.11.</span> <span class="toc-text">设计 LRU 缓存结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LFU-%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.12.</span> <span class="toc-text">LFU 缓存结构设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1-RandomPool-%E7%BB%93%E6%9E%84"><span class="toc-number">9.13.</span> <span class="toc-text">设计 RandomPool 结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.14.</span> <span class="toc-text">并查集的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E6%95%B4-0-x-%E5%8C%BA%E9%97%B4%E4%B8%8A%E7%9A%84%E6%95%B0%E5%87%BA%E7%8E%B0%E7%9A%84%E6%A6%82%E7%8E%87"><span class="toc-number">9.15.</span> <span class="toc-text">调整[0,x)区间上的数出现的概率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E6%95%B0%E7%BB%84%E5%8F%98%E4%B8%BA%E7%BB%9F%E8%AE%A1%E6%95%B0%E7%BB%84"><span class="toc-number">9.16.</span> <span class="toc-text">路径数组变为统计数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E6%95%B0%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E4%B8%8D%E5%8F%AF%E7%BB%84%E6%88%90%E5%92%8C"><span class="toc-number">9.17.</span> <span class="toc-text">正数数组的最小不可组成和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%AF%E5%8A%A0%E5%87%BA%E6%95%B4%E4%B8%AA%E8%8C%83%E5%9B%B4%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%9C%80%E5%B0%91%E8%BF%98%E9%9C%80%E5%87%A0%E4%B8%AA%E6%95%B0"><span class="toc-number">9.18.</span> <span class="toc-text">累加出整个范围所有的数最少还需几个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%A7%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%AD%97%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-number">9.19.</span> <span class="toc-text">一种字符串和数字的对应关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%B0-n-%E4%B8%AD-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-number">9.20.</span> <span class="toc-text">1 到 n 中 1 出现的次数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-N-%E4%B8%AA%E6%95%B0%E4%B8%AD%E7%AD%89%E6%A6%82%E7%8E%87%E6%89%93%E5%8D%B0-M-%E4%B8%AA%E6%95%B0"><span class="toc-number">9.21.</span> <span class="toc-text">从 N 个数中等概率打印 M 个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%98%AF%E5%90%A6%E6%98%AF%E5%9B%9E%E6%96%87%E6%95%B0"><span class="toc-number">9.22.</span> <span class="toc-text">判断一个数是否是回文数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%9C%89%E5%BA%8F%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%88%B0%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">9.23.</span> <span class="toc-text">在有序旋转数组中找到最小值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%9C%89%E5%BA%8F%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E6%95%B0"><span class="toc-number">9.24.</span> <span class="toc-text">在有序旋转数组中找到一个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%9A%84%E8%8B%B1%E6%96%87%E8%A1%A8%E8%BE%BE%E5%92%8C%E4%B8%AD%E6%96%87%E8%A1%A8%E8%BE%BE"><span class="toc-number">9.25.</span> <span class="toc-text">数字的英文表达和中文表达</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%8B%B1%E6%96%87%E8%A1%A8%E8%BE%BE%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.25.1.</span> <span class="toc-text">1. 英文表达的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%AD%E6%96%87%E8%A1%A8%E8%BE%BE%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.25.2.</span> <span class="toc-text">2. 中文表达的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">9.25.3.</span> <span class="toc-text">完整代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B3%96%E6%9E%9C%E9%97%AE%E9%A2%98"><span class="toc-number">9.26.</span> <span class="toc-text">分糖果问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-1"><span class="toc-number">9.26.1.</span> <span class="toc-text">完整代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%A7%8D%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%E5%B9%B6%E6%89%93%E5%8D%B0%E7%9A%84%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.27.</span> <span class="toc-text">一种消息接收并打印的结构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-2"><span class="toc-number">9.27.1.</span> <span class="toc-text">完整代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%97%B6%E6%89%BE%E5%88%B0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">9.28.</span> <span class="toc-text">随时找到数据流的中位数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-3"><span class="toc-number">9.28.1.</span> <span class="toc-text">完整代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%B8%A4%E4%B8%AA%E9%95%BF%E5%BA%A6%E7%9B%B8%E7%AD%89%E7%9A%84%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%8A%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">9.29.</span> <span class="toc-text">在两个长度相等的排序数组中找到上中位数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-4"><span class="toc-number">9.29.1.</span> <span class="toc-text">完整代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%88%B0%E7%AC%AC-k-%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="toc-number">9.30.</span> <span class="toc-text">在两个排序数组中找到第 k 小的数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-5"><span class="toc-number">9.30.1.</span> <span class="toc-text">完整代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%97%B4%E7%9B%B8%E5%8A%A0%E5%92%8C%E7%9A%84-Top-k-%E9%97%AE%E9%A2%98"><span class="toc-number">9.31.</span> <span class="toc-text">两个有序数组间相加和的 Top k 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-6"><span class="toc-number">9.31.1.</span> <span class="toc-text">完整代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E7%9A%84-Top-k-%E9%97%AE%E9%A2%98"><span class="toc-number">9.32.</span> <span class="toc-text">出现次数的 Top k 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-number">9.32.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-number">9.32.2.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E6%B1%82"><span class="toc-number">9.32.3.</span> <span class="toc-text">要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%E9%97%AE%E9%A2%98"><span class="toc-number">9.32.4.</span> <span class="toc-text">进阶问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94"><span class="toc-number">9.32.5.</span> <span class="toc-text">解答</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E9%97%AE%E9%A2%98"><span class="toc-number">9.32.5.1.</span> <span class="toc-text">原问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%E9%97%AE%E9%A2%98-1"><span class="toc-number">9.32.5.2.</span> <span class="toc-text">进阶问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Manacher-%E7%AE%97%E6%B3%95"><span class="toc-number">9.33.</span> <span class="toc-text">Manacher 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP-%E7%AE%97%E6%B3%95"><span class="toc-number">9.34.</span> <span class="toc-text">KMP 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A2%E6%A3%8B%E5%AD%90%E9%97%AE%E9%A2%98"><span class="toc-number">9.35.</span> <span class="toc-text">丢棋子问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-number">9.35.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B-1"><span class="toc-number">9.35.2.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94-1"><span class="toc-number">9.35.3.</span> <span class="toc-text">解答</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92"><span class="toc-number">9.35.3.1.</span> <span class="toc-text">方法一：暴力递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">9.35.3.2.</span> <span class="toc-text">方法二：动态规划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%8E%8B%E7%BC%A9"><span class="toc-number">9.35.3.3.</span> <span class="toc-text">方法三：空间压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%9B%9B%EF%BC%9A%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96"><span class="toc-number">9.35.3.4.</span> <span class="toc-text">方法四：四边形不等式优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%94%EF%BC%9A%E6%9C%80%E4%BC%98%E8%A7%A3"><span class="toc-number">9.35.3.5.</span> <span class="toc-text">方法五：最优解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%BB%E5%8C%A0%E9%97%AE%E9%A2%98"><span class="toc-number">9.36.</span> <span class="toc-text">画匠问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%AE%E5%B1%80%E9%80%89%E5%9D%80%E9%97%AE%E9%A2%98"><span class="toc-number">9.37.</span> <span class="toc-text">邮局选址问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-number">9.37.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B-2"><span class="toc-number">9.37.2.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94-2"><span class="toc-number">9.37.3.</span> <span class="toc-text">解答</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">9.37.3.1.</span> <span class="toc-text">方法一：动态规划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96"><span class="toc-number">9.37.3.2.</span> <span class="toc-text">方法二：四边形不等式优化</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/18/%E7%AE%97%E6%B3%95/" title="算法">算法</a><time datetime="2026-01-18T21:52:00.000Z" title="发表于 2026-01-18 21:52:00">2026-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/17/%E6%A5%A0%E5%AF%BB%E7%9C%BC%E4%B8%AD%E7%9A%84%E7%94%B7%E9%A2%91/" title="楠寻眼中的男频">楠寻眼中的男频</a><time datetime="2026-01-17T17:52:00.000Z" title="发表于 2026-01-17 17:52:00">2026-01-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/14/%E6%A5%A0%E5%AF%BB%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%A5%B3%E9%A2%91/" title="楠寻眼中的女频">楠寻眼中的女频</a><time datetime="2026-01-14T12:52:00.000Z" title="发表于 2026-01-14 12:52:00">2026-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/14/%E6%A5%A0%E5%AF%BB%E7%9C%BC%E4%B8%AD%E7%9A%84%E7%9F%AD%E5%89%A7/" title="楠寻眼中的短剧">楠寻眼中的短剧</a><time datetime="2026-01-14T12:52:00.000Z" title="发表于 2026-01-14 12:52:00">2026-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/05/ace/" title="ace">ace</a><time datetime="2026-01-05T04:00:00.000Z" title="发表于 2026-01-05 04:00:00">2026-01-05</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2026 By 楠寻njmxye</div><div class="footer_custom_text"><a href="https://icp.gov.moe/?keyword=20252779" target="_blank">萌ICP备20252779号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: '',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><div><div class="aplayer aplayer-tag-marker aplayer-withlrc aplayer-withlist aplayer-arrow" id="aplayer-VbASGHkA" style="margin-bottom:20px"><script>var options = {"narrow":false,"autoplay":true,"mode":"random","order":"random","mutex":true,"fixed":"true","theme":"#e6d0b2","preload":"metadata","listmaxheight":"200px","volume":0.06,"music":[{"title":"难断","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/难断.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"吹灭小山河","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/吹灭小山河.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"3 Strikes","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/3%20Strikes.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"ALL MY PEOPLE","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/ALL%20MY%20PEOPLE.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"After The Wind","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/After%20The%20Wind.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"All For Love","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/All%20For%20Love.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Baby love you","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Baby%20love%20you.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Constant Moderato","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Constant%20Moderato.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Dancing With Your Ghost","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Dancing%20With%20Your%20Ghost.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Daylight","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Daylight.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Different Lives (Explicit)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Different%20Lives%20(Explicit).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Dreamer","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Dreamer.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Drown (feat. Clinton Kane)(Alle Farben Remix)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Drown%20(feat.%20Clinton%20Kane)(Alle%20Farben%20Remix).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Fearless Pt. II","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Fearless%20Pt.%20II.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Fractures","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Fractures.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Home (Radio Edit)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Home%20(Radio%20Edit).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Lose Control","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Lose%20Control.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"MONTAGEM XONADA","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/MONTAGEM%20XONADA.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Meant To Be","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Meant%20To%20Be.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Minor Forever","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Minor%20Forever.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Montagem Nada Tropica","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Montagem%20Nada%20Tropica.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Power","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Power.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Sacred Play Secret Place","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Sacred%20Play%20Secret%20Place.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Save Me","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Save%20Me.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Secret Labs","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Secret%20Labs.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"Taped Up Heart (feat. Clara Mae)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/Taped%20Up%20Heart%20(feat.%20Clara%20Mae).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"The Hills (Slap House Mix)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/The%20Hills%20(Slap%20House%20Mix).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"WHOOPTY (Remix)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/WHOOPTY%20(Remix).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"aLIEz","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/aLIEz.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"おはなばたけ","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/おはなばたけ.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"三拜红尘凉","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/三拜红尘凉.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"不是相思是离别","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/不是相思是离别.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"东南西北中","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/东南西北中.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"乘风游","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/乘风游.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"人间惊鸿宴","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/人间惊鸿宴.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"人间烟火","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/人间烟火.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"今世债","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/今世债.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"他乡的月亮","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/他乡的月亮.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"伴你成长","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/伴你成长.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"你的答案","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/你的答案.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"使一颗心免于哀伤","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/使一颗心免于哀伤.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"关山酒 (DJ版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/关山酒%20(DJ版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"关山酒","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/关山酒.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"其实都没有","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/其实都没有.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"冬眠","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/冬眠.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"冬眠·2023","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/冬眠·2023.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"别回头","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/别回头.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"半入清风半入喉","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/半入清风半入喉.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"半生雪","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/半生雪.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"半生风雪","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/半生风雪.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"厚颜无耻","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/厚颜无耻.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"叹云兮","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/叹云兮.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"叹人间","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/叹人间.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"同进退","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/同进退.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"听花","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/听花.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"唯一","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/唯一.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"壁上观","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/壁上观.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"大笑人间","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/大笑人间.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"天亮以前说再见","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/天亮以前说再见.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"妈妈的话","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/妈妈的话.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"姑娘别哭泣","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/姑娘别哭泣.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"姑娘在远方","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/姑娘在远方.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"孤城","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/孤城.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"安和桥","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/安和桥.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"室内系的TrackMaker","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/室内系的TrackMaker.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"寄明月","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/寄明月.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"年轮","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/年轮.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"归途有风","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/归途有风.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"待我踏过彼岸花 (DJ版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/待我踏过彼岸花%20(DJ版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"御龙定乾坤","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/御龙定乾坤.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"循风","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/循风.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"忘川彼岸 (DJ名龙版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/忘川彼岸%20(DJ名龙版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"念","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/念.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"思念绕指尖 (DJ名龙版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/思念绕指尖%20(DJ名龙版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"恋愛サーキュレーション","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/恋愛サーキュレーション.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"想你时风起","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/想你时风起.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"愿与愁","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/愿与愁.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"折芙蓉","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/折芙蓉.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"折风渡夜 (DJ名龙版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/折风渡夜%20(DJ名龙版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"捂住耳朵 (DJ版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/捂住耳朵%20(DJ版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"提笔问飞花","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/提笔问飞花.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"旧梦一场","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/旧梦一场.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"时光背面的我","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/时光背面的我.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"明月不照离别人","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/明月不照离别人.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"明月天涯","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/明月天涯.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"星光就在前方","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/星光就在前方.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"星月落","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/星月落.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"春分","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/春分.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"月华落","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/月华落.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"月色倒映在西湖","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/月色倒映在西湖.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"本日は晴天なり","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/本日は晴天なり.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"梦中客","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/梦中客.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"江南烟雨色","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/江南烟雨色.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"江湖之间","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/江湖之间.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"江湖之间·2025","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/江湖之间·2025.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"沈园外","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/沈园外.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"没有意外","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/没有意外.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"沦陷 (DJ阿幻版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/沦陷%20(DJ阿幻版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"洛南·仓颉颂","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/洛南·仓颉颂.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"海市蜃楼","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/海市蜃楼.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"游京 (燃情版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/游京%20(燃情版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"潮汐","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/潮汐.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"燕无歇","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/燕无歇.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"爱是无畏的冒险","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/爱是无畏的冒险.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"牵丝戏 (DJ亚明版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/牵丝戏%20(DJ亚明版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"画离弦","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/画离弦.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"盐渍月亮 Salty Moon","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/盐渍月亮%20Salty%20Moon.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"盗墓笔记·十年人间","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/盗墓笔记·十年人间.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"知我","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/知我.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"破茧","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/破茧.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"破阵舞","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/破阵舞.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"离人殇","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/离人殇.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"离人赋 (治愈版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/离人赋%20(治愈版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"离别开出花","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/离别开出花.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"笔下江湖","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/笔下江湖.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"红尘回眸","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/红尘回眸.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"纵此生","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/纵此生.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"纸上风雅","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/纸上风雅.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"芒种","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/芒种.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"花开花谢花又飞","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/花开花谢花又飞.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"若月亮没来 (DJ铁柱版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/若月亮没来%20(DJ铁柱版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"若月亮没来","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/若月亮没来.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"荒","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/荒.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"莫问归期","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/莫问归期.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"落","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/落.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"诛神诀 (DJ R7版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/诛神诀%20(DJ%20R7版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"谁家","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/谁家.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"赐我","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/赐我.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"赤伶","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/赤伶.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"跳楼机","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/跳楼机.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"踏山河","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/踏山河.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"辞·九门回忆","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/辞·九门回忆.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"过此生","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/过此生.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"速度与坚果 Fast & Furynuts","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/速度与坚果%20Fast%20&%20Furynuts.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"遗失的心跳","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/遗失的心跳.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"邀","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/邀.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"酒家解相思","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/酒家解相思.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"醉春风 (DJ版)","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/醉春风%20(DJ版).mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"长安姑娘","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/长安姑娘.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"难却","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/难却.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"难得真兄弟","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/难得真兄弟.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"难断","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/难断.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"雾里","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/雾里.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"风催雨","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/风催雨.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"飘浮","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/飘浮.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"飞鸟和蝉","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/飞鸟和蝉.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"马步谣","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/马步谣.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"鸳鸯戏","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/鸳鸯戏.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"},{"title":"龙游万里","author":"寻","url":"https://gh-proxy.org/https://raw.githubusercontent.com/njmxye/cdn_ms/refs/heads/main/龙游万里.mp3","pic":"https://gh-proxy.org/https://github.com/njmxye/cdn_ms/blob/main/1716767227197.jpg"}]};options.element = document.getElementById("aplayer-VbASGHkA");var ap = new APlayer(options);window.aplayers || (window.aplayers = []);window.aplayers.push(ap)</script></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":false},"rect":"opacity:0.7","log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>